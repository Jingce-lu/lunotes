报数
===
<!-- TOC -->

- [报数](#报数)
  - [题目](#题目)
  - [循环计数](#循环计数)
  - [正则计数， `/(\d)\1*/g` (反向引用)可以捕获相同数字](#正则计数-d1g-反向引用可以捕获相同数字)
  - [双指针法，第一个指针记录值，第二个指针记录数量](#双指针法第一个指针记录值第二个指针记录数量)
  - [栈](#栈)

<!-- /TOC -->

## 题目
报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：
```js
1.     1
2.     11
3.     21
4.     1211
5.     111221
```

`1` 被读作  `"one 1"`  (`"一个一"`) , 即 `11`。
`11` 被读作 `"two 1s"` (`"两个一"`）, 即 `21`。
`21` 被读作 `"one 2"`,  `"one 1"` （`"一个二"` ,  `"一个一"`) , 即 `1211`。

给定一个正整数 `n（1 ≤ n ≤ 30）`，输出报数序列的第 `n` 项。

注意：整数顺序将表示为一个字符串。

示例 1:
```js
输入: 1
输出: "1"
```

示例 2:
```js
输入: 4
输出: "1211"
```

## 循环计数
```js
var countAndSay = function(n) {
  if (n == 1) return "1";
  function say(str) {
    var result_str = "",
      i = 0;
    j = 0;
    while (j < str.length) {
      if (str[i] === str[j]) {
        j++;
      } else {
        result_str += j - i + "" + str[i];
        i = j;
      }
    }
    result_str += j - i + "" + str[i];
    return result_str;
  }

  return say(countAndSay(n - 1));
};
```

## 正则计数， `/(\d)\1*/g` (反向引用)可以捕获相同数字
```js
var countAndSay = function(n) {
  if (n == 1) return "1";
  function say(str) {
    var reg = /(\d)\1*/g;
    var result = "";
    var result_str = "";
    while ((result = reg.exec(str))) {
      result_str += result[0].length + result[1];
    }
    return result_str;
  }

  return say(countAndSay(n - 1));
};
```

## 双指针法，第一个指针记录值，第二个指针记录数量
```js
var countAndSay = function(n) {
  let num = "1";
  let sum = "";
  for (let l = 0; l < n - 1; l++) {
    let sum = "";
    for (let i = 0, j = 0; i < num.length; ) {
      if (num[i] == num[i + j]) {
        j++;
      } else {
        sum = sum + j + "" + num[i];
        i += j;
        j = 1;
      }
    }
    num = sum;
  }
  return num;
};
```

## 栈
```js
var countAndSay = function(n) {
  let stark = [];
  let list = "1";
  let result = "";
  if (n === 1) {
    return list;
  }
  for (let i = 1; i < n; i++) {
    let arr_list = list.split("");
    arr_list.forEach((item, index) => {
      if (stark[0] === item || index === 0) {
        stark.unshift(item);
      } else {
        result = result + stark.length.toString() + stark[0].toString();
        stark = [];
        stark.unshift(item);
      }
    });
    if (stark.length != 0) {
      result = result + stark.length.toString() + stark[0].toString();
      stark = [];
    }
    if (i === n - 1) {
      return result;
    }
    list = result;
    result = "";
  }
};
```