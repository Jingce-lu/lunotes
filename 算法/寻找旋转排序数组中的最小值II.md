寻找旋转排序数组中的最小值 II
===
<!-- TOC -->

- [寻找旋转排序数组中的最小值 II](#寻找旋转排序数组中的最小值-II)
  - [题目](#题目)
  - [JS](#JS)

<!-- /TOC -->

## 题目
假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

请找出其中最小的元素。

注意数组中可能存在重复的元素。

示例 1：
```js
输入: [1,3,5]
输出: 1
```

示例 2：
```js
输入: [2,2,2,0,1]
输出: 0
```

说明：

这道题是 寻找旋转排序数组中的最小值 的延伸题目。  
允许重复会影响算法的时间复杂度吗？会如何影响，为什么？

**和Search in Rotated Sorted Array唯一的区别是这道题目中元素会有重复的情况出现。不过正是因为这个条件的出现，出现了比较复杂的case，甚至影响到了算法的时间复杂度。原来我们是依靠中间和边缘元素的大小关系，来判断哪一半是不受rotate影响，仍然有序的。而现在因为重复的出现，如果我们遇到中间和边缘相等的情况，我们就丢失了哪边有序的信息，因为哪边都有可能是有序的结果。假设原数组是{1,2,3,3,3,3,3}，那么旋转之后有可能是{3,3,3,3,3,1,2}，或者{3,1,2,3,3,3,3}，这样的我们判断左边缘和中心的时候都是3，如果我们要寻找1或者2，我们并不知道应该跳向哪一半。解决的办法只能是对边缘移动一步，直到边缘和中间不在相等或者相遇，这就导致了会有不能切去一半的可能。所以最坏情况（比如全部都是一个元素，或者只有一个元素不同于其他元素，而他就在最后一个）就会出现每次移动一步，总共是n步，算法的时间复杂度变成O(n)。**

## JS
js
- 执行用时 : 68 ms, 在Find Minimum in Rotated Sorted Array II的JavaScript提交中击败了100.00% 的用户
- 内存消耗 : 34.5 MB, 在Find Minimum in Rotated Sorted Array II的JavaScript提交中击败了38.10% 的用户
```js
var findMin = function(nums) {
    var left = 0,
        right = nums.length - 1, mid;
    while(left < right){
        mid = Math.floor((left + right) / 2);
        if(nums[mid] > nums[right]){
            left = mid + 1;
        } else if(nums[mid] < nums[right]){
            right = mid;
        } else {
            right--;
        }
    }
    return nums[left];
};
```