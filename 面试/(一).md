js面试题(一)
=====

<!-- TOC -->

- [1. 循环闭包、IIFE、 ES6、 Promise、 ES7 await async](#1-循环闭包iife-es6-promise-es7-await-async)
  - [1.1 不起眼的开始](#11-不起眼的开始)
  - [1.2 期望代码的输出变成 0 -> 1 -> 2 -> 3 -> 4 -> 5，并且要求原有的代码块中的循环和两处 console.log 不变](#12-期望代码的输出变成-0---1---2---3---4---5并且要求原有的代码块中的循环和两处-consolelog-不变)
  - [1.3 ES7](#13-es7)
- [2. 闭包的作用，缺点](#2-闭包的作用缺点)
  - [2.1 定义](#21-定义)
  - [2.2 闭包的特点：](#22-闭包的特点)
  - [2.3 优缺点](#23-优缺点)
- [3. 深浅拷贝的区别和用途](#3-深浅拷贝的区别和用途)
  - [3.1 理解](#31-理解)
  - [3.2 JavaScript的数据类型分为基本数据类型和引用数据类型](#32-javascript的数据类型分为基本数据类型和引用数据类型)
  - [3.3 几种深拷贝的实现](#33-几种深拷贝的实现)
- [4. CSS有哪些实现布局的方式](#4-css有哪些实现布局的方式)
- [5. CSS命名冲突如何解决](#5-css命名冲突如何解决)
- [6. 介绍下 ES 里的 Generator 是怎么运行的？ 和 async + await 有何区别？](#6-介绍下-es-里的-generator-是怎么运行的-和-async--await-有何区别)
- [7. React 里的 key 有什么作用？](#7-react-里的-key-有什么作用)
- [8. React 里什么时候用 Context?](#8-react-里什么时候用-context)
- [9. render props是什么？什么时候用？](#9-render-props是什么什么时候用)
  - [9.1 render props](#91-render-props)
  - [9.2 传递 props](#92-传递-props)
  - [9.3 不局限于 children](#93-不局限于-children)
  - [9.4 依赖注入](#94-依赖注入)
  - [9.5 render props 和高阶组件的比较](#95-render-props-和高阶组件的比较)
- [10. 路由如何做权限校验？](#10-路由如何做权限校验)
  - [10.1 实现](#101-实现)
  - [10.2 vue 路由权限限制](#102-vue-路由权限限制)
  - [10.3 vue 路由验证](#103-vue-路由验证)
  - [10.4 如何用 Vue 实现前端权限控制(CSDN)](#104-如何用-vue-实现前端权限控制csdn)
- [11. SSR 的原理是什么？](#11-ssr-的原理是什么)
  - [11.1 使用 SSR 技术的主要因素](#111-使用-ssr-技术的主要因素)
  - [11.2 SSR 中客户端渲染与服务器端渲染路由代码的差异](#112-ssr-中客户端渲染与服务器端渲染路由代码的差异)
  - [11.3 服务器端代码和客户端代码的打包差异](#113-服务器端代码和客户端代码的打包差异)
  - [11.4 SSR 中异步数据的获取 + Redux 的使用](#114-ssr-中异步数据的获取--redux-的使用)
  - [11.5 Node 只是一个中间层](#115-node-只是一个中间层)
- [12. React中调用setState之后发生了什么事情?](#12-react中调用setstate之后发生了什么事情)
- [13. React中Element与Component的区别?](#13-react中element与component的区别)
- [14. 在什么情况下会优先选择使用ClassComponent而不是FunctionalComponent?](#14-在什么情况下会优先选择使用classcomponent而不是functionalcomponent)
- [15. React中的refs属性的作用是什么?](#15-react中的refs属性的作用是什么)
- [16. React中keys的作用是什么?](#16-react中keys的作用是什么)
- [17. 回调渲染模式( Render Callback Pattern)](#17-回调渲染模式-render-callback-pattern)
- [18. 组件的生命周期有哪三个状态,  有哪几个钩子函数？](#18-组件的生命周期有哪三个状态--有哪几个钩子函数)
- [19. 在生命周期中的哪一步你应该发起 AJAX 请求？](#19-在生命周期中的哪一步你应该发起-ajax-请求)
- [20. shouldComponentUpdate作用,为何重要？](#20-shouldcomponentupdate作用为何重要)
- [21. React 的工作原理](#21-react-的工作原理)
- [22. 使用 React 有何优点](#22-使用-react-有何优点)
- [23. 展示组件(Presentational component)和容器组件(Container component)之间有何不同](#23-展示组件presentational-component和容器组件container-component之间有何不同)
- [24. 类组件(Class component)和函数式组件(Functional component)之间有何不同](#24-类组件class-component和函数式组件functional-component之间有何不同)
- [25. (组件的)状态(state)和属性(props)之间有何不同](#25-组件的状态state和属性props之间有何不同)
- [26. 何为受控组件(controlled component)](#26-何为受控组件controlled-component)
- [27. 何为高阶组件(higher order component)](#27-何为高阶组件higher-order-component)
- [28. 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象](#28-为什么建议传递给-setstate-的参数是一个-callback-而不是一个对象)
- [29. 除了在构造函数中绑定 this，还有其它方式吗](#29-除了在构造函数中绑定-this还有其它方式吗)
- [30. 怎么阻止组件的渲染](#30-怎么阻止组件的渲染)
- [31. (在构造函数中)调用 super(props) 的目的是什么](#31-在构造函数中调用-superprops-的目的是什么)
- [32. 何为 JSX](#32-何为-jsx)
- [33. 何为 Children](#33-何为-children)
- [34. 何为 redux](#34-何为-redux)
- [35. 在 Redux 中，何为 store](#35-在-redux-中何为-store)
- [36. 何为 action](#36-何为-action)
- [37. 何为 reducer](#37-何为-reducer)
- [38. Redux Thunk 的作用是什么](#38-redux-thunk-的作用是什么)
- [39. 何为纯函数(pure function)](#39-何为纯函数pure-function)
- [40. react中的回调渲染模式](#40-react中的回调渲染模式)
- [41. React 中的事件处理逻辑](#41-react-中的事件处理逻辑)
- [42. React解决了什么问题](#42-react解决了什么问题)
- [43. React的协议问题你了解吗](#43-react的协议问题你了解吗)
- [44. 你在过去的项目里遇到的最大问题是什么？你最大的成就？](#44-你在过去的项目里遇到的最大问题是什么你最大的成就)
- [45. 传入 setState 函数的第二个参数的作用是什么？](#45-传入-setstate-函数的第二个参数的作用是什么)
- [46. 封装ajax](#46-封装ajax)
- [47. Bind实现](#47-bind实现)
- [48. 快速排序](#48-快速排序)
- [49. 正则匹配结巴程序](#49-正则匹配结巴程序)
- [50. ['1', '2', '3'].map(parseInt) 解析](#50-1-2-3mapparseint-解析)
- [51. 防抖和节流](#51-防抖和节流)
  - [防抖 debounce](#防抖-debounce)
  - [节流 throttle](#节流-throttle)
- [52. Set、Map、WeakSet 和 WeakMap 的区别？](#52-setmapweakset-和-weakmap-的区别)
- [53. ES5/ES6 的继承除了写法以外还有什么区别](#53-es5es6-的继承除了写法以外还有什么区别)
- [54. 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组](#54-将数组扁平化并去除其中重复数据最终得到一个升序且不重复的数组)
- [55. JS 异步解决方案的发展历程以及优缺点。](#55-js-异步解决方案的发展历程以及优缺点)
  - [1. 回调函数（callback）](#1-回调函数callback)
  - [2. Promise](#2-promise)
  - [3. Generator](#3-generator)
  - [4. Async/await](#4-asyncawait)
- [56. 10 个 Ajax 同时发起请求，全部返回展示结果，并且至多允许三次失败，说出设计思路](#56-10-个-ajax-同时发起请求全部返回展示结果并且至多允许三次失败说出设计思路)
- [57. 基于 Localstorage 设计一个 1M 的缓存系统，需要实现缓存淘汰机制](#57-基于-localstorage-设计一个-1m-的缓存系统需要实现缓存淘汰机制)

<!-- /TOC -->

## 1. 循环闭包、IIFE、 ES6、 Promise、 ES7 await async
### 1.1 不起眼的开始
```js
for (var i = 0; i < 5; i++) {
    setTimeout(function() {
        console.log(new Date, i);
    }, 1000);
}

console.log(new Date, i);
```

### 1.2 期望代码的输出变成 0 -> 1 -> 2 -> 3 -> 4 -> 5，并且要求原有的代码块中的循环和两处 console.log 不变
> 代码执行时，立即输出 0，之后每隔 1 秒依次输出 1,2,3,4，循环结束后在大概第 5 秒的时候输出 5
```js
for (var i = 0; i < 5; i++) {
    (function(j) {
        setTimeout(function() {
            console.log(new Date, j);
        }, 1000 * j);  // 这里修改 0~4 的定时器时间
    })(i);
}

setTimeout(function() { // 这里增加定时器，超时设置为 5 秒
    console.log(new Date, i);
}, 1000 * i);
```

如果把这次的需求抽象为：在系列异步操作完成（每次循环都产生了 1 个异步操作）之后，再做其他的事情

```js
const tasks = [];
for (var i = 0; i < 5; i++) {   // 这里 i 的声明不能改成 let，如果要改该怎么做？
    ((j) => {
        tasks.push(new Promise((resolve) => {
            setTimeout(() => {
                console.log(new Date, j);
                resolve();  // 这里一定要 resolve，否则代码不会按预期 work
            }, 1000 * j);   // 定时器的超时时间逐步增加
        }));
    })(i);
}

Promise.all(tasks).then(() => {
    setTimeout(() => {
        console.log(new Date, i);
    }, 1000);   // 注意这里只需要把超时设置为 1 秒
});
```

相比而言，笔者更倾向于下面这样看起来更简洁的代码，要知道编程风格也是很多面试官重点考察的点，代码阅读时的颗粒度更小，模块化更好，无疑会是加分点。

```js
const tasks = []; // 这里存放异步操作的 Promise
const output = (i) => new Promise((resolve) => {
    setTimeout(() => {
        console.log(new Date, i);
        resolve();
    }, 1000 * i);
});

// 生成全部的异步操作
for (var i = 0; i < 5; i++) {
    tasks.push(output(i));
}

// 异步操作完成之后，输出最后的 i
Promise.all(tasks).then(() => {
    setTimeout(() => {
        console.log(new Date, i);
    }, 1000);
});
```

### 1.3 ES7 
既然 Promise 已经被拿下，如何使用 ES7 中的 async await 特性来让这段代码变的更简洁？
```js
// 模拟其他语言中的 sleep，实际上可以是任何异步操作
const sleep = (timeountMS) => new Promise((resolve) => {
    setTimeout(resolve, timeountMS);
});

(async () => {  // 声明即执行的 async 函数表达式
    for (var i = 0; i < 5; i++) {
        await sleep(1000);
        console.log(new Date, i);
    }

    await sleep(1000);
    console.log(new Date, i);
})();
```


## 2. 闭包的作用，缺点

### 2.1 定义
闭包 当一个函数的返回值是另外一个函数,而返回的那个函数如果调用了其父函数内部的变量,且返回的这个函数在外部被执行就产生了闭包.闭包是一个环境，具体指的就是外部函数--高阶函数。

一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数）

**能够读取其他函数内部变量的函数**

### 2.2 闭包的特点：
1. 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。
2. 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。
   
简单的闭包如下：
```js
function f1(){
   var n = 100;
   return function f2(){
      alert(++n);
   }
}
```

**函数执行时创建了一个内部函数，这个内部函数作为返回值，或以某种方式保留下来（属性），之后才会调用，这就会形成了闭包。通俗来讲，JS所有的function都是一个闭包。**

### 2.3 优缺点
- 优点
    1. 可以读取函数内部的变量
    2. 可以让这些局部变量保存在内存中，实现变量数据共享。
    3. 避免全局变量的污染
    4. 私有成员的存在
- 缺点
    1. 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
    2. 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。


## 3. 深浅拷贝的区别和用途

### 3.1 理解
简单的来说就是，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误！

假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。

浅拷贝例子
```js
let a=[0,1,2,3,4],
    b=a;
console.log(a===b);  // true
a[0]=1;
console.log(a,b);  
// (5) [1, 1, 2, 3, 4] (5) [1, 1, 2, 3, 4] 
```

### 3.2 JavaScript的数据类型分为基本数据类型和引用数据类型

- **基本数据类型:** `number`，`string`，`boolean`，`null`，`undefined`，`symbol`以及未来ES10新增的`BigInt`(任意精度整数)七类
- **引用数据类型**(Object类)有常规名值对的`无序对象`{a:1}，`数组`[1,2,3]，以及`函数`等

而这两类数据存储分别是这样的  
1. **基本类型--名值存储在栈内存中**，例如let a=1;
    <div align="center"><img src='../assets/012801.jpg'/></div>

    当你b=a复制时，栈内存会新开辟一个内存，例如这样：
    <div align="center"><img src='../assets/012802.jpg'/></div>

    所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。  
    当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。

2. **引用数据类型--名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值**
   
    我们以上面浅拷贝的例子画个图：
    <div align="center"><img src='../assets/012803.jpg'/></div>

    当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。
    <div align="center"><img src='../assets/012804.jpg'/></div>

    而当我们**a[0]=1**时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。
    <div align="center"><img src='../assets/012805.jpg'/></div>

    那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，岂不就达到深拷贝的效果了
    <div align="center"><img src='../assets/012806.jpg'/></div>

### 3.3 几种深拷贝的实现
```js
// 法1 
// 递归去复制所有层级属性
function deepClone(obj){
    let objClone = Array.isArray(obj)?[]:{};
    if(obj && typeof obj==="object"){
        for(key in obj){
            if(obj.hasOwnProperty(key)){
                //判断ojb子元素是否为对象，如果是，递归复制
                if(obj[key]&&typeof obj[key] ==="object"){
                    objClone[key] = deepClone(obj[key]);
                }else{
                    //如果不是，简单复制
                    objClone[key] = obj[key];
                }
            }
        }
    }
    return objClone;
}    
let a=[1,2,3,4],
    b=deepClone(a);
a[0]=2;
console.log(a,b);


// 法2
// 除了递归，我们还可以借用JSON对象的parse和stringify
function deepClone(obj){
    let _obj = JSON.stringify(obj),
        objClone = JSON.parse(_obj);
    return objClone
}    
let a=[0,1,[2,3],4],
    b=deepClone(a);
a[0]=1;
a[2][0]=1;
console.log(a,b);

// 法3
function copy(obj){  //浅拷贝
	var newObj = {};
	for(var attr in obj){
		newObj[attr] = obj[attr]
	}
	return newObj;
}

function deepCopy(obj){  //深拷贝

	if(typeof obj != 'object'){
		console.trace();
		return obj;
	}
	
	var newObj = {};
	
	for(var attr in obj){
		newObj[attr] = deepCopy(obj[attr]);
	}
	
	return newObj;
	
}

// 法4
function extendCopy(p){
	var c = {};
	for(var i in p){
		c[i] = p[i];
	}
	c.uber = p;
	return c;
}

function deepCopy(p,c){
	var c = c || {};
	for(var i in p){
		if(typeof p[i] === 'object'){
			c[i] = (p[i].constructor === Array) ? [] : {};
			deepCopy(p[i],c[i]);
		}else{
			c[i] = p[i]
		}
	}
	return c;
}
```


## 4. CSS有哪些实现布局的方式

1. table 布局
2. flex 布局
3. float 布局
4. 响应式布局
    1. meta 标签
    1. 使用 rem
    1. media query


## 5. CSS命名冲突如何解决
1. css-modules
2. 细化选择符  

    假如全局是这样来定义一个元素的样式的：.abc {background:#000}，同时这个class为abc的元素是隶属于某个元素的，比如下面这样的html代码结构
    ```html
    <div class="container">
        <div class="abc"></div>
    </div>
    ```
    那么在细化css里面，只需要在.abc前面加多一个父元素的选择符就行了：   
    .container .abc {background:#fff}   
    这样.container .abc的优先级就大于了.abc，自然细化css里面的background设置也就不会被全局CSS覆盖了~~

3. 提升样式的优先级
   
    这种方法个人不太推荐，相对而言会简单粗暴一些。同样是上面的例子，在细化CSS里面，只要在样式后面加一个!important，例如这样：  
    .abc {background:#fff !improtant;}   
    这个样式的优先级就会默认提升到顶级，全局样式就无法影响到它了。  

4. 改变两个样式的加载顺序

    这种方法比较简单，就是只要把细化css加载在全局css之后就行了，这样后面的样式就会自动覆盖前面的样式。不过如果你的html里面这两个样式表的加载顺序是先细化后全局的话，就要稍微调整一下代码才行。

## 6. 介绍下 ES 里的 Generator 是怎么运行的？ 和 async + await 有何区别？

1. **Promise的写法只是回调函数的改进，使用then方法，只是让异步任务的两段执行更清楚而已。Promise的最大问题是代码冗余，请求任务多时，一堆的then，也使得原来的语义变得很不清楚**
2. **Generator** 函数是一个普通函数，但是有两个特征。
    - 一是，function关键字与函数名之间有一个星号；
    - 二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。

    Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。  
    换言之，**Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。虽然Generator将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段**）
3. **async函数，自动执行Generator函数的方法。**使得异步操作变得更加方便。简单说来，它就是Generator函数的语法糖。
4. 简单的说async函数就相当于自执行的Generator函数，相当于自带一个状态机，在await的部分等待返回， 返回后自动执行下一步。而且相较于Promise,async的优越性就是把每次异步返回的结果从then中拿到最外层的方法中，不需要链式调用，只要用同步的写法就可以了。更加直观而且，更适合处理并发调用的问题。但是async必须以一个Promise对象开始 ，所以async通常是和Promise结合使用的


## 7. React 里的 key 有什么作用？
Keys 是React在操作列表中元素被修改,添加,或者删除的辅助标识.

在开发过程中,我们需要保证某个元素的key 在其同级元素中具有唯一性,在ReactDiff算法中React会借助元素的Key值来判断该元素是新创建的还是被移动而来的元素,React会保存这个辅助状态,从而减少不必要的元素渲染.此外,React还需要借助Key值来判断元素与本地状态的关联干洗,因此我们在开发中不可忽视Key值的使用.

Keys 会有助于 React 识别哪些 items 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key 的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 items 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果 items 可以重新排序，就会导致 re-render 变慢。


## 8. React 里什么时候用 Context?
当我们使用React时，很容易的通过观察组件的`props`来跟踪组件间的数据流流向，这种跟踪观察方式也让我们很容易的去理解组件。

而有的时候，我们不想让一个props从最外层，通过组件一层一层的传递到目标组件上，这时就可以通过context来直接实现我们希望的操作。

context最好的使用场景是隐式的传入登录的用户，当前的语言，或者主题信息。要不然所有这些可能就是全局变量，但是context让你限定他们到一个单独的React树里。


## 9. render props是什么？什么时候用？

### 9.1 render props 
所谓 render props，指的是让 React 组件的 props 支持函数这种模式。因为作为 props 传入的函数往往被用来渲染一部分界面，所以这种模式被称为 render props。

Render Props 的核心思想是，通过一个函数将class组件的state作为props传递给纯函数组件

一个最简单的 render props 组件 `RenderAll`，代码如下：
```javascript
const RenderAll = (props) => {
  return(
     <React.Fragment>
     	{props.children(props)}
     </React.Fragment>
  );
};
```
这个 RenderAll 预期子组件是一个函数，它所做的事情就是把子组件当做函数调用，调用参数就是传入的 props，然后把返回结果渲染出来，除此之外什么事情都没有做。

使用 RenderAll 的代码如下：
```javascript
<RenderAll>
	{() => <h1>hello world</h1>}
</RenderAll>
```
可以看到，RenderAll 的子组件，也就是夹在 RenderAll 标签之间的部分，其实是一个函数。这个函数渲染出 `<h1>hello world</h1>`，这就是上面使用 RenderAll 渲染出来的结果。

当然，这个 RenderAll 没做任何实际工作，接下来我们看 render props 真正强悍的使用方法。

### 9.2 传递 props

和高阶组件一样，render props 可以做很多的定制功能，我们还是以根据是否登录状态来显示一些界面元素为例，来实现一个 render props。

下面是实现 render props 的 `Login` 组件，可以看到，render props 和高阶组件的第一个区别，就是 render props 是真正的 React 组件，而不是一个返回 React 组件的函数。

```javascript
const Login = (props) => {
  const userName = getUserName();

  if (userName) {
    const allProps = {userName, ...props};
    return (
      <React.Fragment>
        {props.children(allProps)}
      </React.Fragment>
    );
  } else {
    return null;
  }
};
```
当用户处于登录状态，`getUserName` 返回当前用户名，否则返回空，然后我们根据这个结果决定是否渲染 `props.children` 返回的结果。

当然，render props 完全可以决定哪些 props 可以传递给 props.children，在 Login 中，我们把 `userName` 作为增加的 props 传递给下去，这样就是 Login 的增强功能。

一个使用上面 Login 的 JSX 代码示例如下：
```javascript
<Login>
    {({userName}) => <h1>Hello {userName}</h1>}
</Login>
```
对于名为“程墨Morgan”的用户登录，上面的 JSX 会产生 `<h1>Hello 程墨Morgan</h1>`。

### 9.3 不局限于 children

在上面的例子中，作为 render 方法的 props 就是 `children`，在我写的[《深入浅出React和Redux》](https://link.juejin.im/?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F26648239)中，将这种模式称为“以函数为子组件（function as child）”的模式，这可以算是 render props 的一种具体形式，也就利用 `children` 这个 props 来作为函数传递。

实际上，render props 这个模式不必局限于 children 这一个 props，任何一个 props 都可以作为函数，也可以利用多个 props 来作为函数。

我们来扩展 Login，不光在用户登录时显示一些东西，也可以定制用户没有登录时显示的东西，我们把这个组件叫做 `Auth`，对应代码如下：
```javascript
const Auth = (props) => {
  const userName = getUserName();

  if (userName) {
    const allProps = {userName, ...props};
    return (
      <React.Fragment>
        {props.login(allProps)}
      </React.Fragment>
    );
  } else {
    <React.Fragment>
      {props.nologin(props)}
    </React.Fragment>
  }
};
```
使用 Auth 的话，可以分别通过 `login` 和 `nologin` 两个 props 来指定用户登录或者没登录时显示什么，用法如下：
```javascript
<Auth
    login={({userName}) => <h1>Hello {userName}</h1>}
    nologin={() => <h1>Please login</h1>}
  />
```

### 9.4 依赖注入

render props 其实就是 React 世界中的 **“依赖注入”（Dependency Injection)**。

所谓依赖注入，指的是解决这样一个问题：逻辑 A 依赖于逻辑 B，如果让 A 直接依赖于 B，当然可行，但是 A 就没法做得通用了。依赖注入就是把 B 的逻辑以函数形式传递给 A，A 和 B 之间只需要对这个函数接口达成一致就行，如此一来，再来一个逻辑 C，也可以用一样的方法重用逻辑 A。

在上面的代码示例中，`Login` 和 `Auth` 组件就是上面所说的逻辑 A，而传递给组件的函数类型 props，就是逻辑 B 和 C。

### 9.5 render props 和高阶组件的比较

我们来比对一下这两种重用 React 组件逻辑的模式。

首先，render props 模式的应用，就是做一个 React 组件，而高阶组件，虽然名为“组件”，其实只是一个产生 React 组件的函数。

render props 不像上一小节中介绍的高阶组件有那么多毛病，如果说 render props 有什么缺点，那就是 render props 不能像高阶组件那样链式调用，当然，这并不是一个致命缺点。

render props 相对于高阶组件还有一个显著优势，就是对于新增的 props 更加灵活。还是以登录状态为例，假如我们扩展 withLogin 的功能，让它给被包裹的组件传递用户名这个 props，代码如下：
```javascript
const withLogin = (Component) => {
  const NewComponent = (props) => {
    const userName= getUserName();
    if (userName) {
      return <Component {...props} userName={userName}/>;
    } else {
      return null;
    }
  }

  return NewComponent;
};
```
这就要求被 withLogin 包住的组件要接受 `userName` 这个props。可是，假如有一个现成的 React 组件不接受 userName，却接受名为 `name` 的 props 作为用户名，这就麻烦了。我们就不能直接用 withLogin 包住这个 React 组件，还要再造一个组件来做 `userName` 到 `name` 的映射，十分费事。

对于应用 render props 的 Login，就不存在这个问题，接受 `name` 不接受 `userName` 是吗？这样写就好了：
```javascript
<Login>
  {
    (props) => {
      const {userName} = props;
      return <TheComponent {...props} name={userName} />
    }
  }
</Login>
```
所以，当需要重用 React 组件的逻辑时，建议首先看这个功能是否可以抽象为一个简单的组件；如果行不通的话，考虑是否可以应用 render props 模式；再不行的话，才考虑应用高阶组件模式。

这并不表示高阶组件无用武之地，在后续章节，我们会对 render props 和高阶组件分别讲解具体的实例。

## 10. 路由如何做权限校验？
### 10.1 实现
1. 登陆权限，一般来说这个是独立出来，不用 spa 做，就一个表单的事情，后面也容易做扩展，包括单点登录什么的；
2. 登陆集成到 spa 里面，这个一般在请求加拦截，vuex 可以存 token，每次请求头带 token，后端校验 token 是否有效，如果修改了或者过期了，返回约定的字段标识，异步请求 axios 在返回 response 的时候优先拦截 token 校验，如果失效直接 vue-router 路由到登录页；
3. 内部权限，子页面什么的，前端一般是打包好了文件，页面是全部的，但是有的页面需要权限控制是否能访问，这时候只能做 2 次校验，后端返回当前权限能访问的路由 or 页面，存 vuex，前端路由加 watch，每次切换跳转都要遍历一次；
4. 接口权限，有的接口是不能提供给无权限的人使用的，比如抓包出来的；这时候后端做鉴权，返回约定的字段就行

------
 
1. 后台接口加一层 api gateway 做权限控制，防止越权调用
2. 请求后台接口获取当前登录用户所有的 [可用菜单（路由）] 及 [权限信息（权限 key ）] 
3. 根据 [可用菜单] 动态生成 router
4. 页面子控件，如按钮（对应权限 key ）通过 v-if 实现显示与隐藏， 如
```js
<button @click="action" v-if="hasPermission('user.create')">新增用户</Button>
hasPermission 做成一个 mixin 混入所有组件
```

### 10.2 vue 路由权限限制
```js
function routerXmlFlag (menu, to) {
  for (let i = 0; i < menu.length; i++) {
    if (menu[i].url === to.fullPath) {
      return true
    }
    if (menu[i].subMenus && menu[i].subMenus.length) {
      routerXmlFlag(menu[i].subMenus, to)
    }
  }
  return false
}
router.beforeEach((to, from, next) => {
  if (to.meta.requireAuth) { // 判断该路由是否需要登录权限
    let token = sessionStorage.getItem('X-CSRF-TOKEN')
    if (token) { // 通过vuex state获取当前的token是否存在
      let menu = store.state.common.menu // 为了菜单的链接，直接跳转404
      if (menu && menu.length > 0) {
        let flag = routerXmlFlag(menu, to)
        if (flag) {
          next()
        } else {
          next('/404')
        }
      } else {
        next()
      }
    } else {
      next({
        path: '/login',
        query: {redirect: to.fullPath} // 将跳转的路由path作为参数，登录成功后跳转到该路由
      })
    }
  } else {
    next()
  }
})
// 前提，每个用户进来分配的菜单权限不一样， 但是手动输入菜单以外的url 可以进行访问
// bug 修改，手动输入菜单以外的链接，返回404
```

### 10.3 vue 路由验证
在没有登录的情况下开发者有可能会不让用户看到某些或者进入某些页面，vue 跳转使用的是vue-roter跳转。

使用vue-router的beforeEach函数接受三个参数to, from, next分别是to：去的页面、from：来自那个页面、next：定向到哪里

beforeEach需要写到vue实例前。

```js
//首先登录成功之后需要存一个状态到本地 这个状态可以是自己设置也可以配合后台来操作
router.beforeEach((to, from, next) => {
    //获取到登录状态
  const loginStuts = sessionStorage.getItem('loginStuts')
    //如果登录状态不存在或者去的页面是某个用户没登录不能去的页面
    //（to.path的意思为去往的 路径是/myinformation也可不写）
    //就跳转到login页面也就是登录界面
    //next函数不传参数即是验证通过去往该页面 传入参数即是调往参数页面
  if (!loginStuts && to.path == '/myinformation') {
        next('/login')
      } else {
        next()
      }
   })
    /* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  components: { App },
  template: '<App/>',
  store
})
```

### 10.4 如何用 Vue 实现前端权限控制(CSDN)
[如何用 Vue 实现前端权限控制](https://blog.csdn.net/gitchat/article/details/78849246)  
https://blog.csdn.net/gitchat/article/details/78849246

项目本身也是一个可运行的 DEMO，演示地址和测试账号同样见下方。

仓库地址：https://github.com/tower1229/Vue-Access-Control

项目主页：http://refined-x.com/Vue-Access-Control/

- root 任意
- client 任意


## 11. SSR 的原理是什么？
SSR，很多人的第一反应是“服务器端渲染”，但我更倾向于称之为“同构”，所以首先我们来对“`客户端渲染`”，“`服务器端渲染`”，“`同构`”这三个概念简单的做一个分析：
- **客户端渲染**：客户端渲染，页面初始加载的 HTML 页面中无网页展示内容，需要加载执行JavaScript 文件中的 React 代码，通过 JavaScript 渲染生成页面，同时，JavaScript 代码会完成页面交互事件的绑定，详细流程可参考下图（图片取材自 fullstackacademy.com）：
    <div align="center"><img src='../assets/012807.png'/></div>

- **服务器端渲染**：用户请求服务器，服务器上直接生成 HTML 内容并返回给浏览器。服务器端渲染来，页面的内容是由 Server 端生成的。一般来说，服务器端渲染的页面交互能力有限，如果要实现复杂交互，还是要通过引入 JavaScript 文件来辅助实现。服务器端渲染这个概念，适用于任何后端语言。
    <div align="center"><img src='../assets/012808.png'/></div>

- **同构**：同构这个概念存在于 Vue，React 这些新型的前端框架中，同构实际上是客户端渲染和服务器端渲染的一个整合。我们把页面的展示内容和交互写在一起，让代码执行两次。在服务器端执行一次，用于实现服务器端渲染，在客户端再执行一次，用于接管页面交互，详细流程可参考下图（图片取材自 fullstackacademy.com）:
    <div align="center"><img src='../assets/012809.png'/></div>

一般情况下，当我们使用 React 编写代码时，页面都是由客户端执行 JavaScript 逻辑动态挂 DOM 生成的，也就是说这种普通的单页面应用实际上采用的是客户端渲染模式。在大多数情况下，客户端渲染完全能够满足我们的业务需求，那为什么我们还需要 SSR 这种同构技术呢？

### 11.1 使用 SSR 技术的主要因素
1. CSR 项目的 TTFP（Time To First Page）时间比较长，参考之前的图例，在 CSR 的页面渲染流程中，首先要加载 HTML 文件，之后要下载页面所需的 JavaScript 文件，然后 JavaScript 文件渲染生成页面。在这个渲染过程中至少涉及到两个 HTTP 请求周期，所以会有一定的耗时，这也是为什么大家在低网速下访问普通的 React 或者 Vue 应用时，初始页面会有出现白屏的原因。
2. CSR 项目的 SEO 能力极弱，在搜索引擎中基本上不可能有好的排名。因为目前大多数搜索引擎主要识别的内容还是 HTML，对 JavaScript 文件内容的识别都还比较弱。如果一个项目的流量入口来自于搜索引擎，这个时候你使用 CSR 进行开发，就非常不合适了。

SSR 的产生，主要就是为了解决上面所说的两个问题。在 React 中使用 SSR 技术，我们让 React 代码在服务器端先执行一次，使得用户下载的 HTML 已经包含了所有的页面展示内容，这样，页面展示的过程只需要经历一个 HTTP 请求周期，TTFP 时间得到一倍以上的缩减。

同时，由于 HTML 中已经包含了网页的所有内容，所以网页的 SEO 效果也会变的非常好。之后，我们让 React 代码在客户端再次执行，为 HTML 网页中的内容添加数据及事件的绑定，页面就具备了 React 的各种交互能力。

但是，SSR 这种理念的实现，并非易事。我们来看一下在 React 中实现 SSR 技术的架构图：
    <div align="center"><img src='../assets/012810.png'/></div>

**SSR 之所以能够实现，本质上是因为虚拟 DOM 的存在**

SSR 的工程中，React 代码会在客户端和服务器端各执行一次。你可能会想，这没什么问题，都是 JavaScript 代码，既可以在浏览器上运行，又可以在 Node 环境下运行。但事实并非如此，如果你的 React 代码里，存在直接操作 DOM 的代码，那么就无法实现 SSR 这种技术了，因为在 Node 环境下，是没有 DOM 这个概念存在的，所以这些代码在 Node 环境下是会报错的。

好在 React 框架中引入了一个概念叫做虚拟 DOM，虚拟 DOM 是真实 DOM 的一个 JavaScript 对象映射，React 在做页面操作时，实际上不是直接操作 DOM，而是操作虚拟 DOM，也就是操作普通的 JavaScript 对象，这就使得 SSR 成为了可能。在服务器，我可以操作 JavaScript 对象，判断环境是服务器环境，我们把虚拟 DOM 映射成字符串输出；在客户端，我也可以操作 JavaScript 对象，判断环境是客户端环境，我就直接将虚拟 DOM 映射成真实 DOM，完成页面挂载。

其他的一些框架，比如 Vue，它能够实现 SSR 也是因为引入了和 React 中一样的虚拟 DOM 技术。

好，接下来我们回过头看流程图，前两步不说了，服务器端渲染肯定要先向 Node 服务器发送请求。重点是第 3 步，大家可以看到，服务器端要根据请求的地址，判断要展示什么样的页面了，这一步叫做服务器端路由。

我们再看第 10 步，当客户端接收到 JavaScript 文件后，要根据当前的路径，在浏览器上再判断当前要展示的组件，重新进行一次客户端渲染，这个时候，还要经历一次客户端路由（前端路由）。

那么，我们下面要说的就是服务器端路由和客户端路由的区别。

### 11.2 SSR 中客户端渲染与服务器端渲染路由代码的差异
实现 React 的 SSR 架构，我们需要让相同的 React 代码在客户端和服务器端各执行一次。大家注意，这里说的相同的 React 代码，指的是我们写的各种组件代码，所以在同构中，只有组件的代码是可以公用的，而路由这样的代码是没有办法公用的，大家思考下这是为什么呢？其实原因很简单，在服务器端需要通过请求路径，找到路由组件，而在客户端需通过浏览器中的网址，找到路由组件，是完全不同的两套机制，所以这部分代码是肯定无法公用。我们来看看在 SSR 中，前后端路由的实现代码：

**客户端路由：**
```js
const App = () => {
  return (
    <Provider store={store}>
      <BrowserRouter>
        <div>
          <Route path='/' component={Home}>
          </div>
      </BrowserRouter>
    </Provider>
  )
}
 
ReactDom.render(<App/>, document.querySelector('#root'))
```

**服务器端路由代码：**
```js
const App = () => {
  return 
    <Provider store={store}>
      <StaticRouter location={req.path} context={context}>
        <div>
          <Route path='/' component={Home}>
        </div>
      </StaticRouter>
    </Provider>
}
 
Return ReactDom.renderToString(<App/>)
```

服务器端路由代码相对要复杂一点，需要你把 location（当前请求路径）传递给 StaticRouter 组件，这样 StaticRouter 才能根据路径分析出当前所需要的组件是谁。（PS：StaticRouter 是 React-Router 针对服务器端渲染专门提供的一个路由组件。）

通过 BrowserRouter 我们能够匹配到浏览器即将显示的路由组件，对浏览器来说，我们需要把组件转化成 DOM，所以需要我们使用 ReactDom.render 方法来进行 DOM 的挂载。而 StaticRouter 能够在服务器端匹配到将要显示的组件，对服务器端来说，我们要把组件转化成字符串，这时我们只需要调用 ReactDom 提供的 renderToString 方法，就可以得到 App 组件对应的 HTML 字符串。

对于一个 React 应用来说，路由一般是整个程序的执行入口。在 SSR 中，服务器端的路由和客户端的路由不一样，也就意味着服务器端的入口代码和客户端的入口代码是不同的。远程控制电脑

我们知道， React 代码是要通过 Webpack 打包之后才能运行的，也就是第 3 步和第10 步运行的代码，实际上是源代码打包过后生成的代码。上面也说到，服务器端和客户端渲染中的代码，只有一部分一致，其余是有区别的。所以，针对代码运行环境的不同，要进行有区别的 Webpack 打包。

### 11.3 服务器端代码和客户端代码的打包差异
简单写两个 Webpack 配置文件作为 DEMO：
- **客户端 Webpack 配置：**  
    ```js
    {
      entry: './src/client/index.js',
      output: {
        filename: 'index.js',
        path: path.resolve(__dirname, 'public')
      },
      module: {
        rules: [{
          test: /\.js?$/,
          loader: 'babel-loader'
        },{
          test: /\.css?$/,
          use: ['style-loader', {
            loader: 'css-loader',
            options: {modules: true}
          }]
        },{
          test: /\.(png|jpeg|jpg|gif|svg)?$/,
          loader: 'url-loader',
          options: {
            limit: 8000,
            publicPath: '/'
          }
        }]
      }
    }
    ```
- **服务器端 Webpack 配置:**
    ```js
    {
      target: 'node',
      entry: './src/server/index.js',
      output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, 'build')
      },
      externals: [nodeExternals()],
      module: {
        rules: [{
          test: /\.js?$/,
          loader: 'babel-loader'
        },{
          test: /\.css?$/,
          use: ['isomorphic-style-loader', {
            loader: 'css-loader',
            options: {modules: true}
          }]
        },{
          test: /\.(png|jpeg|jpg|gif|svg)?$/,
          loader: 'url-loader',
          options: {
            limit: 8000,
            outputPath: '../public/',
            publicPath: '/'
          }
        }]
      }
    };
    ```

### 11.4 SSR 中异步数据的获取 + Redux 的使用
客户端渲染中，异步数据结合 Redux 的使用方式遵循下面的流程（对应图中第 12 步）：
1. 创建 Store
2. 根据路由显示组件
3. 派发 Action 获取数据
4. 更新 Store 中的数据
5. 组件 Rerender

而在服务器端，页面一旦确定内容，就没有办法 Rerender 了，这就要求组件显示的时候，就要把 Store 的数据都准备好，所以服务器端异步数据结合 Redux 的使用方式，流程是下面的样子（对应图中第 4 步）：
1. 创建 Store
2. 根据路由分析 Store 中需要的数据
3. 派发 Action 获取数据
4. 更新Store 中的数据
5. 结合数据和组件生成 HTML，一次性返回

下面，我们分析下服务器端渲染这部分的流程：
1. 创建 Store：这一部分有坑，要注意避免，大家知道，客户端渲染中，用户的浏览器中永远只存在一个 Store，所以代码上你可以这么写：
    ```js
    const store = createStore(reducer, defaultState)
    export default store;
    ```

    然而在服务器端，这么写就有问题了，因为服务器端的 Store 是所有用户都要用的，如果像上面这样构建 Store，Store 变成了一个单例，所有用户共享 Store，显然就有问题了。所以在服务器端渲染中，Store 的创建应该像下面这样，返回一个函数，每个用户访问的时候，这个函数重新执行，为每个用户提供一个独立的 Store：
    ```js
    const getStore = (req) => {
      return createStore(reducer, defaultState);
    }
    export default getStore;
    ```

2. 根据路由分析 Store 中需要的数据： 要想实现这个步骤，在服务器端，首先我们要分析当前出路由要加载的所有组件，这个时候我们可以借助一些第三方的包，比如说 react-router-config, 具体这个包怎么使用，不做过多说明，大家可以查看文档，使用这个包，传入服务器请求路径，它就会帮助你分析出这个路径下要展示的所有组件。

3. 派发 Action 获取数据: 接下来，我们在每个组件上增加一个获取数据的方法：
    ```js
    Home.loadData = (store) => {
      return store.dispatch(getHomeList())
    }
    ```

    这个方法需要你把服务器端渲染的 Store 传递进来，它的作用就是帮助服务器端的 Store 获取到这个组件所需的数据。 所以，组件上有了这样的方法，同时我们也有当前路由所需要的所有组件，依次调用各个组件上的 loadData 方法，就能够获取到路由所需的所有数据内容了。

4. 更新 Store 中的数据: 其实，当我们执行第三步的时候，已经在更新 Store 中的数据了，但是，我们要在生成 HTML 之前，保证所有的数据都获取完毕，这怎么处理呢？
    ```js
    // matchedRoutes 是当前路由对应的所有需要显示的组件集合
    matchedRoutes.forEach(item => {
      if (item.route.loadData) {
        const promise = new Promise((resolve, reject) => {
          item.route.loadData(store).then(resolve).catch(resolve);
        })
        promises.push(promise);
      }
    })
    
    Promise.all(promises).then(() => {
      // 生成 HTML 逻辑
    })
    ```

    这里，我们使用 Promise 来解决这个问题，我们构建一个 Promise 队列，等待所有的 Promise 都执行结束后，也就是所有 store.dispatch 都执行完毕后，再去生成 HTML。这样的话，我们就实现了结合 Redux 的 SSR 流程。

在上面，我们说到，服务器端渲染时，页面的数据是通过 loadData 函数来获取的。而在客户端，数据获取依然要做，因为如果这个页面是你访问的第一个页面，那么你看到的内容是服务器端渲染出来的，但是如果经过 react-router 路由跳转道第二个页面，那么这个页面就完全是客户端渲染出来的了，所以客户端也要去拿数据。

在客户端获取数据，使用的是我们最习惯的方式，通过 `componentDidMount` 进行数据的获取。这里要注意的是，`componentDidMount` 只在客户端才会执行，在服务器端这个生命周期函数是不会执行的。所以我们不必担心 `componentDidMount` 和 loadData 会有冲突，放心使用即可。这也是为什么数据的获取应该放到 `componentDidMount` 这个生命周期函数中而不是 `componentWillMount` 中的原因，可以避免服务器端获取数据和客户端获取数据的冲突。

### 11.5 Node 只是一个中间层
上一部分我们说到了获取数据的问题，在 SSR 架构中，一般 Node 只是一个中间层，用来做 React 代码的服务器端渲染，而 Node 需要的数据通常由 API 服务器单独提供。

这样做一是为了工程解耦，二也是为了规避 Node 服务器的一些计算性能问题。

请大家关注图中的第 4 步和第 12，13 步，我们接下来分析这几个步骤。

服务器端渲染时，直接请求 API 服务器的接口获取数据没有任何问题。但是在客户端，就有可能存在跨域的问题了，所以，这个时候，我们需要在服务器端搭建 Proxy 代理功能，客户端不直接请求 API 服务器，而是请求 Node 服务器，经过代理转发，拿到 API 服务器的数据。

这里你可以通过 express-http-proxy 这样的工具帮助你快速搭建 Proxy 代理功能，但是记得配置的时候，要让代理服务器不仅仅帮你转发请求，还要把 cookie 携带上，这样才不会有权限校验上的一些问题。
```js
// Node 代理功能实现代码
app.use('/api', proxy('http://apiServer.com', {
  proxyReqPathResolver: function (req) {
    return '/ssr' + req.url;
  }
}));
```

## 12. React中调用setState之后发生了什么事情?
React会将当前传入的参数对象与组件当前的状态合并,然后触发调和过程,在调和的过程中,React会以相对高效的方式根据新的状态构建React元素树并且重新渲染整个UI界面.

React得到的元素树之后,React会自动计算出新的树与老的树的节点的差异,然后根据差异对界面进行最小化的渲染,在React的差异算法中,React能够精确的知道在哪些位置发生看改变以及应该如何去改变,这样就保证了UI是按需更新的而不是重新渲染整个界面.

调用setState  >>  将传入参数与组件当前状态合并  >>  触发Reconciliation调和过程(生成最终状态)  >> 高效构建虚拟DOM,并准备renderUI界面  >>  计算新旧DOM异同  >>  根据异同进行render不同点  >>  完成按需更新

在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。

## 13. React中Element与Component的区别?
ReactElement是描述屏幕上所见的内容的数据结构,是对于UI的对象的表述.典型的ReactElement就是利用JSX构建的声明式代码片段,然后被转化为createElement的调用组合.

ReactComponent则是可以接收参数输入并且返回某个ReactElement的函数或者类. 

## 14. 在什么情况下会优先选择使用ClassComponent而不是FunctionalComponent?
组件需要包含内部状态或者使用到生命周期函数的时候使用ClassComponent,否则使用函数式组件

## 15. React中的refs属性的作用是什么?
Refs是React提供给我们安全的访问DOM元素或者某个组件实例的句柄,我们可以为元素添加ref属性然后在回调函数中接收该元素在DOM树中的句柄,该值会作为回调函数的第一个参数的返回.

## 16. React中keys的作用是什么?
Keys 是React在操作列表中元素被修改,添加,或者删除的辅助标识.
	
在开发过程中,我们需要保证某个元素的key 在其同级元素中具有唯一性,在ReactDiff算法中React会借助元素的Key值来判断该元素是新创建的还是被移动而来的元素,React会保存这个辅助状态,从而减少不必要的元素渲染.此外,React还需要借助Key值来判断元素与本地状态的关联干洗,因此我们在开发中不可忽视Key值的使用.

Keys 会有助于 React 识别哪些 items 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key 的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 items 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果 items 可以重新排序，就会导致 re-render 变慢。


key是给每一个vnode的唯一id,可以依靠key,更准确, 更快的拿到oldVnode中对应的vnode节点。

主要是为了提升diff【同级比较】的效率。自己想一下自己要实现前后列表的diff，如果对列表的每一项增加一个key，即唯一索引，那就可以很清楚的知道两个列表谁少了谁没变。而如果不加key的话，就只能一个个对比了。

## 17. 回调渲染模式( Render Callback Pattern)
在这种模式中,组件会接收某个函数作为子组件,然后在渲染函数中以props.children进行调用.
```js
import React ,{ Component, PropTypes } from 'react';
import fetchUser from 'Twitter';

class Twitter extends Component{
    state = {
        user : null
    }
    satic propTypes = {
        userName.propTypes.String.isRequied
    }
    componentDidMount(){
        fetchUser(this.props.userName)
            .then((user)=>{
                this.setState({user})
            })
    }
    render(){
        return this.props.children(this.state.user)
    }
}
```

此模式的优势在于将父组件与子组件解耦,父组件可以直接访问子组件的内部状态而不需要再通过Props传递,这样父组件能够更为方便地控制子组件展示的UI界面.如果将原本展示的Badge替换为Profile,可以方便的修改回调函数来实现

```js
<Twitter username="chuhan">
    { (user) => user === null }
</Twitter>
```

## 18. 组件的生命周期有哪三个状态,  有哪几个钩子函数？

有三个状态:  
1. 已经插入到DOM中      
2. 正在更新    
3. 已经卸载完毕

8个生命周期: 

1. construtor()　　    　　　　　　     创建组件
2. componentWillMount  　　             组件加载前
3. componentDidMount  　　　　       组件加载完成
4. componentWillRecevieProps() 　　父组件发生了  render  的时候, 子组件就调用这个钩子函数, 进行更新当前组件中, 传参相关的状态 
5. shouldComponentUpdate() 　　　 组件挂载完成后,  如果调用setState就会调用shouldComponentUpdate()函数, 来确定是否有必要更新渲染此组件,  默认返回true
6. componentDidUpdate()      　　　  必要的状态更新完成
7. render()　　　　　　　　　　　　开始渲染,  react核心函数
8. componentWillUnMount　　　　   组件卸载 / 销毁时调用,  一般都是:  componentDidMount() 函数中定义注册的事件, 在这里删除  

## 19. 在生命周期中的哪一步你应该发起 AJAX 请求？
我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下：

放到componentWillMount不好.    React 下一代调和算法 `Fiber` 会通过开始或停止渲染的方式优化应用性能，其会影响到 `componentWillMount` 的触发次数。对于 `componentWillMount` 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 `componentWillMount。如果我们将` AJAX 请求放到 `componentWillMount` 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。

如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 `componentDidMount` 函数中进行 AJAX 请求则能有效避免这个问题

在 componentDidMount 函数中发起ajax请求
1. 保证请求仅在组件挂载完毕后才会要求响应
2. 调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。React 可能会多次频繁调用componentWillMount。

## 20. shouldComponentUpdate作用,为何重要？
shouldComponentUpdate  是 允许 我们手动进行组件更新,   可以根据组件的实际应用场景, 设置合理的函数返回值 ,  决定是否要更新,   能够避免不必要的更新.

## 21. React 的工作原理
React 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 "diffing" 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新 DOM。

## 22. 使用 React 有何优点
- 只需查看 render 函数就会很容易知道一个组件是如何被渲染的
- JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的
- 支持服务端渲染，这可以改进 SEO 和性能
- 易于测试
- React 只关注 View 层，所以可以和其它任何框架(如Backbone.js, Angular.js)一起使用

## 23. 展示组件(Presentational component)和容器组件(Container component)之间有何不同
展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。

容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。

## 24. 类组件(Class component)和函数式组件(Functional component)之间有何不同
类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态

当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 '无状态组件(stateless component)'，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件

在组件需要包含内部状态或者使用到生命周期函数的时候使用 Class Component ，否则使用函数式组件。

## 25. (组件的)状态(state)和属性(props)之间有何不同
State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。

Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。

## 26. 何为受控组件(controlled component)
在 HTML 中，类似 `<input>`, `<textarea>` 和 `<select>` 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为"受控元素"。

## 27. 何为高阶组件(higher order component)
高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。

## 28. 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象
因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。

## 29. 除了在构造函数中绑定 this，还有其它方式吗
你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。

## 30. 怎么阻止组件的渲染
在组件的 render 方法中返回 null 并不会影响触发组件的生命周期方法

## 31. (在构造函数中)调用 super(props) 的目的是什么
在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。

## 32. 何为 JSX
JSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React "元素"，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 if 语句和 for 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。

## 33. 何为 Children
在JSX表达式中，一个开始标签(比如<a>)和一个关闭标签(比如</a>)之间的内容会作为一个特殊的属性props.children被自动传递给包含着它的组件。

这个属性有许多可用的方法，包括 React.Children.map，React.Children.forEach， React.Children.count， React.Children.only，React.Children.toArray。

## 34. 何为 redux
Redux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该有任何副作用。

## 35. 在 Redux 中，何为 store
Store 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责：
- 允许通过 getState() 访问 state
- 运行通过 dispatch(action) 改变 state
- 通过 subscribe(listener) 注册 listeners
- 通过 subscribe(listener) 返回的函数处理 listeners 的注销

## 36. 何为 action
Actions 是一个纯 javascript 对象，它们必须有一个 type 属性表明正在执行的 action 的类型。实质上，action 是将数据从应用程序发送到 store 的有效载荷。

## 37. 何为 reducer
一个 reducer 是一个纯函数，该函数以先前的 state 和一个 action 作为参数，并返回下一个 state。

## 38. Redux Thunk 的作用是什么
Redux thunk 是一个允许你编写返回一个函数而不是一个 action 的 actions creators 的中间件。如果满足某个条件，thunk 则可以用来延迟 action 的派发(dispatch)，这可以处理异步 action 的派发(dispatch)

## 39. 何为纯函数(pure function)
一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。

## 40. react中的回调渲染模式
1. 这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以 props.children进行调用：
2. 这种模式的优势在于将父组件与子组件解耦和， 父组件可以直接访问子组件的内部状态而不需要再通过Props传递，这样父组件能够更为方便地控制子组件展示的UI界面

## 41. React 中的事件处理逻辑
为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。

另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的。

## 42. React解决了什么问题
一个是组件复用问题，一个是性能问题，还有一个，如果也算的话，就是兼容性问题

## 43. React的协议问题你了解吗
React遵循的协议是“BSD许可证 + 专利开源协议”，这个协议比较奇葩，如果你的产品跟facebook没有竞争关系，你可以自由的使用react，但是如果有竞争关系，你的react的使用许可将会被取消。

## 44. 你在过去的项目里遇到的最大问题是什么？你最大的成就？
寻找更高级职位的人将解释他如何优化应用程序性能，而带领团队的人会解释他如何通过结对编程提高速度。

## 45. 传入 setState 函数的第二个参数的作用是什么？
该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成：
```js
this.setState(
	{ username: 'tylermcginnis33' },  () => console.log('setState has finished and the component has re-rendered.')
)
```

## 46. 封装ajax
```js
var jsGetAjaxPromise = function(param){
	return new Promise(function(resolve, reject){
		var xhr = new XMLHttpRequest();
		xhr.open(‘get’, param.url, true);
		xhr.onload = resolve;
		xhr.onerror = reject;
		xhr.send();
	})
}
```

## 47. Bind实现
```js
// 将bind方法的参数提取出来拼接返回的闭包函数中
Function.prototype.bind = function(context) {
	var that = this;
	var args = Array.prototype.slice.call(arguments, 1);

	return function() {
		// 预设参数一定是args在前拼接
		return that.apply(context,
			args.concat(Array.prototype.slice.call(arguments)));
	}
};
```

## 48. 快速排序
```js
function quickSort(arr) {
	//如果数组<=1,则直接返回
	if (arr.length <= 1) {
		return arr;
	}
	var pivotIndex = Math.floor(arr.length / 2);
	//找基准，并把基准从原数组删除
	var pivot = arr.splice(pivotIndex, 1)[0];
	//定义左右数组
	var left = [];
	var right = [];
	//比基准小的放在left，比基准大的放在right
	for (var i = 0; i < arr.length; i++) {
		if (arr[i] <= pivot) {
			left.push(arr[i]);
		} else {
			right.push(arr[i]);
		}
	}
	//递归
	return quickSort(left).concat([pivot], quickSort(right));
}
```

## 49. 正则匹配结巴程序
```javascript
var str = '我...我是是.......一个......个.....帅帅帅帅........哥!';

var reg = /\./gi;
var str = str.replace(reg, '');
document.write(str + '<br>');		//我是是个个帅帅帅帅哥!

reg = /(.)\1+/gi;
str = str.replace(reg, '$1');
document.write(str);				//我是个帅哥！
```

## 50. ['1', '2', '3'].map(parseInt) 解析
第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是真正的答案是[1, NaN, NaN]。

- 首先让我们回顾一下，map函数的第一个参数callback：  
  `var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])`
  这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。

- 而`parseInt`则是用来解析字符串的，使字符串成为指定基数的整数。
  > parseInt(string, radix)   
  接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。

- 了解这两个函数后，我们可以模拟一下运行情况
  1. parseInt('1', 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1
  2. parseInt('2', 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN
  3. parseInt('3', 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN
  map函数返回的是一个数组，所以最后结果为[1, NaN, NaN]


早在 2013年, 加里·伯恩哈德就在微博上发布了以下代码段:

```js
['10','10','10','10','10'].map(parseInt);
// [10, NaN, 2, 3, 4]
```
**parseInt**
`parseInt()` 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。

> const intValue = parseInt(string[, radix]);

- `string` 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。
- `radix` 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。
- `返回值` 返回一个整数或NaN

```js
parseInt(100); // 100
parseInt(100, 10); // 100
parseInt(100, 2); // 4 -> converts 100 in base 2 to base 10
```

注意： 在radix为 undefined，或者radix为 0 或者没有指定的情况下，JavaScript 作如下处理：
- 如果字符串 string 以"0x"或者"0X"开头, 则基数是16 (16进制).
- 如果字符串 string 以"0"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。
- 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。


**map**
`map()` 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。

```js
var new_array = arr.map(function callback(currentValue[,index[, array]]) {
 // Return element for new_array
 }[, thisArg])
```

可以看到callback回调函数需要三个参数, 我们通常只使用第一个参数 (其他两个参数是可选的)。
1. currentValue 是callback 数组中正在处理的当前元素。
2. index可选, 是callback 数组中正在处理的当前元素的索引。
3. array可选, 是callback map 方法被调用的数组。
4. 另外还有thisArg可选, 执行 callback 函数时使用的this 值。

```js
const arr = [1, 2, 3];
arr.map((num) => num + 1); // [2, 3, 4]
```

回到真实的事例上
回到我们真实的事例上

```js
['1', '2', '3'].map(parseInt)
```

对于每个迭代map, parseInt()传递两个参数: 字符串和基数。
所以实际执行的的代码是：

```js
['1', '2', '3'].map((item, index) => {
	return parseInt(item, index)
})

// 即返回的值分别为：

parseInt('1', 0) // 1
parseInt('2', 1) // NaN
parseInt('3', 2) // NaN, 3 不是二进制
```

所以：
```js
['1', '2', '3'].map(parseInt)
// 1, NaN, NaN
```

由此，加里·伯恩哈德例子也就很好解释了，这里不再赘述

```js
['10','10','10','10','10'].map(parseInt);
// [10, NaN, 2, 3, 4]
```

## 51. 防抖和节流
### 防抖 debounce
典型例子：限制 鼠标连击 触发。

一个比较好的解释是：
> 当一次事件发生后，事件处理器要等一定阈值的时间，如果这段时间过去后 再也没有 事件发生，就处理最后一次发生的事件。假设还差 0.01 秒就到达指定时间，这时又来了一个事件，那么之前的等待作废，需要重新再等待指定时间。

- 思路:
> 每次触发事件时都取消之前的延时调用方法

```js
function debounce(fn, wait = 50, immediate) {
  let timer;
  return function() {
    if (immediate) {
      fn.apply(this, arguments)
    }
    if (timer) clearTimeout(timer)
    timer = setTimeout(() => {
      fn.apply(this, arguments)
    }, wait)
  }
}
```

```js
function sayHi() {
  console.log('防抖成功');
}

var inp = document.getElementById('inp');
inp.addEventListener('input', debounce(sayHi)); // 防抖
```

### 节流 throttle
> 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率

> 可以理解为事件在一个管道中传输，加上这个节流阀以后，事件的流速就会减慢。实际上这个函数的作用就是如此，它可以将一个函数的调用频率限制在一定阈值内，例如 1s，那么 1s 内这个函数一定不会被调用两次

简单的节流函数:
```js
function throttle(fn, wait) {
	let prev = new Date();
	return function() { 
	  const args = arguments;
		const now = new Date();
		if (now - prev > wait) {
			fn.apply(this, args);
			prev = new Date();
		}
  }
}
```

- 思路：
> 每次触发事件时都判断当前是否有等待执行的延时函数

```js
function throttle(fn) {
  let canRun = true; // 通过闭包保存一个标记
  return function() {
    if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
    canRun = false; // 立即设置为false
    setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中
      fn.apply(this, arguments);
      // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。
      // 当定时器没有执行的时候标记永远是false，在开头被return掉
      canRun = true;
    }, 500);
  };
}

function sayHi(e) {
  console.log(e.target.innerWidth, e.target.innerHeight);
}
window.addEventListener('resize', throttle(sayHi));
```

## 52. Set、Map、WeakSet 和 WeakMap 的区别？
1. Set
   - 成员唯一、无序且不重复；
   - [value, value]，键值与键名是一致的（或者说只有键值，没有键名）；
   - 可以遍历，方法有：add、delete、has。

2. WeakSet
   - 成员都是对象；
   - 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏；
   - 不能遍历，方法有 add、delete、has。

3. Map
   - 本质上是键值对的集合，类似集合；
   - 可以遍历，方法很多，可以跟各种数据格式转换。

4. WeakMap
- 只接受对象最为键名（null 除外），不接受其他类型的值作为键名；
- 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的；
- 不能遍历，方法有 get、set、has、delete。


## 53. ES5/ES6 的继承除了写法以外还有什么区别
1. `class` 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。
    ```js
    const bar = new Bar(); // it's ok
    function Bar() {
      this.bar = 42;
    }

    const foo = new Foo(); // ReferenceError: Foo is not defined
    class Foo {
      constructor() {
        this.foo = 42;
      }
    }
    ```  

2. class 声明内部会启用严格模式。
    ```js
    // 引用一个未声明的变量
    function Bar() {
      baz = 42; // it's ok
    }
    const bar = new Bar();

    class Foo {
      constructor() {
        fol = 42; // ReferenceError: fol is not defined
      }
    }
    const foo = new Foo();
    ```

3. class 的所有方法（包括静态方法和实例方法）都是不可枚举的。
    ```js
    // 引用一个未声明的变量
    function Bar() {
      this.bar = 42;
    }
    Bar.answer = function() {
      return 42;
    };
    Bar.prototype.print = function() {
      console.log(this.bar);
    };
    const barKeys = Object.keys(Bar); // ['answer']
    const barProtoKeys = Object.keys(Bar.prototype); // ['print']

    class Foo {
      constructor() {
        this.foo = 42;
      }
      static answer() {
        return 42;
      }
      print() {
        console.log(this.foo);
      }
    }
    const fooKeys = Object.keys(Foo); // []
    const fooProtoKeys = Object.keys(Foo.prototype); // []
    ```

4. class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。
    ```js
    function Bar() {
      this.bar = 42;
    }
    Bar.prototype.print = function() {
      console.log(this.bar);
    };

    const bar = new Bar();
    const barPrint = new bar.print(); // it's ok

    class Foo {
      constructor() {
        this.foo = 42;
      }
      print() {
        console.log(this.foo);
      }
    }
    const foo = new Foo();
    const fooPrint = new foo.print(); // TypeError: foo.print is not a constructor
    ```

5. 必须使用 new 调用 class。
    ```js
    function Bar() {
      this.bar = 42;
    }
    const bar = Bar(); // it's ok

    class Foo {
      constructor() {
        this.foo = 42;
      }
    }
    const foo = Foo(); 
    // TypeError: Class constructor Foo cannot be invoked without 'new'
    ```

6. class 内部无法重写类名。
    ```js
    function Bar() {
      Bar = 'Baz'; // it's ok
      this.bar = 42;
    }
    const bar = new Bar();
    // Bar: 'Baz'
    // bar: Bar {bar: 42}  

    class Foo {
      constructor() {
        this.foo = 42;
        Foo = 'Fol'; // TypeError: Assignment to constant variable
      }
    }
    const foo = new Foo();
    Foo = 'Fol'; // it's ok
    ```

## 54. 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组
```js
Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{ return a-b})
```

## 55. JS 异步解决方案的发展历程以及优缺点。

### 1. 回调函数（callback）
```js
setTimeout(() => {
   // callback 函数体
}, 1000)
```

1. **缺点**：回调地狱，不能用 try catch 捕获错误，不能 return

回调地狱的根本问题在于：
- 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符；
- 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）；
- 嵌套函数过多的多话，很难处理错误。

```js
ajax('XXX1', () => {
   // callback 函数体
   ajax('XXX2', () => {
       // callback 函数体
       ajax('XXX3', () => {
           // callback 函数体
       })
   })
})
```

2. **优点**：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行）。


### 2. Promise
Promise 就是为了解决 callback 的问题而产生的。

Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装。

**优点：解决了回调地狱的问题。**
```js
ajax('XXX1')
 .then(res => {
     // 操作逻辑
     return ajax('XXX2')
 }).then(res => {
     // 操作逻辑
     return ajax('XXX3')
 }).then(res => {
     // 操作逻辑
 })
```

**缺点：无法取消 Promise ，错误需要通过回调函数来捕获。**

### 3. Generator
**特点：可以控制函数的执行**，可以配合 co 函数库使用。
```js
function *fetch() {
   yield ajax('XXX1', () => {})
   yield ajax('XXX2', () => {})
   yield ajax('XXX3', () => {})
}
let it = fetch()
let result1 = it.next()
let result2 = it.next()
let result3 = it.next()
```

### 4. Async/await
async、await 是异步的终极解决方案。

**优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题；**

**缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。**

```js
async function test() {
 // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式
 // 如果有依赖性的话，其实就是解决回调地狱的例子了
 await fetch('XXX1')
 await fetch('XXX2')
 await fetch('XXX3')
}
```

下面来看一个使用 await 的例子：
```js
let a = 0
let b = async () => {
 a = a + await 10
 console.log('2', a) // -> '2' 10
}
b()
a++
console.log('1', a) // -> '1' 1

// 1 1
// 2 10
```

对于以上代码你可能会有疑惑，让我来解释下原因：
- 首先函数 `b` 先执行，在执行到 `await 10` 之前变量 `a` 还是 0，因为 `await` 内部实现了 `generator` ，**generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来**；
- 因为 `await` 是异步操作，后来的表达式不返回 `Promise` 的话，就会包装成 `Promise.reslove(返回值)`，然后会去执行函数外的同步代码；
- 同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10

上述解释中提到了 `await` 内部实现了 `generator`，其实 `await` 就是 `generator` 加上 Promise的语法糖，且内部实现了自动执行 `generator`。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。


## 56. 10 个 Ajax 同时发起请求，全部返回展示结果，并且至多允许三次失败，说出设计思路
这个问题相信很多人会第一时间想到 Promise.all ，但是这个函数有一个局限在于如果失败一次就返回了，直接这样实现会有点问题，需要变通下。以下是两种实现思路

```js
// 以下是不完整代码，着重于思路 非 Promise 写法
let successCount = 0
let errorCount = 0
let datas = []
ajax(url, (res) => {
     if (success) {
         success++
         if (success + errorCount === 10) {
             console.log(datas)
         } else {
             datas.push(res.data)
         }
     } else {
         errorCount++
         if (errorCount > 3) {
            // 失败次数大于3次就应该报错了
             throw Error('失败三次')
         }
     }
})


// Promise 写法
let errorCount = 0
let p = new Promise((resolve, reject) => {
    if (success) {
         resolve(res.data)
     } else {
         errorCount++
         if (errorCount > 3) {
            // 失败次数大于3次就应该报错了
            reject(error)
         } else {
             resolve(error)
         }
     }
})
Promise.all([p]).then(v => {
  console.log(v);
});
```

## 57. 基于 Localstorage 设计一个 1M 的缓存系统，需要实现缓存淘汰机制
设计思路如下：
- 存储的每个对象需要添加两个属性：分别是过期时间和存储时间。
- 利用一个属性保存系统中目前所占空间大小，每次存储都增加该属性。当该属性值大于 1M 时，需要按照时间排序系统中的数据，删除一定量的数据保证能够存储下目前需要存储的数据。
- 每次取数据时，需要判断该缓存数据是否过期，如果过期就删除。

以下是代码实现，实现了思路，但是可能会存在 Bug，但是这种设计题一般是给出设计思路和部分代码，不会需要写出一个无问题的代码
```js
class Store {
  constructor() {
    let store = localStorage.getItem('cache')
    if (!store) {
      store = {
        maxSize: 1024 * 1024,
        size: 0
      }
      this.store = store
    } else {
      this.store = JSON.parse(store)
    }
  }
  set(key, value, expire) {
    this.store[key] = {
      date: Date.now(),
      expire,
      value
    }
    let size = this.sizeOf(JSON.stringify(this.store[key]))
    if (this.store.maxSize < size + this.store.size) {
      console.log('超了-----------');
      var keys = Object.keys(this.store);
      // 时间排序
      keys = keys.sort((a, b) => {
        let item1 = this.store[a],
          item2 = this.store[b];
        return item2.date - item1.date;
      });
      while (size + this.store.size > this.store.maxSize) {
        let index = keys[keys.length - 1]
        this.store.size -= this.sizeOf(JSON.stringify(this.store[index]))
        delete this.store[index]
      }
    }
    this.store.size += size

    localStorage.setItem('cache', JSON.stringify(this.store))
  }
  get(key) {
    let d = this.store[key]
    if (!d) {
      console.log('找不到该属性');
      return
    }
    if (d.expire > Date.now) {
      console.log('过期删除');
      delete this.store[key]
      localStorage.setItem('cache', JSON.stringify(this.store))
    } else {
      return d.value
    }
  }
  sizeOf(str, charset) {
    var total = 0,
      charCode,
      i,
      len;
    charset = charset ? charset.toLowerCase() : '';
    if (charset === 'utf-16' || charset === 'utf16') {
      for (i = 0, len = str.length; i < len; i++) {
        charCode = str.charCodeAt(i);
        if (charCode <= 0xffff) {
          total += 2;
        } else {
          total += 4;
        }
      }
    } else {
      for (i = 0, len = str.length; i < len; i++) {
        charCode = str.charCodeAt(i);
        if (charCode <= 0x007f) {
          total += 1;
        } else if (charCode <= 0x07ff) {
          total += 2;
        } else if (charCode <= 0xffff) {
          total += 3;
        } else {
          total += 4;
        }
      }
    }
    return total;
  }
}
```
