# js面试题（vue）
<!-- TOC -->

- [js面试题（vue）](#js面试题vue)
  - [1. 请详细说下你对vue生命周期的理解](#1-请详细说下你对vue生命周期的理解)
  - [2. vue 生命周期图](#2-vue-生命周期图)
  - [3. 谈谈你对vue的双向数据绑定的原理的理解](#3-谈谈你对vue的双向数据绑定的原理的理解)
  - [4. 谈谈你对vue组件间数据传递](#4-谈谈你对vue组件间数据传递)
  - [5. vue里面父组件如何修改子组件样式](#5-vue里面父组件如何修改子组件样式)

<!-- /TOC -->

## 1. 请详细说下你对vue生命周期的理解
vue的生命周期总共分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/后。
- 创建前/后：在beforeCreate阶段，vue实例的挂载元素`$el`和数据对象data都为undefined，还未初始化。在created阶段,vue实例的数据对象data有了，`$el`还没有。

- 载入前/后：在beforeMount阶段，vue实例的`$el`和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。

- 更新前/后：当data变化时，会触发beforeUpdate和updated方法。

- 销毁前/后：在执行destoryed方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。

## 2. vue 生命周期图
<div align="center"><img src='../resource/assets/0128vue1.png'/></div>

实例代码：
<div align="center"><img src='../resource/assets/0128vue2.png'/></div>


## 3. 谈谈你对vue的双向数据绑定的原理的理解
vue是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter,getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

具体步骤：
- 第一步：通过Observer提供的接口，对需要observe的数据对象进行递归遍历，给对象的每个属性、子属性对象的属性，都加上setter和getter（都绑定了一个专用的 `Dep`对象，这里的状态对象主要指组件当中的`data`属性）。  
    这样的话，给这个对象的某个值赋值，就会触发setter,那么就能监听到了数据变化。

- 第二步：compile解析模版指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。

- 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是：
    1. 在自身实例化时往属性订阅器(dep)里面添加自己
    2. 自身必须有一个update()方法
    3. 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。

- 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模版指令，最终利用Watcher搭起Observer和Compiler之间的通信桥梁，达到数据变化->视图更新；视图交互变化(input)->数据model变更的双向绑定效果。



## 4. 谈谈你对vue组件间数据传递
1. 通过 props 的方式向子组件传递（父子组件）
2. vuex进行状态管理（父子组件和非父子组件）
3. 非父子组件的通信传递 `Vue Event Bus($emit)`，使用Vue的实例，实现事件的监听和发布，实现组件之间数据的传递。
4. `inheritAttrs` + `$attrs` + `$listeners`



## 5. vue里面父组件如何修改子组件样式
> 在使用 vue 的开发中，我们有时会引用外部组件，包括UI组件。  
> 当 `<style>` 标签有 `scoped` 属性时，它的css只作用于当前组件中的元素。但是在父组件中添加了 `scoped` 之后，父组件的样式将不会渗透到子组件中，所以在父组件中书写子组件的样式是无效的。

解决方案:
1. **去掉scoped**  
    在父组件的 `<style>` 中去掉 `scoped` 后，父组件中可以书写子组件的样式，但是需要注意避免污染了全局样式。

2. **混用本地和全局样式**  
    可以在同一个组件中同时使用有作用域和无作用域的样式：
    ```css
    <style>
    /* ...全局样式...*/
    </style>

    <style scoped>
    /* ...本地样式... */
    </style>
    ```

3. **使用深度作用选择器**   
    如果你希望 `scoped` 样式中的一个选择器能够作用得 “**更深**“，例如影响子组件，你可以使用 `>>>` 操作符：
    ```css
    <style>
    .parent >>> .child {
      /* ... */
    }
    </style>
    ```

    有些像`SASS`之类的预处理器无法正确解析 `>>>` 。这种情况下你可以用 `/deep/` 操作符取而代之，`deep` 是 `>>>` 的别名，同样可以正常工作。

- **需要额外补充的是：**
    1. 通过 v-html 创建的 DOM 内容不受作用域内的样式影响，但是你仍然可以通过深度作用选择器来为他们设置样式
    2. CSS 作用域不能代替 class
    3. 在递归组件中小心使用后代选择器
    