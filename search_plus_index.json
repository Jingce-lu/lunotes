{"./":{"url":"./","title":"Introduction","keywords":"","body":" 世路如今已惯 此心到处悠然 "},"Js/js基础/js基础.html":{"url":"Js/js基础/js基础.html","title":"1.1 Js基础","keywords":"","body":"js基础 自定义模块 随机生成颜色 利用 Object.defineProperty 侦测对象的变化，最简单的可以写出这样的代码 JS中的可枚举属性与不可枚举属性以及扩展 自定义模块 (function(module){ module.exports = function (a, b){ return a + b; } if ('undefined' != typeof window){ window.add = module.exports; } })('undefined' == typeof module ? { module: { exports: {} } } : module); 随机生成颜色 function getRandomColor(){ let rgb = [];: for (let i = 0; i 利用 Object.defineProperty 侦测对象的变化，最简单的可以写出这样的代码 function defineReactive (data, key, val) { Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function () { return val }, set: function (newVal) { if(val === newVal){ return } val = newVal } }) } JS中的可枚举属性与不可枚举属性以及扩展 属性的枚举性会影响以下三个函数的结果： for…in Object.keys() JSON.stringify 先看一个例子，按如下方法创建kxy对象： function Person() { this.name = \"KXY\"; } Person.prototype = { constructor: Person, job: \"student\", }; var kxy = new Person(); Object.defineProperty(kxy, \"sex\", { value: \"female\", enumerable: false }); 其中用defineProperty为对象定义了一个名为”sex”的不可枚举属性 接下来做以下验证： for(var pro in kxy) { console.log(\"kxy.\" + pro + \" = \" + kxy[pro]); } // 结果： /* kxy.name = KXY kxy.constructor = function Person() { this.name = \"KXY\"; } kxy.job = student */ console.log(Object.keys(kxy)); // 返回结果：[\"name\"] // 只包含”name”属性，说明该方法只能返回对象本身具有的可枚举属性。 console.log(JSON.stringify(kxy)); // 返回结果：{\"name\":\"KXY\"} // 此方法也只能读取对象本身的可枚举属性，并序列化为JSON字符串（通过typeof JSON.stringify(kxy)得到string类型）。 function Person(){ this.name = 'kong'; } Person.prototype = { age : 18, job : 'student' } var a = new Person(); Object.defineProperty(a, 'sex', { value : 'men', enumerable : false //定义该属性不可枚举 }) //for in for(var k in a){ console.log(k); } //name age job //Object.keys() console.log(Object.keys(a)); //['name'] //JSON.stringify() console.log(JSON.stringify(a)); //{'name' : 'kong'} //propertyIsEnumerable方法判断该属性是否可枚举 console.log(a.propertyIsEnumerable('name')); //true console.log(a.propertyIsEnumerable('age')); //false console.log(a.propertyIsEnumerable('sex')); //false for (prop in obj) { if (!obj.hasOwnProperty(prop)) continue; // 跳过继承属性 } 如此一来，可以这样来使用 for...in 循环遍历对象属性： (function () { var getEnumPropertyNames = function (obj) { if (typeof obj !== 'object') throw TypeError(); // 参数必须是对象 var props = []; // 将要返回的数组 for (var prop in obj) { // 遍历所有可枚举的属性 if (obj.hasOwnProperty(prop)) { //判断是否是自有属性 props.push(prop); //将属性名添加到数组中 } } return props; //返回这个数组 } // 实例化 var obj = { 'x': 1, 'y':2 } obj.propertyIsEnumerable('toString') var propertys = getEnumPropertyNames(obj); console.log(propertys.length); //2 console.log(propertys.join(\",\")); //x,y })() "},"Js/js基础/ljc-Js.html":{"url":"Js/js基础/ljc-Js.html","title":"1.2 ljc-Js","keywords":"","body":"/** * 作者：路小二 * 开发日期：2016/12/25 * 描述：通用框架 */ //定义一个对象 - 名字是$ var $$ = function() {}; //第二种写法 $$.prototype = { $id: function(id) { return document.getElementById(id); }, //去除左边空格 ltrim: function(str) { return str.replace(/(^\\s*)/g, \"\"); }, //去除右边空格 rtrim: function(str) { return str.replace(/(\\s*$)/g, \"\"); }, //去除空格 trim: function(str) { return str.replace(/(^\\s*)|(\\s*$)/g, \"\"); }, //ajax myAjax: function(URL, fn) { var xhr = createXHR(); //返回了一个对象，这个对象IE6兼容。 xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if ( (xhr.status >= 200 && xhr.status return { left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop }; } return { // 剩下的肯定是怪异模式的 left: document.body.scrollLeft, top: document.body.scrollTop }; }, //封装可视区域大小 client: function() { if (window.innerWidth != null) { // ie9 + 最新浏览器 return { width: window.innerWidth, height: window.innerHeight }; } else if (document.compatMode === \"CSS1Compat\") { // 标准浏览器 return { width: document.documentElement.clientWidth, height: document.documentElement.clientHeight }; } return { // 怪异浏览器 width: document.body.clientWidth, height: document.body.clientHeight }; }, // 多个属性运动框架 添加回调函数 animate: function(obj, json, fn) { // 给谁 json clearInterval(obj.timer); obj.timer = setInterval(function() { var flag = true; // 用来判断是否停止定时器 一定写到遍历的外面 for (var attr in json) { // attr 属性 json[attr] 值 //开始遍历 json // 计算步长 用 target 位置 减去当前的位置 除以 10 // console.log(attr); var current = 0; if (attr == \"opacity\") { current = Math.round(parseInt(getStyle(obj, attr) * 100)) || 0; console.log(current); } else { current = parseInt(getStyle(obj, attr)); // 数值 } // console.log(current); // 目标位置就是 属性值 var step = (json[attr] - current) / 10; // 步长 用目标位置 - 现在的位置 / 10 step = step > 0 ? Math.ceil(step) : Math.floor(step); //判断透明度 if (attr == \"opacity\") { // 判断用户有没有输入 opacity if (\"opacity\" in obj.style) { // 判断 我们浏览器是否支持opacity // obj.style.opacity obj.style.opacity = (current + step) / 100; } else { // obj.style.filter = alpha(opacity = 30) obj.style.filter = \"alpha(opacity = \" + (current + step) * 10 + \")\"; } } else if (attr == \"zIndex\") { obj.style.zIndex = json[attr]; } else { obj.style[attr] = current + step + \"px\"; } if (current != json[attr]) { // 只要其中一个不满足条件 就不应该停止定时器 这句一定遍历里面 flag = false; } } if (flag) { // 用于判断定时器的条件 clearInterval(obj.timer); //alert(\"ok了\"); if (fn) { // 很简单 当定时器停止了。 动画就结束了 如果有回调，就应该执行回调 fn(); // 函数名 + （） 调用函数 执行函数 暂且这样替代 } } }, 30); } }; //在框架中实例化，这样外面使用的使用就不用实例化了 $$ = new $$(); "},"Js/js基础/moveJs.html":{"url":"Js/js基础/moveJs.html","title":"1.3 moveJs","keywords":"","body":"// JavaScript Document function startMove(obj, json, endFn) { clearInterval(obj.timer); obj.timer = setInterval(function() { var bBtn = true; for (var attr in json) { var iCur = 0; if (attr == \"opacity\") { if (Math.round(parseFloat(getStyle(obj, attr)) * 100) == 0) { iCur = Math.round(parseFloat(getStyle(obj, attr)) * 100); } else { iCur = Math.round(parseFloat(getStyle(obj, attr)) * 100) || 100; } } else { iCur = parseInt(getStyle(obj, attr)) || 0; } var iSpeed = (json[attr] - iCur) / 8; iSpeed = iSpeed > 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed); if (iCur != json[attr]) { bBtn = false; } if (attr == \"opacity\") { obj.style.filter = \"alpha(opacity=\" + (iCur + iSpeed) + \")\"; obj.style.opacity = (iCur + iSpeed) / 100; } else { obj.style[attr] = iCur + iSpeed + \"px\"; } } if (bBtn) { clearInterval(obj.timer); if (endFn) { endFn.call(obj); } } }, 30); } function getStyle(obj, attr) { if (obj.currentStyle) { return obj.currentStyle[attr]; } else { return getComputedStyle(obj, false)[attr]; } } "},"Js/js基础/移动web.html":{"url":"Js/js基础/移动web.html","title":"1.4 移动web","keywords":"","body":"移动web 改变meta视口标签 var meta = document.getElemmentsByTagName('meta'[0])； meta.setAttribute('content', 'width=device-width, initial-scale=1') 分辨率 window.devicePixeRatio 屏幕方向 window.orientation css background-attachment: scroll || fixed || local scroll: 默认值 背景图随页面一起滚动 fixed: 背景图相对于视口固定不动 local: 背景图随元素一起滚动 vh 和 vW尺寸单位代表视口的百分比， 比如 50vw表示50%的视口宽度 触摸事件 touchstart -- 在用户的手指触摸屏幕的瞬间触发 touchmove -- 在用户移动手指的过程中连续触发 touchend -- 在用户的手指离开屏幕的瞬间触发 touchstart、touchmove、touchendpointerdown、pointermove、 pointerup事件在同一时刻触发 //获取兼容浏览器事件坐标的函数 function findCoordinates(e){ //如果需要，用PageX/Y代替clientX/Y var x, y; if(e.changedTouches){ //touch事件 x = e.changedTouches[0].clentX; y = e.changedTouches[0].clentY; }else{ //pointer或mouse事件 x = e.clientX; y = e.clientY; } return [x, y]; } "},"Js/js基础/ICD.html":{"url":"Js/js基础/ICD.html","title":"1.5 ICD","keywords":"","body":"﻿ICD.js /** * ICD Library v1.0.0 * * Includes select.js, event.js, animate.js * * Copyright 2014 ICD Foundation * Author XXXXXXX * Tel XXXXXX * Email XXXXXX * * Date: 2014-11-30 */ (function(window){ var ICD = function(str){ if(typeof str == 'function'){ window.onload = str; }else{ return new ICD.init(str); } } ICD.init = function(str){ var sel = '', result = [], context = [], arr = [], that = this; that.length = 0; if(!str){ return that; } if(typeof str === 'string'){ var group = str.split(','); for(var g = 0, glen = group.length; g = 0){ if(context.length){ for(var c = 0, clen = context.length; c = 0){ if(context.length){ for(var c = 0, clen = context.length; c = 0){ arr.push(dom[i]); } } return arr } } function $tag(tag, context){ if(context){ return context.getElementsByTagName(tag); }else{ return document.getElementsByTagName(tag); } } function $class(className, context){ if(context){ if(context.getElementsByClassName){ return context.getElementsByClassName(className); } }else{ if(document.getElementsByClassName){ return document.getElementsByClassName(className); } } var arr = []; if(context){ var dom = context.getElementsByTagName('*'); }else{ var dom = document.getElementsByTagName('*'); } for(var i = 0, len = dom.length; i = 0){ arr.push(dom[i]); } } return arr } return that; } ICD.extend = function() { var key ,arg = arguments ,i = 1 ,len = arg.length ,target = null; if(len === 0){ return; }else if(len === 1){ target = ICD.init.prototype; i--; }else{ target = arg[0]; } for(; i = 0; i--){ this[i].addEventListener(type, fn, false); } }else if(document.attachEvent){ function addEvent(dom){ dom.attachEvent('on' + type, function(){ fn.call(dom); }); } for(; i >= 0; i--){ // IE 下this为window，此解决办法事件不能移除，解决办法详见jQuery un方法 addEvent(this[i]); } }else{ for(; i >= 0; i--){ this[i]['on' + type] = fn; } } return this; } // 解除事件 ,un : function(type, fn){ if (this.length == 0) { return this; }; var i = this.length - 1; if(document.removeEventListener){ for(; i >= 0; i--){ this[i].removeEventListener(type, fn); } }else if(document.detachEvent){ for(; i >= 0; i--){ this[i].detachEvent(type, fn); } }else{ for(; i >= 0; i--){ this[i]['on' + type] = null; } } return this; } }); ICD.extend(ICD, { // 获取事件对象 getEvent : function(event){ return event ? event : window.event; } // 获取元素 ,getTarget : function(event){ var event = this.getEvent(event); return event.target || event.srcElement; } ,getICDTarget : function(event){ var event = this.getEvent(event); return ICD(event.target || event.srcElement); } // 阻止冒泡以及捕获 ,stopPropagation : function(event){ var event = this.getEvent(event); if(event.stopPropagation){ event.stopPropagation(); }else{ event.cancelBubble = true; } } // 阻止默认行为 ,preventDefault : function(event){ var event = this.getEvent(event); if(event.preventDefault){ event.preventDefault(); }else{ event.returnValue = false; } } ,getDetail : function(event){ var event = this.getEvent(event); if(event.wheelDelta){ return event.wheelDelta; }else{ return -event.detail * 40; } } }); //公共方法 ICD.extend(ICD, { camelCase : function(str){ return str.replace(/\\-(\\w)/g, function(all, letter){ return letter.toUpperCase(); }); }, trim : function(str){ return str.replace(/^\\s+|\\s+$/g, '') }, formateString : function(str, data){ return str.replace(/@\\((\\w+)\\)/g, function(match, key){ return typeof data[key] === \"undefined\" ? '' : data[key]}); } }); //元素模块 ICD.extend({ css : function(){ var arg = arguments, len = arg.length; if(this.length = 0; j--){ this[j].style[ICD.camelCase(i)] = arg[0][i]; } } } }else if(len === 2){ for(var j = this.length - 1; j >= 0; j--){ this[j].style[ICD.camelCase(arg[0])] = arg[1]; } } return this; } ,attr : function(){ var arg = arguments, len = arg.length; if(this.length = 0; j--){ this[j].setAttribute(i, arg[0][i]); } } } }else if(len === 2){ for(var j = this.length - 1; j >= 0; j--){ this[j].setAttribute(arg[0], arg[1]); } } return this; } ,html : function(){ var arg = arguments, len = arg.length; if(this.length = 0; i--){ this[i].innerHTML = arg[0]; } }else if(len === 2 && arg[1]){ for(var i = this.length - 1; i >= 0; i--){ this[i].innerHTML += arg[0]; } } return this; } ,hasClass : function(val){ if(!this[0]){ return; } var value = ICD.trim(val); return this[0].className.indexOf(value) >= 0 ? true : false; } ,addClass : function(val){ var value = ICD.trim(val), str = ''; for(var i = 0, len = this.length; i = 0){ this[i].className = this[i].className.replace(value, ''); }else{ this[i].className += ' ' + value; } } return this; } }); //操作模块 ICD.extend(ICD, { create : function(type, value){ var dom = document.createElement(type); return ICD().add(dom).attr(value); } ,directChildren : function(dom, tag){ var result = [], children, tag = tag; if(typeof dom == 'string'){ dom = ICD.init(dom); } if(dom.length){ for(var i = 0, len = dom.length; i = 0; j--){ this[j].appendChild(doms[i]); } } }, appendTo : function(parent){ var doms = ICD(parent); for(var i = 0; i = 0; j--){ doms[i].appendChild(this[j]); } } }, get : function(num){ return this[num] ? this[num] : null; }, eq : function(num){ return ICD(this.get(num)); } }) // 动画模块 var _requestAnimateFrame = (function(w, r){ var _lastTime = 0; return w['r' + r] || w['webkitR' + r] || w['mozR' + r] || w['msR' + r] || w['oR' + r] || function(callback, element) { var _currTime = +new Date(), _timeToCall = Math.max(0, 16 - (_currTime - _lastTime)), _newTime = _currTime + _timeToCall, id = w.setTimeout(function() { callback(_newTime); }, _timeToCall); _lastTime = _newTime; return id; }; })(window, 'equestAnimationFrame'), _cancelAnimateFrame = (function(w, c){ return w['c' + c] || w['webkitC' + c] || w['mozC' + c] || w['msC' + c] || w['oC' + c] || function(t){ clearTimeout(t); }; })(window, 'ancelAnimationFrame'), _setIntervalFram = function(callback, interval){ var id = setInterval(callback, interval); return id; }, _clearIntervalFram = function(id){ clearInterval(id); }; var Animate = function(interval){ this._timer = 0; this._queen = []; this._interval = interval || false; } Animate.prototype = { easing : { def: function (t, b, c, d) { return (c - b) * t / d + b }, linear : function(t, b, c, d){ return this.def(t, b, c, d); } } ,_run : function(){ if(this._timer) return; this._reset(); } ,_clear : function(){ !this._interval ? _cancelAnimateFrame(this._timer) : _clearIntervalFram(this._timer); this._timer = 0; } ,_reset : function(){ this._clear(); this._go(); } ,_go : function(){ var that = this; that._timer = !this._interval ? _requestAnimateFrame(function(){ that._loop(); }) : _setIntervalFram(function(){ that._loop(); }, that._interval); } ,_loop : function(){ if(this._queen.length === 0){ this._clear(); return; } var now = +new Date() ,i = this._queen.length - 1 ,instance = null; for(; i >= 0; i--){ instance = this._queen[i]; instance.passed = now - instance.time; if(instance.passed = instance.duration){ instance.passed = instance.duration; instance.tween = instance.to; this._execute(instance); this._destory(instance); }else{ this._bufferExec(instance); } instance = null; } !this._interval && this._go(); } ,_execute : function(instance){ try{ instance.main(instance.dom, instance.args); }catch(e){ } } ,_bufferExec : function(instance){ instance.tween = typeof instance.step === 'undefined' ? this.easing[instance.type](instance.passed, instance.from, instance.to, instance.duration) : instance.step; this._execute(instance); } ,_adaptInstance : function(instance){ var opinion = ICD.extend({}, { from : 0 ,to : 1 ,type : 'def' ,duration : 400 ,args : null ,dom : null ,main : function(){} ,time : +new Date() ,end : function(){} }); if(instance.type && !(instance.type in this.easing)) instance.type = 'def'; for(var key in opinion){ if(typeof instance[key] === 'undefined') instance[key] = opinion[key]; } return instance; } ,_addInstance : function(instance, shouldReset){ var obj = this._adaptInstance(instance), pos = this._getIndex(obj); if(pos = 0; i--){ if(this._queen[i] === instance){ return i } } return -1; } ,_destory : function(instance){ var that = this; that._queen.splice(that._getIndex(instance), 1); instance.end(instance.dom, instance.args); for(var key in instance){ delete instance[key]; } instance = null; } ,add : function(param, shouldReset){ if(!param) return; var tostring = Object.prototype.toString; if(tostring.call(param) === \"[object Array]\"){ for(var i = 0, len = param.length; i = 0){ this._queen[pos].time += getNewTime(this._queen[pos].time, this._queen[pos].passed); } this._run(); }else{ var i = this._queen.length - 1; for(; i >= 0; i--){ this._queen[i].time += getNewTime(this._queen[i].time, this._queen[i].passed); } this._run(); } function getNewTime(queenTime, passTime){ return +new Date() - queenTime - (!!passTime ? +passTime : 0); } return this; } ,clear : function(){ this._clear(); var i = this._queen.length - 1; for(; i >= 0; i--){ this._destory(this._queen[i]); } return this; } ,remove : function(instance){ this._destory(this._adaptInstance(instance)); return this; } ,changeInterval : function(interval){ this._clear(); if(typeof interval === 'number'){ this._interval = interval; }else if(typeof interval === 'boolean' && !interval){ this._interval = interval; }else if(!interval){ this._interval = !!interval; } this._go(); return this; } // number, object, string, boolean ,create : function(){ var len = arguments.length, _num = null, cout = 1; if(typeof arguments[0] === \"number\"){ _num = arguments[0]; }else{ cont = 0; } if(len > cout){ if(typeof arguments[cout] === \"object\"){ arguments[cout][arguments[cout + 1] && typeof arguments[cout + 1] === \"string\" ? arguments[cout + 1] : 'animate'] = new Animate(_num); if((arguments[cout + 1] && typeof arguments[cout + 1] === \"boolean\") || (arguments[cout + 2] && typeof arguments[cout + 2] === \"boolean\")){ delete w.animate; } }else if(typeof arguments[cout] === \"string\"){ if(typeof arguments[cout] === \"boolean\"){ return new Animate(_num); }else{ try{ if(arguments[cout] in w) return; }catch(e){} w[arguments[cout]] = new Animate(_num); delete w.animate; } }else{ return new Animate(_num); } }else{ if(_num){ w.animate = new Animate(_num); }else{ return new Animate(); } } return this; } } ICD.extend(ICD, { animate : new Animate() }); ICD.extend({ tween : ICD.animate.create(), animate : function(obj){ obj.dom = this; this.tween.add(obj); return this; } }); ICD.noConflict = function(library){ if(library){ window.$ = library; }else{ window.$ = null; delete window.$; } return ICD; } window.ICD = window.$ = ICD; })(window); // 算法扩展 ICD.extend(ICD.animate.easing, { swing: function (t, b, c, d) { return this.easeOutQuad(t, b, c, d); }, easeInQuad: function (t, b, c, d) { return c*(t/=d)*t + b; }, easeOutQuad: function (t, b, c, d) { return -c *(t/=d)*(t-2) + b; }, easeInOutQuad: function (t, b, c, d) { if ((t/=d/2) "},"Js/js基础/js-es6-Map.html":{"url":"Js/js基础/js-es6-Map.html","title":"1.6 js es6 Map","keywords":"","body":"es6 javascript的map数据类型转换 es6 javascript的map数据类型转换 1. Map定义 | 属性 | 方法 1.1. 定义 1.2. 语法 1.3. 属性 1.4. 方法 示例 2. 数据类型转换 2.1. Map 转为数组 2.2. 数组转为 Map 2.3. Map 转为对象 2.4. 对象转为 Map 2.5. Map 转为 JSON 2.6. JSON 转为 Map 1. Map定义 | 属性 | 方法 1.1. 定义 键/值对的集合 1.2. 语法 mapObj = new Map() 集合中的键和值可以是任何类型。如果使用现有密钥向集合添加值，则新值会替换旧值。 1.3. 属性 下表列出了 Map 对象的属性和描述 构造函数 指定创建映射的函数。 Prototype — 原型 为映射返回对原型的引用。 size 返回映射中的元素数。 1.4. 方法 下表列出了 Map 对象的方法和描述。 clear 从映射中移除所有元素。 delete 从映射中移除指定的元素。 forEach 对映射中的每个元素执行指定操作。 get 返回映射中的指定元素。 has 如果映射包含指定元素，则返回 true。 set 添加一个新建元素到映射。 toString 返回映射的字符串表示形式。 valueOf 返回指定对象的原始值。 示例 var m = new Map(); m.set(1, \"black\"); m.set(2, \"red\"); m.set(\"colors\", 2); m.set({x:1}, 3); m.forEach(function (item, key, mapObj) { document.write(item.toString() + \"\"); }); document.write(\"\"); document.write(m.get(2)); // Output: // black // red // 2 // 3 // // red 2. 数据类型转换 2.1. Map 转为数组 // 使用扩展运算符(...) let myMap = new Map().set(true, 7).set({ foo: 3 }, ['abc']); [...myMap] // [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ] 2.2. 数组转为 Map 将数组转入 Map 构造函数, 就可以转为 Map new Map([ [true, 7], [ { foo: 3 }, ['abc'] ] ]) // Map {true => 7, Object {foo: 3} => ['abc']} 2.3. Map 转为对象 如果所有 Map 的键都是字符串, 它可以转为对象。 function strMapToObj(strMap) { let obj = Object.create(null); for (let [k, v] of strMap) { obj[k] = v; } return obj; } let myMap = new Map().set('yes', true).set('no', false); strMapToObj(myMap) // { yes: true, no: false } 2.4. 对象转为 Map function objToStrMap(obj) { let strMap = new Map(); for (let k of Object.keys(obj)) { strMap.set(k, obj[k]); } return strMap; } objToStrMap({ yes: true, no: false }) // [ [ 'yes', true ], [ 'no', false ] ] 2.5. Map 转为 JSON Map 转为 JSON 要区分两种情况。 一种情况是, Map 的键名都是字符串, 这时可以选择转为对象 JSON。 function strMapToJson(strMap) { return JSON.stringify(strMapToObj(strMap)); } let myMap = new Map().set('yes', true).set('no', false); strMapToJson(myMap) // '{\"yes\":true,\"no\":false}' 另一种情况是, Map 的键名有非字符串, 这时可以选择转为数组 JSON。 function mapToArrayJson(map) { return JSON.stringify([...map]); } let myMap = new Map().set(true, 7).set({ foo: 3 }, ['abc']); mapToArrayJson(myMap) // '[[true,7],[{\"foo\":3},[\"abc\"]]]' 2.6. JSON 转为 Map JSON 转为 Map, 正常情况下, 所有键名都是字符串。 function jsonToStrMap(jsonStr) { return objToStrMap(JSON.parse(jsonStr)); } jsonToStrMap('{\"yes\":true,\"no\":false}') // Map {'yes' => true, 'no' => false} 但是, 有一种特殊情况, 整个 JSON 就是一个数组, 且每个数组成员本身, 又是一个有两个成员的数组。 这时, 它可以一一对应地转为 Map。 这往往是数组转为 JSON 的逆操作。 function jsonToMap(jsonStr) { return new Map(JSON.parse(jsonStr)); } jsonToMap('[[true,7],[{\"foo\":3},[\"abc\"]]]') // Map {true => 7, Object {foo: 3} => ['abc']} "},"Js/js基础/ES6-数组array新增方法.html":{"url":"Js/js基础/ES6-数组array新增方法.html","title":"ES6-数组array新增方法","keywords":"","body":"ES6---数组array新增方法 ES6---数组array新增方法 1. find(fn) 2. findIndex 3. includes 4. keys 5. values 6. entries 7. fill 8. Array.of() 9. Array.from() 10. copyWithin 1. find(fn) find的参数为回调函数，回调函数可以接收3个参数，值x、索引i、数组arr，回调函数默认返回值x。 let arr=[1,2,234,'sdf',-2]; arr.find(function(x){ return x 2. findIndex findIndex和find差不多，不过默认返回的是索引 let arr=[1,2,234,'sdf',-2]; arr.findIndex(function(x){ return x 3. includes includes函数与string的includes一样，接收2参数，查询的项以及查询起始位置。 let arr=[1,2,234,'sdf',-2]; arr.includes(2);// 结果true，返回布尔值 arr.includes(20);// 结果：false，返回布尔值 arr.includes(2,3)//结果：false，返回布尔值 4. keys keys，对数组索引的遍历 let arr=[1,2,234,'sdf',-2]; for(let a of arr.keys()){ console.log(a) }//结果：0,1,2,3,4 遍历了数组arr的索引 5. values values，对数组项的遍历 let arr=[1,2,234,'sdf',-2]; for(let a of arr.values()){ console.log(a) }//结果：1,2,234,sdf,-2 遍历了数组arr的值 6. entries entries，对数组键值对的遍历。 let arr=['w','b']; for(let a of arr.entries()){ console.log(a) }//结果：[0,w],[1,b] for(let [i,v] of arr.entries()){ console.log(i,v) }//结果：0 w,1 b 7. fill fill方法改变原数组，当第三个参数大于数组长度时候，以最后一位为结束位置。 let arr=['w','b']; arr.fill('i')//结果：['i','i']，改变原数组 arr.fill('o',1)//结果：['i','o']改变原数组,第二个参数表示填充起始位置 new Array(3).fill('k').fill('r',1,2)//结果：['k','r','k']，第三个数组表示填充的结束位置 8. Array.of() Array.of()方法永远返回一个数组，参数不分类型，只分数量，数量为0返回空数组。 Array.of('w','i','r')//[\"w\", \"i\", \"r\"]返回数组 Array.of(['w','o'])//[['w','o']]返回嵌套数组 Array.of(undefined)//[undefined]依然返回数组 Array.of()//[]返回一个空数组 9. Array.from() Array.from可以把带有lenght属性类似数组的对象转换为数组，也可以把字符串等可以遍历的对象转换为数组，它接收2个参数，转换对象与回调函数 Array.from({'0':'w','1':'b',length:2})//[\"w\", \"b\"],返回数组的长度取决于对象中的length，故此项必须有！ Array.from({'0':'w','1':'b',length:4})//[\"w\", \"b\", undefined, undefined],数组后2项没有属性去赋值，故undefined Array.from({'0':'w','1':'b',length:1})//[\"w\"],length小于key的数目，按序添加数组 ////////////////////////////// let divs=document.getElementsByTagName('div'); Array.from(divs)//返回div元素数组 Array.from('wbiokr')//[\"w\", \"b\", \"i\", \"o\", \"k\", \"r\"] Array.from([1,2,3],function(x){ return x+1 } )//[2, 3, 4],第二个参数为回调函数 10. copyWithin copyWithin方法接收三个参数，被替换数据的开始处、替换块的开始处、替换块的结束处(不包括);copyWithin(s,m,n). [\"w\", \"i\", \"r\"].copyWithin(0)//此时数组不变 [\"w\", \"i\", \"r\"].copyWithin(1)//[\"w\", \"w\", \"i\"],数组从位置1开始被原数组覆盖，只有1之前的项0保持不变 [\"w\", \"i\", \"r\",\"b\"].copyWithin(1,2)//[\"w\", \"r\", \"b\", \"b\"],索引2到最后的r,b两项分别替换到原数组1开始的各项，当数量不够，变终止 [\"w\", \"i\", \"r\",'b'].copyWithin(1,2,3)//[\"w\", \"r\", \"r\", \"b\"]，强第1项的i替换为第2项的r "},"Js/js基础/require和import区别.html":{"url":"Js/js基础/require和import区别.html","title":"require和import区别","keywords":"","body":"JS 中的require 和 import 区别 这两个都是为了JS模块化编程使用. 1. 遵循规范 require 是 AMD规范引入方式 import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法 2. 调用时间 require是运行时调用，所以require理论上可以运用在代码的任何地方 import是编译时调用，所以必须放在文件开头 3. 本质 require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量 import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require require / exports ： 遵循 CommonJS/AMD，只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化。 用法只有以下三种简单的写法： const fs = require('fs') exports.fs = fs module.exports = fs import / export： 遵循 ES6 规范，支持编译时静态分析，便于JS引入宏和类型检验。动态绑定。 写法就比较多种多样： import fs from 'fs' import {default as fs} from 'fs' import * as fs from 'fs' import {readFile} from 'fs' import {readFile as read} from 'fs' import fs, {readFile} from 'fs' export default fs export const fs export function readFile export {readFile, read} export * from 'fs' ` 通过require引入基础数据类型时，属于复制该变量。 通过require引入复杂数据类型时，数据浅拷贝该对象。 出现模块之间的循环引用时，会输出已经执行的模块，而未执行的模块不输出（比较复杂） CommonJS模块默认export的是一个对象，即使导出的是基础数据类型 加载方式 规范 命令 特点 运行时加载 CommonJS/AMD require 社区方案，提供了服务器/浏览器的模块加载方案。非语言层面的标准。只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化。 编译时加载 ESMAScript6+ import 语言规格层面支持模块功能。支持编译时静态分析，便于JS引入宏和类型检验。动态绑定 "},"Js/js基础/window.history方法总结.html":{"url":"Js/js基础/window.history方法总结.html","title":"window.history方法总结","keywords":"","body":"window.history 方法总结 一、历史记录概览 window.history.back(); window.history.forward(); window.history.go(-1); window.history.go(1); var numberOfEntries = window.history.length; 二、添加和修改历史记录条目： 1、history.pushState(); 2、history.replaceState(); 两种方法都允许我们添加和更新历史记录，它们的工作原理相同并且可以添加数量相同的参数。 除了方法之外，还有popstate事件。在后文中将介绍怎么使用和什么时候使用popstate事件。 pushState()和replaceState()参数一样，参数说明如下： 1、state：存储JSON字符串，可以用在popstate事件中。 2、title：现在大多数浏览器不支持或者忽略这个参数，最好用null代替 3、url：任意有效的URL，用于更新浏览器的地址栏，并不在乎URL是否已经存在地址列表中。更重要的是，它不会重新加载页面。 两个方法的主要区别就是：pushState()是在history栈中添加一个新的条目，replaceState()是替换当前的记录值。 使用方法： onpopstate window.onpopstate = function(event) { alert(\"location: \" + document.location + \", state: \" + JSON.stringify(event.state)); }; //绑定事件处理函数. history.pushState({page: 1}, \"title 1\", \"?page=1\"); //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1 history.pushState({page: 2}, \"title 2\", \"?page=2\"); //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2 history.replaceState({page: 3}, \"title 3\", \"?page=3\"); //修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3 history.back(); // 弹出 \"location: http://example.com/example.html?page=1, state: {\"page\":1}\" history.back(); // 弹出 \"location: http://example.com/example.html, state: null history.go(2); // 弹出 \"location: http://example.com/example.html?page=3, state: {\"page\":3} pushState 在history栈中添加一个新的条目 var stateObj = { foo: \"bar\" }; history.pushState(stateObj, \"page 2\", \"bar.html\"); replaceState 替换当前的记录值 history.replaceState(stateObj, \"page 2\", \"bar.html\"); 读取当前状态 在页面加载时，可能会包含一个非空的状态对象。这种情况是会发生的，例如，如果页面中使用pushState()或replaceState()方法设置了一个状态对象，然后用户重启了浏览器。当页面重新加载时，页面会触发onload事件，但不会触发popstate事件。但是，如果你读取 history.state 属性，你会得到一个与 popstate 事件触发时得到的一样的状态对象。 你可以直接读取当前历史记录条目的状态，而不需要等待popstate事件： var currentState = history.state; 微信中打开头条新闻， 返回却到头条webApp首页源码，实现PV回流增长！ 这种提高网站流量的方式，各大门户网站都在使用，包括通过App推送push的一些消息，通过浏览器打开的详情页面都做了这种措施。 实现并不困难，重点就在监听了浏览器返回的历史记录。 具体代码： function Goback(url){ setTimeout(function () { if (history.length "},"Js/js基础/fetch.html":{"url":"Js/js基础/fetch.html","title":"fetch","keywords":"","body":"在 JS 中使用 fetch 更加高效地进行网络请求 Why Fetch XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。 使用 XHR 发送一个 json 请求一般是这样： var xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.responseType = 'json'; xhr.onload = function() { console.log(xhr.response); }; xhr.onerror = function() { console.log(\"Oops, error\"); }; 使用 Fetch： fetch(url).then(function(response) { return response.json(); }).then(function(data) { console.log(data); }).catch(function(e) { console.log(\"Oops, error\"); }); 使用 ES6 的 箭头函数： fetch(url).then(response => response.json()) .then(data => console.log(data)) .catch(e => console.log(\"Oops, error\", e)) 使用 async/await 来做最终优化： try { let response = await fetch(url); let data = response.json(); console.log(data); } catch(e) { console.log(\"Oops, error\", e); } // 注：这段代码如果想运行，外面需要包一个 async function Fetch 常见坑 Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: 'include'}) 服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。 Fetch 和标准 Promise 的不足 没有 Deferred Deferred 可以在创建 Promise 时可以减少一层嵌套，还有就是跨方法使用时很方便。 没有获取状态方法：isRejected，isResolved 标准 Promise 没有提供获取当前状态 rejected 或者 resolved 的方法。只允许外部传入成功或失败后的回调。我认为这其实是优点，这是一种声明式的接口，更简单。 缺少其它一些方法：always，progress，finally always 可以通过在 then 和 catch 里重复调用方法实现。finally 也类似。progress 这种进度通知的功能还没有用过，暂不知道如何替代。 不能中断，没有 abort、terminate、onTimeout 或 cancel 方法 Fetch 和 Promise 一样，一旦发起，不能中断，也不会超时，只能等待被 resolve 或 reject。幸运的是，whatwg 目前正在尝试解决这个问题whatwg/fetch#27 fetch进行post请求为什么会首先发一个options 请求? 不仅仅是fetch，只要你满足以下几种情况，都会去发起一个 Preflighted requests，也就是options请求， It uses methods other than GET, HEAD or POST. Also, if POST is used to send request data with a Content-Type other than application/x-www-form-urlencoded, multipart/form-data, ortext/plain, e.g. if the POST request sends an XML payload to the server using application/xmlor text/xml, then the request is preflighted. It sets custom headers in the request (e.g. the request uses a header such as X-PINGOTHER) 浏览器在发起跨域请求的时候会带着一个Origin header，那么其实就是个custom headers，那么也就会先触发一个Preflighted requests， 最近在用fetch请求接口数据时，会自动加上一次OPTIONS请求，而且还会返回数据。后面发现是因为这次请求在header上加了个Authorization字段（以前的项目如果不在header上加字段的话，是不会看到这次请求的），这样fetch就会默认发送一次OPTIONS检测是否有权限调用，后面后端就判断了下，当请求是OPTIONS，直接设置返回的头部信息就行了，这样虽然每次还会调用OPTIONS接口，但起码不会有数据了 if($_SERVE['REQUEST_METHOD'] === 'OPTIONS') { header(\"Access-Control-Allow-Origin: *\"); header(\"Access-Control-Allow-Origin-Headers: Authorization\"); exit; } "},"Js/js基础/Js判断字符串中是否包含某个字符串.html":{"url":"Js/js基础/Js判断字符串中是否包含某个字符串.html","title":"Js判断字符串中是否包含某个字符串","keywords":"","body":"js 判断字符串中是否包含某个字符串 1. String对象的方法 indexOf() var str = \"123\"; console.log(str.indexOf(\"3\") != -1 ); // true indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果要检索的字符串值没有出现，则该方法返回 -1。 search() var str = \"123\"; console.log(str.search(\"3\") != -1 ); // true search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。 match() var str = \"123\"; var reg = RegExp(/3/); if(str.match(reg)){ // 包含 } match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 2. RegExp 对象方法 test() var str = \"123\"; var reg = RegExp(/3/); console.log(reg.test(str)); // true test() 方法用于检索字符串中指定的值。返回 true 或 false。 exec() var str = \"123\"; var reg = RegExp(/3/); if(reg.exec(str)){ // 包含 } exec() 方法用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 3. ES6 includes() str.includes(searchString[, position]) searchString：查询的子字符串 position：可选，开始搜索的位置，默认为0 'Blue Whale'.includes('Blue'); // returns true 'Blue Whale'.includes('blue'); // returns false includes方法是会区分大小写。 对于不支持es6的浏览器，可以添加es6-shim，如： require('es6-shim') 4. ES6 startsWith() endsWith() startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 Polyfill /*! http://mths.be/startswith v0.2.0 by @mathias */ if (!String.prototype.startsWith) { (function() { 'use strict'; // needed to support `apply`/`call` with `undefined`/`null` var defineProperty = (function() { // IE 8 only supports `Object.defineProperty` on DOM elements try { var object = {}; var $defineProperty = Object.defineProperty; var result = $defineProperty(object, object, object) && $defineProperty; } catch(error) {} return result; }()); var toString = {}.toString; var startsWith = function(search) { if (this == null) { throw TypeError(); } var string = String(this); if (search && toString.call(search) == '[object RegExp]') { throw TypeError(); } var stringLength = string.length; var searchString = String(search); var searchLength = searchString.length; var position = arguments.length > 1 ? arguments[1] : undefined; // `ToInteger` var pos = position ? Number(position) : 0; if (pos != pos) { // better `isNaN` pos = 0; } var start = Math.min(Math.max(pos, 0), stringLength); // Avoid the `indexOf` call if no match is possible if (searchLength + start > stringLength) { return false; } var index = -1; while (++index "},"Js/正则/正则表达式不要背.html":{"url":"Js/正则/正则表达式不要背.html","title":"正则表达式不要背","keywords":"","body":"正则表达式不要背 正则表达式不要背 从字符出发 单个字符 多个字符 循环与重复 0 | 1 >= 0 >= 1 特定次数 位置边界 单词边界 字符串边界 子表达式 分组 回溯引用 前向查找 后向查找 逻辑处理 最后 从字符出发 正则表达式的基本组成元素可以分为：字符和元字符。 字符很好理解，就是基础的计算机字符编码，通常正则表达式里面使用的就是数字、英文字母。而元字符，也被称为特殊字符，是一些用来表示特殊语义的字符。如^表示非,|表示或等。 利用这些元字符，才能构造出强大的表达式模式(pattern) 单个字符 最简单的正则表达式可以由简单的数字和字母组成，没有特殊的语义，纯粹就是一一对应的关系。如想在'apple'这个单词里找到‘a'这个字符，就直接用/a/这个正则就可以了。 但是如果想要匹配特殊字符的话，就得请出我们第一个元字符**\\**， 它是转义字符字符，顾名思义，就是让其后续的字符失去其本来的含义。举个例子： 我想匹配*这个符号，由于*这个符号本身是个特殊字符，所以我要利用转义元字符\\来让它失去其本来的含义： /\\*/ 如果本来这个字符不是特殊字符，使用转义符号就会让它拥有特殊的含义。我们常常需要匹配一些特殊字符，比如空格，制表符，回车，换行等, 而这些就需要我们使用转义字符来匹配。为了便于记忆，我整理了下面这个表格，并附上记忆方式： 特殊字符 正则表达式 记忆方式 换行符 \\n new line 换页符 \\f form feed 回车符 \\r return 空白符 \\s space 制表符 \\t tab 垂直制表符 \\v vertical tab 回退符 [\\b] backspace,之所以使用[]符号是避免和\\b重复 多个字符 单个字符的映射关系是一对一的，即正则表达式的被用来筛选匹配的字符只有一个。而这显然是不够的，只要引入集合区间和通配符的方式就可以实现一对多的匹配了。 在正则表达式里，集合的定义方式是使用中括号[和]。如/[123]/这个正则就能同时匹配1,2,3三个字符。那如果我想匹配所有的数字怎么办呢？从0写到9显然太过低效，所以元字符-就可以用来表示区间范围，利用/[0-9]/就能匹配所有的数字, /[a-z]/则可以匹配所有的英文小写字母。 即便有了集合和区间的定义方式，如果要同时匹配多个字符也还是要一一列举，这是低效的。所以在正则表达式里衍生了一批用来同时匹配多个字符的简便正则表达式: 匹配区间 正则表达式 记忆方式 除了换行符之外的任何字符 . 句号,除了句子结束符 单个数字, [0-9] \\d digit 除了[0-9] \\D not digit 包括下划线在内的单个字符，[A-Za-z0-9_] \\w word 非单字字符 \\W not word 匹配空白字符,包括空格、制表符、换页符和换行符 \\s space 匹配非空白字符 \\S not space 循环与重复 一对一和一对多的字符匹配都讲完了。接下来，就该介绍如何同时匹配多个字符。要实现多个字符的匹配我们只要多次循环，重复使用我们的之前的正则规则就可以了。那么根据循环次数的多与少，我们可以分为0次，1次，多次，特定次。 0 | 1 元字符?代表了匹配一个字符或0个字符。设想一下，如果你要匹配color和colour这两个单词，就需要同时保证u这个字符是否出现都能被匹配到。所以你的正则表达式应该是这样的：/colou?r/。 >= 0 元字符*用来表示匹配0个字符或无数个字符。通常用来过滤某些可有可无的字符串。 >= 1 元字符+适用于要匹配同个字符出现1次或多次的情况。 特定次数 在某些情况下，我们需要匹配特定的重复次数，元字符{和}用来给重复匹配设置精确的区间范围。如'a'我想匹配3次,那么我就使用/a{3}/这个正则，或者说'a'我想匹配至少两次就是用/a{2,}/这个正则。 以下是完整的语法： - {x}: x次 - {min, max}： 介于min次到max次之间 - {min, }: 至少min次 - {0, max}： 至多max次 由于这些元字符比较抽象，且容易混淆，所以我用了联想记忆的方式编了口诀能保证在用到的时候就能回忆起来。 匹配规则 元字符 联想方式 0次或1次 ? 且问,此事有还无 0次或无数次 * 宇宙洪荒,辰宿列张：宇宙伊始，从无到有，最后星宿布满星空 1次或无数次 + 一加, +1 特定次数 {x}, {min, max} 可以想象成一个数轴，从一个点，到一个射线再到线段。min和max分别表示了左闭右闭区间的左界和右界 位置边界 上面我们把字符的匹配都介绍完了，接着我们还需要位置边界的匹配。在长文本字符串查找过程中，我们常常需要限制查询的位置。比如我只想在单词的开头结尾查找。 单词边界 单词是构成句子和文章的基本单位，一个常见的使用场景是把文章或句子中的特定单词找出来。如： The cat scattered his food all over the room. 我想找到cat这个单词，但是如果只是使用/cat/这个正则，就会同时匹配到cat和scattered这两处文本。这时候我们就需要使用边界正则表达式\\b，其中b是boundary的首字母。在正则引擎里它其实匹配的是能构成单词的字符(\\w)和不能构成单词的字符(\\W)中间的那个位置。 上面的例子改写成/\\bcat\\b/这样就能匹配到cat这个单词了。 字符串边界 匹配完单词，我们再来看一下一整个字符串的边界怎么匹配。元字符^用来匹配字符串的开头。而元字符$用来匹配字符串的末尾。注意的是在长文本里，如果要排除换行符的干扰，我们要使用多行模式。试着匹配I am scq000这个句子： I am scq000. I am scq000. I am scq000. 我们可以使用/^I am scq000\\.$/m这样的正则表达式，其实m是multiple line的首字母。正则里面的模式除了m外比较常用的还有i和g。前者的意思是忽略大小写，后者的意思是找到所有符合的匹配。 最后，总结一下： 边界和标志 正则表达式 记忆方式 单词边界 \\b boundary 非单词边界 \\B not boundary 字符串开头 ^ 小头尖尖那么大个 字符串结尾 $ 终结者，美国科幻电影，美元符$ 多行模式 m标志 multiple of lines 忽略大小写 i标志 ignore case, case-insensitive 全局模式 g标志 global 子表达式 字符匹配我们介绍的差不多了，更加高级的用法就得用到子表达式了。通过嵌套递归和自身引用可以让正则发挥更强大的功能。 从简单到复杂的正则表达式演变通常要采用分组、回溯引用和逻辑处理的思想。利用这三种规则，可以推演出无限复杂的正则表达式。 分组 其中分组体现在：所有以(和)元字符所包含的正则表达式被分为一组，每一个分组都是一个子表达式，它也是构成高级正则表达式的基础。如果只是使用简单的(regex)匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。 回溯引用 所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你可以把它想象成是变量，回溯引用的语法像\\1,\\2,....,其中\\1表示引用的第一个子表达式，\\2表示引用的第二个子表达式，以此类推。而\\0则表示整个表达式。 假设现在要在下面这个文本里匹配两个连续相同的单词，你要怎么做呢？ Hello what what is the first thing, and I am am scq000. 利用回溯引用，我们可以很容易地写出\\b(\\w+)\\s\\1这样的正则。 回溯引用在替换字符串中十分常用，语法上有些许区别，用$1,$2...来引用要被替换的字符串。下面以js代码作演示： var str = 'abc abc 123'; str.replace(/(ab)c/g,'$1g'); // 得到结果 'abg abg 123' 如果我们不想子表达式被引用，可以使用非捕获正则(?:regex)这样就可以避免浪费内存。 var str = 'scq000'. str.replace(/(scq00)(?:0)/, '$1,$2') // 返回scq00,$2 // 由于使用了非捕获正则，所以第二个引用没有值，这里直接替换为$2 有时，我们需要限制回溯引用的适用范围。那么通过前向查找和后向查找就可以达到这个目的。 前向查找 前向查找(lookahead)是用来限制后缀的。凡是以(?=regex)包含的子表达式在匹配过程中都会用来限制前面的表达式的匹配。例如happy happily这两个单词，我想获得以happ开头的副词，那么就可以使用happ(?=ily)来匹配。如果我想过滤所有以happ开头的副词，那么也可以采用负前向查找的正则happ(?!ily)，就会匹配到happy单词的happ前缀。 后向查找 介绍完前向查找，接着我们再来介绍一下它的反向操作：后向查找(lookbehind)。后向查找(lookbehind)是通过指定一个子表达式，然后从符合这个子表达式的位置出发开始查找符合规则的字串。举个简单的例子： apple和people都包含ple这个后缀，那么如果我只想找到apple的ple，该怎么做呢？我们可以通过限制app这个前缀，就能唯一确定ple这个单词了。 /(? 其中(?的语法就是我们这里要介绍的后向查找。regex指代的子表达式会作为限制项进行匹配，匹配到这个子表达式后，就会继续向后查找。另外一种限制匹配是利用(? 语法，这里称为负后向查找。与正前向查找不同的是，被指定的子表达式不能被匹配到。于是，在上面的例子中，如果想要查找apple的ple也可以这么写成/(?ple。 需要注意的，不是每种正则实现都支持后向查找。在javascript中是不支持的，所以如果有用到后向查找的情况，有一个思路是将字符串进行翻转，然后再使用前向查找，作完处理后再翻转回来。看一个简单的例子： // 比如我想替换apple的ple为ply var str = 'apple people'; str.split('').reverse().join('').replace(/elp(?=pa)/, 'ylp').split('').reverse().join(''); 最后回顾一下这部分内容： 回溯查找 正则 记忆方式 引用 \\0,\\1,\\2 和 $0, $1, $2 转义+数字 非捕获组 (?:) 引用表达式(()), 本身不被消费(?),引用(:) 前向查找 (?=) 引用子表达式(())，本身不被消费(?), 正向的查找(=) 前向负查找 (?!) 引用子表达式(())，本身不被消费(?), 负向的查找(!) 后向查找 (? 引用子表达式(())，本身不被消费(?), 后向的( 后向负查找 (? 引用子表达式(())，本身不被消费(?), 后向的( 逻辑处理 计算机科学就是一门包含逻辑的科学。让我们回忆一下编程语言当中用到的三种逻辑关系，与或非。 在正则里面，默认的正则规则都是与的关系所以这里不讨论。 而非关系，分为两种情况：一种是字符匹配，另一种是子表达式匹配。在字符匹配的时候，需要使用^这个元字符。在这里要着重记忆一下：只有在[和]内部使用的^才表示非的关系。子表达式匹配的非关系就要用到前面介绍的前向负查找子表达式(?!regex)或后向负查找子表达式(?。 或关系，通常给子表达式进行归类使用。比如，我同时匹配a,b两种情况就可以使用(a|b)这样的子表达式。 逻辑关系 正则元字符 与 无 非 [^regex]和! 或 丨 最后 在最后，出个常用的正则面试题吧：请写出一个正则来处理数字千分位，如12345替换为12,345 function splitNum(n){ return (`${n}`).replace(/\\B(?=(?:\\d{3})+\\b)/g,','); } splitNum(1234567.333333) // \"1,234,567.333,333\" var num = '12345678'; num.replace(/(\\d)(?=(\\d{3})+$)/g,'$1,'); num.replace(/\\d{1,3}(?=(\\d{3})+$)/g,'$&,'); num.replace(/\\B(?=(\\d{3})+$)/g,','); // 以上三种的 $都可以替换成\\b的形式. "},"Js/正则/RegExp.html":{"url":"Js/正则/RegExp.html","title":"RegExp","keywords":"","body":"RegExp RegExp 一些常用正则验证 验证数字的正则表达式集 金额最多保留两位小数 && . -> 0. ant mobile InputItem ant design FormItem 正则进阶之路 1、获取链接 https://www.baidu.com?name=jawil&age=23 name的value值 2. 数字格式化问题，1234567890 --> 1,234,567,890 3、去掉字符串左右两边的空格，\" jaw il \" --> “jaw il” 4、判断一个数是否是质数 3 --> true 5、字符串数组去重 [\"a\",\"b\",\"c\",\"a\",\"b\",\"c\"] --> [\"a\",\"b\",\"c\"] 一张图快速入门正则表达式： 一些常用正则验证 验证数字的正则表达式集 验证数字：^[0-9]*$ 验证n位的数字：^\\d{n}$ 验证至少n位数字：^\\d{n,}$ 验证m-n位的数字：^\\d{m,n}$ 验证零和非零开头的数字：^(0|[1-9][0-9]*)$ 验证有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 验证有1-3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 验证非零的正整数：^+?[1-9][0-9]*$ 验证非零的负整数：^-[1-9][0-9]*$ 验证非负整数（正整数 + 0） ^\\d+$ 验证非正整数（负整数 + 0） ^((-\\d+)|(0+))$ 验证长度为3的字符：^.{3}$ 验证由26个英文字母组成的字符串：^[A-Za-z]+$ 验证由26个大写英文字母组成的字符串：^[A-Z]+$ 验证由26个小写英文字母组成的字符串：^[a-z]+$ 验证由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 验证由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 验证用户密码:^[a-zA-Z]\\w{5,17}$ 正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。 验证是否含有 ^%&',;=?$\\\" 等字符：%&',;=?$\\x22+ 验证汉字：^[\\u4e00-\\u9fa5],{0,}$ 验证Email地址：/^([a-zA-Z0-9]+[|\\|.]?)[a-zA-Z0-9]+@([a-zA-Z0-9]+[|\\|.]?)[a-zA-Z0-9]+.[a-zA-Z]{2,3}$/ 验证InternetURL：^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$ ；^[a-zA-z]+://(w+(-w+))(.(w+(-w+)))(?S)?$ 验证电话号码：^((\\d{3,4})|\\d{3,4}-)?\\d{7,8}$：--正确格式为：XXXX-XXXXXXX，XXXX-XXXXXXXX，XXX-XXXXXXX，XXX-XXXXXXXX，XXXXXXX，XXXXXXXX。 验证身份证号（15位或18位数字）：^\\d{15}|\\d{}18$ 验证一年的12个月：^(0?[1-9]|1[0-2])$ 正确格式为：“01”-“09”和“1”“12” 验证一个月的31天：^((0?[1-9])|((1|2)[0-9])|30|31)$ 正确格式为：01、09和1、31。 整数：^-?\\d+$ 非负浮点数（正浮点数 + 0）：^\\d+(.\\d+)?$ 正浮点数 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 非正浮点数（负浮点数 + 0） ^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 负浮点数 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数 ^(-?\\d+)(.\\d+)?$ 金额最多保留两位小数 && . -> 0. /^\\d{1,}.{0,1}\\d{0,2}$/ /^([1-9]\\d*|0)(.\\d{1,2})?$/ ant mobile InputItem const isIPhone = new RegExp('\\\\biPhone\\\\b|\\\\biPod\\\\b', 'i').test(window.navigator.userAgent); let moneyKeyboardWrapProps; if (isIPhone) { moneyKeyboardWrapProps = { onTouchStart: e => e.preventDefault(), }; } { if (v && !/^(([1-9]\\d*)|0)(\\.\\d{0,2}?)?$/.test(v)) { if (v === '.') { return '0.'; } return prev; } return v; }, rules: [ { required: true, message: '请输入' }, {validator(rule, value, callback, source, options){ let errors = []; const reg = /^([1-9]\\d*|0)(\\.\\d{1,2})?$/; if(!reg.test(value)){ callback('mileage is error'); }else { callback(errors); } }} ], })} type={type} placeholder=\"money format\" ref={el => this.inputRef = el} onVirtualKeyboardConfirm={v => console.log('onVirtualKeyboardConfirm:', v)} clear moneyKeyboardWrapProps={moneyKeyboardWrapProps} >数字键盘 ant design FormItem {getFieldDecorator('vehiclePrice', {initialValue: yixindata.salePrice?yixindata.salePrice:_vehiclePrice, rules: [{ required: true, message: '请输入车辆成交价', pattern: /^\\d{1,}\\.{0,1}\\d{0,2}$/},]})( )} 正则进阶之路 1、获取链接 https://www.baidu.com?name=jawil&age=23 name的value值 非正则实现： function getParamName(attr) { let search = window.location.search // \"?name=jawil&age=23\" let param_str = search.split('?')[1] // \"name=jawil&age=23\" let param_arr = param_str.split('&') // [\"name=jawil\", \"age=23\"] let filter_arr = param_arr.filter(ele => { // [\"name=jawil\"] return ele.split('=')[0] === attr }) return decodeURIComponent(filter_arr[0].split('=')[1]) } console.log(getParamName('name')) // \"jawil\" 用正则实现： function getParamName(attr) { let match = RegExp(`[?&]${attr}=([^&]*)`) //分组运算符是为了把结果存到exec函数返回的结果里 .exec(window.location.search) //[\"?name=jawil\", \"jawil\", index: 0, input: \"?name=jawil&age=23\"] return match && decodeURIComponent(match[1].replace(/\\+/g, ' ')) // url中+号表示空格,要替换掉 } console.log(getParamName('name')) // \"jawil\" 2. 数字格式化问题，1234567890 --> 1,234,567,890 非正则实现： let test = '1234567890' function formatCash(str) { let arr = [] for (let i = 1; i 用正则实现： let test1 = '1234567890' let format = test1.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',') console.log(format) // 1,234,567,890 下面简单分析下正则/\\B(?=(\\d{3})+(?!\\d))/g： /\\B(?=(\\d{3})+(?!\\d))/g：正则匹配边界\\B，边界后面必须跟着(\\d{3})+(?!\\d); (\\d{3})+：必须是1个或多个的3个连续数字; (?!\\d)：第2步中的3个数字不允许后面跟着数字; (\\d{3})+(?!\\d)：所以匹配的边界后面必须跟着3*n（n>=1）的数字。 最终把匹配到的所有边界换成,即可达成目标。 3、去掉字符串左右两边的空格，\" jaw il \" --> “jaw il” 非正则实现： function trim(str) { let start, end for (let i = 0; i 0; i--) { if (str[i] !== ' ') { end = i break } } return str.substring(start, end + 1) } let str = \" jaw il \" console.log(trim(str)) // \"jaw il\" 用正则实现： function trim(str) { return str.replace(/(^\\s*)|(\\s*$)/g, \"\") } let str = \" jaw il \" console.log(trim(str)) // \"jaw il\" 4、判断一个数是否是质数 3 --> true 质数又称素数。指在一个大于1的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。 非正则实现： function isPrime(num){ // 不是数字或者数字小于2 if(typeof num !== \"number\" || !Number.isInteger(num)){　　　　　　 // Number.isInterget 判断是否为整数 return false } //2是质数 if(num == 2){ return true }else if(num % 2 == 0){ //排除偶数 return false } //依次判断是否能被奇数整除，最大循环为数值的开方 let squareRoot = Math.sqrt(num) //因为2已经验证过，所以从3开始；且已经排除偶数，所以每次加2 for(let i = 3; i 用正则实现： function isPrime(num) { return !/^1?$|^(11+?)\\1+$/.test(Array(num+1).join('1')) } console.log(isPrime(19)) // true 要使用这个正规则表达式，你需要把自然数转成多个1的字符串，如：2 要写成 “11”， 3 要写成 “111”, 17 要写成“11111111111111111”，这种工作使用一些脚本语言可以轻松的完成，JS实现也很简单，我用Array(num+1).join('1')这种方式实现了一下。 一开始我对这个表达式持怀疑态度，但仔细研究了一下这个表达式，发现是非常合理的，下面，让我带你来细细剖析一下是这个表达式的工作原理。 首先，我们看到这个表达式中有“|”，也就是说这个表达式可以分成两个部分：/^1?$/ 和 /^(11+?)\\1+$/ 第一部分：/^1?$/， 这个部分相信不用我多说了，其表示匹配“空串”以及字串中只有一个“1”的字符串。 第二部分：/^(11+?)\\1+$/ ，这个部分是整个表达式的关键部分。其可以分成两个部分，(11+?) 和 \\1+$ ，前半部很简单了，匹配以“11”开头的并重复0或n个1的字符串，后面的部分意思是把前半部分作为一个字串去匹配还剩下的字符串1次或多次（这句话的意思是——剩余的字串的1的个数要是前面字串1个数的整数倍）。 可见这个正规则表达式是取非素数，要得到素数还得要对整个表达式求反。通过上面的分析，我们知道，第二部分是最重要的，对于第二部分，举几个例子， 示例一：判断自然数8。我们可以知道，8转成我们的格式就是“11111111”，对于 (11+?) ，其匹配了“11”，于是还剩下“111111”，而 \\1+$ 正好匹配了剩下的“111111”，因为，“11”这个模式在“111111”出现了三次，符合模式匹配，返回true。所以，匹配成功，于是这个数不是质数。 示例二：判断自然数11。转成我们需要的格式是“11111111111”（11个1），对于 (11+?) ，其匹配了“11”（前两个1），还剩下“111111111”（九个1），而 \\1+$无法为“11”匹配那“九个1”，因为“11”这个模式并没有在“九个1”这个串中正好出现N次。于是，我们的正则表达式引擎会尝试下一种方法，先匹配“111”（前三个1），然后把“111”作为模式去匹配剩下的“11111111”（八个1），很明显，那“八个1”并没有匹配“三个1”多次。所以，引擎会继续向下尝试……直至尝试所有可能都无法匹配成功。所以11是素数。 通过示例二，我们可以得到这样的等价数算算法，正则表达式会匹配这若干个1中有没有出现“二个1”的整数倍，“三个1”的整数倍，“四个1”的整数倍……，而，这正好是我们需要的算素数的算法。现在大家明白了吧。 5、字符串数组去重 [\"a\",\"b\",\"c\",\"a\",\"b\",\"c\"] --> [\"a\",\"b\",\"c\"] 这里只考虑最简单字符串的数组去重，暂不考虑，对象，函数，NaN等情况，这种用正则实现起来就吃力不讨好了。 非正则实现： // ES6 let str_arr=[\"a\",\"b\",\"c\",\"a\",\"b\",\"c\"] function unique(arr){ return [...new Set(arr)] } console.log(unique(str_arr)) // [\"a\",\"b\",\"c\"] // ES5 var str_arr = [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\"] function unique(arr) { return arr.filter(function(ele, index, array) { return array.indexOf(ele) === index }) } console.log(unique(str_arr)) // [\"a\",\"b\",\"c\"] // ES3 var str_arr = [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\"] function unique(arr) { var obj = {}, array = [] for (var i = 0, len = arr.length; i 正则实现： var str_arr = [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\"] function unique(arr) { return arr.sort().join(\",,\"). replace(/(,|^)([^,]+)(,,\\2)+(,|$)/g, \"$1$2$4\"). replace(/,,+/g, \",\"). replace(/,$/, \"\"). split(\",\") } console.log(unique(str_arr)) // [\"a\",\"b\",\"c\"] 一张图快速入门正则表达式： "},"Js/面向对象/面向对象之组件开发之弹窗.html":{"url":"Js/面向对象/面向对象之组件开发之弹窗.html","title":"面向对象之组件开发之弹窗","keywords":"","body":" 面向对象之组件开发之弹窗练习 *{margin:0; padding:0;} .btn{width:50px; height:30px; background:yellowgreen; margin-left:30px;} .div1{border:1px solid black; position:absolute; left:0px; top:100px;z-index:2;} .title{height:30px; line-height:30px; background:lightgray;} .close{display:inline-block; width:28px; height:28px;border:1px solid white; float:right; text-align:center;border-radius:50%; line-height:28px; color:red; } .close:hover{background:red; color:#fff;} #mark{z-index:1;position:absolute; left:0; top:0; background:gray; filter:alpha(opacity=50); opacity:0.5;} X --> window.onload = function(){ var aBtn = document.getElementsByClassName('btn'); aBtn[1].onclick = function(){ var win2 = new Wind(); win2.init({//配置参数 iNow:1, w:200, h:300, dir:'right', title:\"公告\" }); } aBtn[0].onclick = function(){ var win1 = new Wind(); win1.init({//配置参数 iNow:0, title:\"登录\" }); } aBtn[2].onclick = function(){//配置参数 var win1 = new Wind(); win1.init({ iNow:2, mark:true }); } } function Wind(){ this.oDiv = null; this.setting = {//默认参数 w:300, h:300, dir:'center', title:'', mark:false } } Wind.prototype.json={}; Wind.prototype.init = function(opt){ extend(this.setting,opt); if(this.json[opt.iNow]==undefined){ this.json[opt.iNow]=true; } if(this.json[opt.iNow]){ this.fnCreate(); this.fnClose(); if(this.setting.mark){ this.fnMark(); } } this.json[opt.iNow]=false; } Wind.prototype.fnCreate = function(){ this.oDiv = document.createElement('div'); this.oDiv.className = 'div1'; this.oDiv.innerHTML = ''+ this.setting.title+'X'; document.body.appendChild(this.oDiv); this.setStyle(); } Wind.prototype.fnMark = function(){ var oMark = document.createElement('div'); oMark.id = 'mark'; document.body.appendChild(oMark); this.oMark = oMark; oMark.style.width=veiwWidth()+'px'; oMark.style.height=veiwHeight()+'px'; } Wind.prototype.setStyle = function(){ this.oDiv.style.width = this.setting.w+'px'; this.oDiv.style.height = this.setting.h +'px'; if(this.setting.dir=='center'){ this.oDiv.style.left = (veiwWidth() - this.oDiv.offsetWidth)/2 +'px'; this.oDiv.style.top = (veiwHeight() - this.oDiv.offsetHeight)/2 +'px'; } if(this.setting.dir=='right'){ this.oDiv.style.left = (veiwWidth() - this.oDiv.offsetWidth)+'px'; this.oDiv.style.top = (veiwHeight() - this.oDiv.offsetHeight) +'px'; } } Wind.prototype.fnClose = function(){ var oClose = this.oDiv.getElementsByClassName('close')[0]; var This = this; oClose.onclick = function(){ document.body.removeChild(This.oDiv); if(This.setting.mark){ document.body.removeChild(This.oMark); } This.json[This.setting.iNow] = true; }; } function extend(obj1,obj2){ for(var attr in obj2){ obj1[attr] = obj2[attr]; } } function veiwWidth(){ return document.documentElement.clientWidth; } function veiwHeight(){ return document.documentElement.clientHeight; } 面向对象之组件开发之弹窗练习 *{margin:0; padding:0;} .btn{width:50px; height:30px; background:yellowgreen; margin-left:30px;} .div1{border:1px solid black; position:absolute; left:0px; top:100px;z-index:2;} .title{height:30px; line-height:30px; background:lightgray;} .close{display:inline-block; width:28px; height:28px;border:1px solid white; float:right; text-align:center;border-radius:50%; line-height:28px; color:red; } .close:hover{background:red; color:#fff;} #mark{z-index:1;position:absolute; left:0; top:0; background:gray; filter:alpha(opacity=50); opacity:0.5;} X --> window.onload = function(){ var aBtn = document.getElementsByClassName('btn'); aBtn[1].onclick = function(){ var win2 = new Wind(); win2.init({//配置参数 iNow:1, w:200, h:300, dir:'right', title:\"公告\" }); } aBtn[0].onclick = function(){ var win1 = new Wind(); win1.init({//配置参数 iNow:0, title:\"登录\" }); } aBtn[2].onclick = function(){//配置参数 var win1 = new Wind(); win1.init({ iNow:2, mark:true }); } } function Wind(){ this.oDiv = null; this.setting = {//默认参数 w:300, h:300, dir:'center', title:'', mark:false } } Wind.prototype.json={}; Wind.prototype.init = function(opt){ extend(this.setting,opt); if(this.json[opt.iNow]==undefined){ this.json[opt.iNow]=true; } if(this.json[opt.iNow]){ this.fnCreate(); this.fnClose(); if(this.setting.mark){ this.fnMark(); } } this.json[opt.iNow]=false; } Wind.prototype.fnCreate = function(){ this.oDiv = document.createElement('div'); this.oDiv.className = 'div1'; this.oDiv.innerHTML = ''+ this.setting.title+'X'; document.body.appendChild(this.oDiv); this.setStyle(); } Wind.prototype.fnMark = function(){ var oMark = document.createElement('div'); oMark.id = 'mark'; document.body.appendChild(oMark); this.oMark = oMark; oMark.style.width=veiwWidth()+'px'; oMark.style.height=veiwHeight()+'px'; } Wind.prototype.setStyle = function(){ this.oDiv.style.width = this.setting.w+'px'; this.oDiv.style.height = this.setting.h +'px'; if(this.setting.dir=='center'){ this.oDiv.style.left = (veiwWidth() - this.oDiv.offsetWidth)/2 +'px'; this.oDiv.style.top = (veiwHeight() - this.oDiv.offsetHeight)/2 +'px'; } if(this.setting.dir=='right'){ this.oDiv.style.left = (veiwWidth() - this.oDiv.offsetWidth)+'px'; this.oDiv.style.top = (veiwHeight() - this.oDiv.offsetHeight) +'px'; } } Wind.prototype.fnClose = function(){ var oClose = this.oDiv.getElementsByClassName('close')[0]; var This = this; oClose.onclick = function(){ document.body.removeChild(This.oDiv); if(This.setting.mark){ document.body.removeChild(This.oMark); } This.json[This.setting.iNow] = true; }; } function extend(obj1,obj2){ for(var attr in obj2){ obj1[attr] = obj2[attr]; } } function veiwWidth(){ return document.documentElement.clientWidth; } function veiwHeight(){ return document.documentElement.clientHeight; } "},"Js/面向对象/面向对象的微博登录提示邮箱.html":{"url":"Js/面向对象/面向对象的微博登录提示邮箱.html","title":"面向对象的微博登录提示邮箱","keywords":"","body":"\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> 无标题文档 *{ margin:0; padding:0;} body{ font:12px/1.125 Arial,Helvetica,sans-serif;} li{ list-style:none;} #login{ width:252px; height:385px; background:url(bg.jpg) no-repeat; margin:20px auto; position:relative;} .detail{margin:0 0 5px 30px; position:relative; top:110px;} .detail input{ color: #999999; border:1px solid #74C8E5; border-radius:3px 3px 3px 3px; height:15px; line-height:14px; padding:8px 5px 7px; width:184px;} #suggest{ background:none repeat scroll 0 0 #FFFFFF; border:1px solid #CCCCCC; left:30px; margin:0; overflow:hidden; padding:0; position:absolute; text-align:left; top:142px; visibility:visible; width:194px ;z-index:1; display:none;} .note, .item{ clear: both; color: #999999; cursor: pointer; font-size: 12px; height: 20px; line-height: 20px; list-style: none outside none; margin: 0 1px; padding: 0 5px; white-space: nowrap;} .active{ white-space:nowrap; clear:both; color:rgb(153, 153, 153); cursor:pointer; font-size:12px; height:20px; line-height:20px; list-style:none outside none; margin:0pt 1px; padding:0pt 5px; background:none repeat scroll 0% 0% rgb(232, 244, 252);} window.onload = function(){ var s1 = new Suggest(); s1.init(); //初始化程序 }; function Suggest(){ this.oInput = document.getElementById('input1'); this.oUl = document.getElementById('suggest'); this.aLi = this.oUl.getElementsByTagName('li'); } Suggest.prototype = { init : function(){ this.toChange(); this.toBlur(); }, toChange : function(){ //ie : onpropertychange //标准 : oninput var ie = !-[1,]; var This = this; if(ie){ this.oInput.onpropertychange = function(){ if(This.oInput.value==''){ This.tips(); return; } This.thowUl(); This.tips(); This.sel(0); }; } else{ this.oInput.oninput = function(){ This.thowUl(); This.tips(); This.sel(0); }; } }, thowUl : function(){ this.oUl.style.display = 'block'; }, toBlur : function(){ var This = this; this.oInput.onblur = function(){ This.oUl.style.display = 'none'; }; }, tips : function(){ var value = this.oInput.value; var re = new RegExp('@'+value.substring(value.indexOf('@')+1)+''); for(var i=1;i 请选择邮箱类型 @sina.com @163.com @qq.com @126.com @vip.sina.com @sina.cn @hotmail.com @gmail.com @sohu.com @yahoo.cn @139.com @wo.com.cn @189.cn 无标题文档 *{ margin:0; padding:0;} body{ font:12px/1.125 Arial,Helvetica,sans-serif;} li{ list-style:none;} #login{ width:252px; height:385px; background:url(bg.jpg) no-repeat; margin:20px auto; position:relative;} .detail{margin:0 0 5px 30px; position:relative; top:110px;} .detail input{ color: #999999; border:1px solid #74C8E5; border-radius:3px 3px 3px 3px; height:15px; line-height:14px; padding:8px 5px 7px; width:184px;} #suggest{ background:none repeat scroll 0 0 #FFFFFF; border:1px solid #CCCCCC; left:30px; margin:0; overflow:hidden; padding:0; position:absolute; text-align:left; top:142px; visibility:visible; width:194px ;z-index:1; display:none;} .note, .item{ clear: both; color: #999999; cursor: pointer; font-size: 12px; height: 20px; line-height: 20px; list-style: none outside none; margin: 0 1px; padding: 0 5px; white-space: nowrap;} .active{ white-space:nowrap; clear:both; color:rgb(153, 153, 153); cursor:pointer; font-size:12px; height:20px; line-height:20px; list-style:none outside none; margin:0pt 1px; padding:0pt 5px; background:none repeat scroll 0% 0% rgb(232, 244, 252);} window.onload = function(){ var s1 = new Suggest(); s1.init(); //初始化程序 }; function Suggest(){ this.oInput = document.getElementById('input1'); this.oUl = document.getElementById('suggest'); this.aLi = this.oUl.getElementsByTagName('li'); } Suggest.prototype = { init : function(){ this.toChange(); this.toBlur(); }, toChange : function(){ //ie : onpropertychange //标准 : oninput var ie = !-[1,]; var This = this; if(ie){ this.oInput.onpropertychange = function(){ if(This.oInput.value==''){ This.tips(); return; } This.thowUl(); This.tips(); This.sel(0); }; } else{ this.oInput.oninput = function(){ This.thowUl(); This.tips(); This.sel(0); }; } }, thowUl : function(){ this.oUl.style.display = 'block'; }, toBlur : function(){ var This = this; this.oInput.onblur = function(){ This.oUl.style.display = 'none'; }; }, tips : function(){ var value = this.oInput.value; var re = new RegExp('@'+value.substring(value.indexOf('@')+1)+''); for(var i=1;i 请选择邮箱类型 @sina.com @163.com @qq.com @126.com @vip.sina.com @sina.cn @hotmail.com @gmail.com @sohu.com @yahoo.cn @139.com @wo.com.cn @189.cn "},"浏览器/事件机制.html":{"url":"浏览器/事件机制.html","title":"事件机制","keywords":"","body":"事件机制 事件触发三阶段 注册事件 事件代理 事件触发三阶段 事件触发有三个阶段 window 往事件触发处传播，遇到注册的捕获事件会触发 传播到事件触发处时触发注册的事件 从事件触发处往 window 传播，遇到注册的冒泡事件会触发 事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。 // 以下会先打印冒泡然后是捕获 node.addEventListener( 'click', event => { console.log('冒泡') }, false ) node.addEventListener( 'click', event => { console.log('捕获 ') }, true ) 注册事件 通常我们使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性 capture，布尔值，和 useCapture 作用一样 once，布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听 passive，布尔值，表示永远不会调用 preventDefault 一般来说，我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。 node.addEventListener( 'click', event => { event.stopImmediatePropagation() console.log('冒泡') }, false ) // 点击 node 只会执行上面的函数，该函数不会执行 node.addEventListener( 'click', event => { console.log('捕获 ') }, true ) 事件代理 如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上 1 2 3 4 5 let ul = document.querySelector('##ul') ul.addEventListener('click', event => { console.log(event.target) }) 事件代理的方式相对于直接给目标注册事件来说，有以下优点 节省内存 不需要给子节点注销事件 "},"浏览器/跨域.html":{"url":"浏览器/跨域.html","title":"跨域","keywords":"","body":"跨域 JSONP CORS document.domain postMessage 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。 我们可以通过以下几种常用方法解决跨域的问题 JSONP JSONP 的原理很简单，就是利用 标签没有跨域限制的漏洞。通过 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。 function jsonp(data) { console.log(data) } JSONP 使用简单且兼容性不错，但是只限于 get 请求。 在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现 function jsonp(url, jsonpCallback, success) { let script = document.createElement('script') script.src = url script.async = true script.type = 'text/javascript' window[jsonpCallback] = function(data) { success && success(data) } document.body.appendChild(script) } jsonp('http://xxx', 'callback', function(value) { console.log(value) }) CORS CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 document.domain 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域 postMessage 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息 // 发送消息端 window.parent.postMessage('message', 'http://test.com') // 接收消息端 var mc = new MessageChannel() mc.addEventListener('message', event => { var origin = event.origin || event.originalEvent.origin if (origin === 'http://test.com') { console.log('验证通过') } }) "},"浏览器/Event-loop.html":{"url":"浏览器/Event-loop.html","title":"Event loop","keywords":"","body":"Event loop Event loop Node 中的 Event loop timer I/O idle, prepare check close callbacks Event loop 众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题。 JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。 console.log('script start') setTimeout(function() { console.log('setTimeout') }, 0) console.log('script end') 以上代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 setTimeout 还是会在 script end 之后打印。 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。 console.log('script start') setTimeout(function() { console.log('setTimeout') }, 0) new Promise(resolve => { console.log('Promise') resolve() }) .then(function() { console.log('promise1') }) .then(function() { console.log('promise2') }) console.log('script end') // script start => Promise => script end => promise1 => promise2 => setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务，所以会有以上的打印。 微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver 宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering 很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。 所以正确的一次 Event loop 顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中。 Node 中的 Event loop Node 中的 Event loop 和浏览器中的不相同。 Node 的 Event loop 分为 6 个阶段，它们会按照顺序反复运行 ┌───────────────────────┐ ┌─>│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │timer timers 阶段会执行 setTimeout 和 setInterval 一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟。 下限的时间有一个范围：[1, 2147483647] ，如果设定的时间不在这个范围，将被设置为 1。 I/O I/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调 idle, prepare poll 阶段很重要，这一阶段中，系统会做两件事情 执行到点的定时器 执行 poll 队列中的事件 并且当 poll 中没有定时器的情况下，会发现以下两件事情 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制 如果 poll 队列为空，会有两件事发生 如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate 如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调 如果有别的定时器需要被执行，会回到 timer 阶段执行回调。 check check 阶段执行 setImmediate close callbacks close callbacks 阶段执行 close 事件 并且在 Node 中，有些情况下的定时器执行顺序是随机的 setTimeout(() => { console.log('setTimeout') }, 0) setImmediate(() => { console.log('setImmediate') }) // 这里可能会输出 setTimeout，setImmediate // 可能也会相反的输出，这取决于性能 // 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate // 否则会执行 setTimeout 当然在这种情况下，执行顺序是相同的 var fs = require('fs') fs.readFile(__filename, () => { setTimeout(() => { console.log('timeout') }, 0) setImmediate(() => { console.log('immediate') }) }) // 因为 readFile 的回调在 poll 中执行 // 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调 // 再去 timer 阶段执行 setTimeout // 所以以上输出一定是 setImmediate，setTimeout 上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行。 setTimeout(() => { console.log('timer1') Promise.resolve().then(function() { console.log('promise1') }) }, 0) setTimeout(() => { console.log('timer2') Promise.resolve().then(function() { console.log('promise2') }) }, 0) // 以上代码在浏览器和 node 中打印情况是不同的 // 浏览器中一定打印 timer1, promise1, timer2, promise2 // node 中可能打印 timer1, timer2, promise1, promise2 // 也可能打印 timer1, promise1, timer2, promise2 Node 中的 process.nextTick 会先于其他 microtask 执行。 setTimeout(() => { console.log('timer1') Promise.resolve().then(function() { console.log('promise1') }) }, 0) process.nextTick(() => { console.log('nextTick') }) // nextTick, timer1, promise1 "},"浏览器/存储.html":{"url":"浏览器/存储.html","title":"存储","keywords":"","body":"存储 cookie，localStorage，sessionStorage，indexDB Service Worker cookie，localStorage，sessionStorage，indexDB 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 不参与 从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。 对于 cookie，我们还需要注意安全性。 sessionStorage indexDB value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 Service Worker Service workers 本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步 API。 目前该技术通常用来做缓存文件，提高首屏速度，可以试着来实现这个功能。 // index.js if (navigator.serviceWorker) { navigator.serviceWorker .register('sw.js') .then(function(registration) { console.log('service worker 注册成功') }) .catch(function(err) { console.log('servcie worker 注册失败') }) } // sw.js // 监听 `install` 事件，回调中缓存所需文件 self.addEventListener('install', e => { e.waitUntil( caches.open('my-cache').then(function(cache) { return cache.addAll(['./index.html', './index.js']) }) ) }) // 拦截所有请求事件 // 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据 self.addEventListener('fetch', e => { e.respondWith( caches.match(e.request).then(function(response) { if (response) { return response } console.log('fetch source') }) ) }) 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了 在 Cache 中也可以发现我们所需的文件已被缓存 当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的 "},"浏览器/渲染机制.html":{"url":"浏览器/渲染机制.html","title":"渲染机制","keywords":"","body":"渲染机制 浏览器的渲染机制 Load 和 DOMContentLoaded 区别 图层 重绘（Repaint）和回流（Reflow） 减少重绘和回流 浏览器的渲染机制 浏览器的渲染机制一般分为以下几个步骤 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上。 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。 Load 和 DOMContentLoaded 区别 Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。 DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。 图层 一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。 通过以下几个常用属性可以生成新图层 3D 变换：translate3d、translateZ will-change video、iframe 标签 通过动画实现的 opacity 动画转换 position: fixed 重绘（Repaint）和回流（Reflow） 重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。 所以以下几个动作可能会导致性能问题： 改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 很多人不知道的是，重绘和回流其实和 Event loop 有关。 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。 减少重绘和回流 使用 translate 替代 top .test { position: absolute; top: 10px; width: 100px; height: 100px; background: red; } setTimeout(() => { // 引起回流 document.querySelector('.test').style.top = '100px' }, 1000) 使用 visibility 替换display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量 for (let i = 0; i 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免 DOM 深度过深 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层。 "},"Node/node基础/node命令.html":{"url":"Node/node基础/node命令.html","title":"node命令","keywords":"","body":"Node 命令 npm 查看全局安装过的包 $ npm list -g --depth 0 $ npm view jquery versions $ npm install jquery@1.11.1 # npm查看包的最新版本 $ npm view versions --json # 查看node安装路径 $ which node nvm包管理器 $ nvm alias default $ nvm alias default 9.5.0 16. Yarn >> Npm $ yarn install == npm install $ yarn add koa || yarn global add koa == npm install koa -g $ yarn list $ yarn info koa == npm view koa $ yarn init == npm init $ yarn run == npm run $ yarn remove [package] == npm uninstall --save [package] && npm uninstall --save-dev [package] && npm uninstall --save-optional [package] $ yarn cache clean == npm cache clean $ yarn upgrade == rm -rf node_modules && npm install $ yarn remove [package] == npm uninstall [package] FTP常用命令 $ ftp 60.205.47.38 $ put file $ get file "},"框架通识/MVVM.html":{"url":"框架通识/MVVM.html","title":"MVVM","keywords":"","body":"MVVM MVVM MVVM 脏数据检测 数据劫持 Proxy 与 Object.defineProperty 对比 MVVM MVVM 由以下三个内容组成 View：界面 Model：数据模型 ViewModel：作为桥梁负责沟通 View 和 Model 在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合。 在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。 在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。 脏数据检测 当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次。 脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数。所以低效也是相对的，这就仁者见仁智者见智了。 数据劫持 Vue 内部使用了 Object.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set 和 get 的事件。 var data = { name: 'yck' } observe(data) let name = data.name // -> get value data.name = 'yyy' // -> change value function observe(obj) { // 判断类型 if (!obj || typeof obj !== 'object') { return } Object.keys(obj).forEach(key => { defineReactive(obj, key, obj[key]) }) } function defineReactive(obj, key, val) { // 递归子属性 observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter() { console.log('get value') return val }, set: function reactiveSetter(newVal) { console.log('change value') val = newVal } }) } 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅 {{name}} 在解析如上模板代码时，遇到 {{name}} 就会给属性 name 添加发布订阅。 // 通过 Dep 解耦 class Dep { constructor() { this.subs = [] } addSub(sub) { // sub 是 Watcher 实例 this.subs.push(sub) } notify() { this.subs.forEach(sub => { sub.update() }) } } // 全局属性，通过该属性配置 Watcher Dep.target = null function update(value) { document.querySelector('div').innerText = value } class Watcher { constructor(obj, key, cb) { // 将 Dep.target 指向自己 // 然后触发属性的 getter 添加监听 // 最后将 Dep.target 置空 Dep.target = this this.cb = cb this.obj = obj this.key = key this.value = obj[key] Dep.target = null } update() { // 获得新值 this.value = this.obj[this.key] // 调用 update 方法更新 Dom this.cb(this.value) } } var data = { name: 'yck' } observe(data) // 模拟解析到 `{{name}}` 触发的操作 new Watcher(data, 'name', update) // update Dom innerText data.name = 'yyy' 接下来,对 defineReactive 函数进行改造 function defineReactive(obj, key, val) { // 递归子属性 observe(val) let dp = new Dep() Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter() { console.log('get value') // 将 Watcher 添加到订阅 if (Dep.target) { dp.addSub(Dep.target) } return val }, set: function reactiveSetter(newVal) { console.log('change value') val = newVal // 执行 watcher 的 update 方法 dp.notify() } }) } 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加。 Proxy 与 Object.defineProperty 对比 Object.defineProperty 虽然已经能够实现双向绑定了，但是他还是有缺陷的。 只能对属性进行数据劫持，所以需要深度遍历整个对象 对于数组不能监听到数据的变化 虽然 Vue 中确实能检测到数组数据的变化，但是其实是使用了 hack 的办法，并且也是有缺陷的。 const arrayProto = Array.prototype export const arrayMethods = Object.create(arrayProto) // hack 以下几个函数 const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse' ] methodsToPatch.forEach(function(method) { // 获得原生函数 const original = arrayProto[method] def(arrayMethods, method, function mutator(...args) { // 调用原生函数 const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) { case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break } if (inserted) ob.observeArray(inserted) // 触发更新 ob.dep.notify() return result }) }) 反观 Proxy 就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 Vue 也将在下个大版本中使用 Proxy 替换 Object.defineProperty let onWatch = (obj, setBind, getLogger) => { let handler = { get(target, property, receiver) { getLogger(target, property) return Reflect.get(target, property, receiver) }, set(target, property, value, receiver) { setBind(value) return Reflect.set(target, property, value) } } return new Proxy(obj, handler) } let obj = { a: 1 } let value let p = onWatch( obj, v => { value = v }, (target, property) => { console.log(`Get '${property}' = ${target[property]}`) } ) p.a = 2 // bind `value` to `2` p.a // -> Get 'a' = 2 "},"框架通识/VirtualDom.html":{"url":"框架通识/VirtualDom.html","title":"Virtual Dom","keywords":"","body":"Virtual Dom Virtual Dom 为什么需要 Virtual Dom Virtual Dom 算法简述 Virtual Dom 算法实现 树的递归 判断属性的更改 判断列表差异算法实现 遍历子元素打标识 渲染差异 最后 为什么需要 Virtual Dom 众所周知，操作 DOM 是很耗费性能的一件事情，既然如此，我们可以考虑通过 JS 对象来模拟 DOM 对象，毕竟操作 JS 对象比操作 DOM 省时的多。 举个例子 // 假设这里模拟一个 ul，其中包含了 5 个 li ;[1, 2, 3, 4, 5][ // 这里替换上面的 li (1, 2, 5, 4) ] 从上述例子中，我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。 如果以上操作对应到 DOM 中，那么就是以下代码 // 删除第三个 li ul.childNodes[2].remove() // 将第四个 li 和第五个交换位置 let fromNode = ul.childNodes[4] let toNode = node.childNodes[3] let cloneFromNode = fromNode.cloneNode(true) let cloenToNode = toNode.cloneNode(true) ul.replaceChild(cloneFromNode, toNode) ul.replaceChild(cloenToNode, fromNode) 当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 Vue 和 React 中官方推荐列表里的节点使用唯一的 key 来保证性能。 那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM 以下是一个 JS 对象模拟 DOM 对象的简单实现 export default class Element { /** * @param {String} tag 'div' * @param {Object} props { class: 'item' } * @param {Array} children [ Element1, 'text'] * @param {String} key option */ constructor(tag, props, children, key) { this.tag = tag this.props = props if (Array.isArray(children)) { this.children = children } else if (isString(children)) { this.key = children this.children = null } if (key) this.key = key } // 渲染 render() { let root = this._createElement( this.tag, this.props, this.children, this.key ) document.body.appendChild(root) return root } create() { return this._createElement(this.tag, this.props, this.children, this.key) } // 创建节点 _createElement(tag, props, child, key) { // 通过 tag 创建节点 let el = document.createElement(tag) // 设置节点属性 for (const key in props) { if (props.hasOwnProperty(key)) { const value = props[key] el.setAttribute(key, value) } } if (key) { el.setAttribute('key', key) } // 递归添加子节点 if (child) { child.forEach(element => { let child if (element instanceof Element) { child = this._createElement( element.tag, element.props, element.children, element.key ) } else { child = document.createTextNode(element) } el.appendChild(child) }) } return el } } Virtual Dom 算法简述 既然我们已经通过 JS 来模拟实现了 DOM，那么接下来的难点就在于如何判断旧的对象和新的对象之间的差异。 DOM 是多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现 O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。 所以判断差异的算法就分为了两步 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异 一旦节点有子元素，就去判断子元素是否有不同 Virtual Dom 算法实现 树的递归 首先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对比会有几种情况 新的节点的 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了 新的节点的 tagName 和 key（可能都没有）和旧的相同，开始遍历子树 没有新的节点，那么什么都不用做 import { StateEnums, isString, move } from './util' import Element from './element' export default function diff(oldDomTree, newDomTree) { // 用于记录差异 let pathchs = {} // 一开始的索引为 0 dfs(oldDomTree, newDomTree, 0, pathchs) return pathchs } function dfs(oldNode, newNode, index, patches) { // 用于保存子树的更改 let curPatches = [] // 需要判断三种情况 // 1.没有新的节点，那么什么都不用做 // 2.新的节点的 tagName 和 `key` 和旧的不同，就替换 // 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树 if (!newNode) { } else if (newNode.tag === oldNode.tag && newNode.key === oldNode.key) { // 判断属性是否变更 let props = diffProps(oldNode.props, newNode.props) if (props.length) curPatches.push({ type: StateEnums.ChangeProps, props }) // 遍历子树 diffChildren(oldNode.children, newNode.children, index, patches) } else { // 节点不同，需要替换 curPatches.push({ type: StateEnums.Replace, node: newNode }) } if (curPatches.length) { if (patches[index]) { patches[index] = patches[index].concat(curPatches) } else { patches[index] = curPatches } } } 判断属性的更改 判断属性的更改也分三个步骤 遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中 遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化 在第二步中同时查看是否有属性不存在与旧的属性列列表中 function diffProps(oldProps, newProps) { // 判断 Props 分以下三步骤 // 先遍历 oldProps 查看是否存在删除的属性 // 然后遍历 newProps 查看是否有属性值被修改 // 最后查看是否有属性新增 let change = [] for (const key in oldProps) { if (oldProps.hasOwnProperty(key) && !newProps[key]) { change.push({ prop: key }) } } for (const key in newProps) { if (newProps.hasOwnProperty(key)) { const prop = newProps[key] if (oldProps[key] && oldProps[key] !== newProps[key]) { change.push({ prop: key, value: newProps[key] }) } else if (!oldProps[key]) { change.push({ prop: key, value: newProps[key] }) } } } return change } 判断列表差异算法实现 这个算法是整个 Virtual Dom 中最核心的算法，且让我一一为你道来。 这里的主要步骤其实和判断属性差异是类似的，也是分为三步 遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中 遍历新的节点列表，判断是否有新的节点 在第二步中同时判断节点是否有移动 PS：该算法只对有 key 的节点做处理 function listDiff(oldList, newList, index, patches) { // 为了遍历方便，先取出两个 list 的所有 keys let oldKeys = getKeys(oldList) let newKeys = getKeys(newList) let changes = [] // 用于保存变更后的节点数据 // 使用该数组保存有以下好处 // 1.可以正确获得被删除节点索引 // 2.交换节点位置只需要操作一遍 DOM // 3.用于 `diffChildren` 函数中的判断，只需要遍历 // 两个树中都存在的节点，而对于新增或者删除的节点来说，完全没必要 // 再去判断一遍 let list = [] oldList && oldList.forEach(item => { let key = item.key if (isString(item)) { key = item } // 寻找新的 children 中是否含有当前节点 // 没有的话需要删除 let index = newKeys.indexOf(key) if (index === -1) { list.push(null) } else list.push(key) }) // 遍历变更后的数组 let length = list.length // 因为删除数组元素是会更改索引的 // 所有从后往前删可以保证索引不变 for (let i = length - 1; i >= 0; i--) { // 判断当前元素是否为空，为空表示需要删除 if (!list[i]) { list.splice(i, 1) changes.push({ type: StateEnums.Remove, index: i }) } } // 遍历新的 list，判断是否有节点新增或移动 // 同时也对 `list` 做节点新增和移动节点的操作 newList && newList.forEach((item, i) => { let key = item.key if (isString(item)) { key = item } // 寻找旧的 children 中是否含有当前节点 let index = list.indexOf(key) // 没找到代表新节点，需要插入 if (index === -1 || key == null) { changes.push({ type: StateEnums.Insert, node: item, index: i }) list.splice(i, 0, key) } else { // 找到了，需要判断是否需要移动 if (index !== i) { changes.push({ type: StateEnums.Move, from: index, to: i }) move(list, index, i) } } }) return { changes, list } } function getKeys(list) { let keys = [] let text list && list.forEach(item => { let key if (isString(item)) { key = [item] } else if (item instanceof Element) { key = item.key } keys.push(key) }) return keys } 遍历子元素打标识 对于这个函数来说，主要功能就两个 判断两个列表差异 给节点打上标记 总体来说，该函数实现的功能很简单 function diffChildren(oldChild, newChild, index, patches) { let { changes, list } = listDiff(oldChild, newChild, index, patches) if (changes.length) { if (patches[index]) { patches[index] = patches[index].concat(changes) } else { patches[index] = changes } } // 记录上一个遍历过的节点 let last = null oldChild && oldChild.forEach((item, i) => { let child = item && item.children if (child) { index = last && last.children ? index + last.children.length + 1 : index + 1 let keyIndex = list.indexOf(item.key) let node = newChild[keyIndex] // 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历 if (node) { dfs(item, node, index, patches) } } else index += 1 last = item }) } 渲染差异 通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 DOM 了，下面就让我们来看看 Virtual Dom 算法的最后一步骤 这个函数主要两个功能 深度遍历树，将需要做变更操作的取出来 局部更新 DOM 整体来说这部分代码还是很好理解的 let index = 0 export default function patch(node, patchs) { let changes = patchs[index] let childNodes = node && node.childNodes // 这里的深度遍历和 diff 中是一样的 if (!childNodes) index += 1 if (changes && changes.length && patchs[index]) { changeDom(node, changes) } let last = null if (childNodes && childNodes.length) { childNodes.forEach((item, i) => { index = last && last.children ? index + last.children.length + 1 : index + 1 patch(item, patchs) last = item }) } } function changeDom(node, changes, noChild) { changes && changes.forEach(change => { let { type } = change switch (type) { case StateEnums.ChangeProps: let { props } = change props.forEach(item => { if (item.value) { node.setAttribute(item.prop, item.value) } else { node.removeAttribute(item.prop) } }) break case StateEnums.Remove: node.childNodes[change.index].remove() break case StateEnums.Insert: let dom if (isString(change.node)) { dom = document.createTextNode(change.node) } else if (change.node instanceof Element) { dom = change.node.create() } node.insertBefore(dom, node.childNodes[change.index]) break case StateEnums.Replace: node.parentNode.replaceChild(change.node.create(), node) break case StateEnums.Move: let fromNode = node.childNodes[change.from] let toNode = node.childNodes[change.to] let cloneFromNode = fromNode.cloneNode(true) let cloenToNode = toNode.cloneNode(true) node.replaceChild(cloneFromNode, toNode) node.replaceChild(cloenToNode, fromNode) break default: break } }) } 最后 Virtual Dom 算法的实现也就是以下三步 通过 JS 来模拟创建 DOM 对象 判断两个对象的差异 渲染差异 let test4 = new Element('div', { class: 'my-div' }, ['test4']) let test5 = new Element('ul', { class: 'my-div' }, ['test5']) let test1 = new Element('div', { class: 'my-div' }, [test4]) let test2 = new Element('div', { id: '11' }, [test5, test4]) let root = test1.render() let pathchs = diff(test1, test2) console.log(pathchs) setTimeout(() => { console.log('开始更新') patch(root, pathchs) console.log('结束更新') }, 1000) "},"安全/安全.html":{"url":"安全/安全.html","title":"2.安全XSS-CSRF","keywords":"","body":" XSS 如何攻击 如何防御 CSP CSRF 如何攻击 如何防御 密码安全 加盐 XSS 跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。 XSS 分为三种：反射型，存储型和 DOM-based 如何攻击 XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。 例如通过 URL 获取某些参数 alert(1) --> {{name}} 上述 URL 输入可能会将 HTML 改为 alert(1) ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击。 也有另一种场景，比如写了一篇包含攻击代码 alert(1) 的文章，那么可能浏览文章的用户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based 攻击，并且这种攻击打击面更广。 如何防御 最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义 function escape(str) { str = str.replace(/&/g, '&amp;') str = str.replace(//g, '&gt;') str = str.replace(/\"/g, '&quto;') str = str.replace(/'/g, '&#39;') str = str.replace(/`/g, '&#96;') str = str.replace(/\\//g, '&#x2F;') return str } 通过转义可以将攻击代码 alert(1) 变成 // -> &lt;script&gt;alert(1)&lt;&#x2F;script&gt; escape('alert(1)') 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。 var xss = require('xss') var html = xss('XSS Demoalert(\"xss\");') // -> XSS Demo&lt;script&gt;alert(\"xss\");&lt;/script&gt; console.log(html) 以上示例使用了 js-xss 来实现。可以看到在输出中保留了 h1 标签且过滤了 script 标签 CSP 内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。 我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。 通常可以通过 HTTP Header 中的 Content-Security-Policy 来开启 CSP 只允许加载本站资源 Content-Security-Policy: default-src ‘self’ 只允许加载 HTTPS 协议图片 Content-Security-Policy: img-src https://* 允许加载任何来源框架 Content-Security-Policy: child-src 'none' CSRF 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。[1] 跟跨網站指令碼（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 简单点说，CSRF 就是利用用户的登录态发起恶意请求。 如何攻击 假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口 如果接口是 Post 提交的，就相对麻烦点，需要用表单来提交接口 如何防御 防范 CSRF 可以遵循以下几种规则： Get 请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 token SameSite可以对 Cookie 设置 SameSite 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。 验证 Referer对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。 Token服务器下发一个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。 密码安全 密码安全虽然大多是后端的事情，但是作为一名优秀的前端程序员也需要熟悉这方面的知识。 加盐 对于密码存储来说，必然是不能明文存储在数据库中的，否则一旦数据库泄露，会对用户造成很大的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。 通常需要对密码加盐，然后进行几次不同加密算法的加密。 // 加盐也就是给原密码添加字符串，增加原密码长度 sha256(sha1(md5(salt + password + salt))) 但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误。 "},"安全/性能.html":{"url":"安全/性能.html","title":"3.性能","keywords":"","body":"性能 性能 网络相关 DNS 预解析 缓存 强缓存 协商缓存 选择合适的缓存策略 使用 HTTP / 2.0 预加载 预渲染 优化渲染过程 懒执行 懒加载 文件优化 图片优化 计算图片大小 图片加载优化 其他文件优化 CDN 其他 使用 Webpack 优化项目 监控 网络相关 DNS 预解析 DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。 缓存 缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。 通常浏览器缓存策略分为两种：强缓存和协商缓存。 强缓存 实现强缓存可以通过两种响应头实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200 Expires: Wed, 22 Oct 2018 08:41:00 GMT Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 Cache-control: max-age=30 Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。 协商缓存 如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。 Last-Modified 和 If-Modified-Since Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。 ETag 和 If-None-Match ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。 选择合适的缓存策略 对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。 使用 HTTP / 2.0 因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。 在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。 预加载 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。 预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。 预渲染 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染 优化渲染过程 代码层面的优化 懒执行 懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。 懒加载 懒加载就是将不关键的资源延后加载。 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。 文件优化 图片优化 计算图片大小 对于一张 100 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1 个字节），所以该图片大小大概为 39KB（10000 1 * 4 / 1024）。 但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。 了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了： 减少像素点 减少每个像素点能够显示的颜色 图片加载优化 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。 小图使用 base64 格式 将多个图标文件整合到一张图片中（雪碧图） 选择正确的图片格式： 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替 照片使用 JPEG 其他文件优化 CSS 文件放在 head 中 服务端开启文件压缩功能 将 script 标签放在 body 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 script 标签放在任意位置然后加上 defer ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 async ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。 执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 Webworker。Webworker 可以让我们另开一个线程执行脚本而不影响渲染。 CDN 静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。 其他 使用 Webpack 优化项目 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码 优化图片，对于小图可以使用 base64 的方式写入文件中 按照路由拆分代码，实现按需加载 给打包出来的文件名添加哈希，实现浏览器缓存文件 监控 对于代码运行错误，通常的办法是使用 window.onerror 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外 对于跨域的代码运行错误会显示 Script error. 对于这种情况我们需要给 script 标签添加 crossorigin 属性 对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 arguments.callee.caller 来做栈递归 对于异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch 但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。 对于捕获的错误需要上传给服务器，通常可以通过 img 标签的 src 发起一个请求。 "},"面试/如何渲染几万条数据并不卡住界面.html":{"url":"面试/如何渲染几万条数据并不卡住界面.html","title":"4.如何渲染几万条数据并不卡住界面","keywords":"","body":"如何渲染几万条数据并不卡住界面 这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 requestAnimationFrame 来每 16 ms 刷新一次。 Document 控件 setTimeout(() => { // 插入十万条数据 const total = 100000 // 一次插入 20 条，如果觉得性能不好就减少 const once = 20 // 渲染数据总共需要几次 const loopCount = total / once let countOfRender = 0 let ul = document.querySelector('ul') function add() { // 优化性能，插入不会造成回流 const fragment = document.createDocumentFragment() for (let i = 0; i "},"面试/综合1.html":{"url":"面试/综合1.html","title":"综合1","keywords":"","body":"js面试题(一) js面试题(一) 1. 循环闭包、IIFE、 ES6、 Promise、 ES7 await async 1.1 不起眼的开始 1.2 期望代码的输出变成 0 -> 1 -> 2 -> 3 -> 4 -> 5，并且要求原有的代码块中的循环和两处 console.log 不变 1.3 ES7 2. 闭包的作用，缺点 2.1 定义 2.2 闭包的特点： 2.3 优缺点 3. 深浅拷贝的区别和用途 3.1 理解 3.2 JavaScript的数据类型分为基本数据类型和引用数据类型 3.3 几种深拷贝的实现 4. CSS有哪些实现布局的方式 5. CSS命名冲突如何解决 6. 介绍下 ES 里的 Generator 是怎么运行的？ 和 async + await 有何区别？ 7. React 里的 key 有什么作用？ 8. React 里什么时候用 Context? 9. render props是什么？什么时候用？ 9.1 render props 9.2 传递 props 9.3 不局限于 children 9.4 依赖注入 9.5 render props 和高阶组件的比较 10. 路由如何做权限校验？ 10.1 实现 10.2 vue 路由权限限制 10.3 vue 路由验证 10.4 如何用 Vue 实现前端权限控制(CSDN) 11. SSR 的原理是什么？ 11.1 使用 SSR 技术的主要因素 11.2 SSR 中客户端渲染与服务器端渲染路由代码的差异 11.3 服务器端代码和客户端代码的打包差异 11.4 SSR 中异步数据的获取 + Redux 的使用 11.5 Node 只是一个中间层 12. React中调用setState之后发生了什么事情? 13. React中Element与Component的区别? 14. 在什么情况下会优先选择使用ClassComponent而不是FunctionalComponent? 15. React中的refs属性的作用是什么? 16. React中keys的作用是什么? 17. 回调渲染模式( Render Callback Pattern) 18. 组件的生命周期有哪三个状态, 有哪几个钩子函数？ 19. 在生命周期中的哪一步你应该发起 AJAX 请求？ 20. shouldComponentUpdate作用,为何重要？ 21. React 的工作原理 22. 使用 React 有何优点 23. 展示组件(Presentational component)和容器组件(Container component)之间有何不同 24. 类组件(Class component)和函数式组件(Functional component)之间有何不同 25. (组件的)状态(state)和属性(props)之间有何不同 26. 何为受控组件(controlled component) 27. 何为高阶组件(higher order component) 28. 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象 29. 除了在构造函数中绑定 this，还有其它方式吗 30. 怎么阻止组件的渲染 31. (在构造函数中)调用 super(props) 的目的是什么 32. 何为 JSX 33. 何为 Children 34. 何为 redux 35. 在 Redux 中，何为 store 36. 何为 action 37. 何为 reducer 38. Redux Thunk 的作用是什么 39. 何为纯函数(pure function) 40. react中的回调渲染模式 41. React 中的事件处理逻辑 42. React解决了什么问题 43. React的协议问题你了解吗 44. 你在过去的项目里遇到的最大问题是什么？你最大的成就？ 45. 传入 setState 函数的第二个参数的作用是什么？ 46. 封装ajax 47. Bind实现 48. 快速排序 49. 正则匹配结巴程序 50. ['1', '2', '3'].map(parseInt) 解析 51. 防抖和节流 防抖 debounce 节流 throttle 52. Set、Map、WeakSet 和 WeakMap 的区别？ 53. ES5/ES6 的继承除了写法以外还有什么区别 54. 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组 55. JS 异步解决方案的发展历程以及优缺点。 1. 回调函数（callback） 2. Promise 3. Generator 4. Async/await 56. 10 个 Ajax 同时发起请求，全部返回展示结果，并且至多允许三次失败，说出设计思路 57. 基于 Localstorage 设计一个 1M 的缓存系统，需要实现缓存淘汰机制 1. 循环闭包、IIFE、 ES6、 Promise、 ES7 await async 1.1 不起眼的开始 for (var i = 0; i 1.2 期望代码的输出变成 0 -> 1 -> 2 -> 3 -> 4 -> 5，并且要求原有的代码块中的循环和两处 console.log 不变 代码执行时，立即输出 0，之后每隔 1 秒依次输出 1,2,3,4，循环结束后在大概第 5 秒的时候输出 5 ```js for (var i = 0; i setTimeout(function() { // 这里增加定时器，超时设置为 5 秒 console.log(new Date, i); }, 1000 * i); 如果把这次的需求抽象为：在系列异步操作完成（每次循环都产生了 1 个异步操作）之后，再做其他的事情 ```js const tasks = []; for (var i = 0; i { tasks.push(new Promise((resolve) => { setTimeout(() => { console.log(new Date, j); resolve(); // 这里一定要 resolve，否则代码不会按预期 work }, 1000 * j); // 定时器的超时时间逐步增加 })); })(i); } Promise.all(tasks).then(() => { setTimeout(() => { console.log(new Date, i); }, 1000); // 注意这里只需要把超时设置为 1 秒 }); 相比而言，笔者更倾向于下面这样看起来更简洁的代码，要知道编程风格也是很多面试官重点考察的点，代码阅读时的颗粒度更小，模块化更好，无疑会是加分点。 const tasks = []; // 这里存放异步操作的 Promise const output = (i) => new Promise((resolve) => { setTimeout(() => { console.log(new Date, i); resolve(); }, 1000 * i); }); // 生成全部的异步操作 for (var i = 0; i { setTimeout(() => { console.log(new Date, i); }, 1000); }); 1.3 ES7 既然 Promise 已经被拿下，如何使用 ES7 中的 async await 特性来让这段代码变的更简洁？ // 模拟其他语言中的 sleep，实际上可以是任何异步操作 const sleep = (timeountMS) => new Promise((resolve) => { setTimeout(resolve, timeountMS); }); (async () => { // 声明即执行的 async 函数表达式 for (var i = 0; i 2. 闭包的作用，缺点 2.1 定义 闭包 当一个函数的返回值是另外一个函数,而返回的那个函数如果调用了其父函数内部的变量,且返回的这个函数在外部被执行就产生了闭包.闭包是一个环境，具体指的就是外部函数--高阶函数。 一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数） 能够读取其他函数内部变量的函数 2.2 闭包的特点： 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。 简单的闭包如下： function f1(){ var n = 100; return function f2(){ alert(++n); } } 函数执行时创建了一个内部函数，这个内部函数作为返回值，或以某种方式保留下来（属性），之后才会调用，这就会形成了闭包。通俗来讲，JS所有的function都是一个闭包。 2.3 优缺点 优点 可以读取函数内部的变量 可以让这些局部变量保存在内存中，实现变量数据共享。 避免全局变量的污染 私有成员的存在 缺点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 3. 深浅拷贝的区别和用途 3.1 理解 简单的来说就是，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误！ 假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。 浅拷贝例子 let a=[0,1,2,3,4], b=a; console.log(a===b); // true a[0]=1; console.log(a,b); // (5) [1, 1, 2, 3, 4] (5) [1, 1, 2, 3, 4] 3.2 JavaScript的数据类型分为基本数据类型和引用数据类型 基本数据类型: number，string，boolean，null，undefined，symbol以及未来ES10新增的BigInt(任意精度整数)七类 引用数据类型(Object类)有常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等 而这两类数据存储分别是这样的 基本类型--名值存储在栈内存中，例如let a=1; 当你b=a复制时，栈内存会新开辟一个内存，例如这样： 所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。 当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。 引用数据类型--名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值 我们以上面浅拷贝的例子画个图： 当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。 而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。 那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，岂不就达到深拷贝的效果了 3.3 几种深拷贝的实现 // 法1 // 递归去复制所有层级属性 function deepClone(obj){ let objClone = Array.isArray(obj)?[]:{}; if(obj && typeof obj===\"object\"){ for(key in obj){ if(obj.hasOwnProperty(key)){ //判断ojb子元素是否为对象，如果是，递归复制 if(obj[key]&&typeof obj[key] ===\"object\"){ objClone[key] = deepClone(obj[key]); }else{ //如果不是，简单复制 objClone[key] = obj[key]; } } } } return objClone; } let a=[1,2,3,4], b=deepClone(a); a[0]=2; console.log(a,b); // 法2 // 除了递归，我们还可以借用JSON对象的parse和stringify function deepClone(obj){ let _obj = JSON.stringify(obj), objClone = JSON.parse(_obj); return objClone } let a=[0,1,[2,3],4], b=deepClone(a); a[0]=1; a[2][0]=1; console.log(a,b); // 法3 function copy(obj){ //浅拷贝 var newObj = {}; for(var attr in obj){ newObj[attr] = obj[attr] } return newObj; } function deepCopy(obj){ //深拷贝 if(typeof obj != 'object'){ console.trace(); return obj; } var newObj = {}; for(var attr in obj){ newObj[attr] = deepCopy(obj[attr]); } return newObj; } // 法4 function extendCopy(p){ var c = {}; for(var i in p){ c[i] = p[i]; } c.uber = p; return c; } function deepCopy(p,c){ var c = c || {}; for(var i in p){ if(typeof p[i] === 'object'){ c[i] = (p[i].constructor === Array) ? [] : {}; deepCopy(p[i],c[i]); }else{ c[i] = p[i] } } return c; } 4. CSS有哪些实现布局的方式 table 布局 flex 布局 float 布局 响应式布局 meta 标签 使用 rem media query 5. CSS命名冲突如何解决 css-modules 细化选择符 假如全局是这样来定义一个元素的样式的：.abc {background:#000}，同时这个class为abc的元素是隶属于某个元素的，比如下面这样的html代码结构 那么在细化css里面，只需要在.abc前面加多一个父元素的选择符就行了： .container .abc {background:#fff} 这样.container .abc的优先级就大于了.abc，自然细化css里面的background设置也就不会被全局CSS覆盖了~~ 提升样式的优先级 这种方法个人不太推荐，相对而言会简单粗暴一些。同样是上面的例子，在细化CSS里面，只要在样式后面加一个!important，例如这样： .abc {background:#fff !improtant;} 这个样式的优先级就会默认提升到顶级，全局样式就无法影响到它了。 改变两个样式的加载顺序 这种方法比较简单，就是只要把细化css加载在全局css之后就行了，这样后面的样式就会自动覆盖前面的样式。不过如果你的html里面这两个样式表的加载顺序是先细化后全局的话，就要稍微调整一下代码才行。 6. 介绍下 ES 里的 Generator 是怎么运行的？ 和 async + await 有何区别？ Promise的写法只是回调函数的改进，使用then方法，只是让异步任务的两段执行更清楚而已。Promise的最大问题是代码冗余，请求任务多时，一堆的then，也使得原来的语义变得很不清楚 Generator 函数是一个普通函数，但是有两个特征。 一是，function关键字与函数名之间有一个星号； 二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。虽然Generator将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段） async函数，自动执行Generator函数的方法。使得异步操作变得更加方便。简单说来，它就是Generator函数的语法糖。 简单的说async函数就相当于自执行的Generator函数，相当于自带一个状态机，在await的部分等待返回， 返回后自动执行下一步。而且相较于Promise,async的优越性就是把每次异步返回的结果从then中拿到最外层的方法中，不需要链式调用，只要用同步的写法就可以了。更加直观而且，更适合处理并发调用的问题。但是async必须以一个Promise对象开始 ，所以async通常是和Promise结合使用的 7. React 里的 key 有什么作用？ Keys 是React在操作列表中元素被修改,添加,或者删除的辅助标识. 在开发过程中,我们需要保证某个元素的key 在其同级元素中具有唯一性,在ReactDiff算法中React会借助元素的Key值来判断该元素是新创建的还是被移动而来的元素,React会保存这个辅助状态,从而减少不必要的元素渲染.此外,React还需要借助Key值来判断元素与本地状态的关联干洗,因此我们在开发中不可忽视Key值的使用. Keys 会有助于 React 识别哪些 items 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key 的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 items 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果 items 可以重新排序，就会导致 re-render 变慢。 8. React 里什么时候用 Context? 当我们使用React时，很容易的通过观察组件的props来跟踪组件间的数据流流向，这种跟踪观察方式也让我们很容易的去理解组件。 而有的时候，我们不想让一个props从最外层，通过组件一层一层的传递到目标组件上，这时就可以通过context来直接实现我们希望的操作。 context最好的使用场景是隐式的传入登录的用户，当前的语言，或者主题信息。要不然所有这些可能就是全局变量，但是context让你限定他们到一个单独的React树里。 9. render props是什么？什么时候用？ 9.1 render props 所谓 render props，指的是让 React 组件的 props 支持函数这种模式。因为作为 props 传入的函数往往被用来渲染一部分界面，所以这种模式被称为 render props。 Render Props 的核心思想是，通过一个函数将class组件的state作为props传递给纯函数组件 一个最简单的 render props 组件 RenderAll，代码如下： const RenderAll = (props) => { return( {props.children(props)} ); }; 这个 RenderAll 预期子组件是一个函数，它所做的事情就是把子组件当做函数调用，调用参数就是传入的 props，然后把返回结果渲染出来，除此之外什么事情都没有做。 使用 RenderAll 的代码如下： {() => hello world} 可以看到，RenderAll 的子组件，也就是夹在 RenderAll 标签之间的部分，其实是一个函数。这个函数渲染出 hello world，这就是上面使用 RenderAll 渲染出来的结果。 当然，这个 RenderAll 没做任何实际工作，接下来我们看 render props 真正强悍的使用方法。 9.2 传递 props 和高阶组件一样，render props 可以做很多的定制功能，我们还是以根据是否登录状态来显示一些界面元素为例，来实现一个 render props。 下面是实现 render props 的 Login 组件，可以看到，render props 和高阶组件的第一个区别，就是 render props 是真正的 React 组件，而不是一个返回 React 组件的函数。 const Login = (props) => { const userName = getUserName(); if (userName) { const allProps = {userName, ...props}; return ( {props.children(allProps)} ); } else { return null; } }; 当用户处于登录状态，getUserName 返回当前用户名，否则返回空，然后我们根据这个结果决定是否渲染 props.children 返回的结果。 当然，render props 完全可以决定哪些 props 可以传递给 props.children，在 Login 中，我们把 userName 作为增加的 props 传递给下去，这样就是 Login 的增强功能。 一个使用上面 Login 的 JSX 代码示例如下： {({userName}) => Hello {userName}} 对于名为“程墨Morgan”的用户登录，上面的 JSX 会产生 Hello 程墨Morgan。 9.3 不局限于 children 在上面的例子中，作为 render 方法的 props 就是 children，在我写的《深入浅出React和Redux》中，将这种模式称为“以函数为子组件（function as child）”的模式，这可以算是 render props 的一种具体形式，也就利用 children 这个 props 来作为函数传递。 实际上，render props 这个模式不必局限于 children 这一个 props，任何一个 props 都可以作为函数，也可以利用多个 props 来作为函数。 我们来扩展 Login，不光在用户登录时显示一些东西，也可以定制用户没有登录时显示的东西，我们把这个组件叫做 Auth，对应代码如下： const Auth = (props) => { const userName = getUserName(); if (userName) { const allProps = {userName, ...props}; return ( {props.login(allProps)} ); } else { {props.nologin(props)} } }; 使用 Auth 的话，可以分别通过 login 和 nologin 两个 props 来指定用户登录或者没登录时显示什么，用法如下： Hello {userName}} nologin={() => Please login} /> 9.4 依赖注入 render props 其实就是 React 世界中的 “依赖注入”（Dependency Injection)。 所谓依赖注入，指的是解决这样一个问题：逻辑 A 依赖于逻辑 B，如果让 A 直接依赖于 B，当然可行，但是 A 就没法做得通用了。依赖注入就是把 B 的逻辑以函数形式传递给 A，A 和 B 之间只需要对这个函数接口达成一致就行，如此一来，再来一个逻辑 C，也可以用一样的方法重用逻辑 A。 在上面的代码示例中，Login 和 Auth 组件就是上面所说的逻辑 A，而传递给组件的函数类型 props，就是逻辑 B 和 C。 9.5 render props 和高阶组件的比较 我们来比对一下这两种重用 React 组件逻辑的模式。 首先，render props 模式的应用，就是做一个 React 组件，而高阶组件，虽然名为“组件”，其实只是一个产生 React 组件的函数。 render props 不像上一小节中介绍的高阶组件有那么多毛病，如果说 render props 有什么缺点，那就是 render props 不能像高阶组件那样链式调用，当然，这并不是一个致命缺点。 render props 相对于高阶组件还有一个显著优势，就是对于新增的 props 更加灵活。还是以登录状态为例，假如我们扩展 withLogin 的功能，让它给被包裹的组件传递用户名这个 props，代码如下： const withLogin = (Component) => { const NewComponent = (props) => { const userName= getUserName(); if (userName) { return ; } else { return null; } } return NewComponent; }; 这就要求被 withLogin 包住的组件要接受 userName 这个props。可是，假如有一个现成的 React 组件不接受 userName，却接受名为 name 的 props 作为用户名，这就麻烦了。我们就不能直接用 withLogin 包住这个 React 组件，还要再造一个组件来做 userName 到 name 的映射，十分费事。 对于应用 render props 的 Login，就不存在这个问题，接受 name 不接受 userName 是吗？这样写就好了： { (props) => { const {userName} = props; return } } 所以，当需要重用 React 组件的逻辑时，建议首先看这个功能是否可以抽象为一个简单的组件；如果行不通的话，考虑是否可以应用 render props 模式；再不行的话，才考虑应用高阶组件模式。 这并不表示高阶组件无用武之地，在后续章节，我们会对 render props 和高阶组件分别讲解具体的实例。 10. 路由如何做权限校验？ 10.1 实现 登陆权限，一般来说这个是独立出来，不用 spa 做，就一个表单的事情，后面也容易做扩展，包括单点登录什么的； 登陆集成到 spa 里面，这个一般在请求加拦截，vuex 可以存 token，每次请求头带 token，后端校验 token 是否有效，如果修改了或者过期了，返回约定的字段标识，异步请求 axios 在返回 response 的时候优先拦截 token 校验，如果失效直接 vue-router 路由到登录页； 内部权限，子页面什么的，前端一般是打包好了文件，页面是全部的，但是有的页面需要权限控制是否能访问，这时候只能做 2 次校验，后端返回当前权限能访问的路由 or 页面，存 vuex，前端路由加 watch，每次切换跳转都要遍历一次； 接口权限，有的接口是不能提供给无权限的人使用的，比如抓包出来的；这时候后端做鉴权，返回约定的字段就行 后台接口加一层 api gateway 做权限控制，防止越权调用 请求后台接口获取当前登录用户所有的 [可用菜单（路由）] 及 [权限信息（权限 key ）] 根据 [可用菜单] 动态生成 router 页面子控件，如按钮（对应权限 key ）通过 v-if 实现显示与隐藏， 如新增用户 hasPermission 做成一个 mixin 混入所有组件 10.2 vue 路由权限限制 function routerXmlFlag (menu, to) { for (let i = 0; i { if (to.meta.requireAuth) { // 判断该路由是否需要登录权限 let token = sessionStorage.getItem('X-CSRF-TOKEN') if (token) { // 通过vuex state获取当前的token是否存在 let menu = store.state.common.menu // 为了菜单的链接，直接跳转404 if (menu && menu.length > 0) { let flag = routerXmlFlag(menu, to) if (flag) { next() } else { next('/404') } } else { next() } } else { next({ path: '/login', query: {redirect: to.fullPath} // 将跳转的路由path作为参数，登录成功后跳转到该路由 }) } } else { next() } }) // 前提，每个用户进来分配的菜单权限不一样， 但是手动输入菜单以外的url 可以进行访问 // bug 修改，手动输入菜单以外的链接，返回404 10.3 vue 路由验证 在没有登录的情况下开发者有可能会不让用户看到某些或者进入某些页面，vue 跳转使用的是vue-roter跳转。 使用vue-router的beforeEach函数接受三个参数to, from, next分别是to：去的页面、from：来自那个页面、next：定向到哪里 beforeEach需要写到vue实例前。 //首先登录成功之后需要存一个状态到本地 这个状态可以是自己设置也可以配合后台来操作 router.beforeEach((to, from, next) => { //获取到登录状态 const loginStuts = sessionStorage.getItem('loginStuts') //如果登录状态不存在或者去的页面是某个用户没登录不能去的页面 //（to.path的意思为去往的 路径是/myinformation也可不写） //就跳转到login页面也就是登录界面 //next函数不传参数即是验证通过去往该页面 传入参数即是调往参数页面 if (!loginStuts && to.path == '/myinformation') { next('/login') } else { next() } }) /* eslint-disable no-new */ new Vue({ el: '#app', router, components: { App }, template: '', store }) 10.4 如何用 Vue 实现前端权限控制(CSDN) 如何用 Vue 实现前端权限控制https://blog.csdn.net/gitchat/article/details/78849246 项目本身也是一个可运行的 DEMO，演示地址和测试账号同样见下方。 仓库地址：https://github.com/tower1229/Vue-Access-Control 项目主页：http://refined-x.com/Vue-Access-Control/ root 任意 client 任意 11. SSR 的原理是什么？ SSR，很多人的第一反应是“服务器端渲染”，但我更倾向于称之为“同构”，所以首先我们来对“客户端渲染”，“服务器端渲染”，“同构”这三个概念简单的做一个分析： 客户端渲染：客户端渲染，页面初始加载的 HTML 页面中无网页展示内容，需要加载执行JavaScript 文件中的 React 代码，通过 JavaScript 渲染生成页面，同时，JavaScript 代码会完成页面交互事件的绑定，详细流程可参考下图（图片取材自 fullstackacademy.com）： 服务器端渲染：用户请求服务器，服务器上直接生成 HTML 内容并返回给浏览器。服务器端渲染来，页面的内容是由 Server 端生成的。一般来说，服务器端渲染的页面交互能力有限，如果要实现复杂交互，还是要通过引入 JavaScript 文件来辅助实现。服务器端渲染这个概念，适用于任何后端语言。 同构：同构这个概念存在于 Vue，React 这些新型的前端框架中，同构实际上是客户端渲染和服务器端渲染的一个整合。我们把页面的展示内容和交互写在一起，让代码执行两次。在服务器端执行一次，用于实现服务器端渲染，在客户端再执行一次，用于接管页面交互，详细流程可参考下图（图片取材自 fullstackacademy.com）: 一般情况下，当我们使用 React 编写代码时，页面都是由客户端执行 JavaScript 逻辑动态挂 DOM 生成的，也就是说这种普通的单页面应用实际上采用的是客户端渲染模式。在大多数情况下，客户端渲染完全能够满足我们的业务需求，那为什么我们还需要 SSR 这种同构技术呢？ 11.1 使用 SSR 技术的主要因素 CSR 项目的 TTFP（Time To First Page）时间比较长，参考之前的图例，在 CSR 的页面渲染流程中，首先要加载 HTML 文件，之后要下载页面所需的 JavaScript 文件，然后 JavaScript 文件渲染生成页面。在这个渲染过程中至少涉及到两个 HTTP 请求周期，所以会有一定的耗时，这也是为什么大家在低网速下访问普通的 React 或者 Vue 应用时，初始页面会有出现白屏的原因。 CSR 项目的 SEO 能力极弱，在搜索引擎中基本上不可能有好的排名。因为目前大多数搜索引擎主要识别的内容还是 HTML，对 JavaScript 文件内容的识别都还比较弱。如果一个项目的流量入口来自于搜索引擎，这个时候你使用 CSR 进行开发，就非常不合适了。 SSR 的产生，主要就是为了解决上面所说的两个问题。在 React 中使用 SSR 技术，我们让 React 代码在服务器端先执行一次，使得用户下载的 HTML 已经包含了所有的页面展示内容，这样，页面展示的过程只需要经历一个 HTTP 请求周期，TTFP 时间得到一倍以上的缩减。 同时，由于 HTML 中已经包含了网页的所有内容，所以网页的 SEO 效果也会变的非常好。之后，我们让 React 代码在客户端再次执行，为 HTML 网页中的内容添加数据及事件的绑定，页面就具备了 React 的各种交互能力。 但是，SSR 这种理念的实现，并非易事。我们来看一下在 React 中实现 SSR 技术的架构图： SSR 之所以能够实现，本质上是因为虚拟 DOM 的存在 SSR 的工程中，React 代码会在客户端和服务器端各执行一次。你可能会想，这没什么问题，都是 JavaScript 代码，既可以在浏览器上运行，又可以在 Node 环境下运行。但事实并非如此，如果你的 React 代码里，存在直接操作 DOM 的代码，那么就无法实现 SSR 这种技术了，因为在 Node 环境下，是没有 DOM 这个概念存在的，所以这些代码在 Node 环境下是会报错的。 好在 React 框架中引入了一个概念叫做虚拟 DOM，虚拟 DOM 是真实 DOM 的一个 JavaScript 对象映射，React 在做页面操作时，实际上不是直接操作 DOM，而是操作虚拟 DOM，也就是操作普通的 JavaScript 对象，这就使得 SSR 成为了可能。在服务器，我可以操作 JavaScript 对象，判断环境是服务器环境，我们把虚拟 DOM 映射成字符串输出；在客户端，我也可以操作 JavaScript 对象，判断环境是客户端环境，我就直接将虚拟 DOM 映射成真实 DOM，完成页面挂载。 其他的一些框架，比如 Vue，它能够实现 SSR 也是因为引入了和 React 中一样的虚拟 DOM 技术。 好，接下来我们回过头看流程图，前两步不说了，服务器端渲染肯定要先向 Node 服务器发送请求。重点是第 3 步，大家可以看到，服务器端要根据请求的地址，判断要展示什么样的页面了，这一步叫做服务器端路由。 我们再看第 10 步，当客户端接收到 JavaScript 文件后，要根据当前的路径，在浏览器上再判断当前要展示的组件，重新进行一次客户端渲染，这个时候，还要经历一次客户端路由（前端路由）。 那么，我们下面要说的就是服务器端路由和客户端路由的区别。 11.2 SSR 中客户端渲染与服务器端渲染路由代码的差异 实现 React 的 SSR 架构，我们需要让相同的 React 代码在客户端和服务器端各执行一次。大家注意，这里说的相同的 React 代码，指的是我们写的各种组件代码，所以在同构中，只有组件的代码是可以公用的，而路由这样的代码是没有办法公用的，大家思考下这是为什么呢？其实原因很简单，在服务器端需要通过请求路径，找到路由组件，而在客户端需通过浏览器中的网址，找到路由组件，是完全不同的两套机制，所以这部分代码是肯定无法公用。我们来看看在 SSR 中，前后端路由的实现代码： 客户端路由： const App = () => { return ( ) } ReactDom.render(, document.querySelector('#root')) 服务器端路由代码： const App = () => { return } Return ReactDom.renderToString() 服务器端路由代码相对要复杂一点，需要你把 location（当前请求路径）传递给 StaticRouter 组件，这样 StaticRouter 才能根据路径分析出当前所需要的组件是谁。（PS：StaticRouter 是 React-Router 针对服务器端渲染专门提供的一个路由组件。） 通过 BrowserRouter 我们能够匹配到浏览器即将显示的路由组件，对浏览器来说，我们需要把组件转化成 DOM，所以需要我们使用 ReactDom.render 方法来进行 DOM 的挂载。而 StaticRouter 能够在服务器端匹配到将要显示的组件，对服务器端来说，我们要把组件转化成字符串，这时我们只需要调用 ReactDom 提供的 renderToString 方法，就可以得到 App 组件对应的 HTML 字符串。 对于一个 React 应用来说，路由一般是整个程序的执行入口。在 SSR 中，服务器端的路由和客户端的路由不一样，也就意味着服务器端的入口代码和客户端的入口代码是不同的。远程控制电脑 我们知道， React 代码是要通过 Webpack 打包之后才能运行的，也就是第 3 步和第10 步运行的代码，实际上是源代码打包过后生成的代码。上面也说到，服务器端和客户端渲染中的代码，只有一部分一致，其余是有区别的。所以，针对代码运行环境的不同，要进行有区别的 Webpack 打包。 11.3 服务器端代码和客户端代码的打包差异 简单写两个 Webpack 配置文件作为 DEMO： 客户端 Webpack 配置： { entry: './src/client/index.js', output: { filename: 'index.js', path: path.resolve(__dirname, 'public') }, module: { rules: [{ test: /\\.js?$/, loader: 'babel-loader' },{ test: /\\.css?$/, use: ['style-loader', { loader: 'css-loader', options: {modules: true} }] },{ test: /\\.(png|jpeg|jpg|gif|svg)?$/, loader: 'url-loader', options: { limit: 8000, publicPath: '/' } }] } } 服务器端 Webpack 配置: { target: 'node', entry: './src/server/index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'build') }, externals: [nodeExternals()], module: { rules: [{ test: /\\.js?$/, loader: 'babel-loader' },{ test: /\\.css?$/, use: ['isomorphic-style-loader', { loader: 'css-loader', options: {modules: true} }] },{ test: /\\.(png|jpeg|jpg|gif|svg)?$/, loader: 'url-loader', options: { limit: 8000, outputPath: '../public/', publicPath: '/' } }] } }; 11.4 SSR 中异步数据的获取 + Redux 的使用 客户端渲染中，异步数据结合 Redux 的使用方式遵循下面的流程（对应图中第 12 步）： 创建 Store 根据路由显示组件 派发 Action 获取数据 更新 Store 中的数据 组件 Rerender 而在服务器端，页面一旦确定内容，就没有办法 Rerender 了，这就要求组件显示的时候，就要把 Store 的数据都准备好，所以服务器端异步数据结合 Redux 的使用方式，流程是下面的样子（对应图中第 4 步）： 创建 Store 根据路由分析 Store 中需要的数据 派发 Action 获取数据 更新Store 中的数据 结合数据和组件生成 HTML，一次性返回 下面，我们分析下服务器端渲染这部分的流程： 创建 Store：这一部分有坑，要注意避免，大家知道，客户端渲染中，用户的浏览器中永远只存在一个 Store，所以代码上你可以这么写： const store = createStore(reducer, defaultState) export default store; 然而在服务器端，这么写就有问题了，因为服务器端的 Store 是所有用户都要用的，如果像上面这样构建 Store，Store 变成了一个单例，所有用户共享 Store，显然就有问题了。所以在服务器端渲染中，Store 的创建应该像下面这样，返回一个函数，每个用户访问的时候，这个函数重新执行，为每个用户提供一个独立的 Store： const getStore = (req) => { return createStore(reducer, defaultState); } export default getStore; 根据路由分析 Store 中需要的数据： 要想实现这个步骤，在服务器端，首先我们要分析当前出路由要加载的所有组件，这个时候我们可以借助一些第三方的包，比如说 react-router-config, 具体这个包怎么使用，不做过多说明，大家可以查看文档，使用这个包，传入服务器请求路径，它就会帮助你分析出这个路径下要展示的所有组件。 派发 Action 获取数据: 接下来，我们在每个组件上增加一个获取数据的方法： Home.loadData = (store) => { return store.dispatch(getHomeList()) } 这个方法需要你把服务器端渲染的 Store 传递进来，它的作用就是帮助服务器端的 Store 获取到这个组件所需的数据。 所以，组件上有了这样的方法，同时我们也有当前路由所需要的所有组件，依次调用各个组件上的 loadData 方法，就能够获取到路由所需的所有数据内容了。 更新 Store 中的数据: 其实，当我们执行第三步的时候，已经在更新 Store 中的数据了，但是，我们要在生成 HTML 之前，保证所有的数据都获取完毕，这怎么处理呢？ // matchedRoutes 是当前路由对应的所有需要显示的组件集合 matchedRoutes.forEach(item => { if (item.route.loadData) { const promise = new Promise((resolve, reject) => { item.route.loadData(store).then(resolve).catch(resolve); }) promises.push(promise); } }) Promise.all(promises).then(() => { // 生成 HTML 逻辑 }) 这里，我们使用 Promise 来解决这个问题，我们构建一个 Promise 队列，等待所有的 Promise 都执行结束后，也就是所有 store.dispatch 都执行完毕后，再去生成 HTML。这样的话，我们就实现了结合 Redux 的 SSR 流程。 在上面，我们说到，服务器端渲染时，页面的数据是通过 loadData 函数来获取的。而在客户端，数据获取依然要做，因为如果这个页面是你访问的第一个页面，那么你看到的内容是服务器端渲染出来的，但是如果经过 react-router 路由跳转道第二个页面，那么这个页面就完全是客户端渲染出来的了，所以客户端也要去拿数据。 在客户端获取数据，使用的是我们最习惯的方式，通过 componentDidMount 进行数据的获取。这里要注意的是，componentDidMount 只在客户端才会执行，在服务器端这个生命周期函数是不会执行的。所以我们不必担心 componentDidMount 和 loadData 会有冲突，放心使用即可。这也是为什么数据的获取应该放到 componentDidMount 这个生命周期函数中而不是 componentWillMount 中的原因，可以避免服务器端获取数据和客户端获取数据的冲突。 11.5 Node 只是一个中间层 上一部分我们说到了获取数据的问题，在 SSR 架构中，一般 Node 只是一个中间层，用来做 React 代码的服务器端渲染，而 Node 需要的数据通常由 API 服务器单独提供。 这样做一是为了工程解耦，二也是为了规避 Node 服务器的一些计算性能问题。 请大家关注图中的第 4 步和第 12，13 步，我们接下来分析这几个步骤。 服务器端渲染时，直接请求 API 服务器的接口获取数据没有任何问题。但是在客户端，就有可能存在跨域的问题了，所以，这个时候，我们需要在服务器端搭建 Proxy 代理功能，客户端不直接请求 API 服务器，而是请求 Node 服务器，经过代理转发，拿到 API 服务器的数据。 这里你可以通过 express-http-proxy 这样的工具帮助你快速搭建 Proxy 代理功能，但是记得配置的时候，要让代理服务器不仅仅帮你转发请求，还要把 cookie 携带上，这样才不会有权限校验上的一些问题。 // Node 代理功能实现代码 app.use('/api', proxy('http://apiServer.com', { proxyReqPathResolver: function (req) { return '/ssr' + req.url; } })); 12. React中调用setState之后发生了什么事情? React会将当前传入的参数对象与组件当前的状态合并,然后触发调和过程,在调和的过程中,React会以相对高效的方式根据新的状态构建React元素树并且重新渲染整个UI界面. React得到的元素树之后,React会自动计算出新的树与老的树的节点的差异,然后根据差异对界面进行最小化的渲染,在React的差异算法中,React能够精确的知道在哪些位置发生看改变以及应该如何去改变,这样就保证了UI是按需更新的而不是重新渲染整个界面. 调用setState >> 将传入参数与组件当前状态合并 >> 触发Reconciliation调和过程(生成最终状态) >> 高效构建虚拟DOM,并准备renderUI界面 >> 计算新旧DOM异同 >> 根据异同进行render不同点 >> 完成按需更新 在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。 13. React中Element与Component的区别? ReactElement是描述屏幕上所见的内容的数据结构,是对于UI的对象的表述.典型的ReactElement就是利用JSX构建的声明式代码片段,然后被转化为createElement的调用组合. ReactComponent则是可以接收参数输入并且返回某个ReactElement的函数或者类. 14. 在什么情况下会优先选择使用ClassComponent而不是FunctionalComponent? 组件需要包含内部状态或者使用到生命周期函数的时候使用ClassComponent,否则使用函数式组件 15. React中的refs属性的作用是什么? Refs是React提供给我们安全的访问DOM元素或者某个组件实例的句柄,我们可以为元素添加ref属性然后在回调函数中接收该元素在DOM树中的句柄,该值会作为回调函数的第一个参数的返回. 16. React中keys的作用是什么? Keys 是React在操作列表中元素被修改,添加,或者删除的辅助标识. 在开发过程中,我们需要保证某个元素的key 在其同级元素中具有唯一性,在ReactDiff算法中React会借助元素的Key值来判断该元素是新创建的还是被移动而来的元素,React会保存这个辅助状态,从而减少不必要的元素渲染.此外,React还需要借助Key值来判断元素与本地状态的关联干洗,因此我们在开发中不可忽视Key值的使用. Keys 会有助于 React 识别哪些 items 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key 的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 items 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果 items 可以重新排序，就会导致 re-render 变慢。 key是给每一个vnode的唯一id,可以依靠key,更准确, 更快的拿到oldVnode中对应的vnode节点。 主要是为了提升diff【同级比较】的效率。自己想一下自己要实现前后列表的diff，如果对列表的每一项增加一个key，即唯一索引，那就可以很清楚的知道两个列表谁少了谁没变。而如果不加key的话，就只能一个个对比了。 17. 回调渲染模式( Render Callback Pattern) 在这种模式中,组件会接收某个函数作为子组件,然后在渲染函数中以props.children进行调用. import React ,{ Component, PropTypes } from 'react'; import fetchUser from 'Twitter'; class Twitter extends Component{ state = { user : null } satic propTypes = { userName.propTypes.String.isRequied } componentDidMount(){ fetchUser(this.props.userName) .then((user)=>{ this.setState({user}) }) } render(){ return this.props.children(this.state.user) } } 此模式的优势在于将父组件与子组件解耦,父组件可以直接访问子组件的内部状态而不需要再通过Props传递,这样父组件能够更为方便地控制子组件展示的UI界面.如果将原本展示的Badge替换为Profile,可以方便的修改回调函数来实现 { (user) => user === null } 18. 组件的生命周期有哪三个状态, 有哪几个钩子函数？ 有三个状态: 已经插入到DOM中 正在更新 已经卸载完毕 8个生命周期: construtor()　　 　　　　　　 创建组件 componentWillMount 　　 组件加载前 componentDidMount 　　　　 组件加载完成 componentWillRecevieProps() 　　父组件发生了 render 的时候, 子组件就调用这个钩子函数, 进行更新当前组件中, 传参相关的状态 shouldComponentUpdate() 　　　 组件挂载完成后, 如果调用setState就会调用shouldComponentUpdate()函数, 来确定是否有必要更新渲染此组件, 默认返回true componentDidUpdate() 　　　 必要的状态更新完成 render()　　　　　　　　　　　　开始渲染, react核心函数 componentWillUnMount　　　　 组件卸载 / 销毁时调用, 一般都是: componentDidMount() 函数中定义注册的事件, 在这里删除 19. 在生命周期中的哪一步你应该发起 AJAX 请求？ 我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下： 放到componentWillMount不好. React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。 如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题 在 componentDidMount 函数中发起ajax请求 保证请求仅在组件挂载完毕后才会要求响应 调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。React 可能会多次频繁调用componentWillMount。 20. shouldComponentUpdate作用,为何重要？ shouldComponentUpdate 是 允许 我们手动进行组件更新, 可以根据组件的实际应用场景, 设置合理的函数返回值 , 决定是否要更新, 能够避免不必要的更新. 21. React 的工作原理 React 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 \"diffing\" 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新 DOM。 22. 使用 React 有何优点 只需查看 render 函数就会很容易知道一个组件是如何被渲染的 JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的 支持服务端渲染，这可以改进 SEO 和性能 易于测试 React 只关注 View 层，所以可以和其它任何框架(如Backbone.js, Angular.js)一起使用 23. 展示组件(Presentational component)和容器组件(Container component)之间有何不同 展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。 容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。 24. 类组件(Class component)和函数式组件(Functional component)之间有何不同 类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态 当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 '无状态组件(stateless component)'，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件 在组件需要包含内部状态或者使用到生命周期函数的时候使用 Class Component ，否则使用函数式组件。 25. (组件的)状态(state)和属性(props)之间有何不同 State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。 Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。 26. 何为受控组件(controlled component) 在 HTML 中，类似 , 和 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为\"受控元素\"。 27. 何为高阶组件(higher order component) 高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。 28. 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象 因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。 29. 除了在构造函数中绑定 this，还有其它方式吗 你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。 30. 怎么阻止组件的渲染 在组件的 render 方法中返回 null 并不会影响触发组件的生命周期方法 31. (在构造函数中)调用 super(props) 的目的是什么 在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。 32. 何为 JSX JSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React \"元素\"，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 if 语句和 for 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。 33. 何为 Children 在JSX表达式中，一个开始标签(比如)和一个关闭标签(比如)之间的内容会作为一个特殊的属性props.children被自动传递给包含着它的组件。 这个属性有许多可用的方法，包括 React.Children.map，React.Children.forEach， React.Children.count， React.Children.only，React.Children.toArray。 34. 何为 redux Redux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该有任何副作用。 35. 在 Redux 中，何为 store Store 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责： 允许通过 getState() 访问 state 运行通过 dispatch(action) 改变 state 通过 subscribe(listener) 注册 listeners 通过 subscribe(listener) 返回的函数处理 listeners 的注销 36. 何为 action Actions 是一个纯 javascript 对象，它们必须有一个 type 属性表明正在执行的 action 的类型。实质上，action 是将数据从应用程序发送到 store 的有效载荷。 37. 何为 reducer 一个 reducer 是一个纯函数，该函数以先前的 state 和一个 action 作为参数，并返回下一个 state。 38. Redux Thunk 的作用是什么 Redux thunk 是一个允许你编写返回一个函数而不是一个 action 的 actions creators 的中间件。如果满足某个条件，thunk 则可以用来延迟 action 的派发(dispatch)，这可以处理异步 action 的派发(dispatch) 39. 何为纯函数(pure function) 一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。 40. react中的回调渲染模式 这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以 props.children进行调用： 这种模式的优势在于将父组件与子组件解耦和， 父组件可以直接访问子组件的内部状态而不需要再通过Props传递，这样父组件能够更为方便地控制子组件展示的UI界面 41. React 中的事件处理逻辑 为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。 另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的。 42. React解决了什么问题 一个是组件复用问题，一个是性能问题，还有一个，如果也算的话，就是兼容性问题 43. React的协议问题你了解吗 React遵循的协议是“BSD许可证 + 专利开源协议”，这个协议比较奇葩，如果你的产品跟facebook没有竞争关系，你可以自由的使用react，但是如果有竞争关系，你的react的使用许可将会被取消。 44. 你在过去的项目里遇到的最大问题是什么？你最大的成就？ 寻找更高级职位的人将解释他如何优化应用程序性能，而带领团队的人会解释他如何通过结对编程提高速度。 45. 传入 setState 函数的第二个参数的作用是什么？ 该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成： this.setState( { username: 'tylermcginnis33' }, () => console.log('setState has finished and the component has re-rendered.') ) 46. 封装ajax var jsGetAjaxPromise = function(param){ return new Promise(function(resolve, reject){ var xhr = new XMLHttpRequest(); xhr.open(‘get’, param.url, true); xhr.onload = resolve; xhr.onerror = reject; xhr.send(); }) } 47. Bind实现 // 将bind方法的参数提取出来拼接返回的闭包函数中 Function.prototype.bind = function(context) { var that = this; var args = Array.prototype.slice.call(arguments, 1); return function() { // 预设参数一定是args在前拼接 return that.apply(context, args.concat(Array.prototype.slice.call(arguments))); } }; 48. 快速排序 function quickSort(arr) { //如果数组 49. 正则匹配结巴程序 var str = '我...我是是.......一个......个.....帅帅帅帅........哥!'; var reg = /\\./gi; var str = str.replace(reg, ''); document.write(str + ''); //我是是个个帅帅帅帅哥! reg = /(.)\\1+/gi; str = str.replace(reg, '$1'); document.write(str); //我是个帅哥！ 50. ['1', '2', '3'].map(parseInt) 解析 第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是真正的答案是[1, NaN, NaN]。 首先让我们回顾一下，map函数的第一个参数callback：var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg]) 这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。 而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。 parseInt(string, radix)接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。 了解这两个函数后，我们可以模拟一下运行情况 parseInt('1', 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1 parseInt('2', 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN parseInt('3', 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN map函数返回的是一个数组，所以最后结果为[1, NaN, NaN] 早在 2013年, 加里·伯恩哈德就在微博上发布了以下代码段: ['10','10','10','10','10'].map(parseInt); // [10, NaN, 2, 3, 4] parseInt parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。 const intValue = parseInt(string[, radix]); string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。 radix 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。 返回值 返回一个整数或NaN parseInt(100); // 100 parseInt(100, 10); // 100 parseInt(100, 2); // 4 -> converts 100 in base 2 to base 10 注意： 在radix为 undefined，或者radix为 0 或者没有指定的情况下，JavaScript 作如下处理： 如果字符串 string 以\"0x\"或者\"0X\"开头, 则基数是16 (16进制). 如果字符串 string 以\"0\"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。 map map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 var new_array = arr.map(function callback(currentValue[,index[, array]]) { // Return element for new_array }[, thisArg]) 可以看到callback回调函数需要三个参数, 我们通常只使用第一个参数 (其他两个参数是可选的)。 currentValue 是callback 数组中正在处理的当前元素。 index可选, 是callback 数组中正在处理的当前元素的索引。 array可选, 是callback map 方法被调用的数组。 另外还有thisArg可选, 执行 callback 函数时使用的this 值。 const arr = [1, 2, 3]; arr.map((num) => num + 1); // [2, 3, 4] 回到真实的事例上 回到我们真实的事例上 ['1', '2', '3'].map(parseInt) 对于每个迭代map, parseInt()传递两个参数: 字符串和基数。 所以实际执行的的代码是： ['1', '2', '3'].map((item, index) => { return parseInt(item, index) }) // 即返回的值分别为： parseInt('1', 0) // 1 parseInt('2', 1) // NaN parseInt('3', 2) // NaN, 3 不是二进制 所以： ['1', '2', '3'].map(parseInt) // 1, NaN, NaN 由此，加里·伯恩哈德例子也就很好解释了，这里不再赘述 ['10','10','10','10','10'].map(parseInt); // [10, NaN, 2, 3, 4] 51. 防抖和节流 防抖 debounce 典型例子：限制 鼠标连击 触发。 一个比较好的解释是： 当一次事件发生后，事件处理器要等一定阈值的时间，如果这段时间过去后 再也没有 事件发生，就处理最后一次发生的事件。假设还差 0.01 秒就到达指定时间，这时又来了一个事件，那么之前的等待作废，需要重新再等待指定时间。 思路: 每次触发事件时都取消之前的延时调用方法 function debounce(fn, wait = 50, immediate) { let timer; return function() { if (immediate) { fn.apply(this, arguments) } if (timer) clearTimeout(timer) timer = setTimeout(() => { fn.apply(this, arguments) }, wait) } } function sayHi() { console.log('防抖成功'); } var inp = document.getElementById('inp'); inp.addEventListener('input', debounce(sayHi)); // 防抖 节流 throttle 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率 可以理解为事件在一个管道中传输，加上这个节流阀以后，事件的流速就会减慢。实际上这个函数的作用就是如此，它可以将一个函数的调用频率限制在一定阈值内，例如 1s，那么 1s 内这个函数一定不会被调用两次 简单的节流函数: function throttle(fn, wait) { let prev = new Date(); return function() { const args = arguments; const now = new Date(); if (now - prev > wait) { fn.apply(this, args); prev = new Date(); } } } 思路： 每次触发事件时都判断当前是否有等待执行的延时函数 function throttle(fn) { let canRun = true; // 通过闭包保存一个标记 return function() { if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return canRun = false; // 立即设置为false setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中 fn.apply(this, arguments); // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。 // 当定时器没有执行的时候标记永远是false，在开头被return掉 canRun = true; }, 500); }; } function sayHi(e) { console.log(e.target.innerWidth, e.target.innerHeight); } window.addEventListener('resize', throttle(sayHi)); 52. Set、Map、WeakSet 和 WeakMap 的区别？ Set 成员唯一、无序且不重复； [value, value]，键值与键名是一致的（或者说只有键值，没有键名）； 可以遍历，方法有：add、delete、has。 WeakSet 成员都是对象； 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏； 不能遍历，方法有 add、delete、has。 Map 本质上是键值对的集合，类似集合； 可以遍历，方法很多，可以跟各种数据格式转换。 WeakMap 只接受对象最为键名（null 除外），不接受其他类型的值作为键名； 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的； 不能遍历，方法有 get、set、has、delete。 53. ES5/ES6 的继承除了写法以外还有什么区别 class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。 const bar = new Bar(); // it's ok function Bar() { this.bar = 42; } const foo = new Foo(); // ReferenceError: Foo is not defined class Foo { constructor() { this.foo = 42; } } class 声明内部会启用严格模式。 // 引用一个未声明的变量 function Bar() { baz = 42; // it's ok } const bar = new Bar(); class Foo { constructor() { fol = 42; // ReferenceError: fol is not defined } } const foo = new Foo(); class 的所有方法（包括静态方法和实例方法）都是不可枚举的。 // 引用一个未声明的变量 function Bar() { this.bar = 42; } Bar.answer = function() { return 42; }; Bar.prototype.print = function() { console.log(this.bar); }; const barKeys = Object.keys(Bar); // ['answer'] const barProtoKeys = Object.keys(Bar.prototype); // ['print'] class Foo { constructor() { this.foo = 42; } static answer() { return 42; } print() { console.log(this.foo); } } const fooKeys = Object.keys(Foo); // [] const fooProtoKeys = Object.keys(Foo.prototype); // [] class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。 function Bar() { this.bar = 42; } Bar.prototype.print = function() { console.log(this.bar); }; const bar = new Bar(); const barPrint = new bar.print(); // it's ok class Foo { constructor() { this.foo = 42; } print() { console.log(this.foo); } } const foo = new Foo(); const fooPrint = new foo.print(); // TypeError: foo.print is not a constructor 必须使用 new 调用 class。 function Bar() { this.bar = 42; } const bar = Bar(); // it's ok class Foo { constructor() { this.foo = 42; } } const foo = Foo(); // TypeError: Class constructor Foo cannot be invoked without 'new' class 内部无法重写类名。 function Bar() { Bar = 'Baz'; // it's ok this.bar = 42; } const bar = new Bar(); // Bar: 'Baz' // bar: Bar {bar: 42} class Foo { constructor() { this.foo = 42; Foo = 'Fol'; // TypeError: Assignment to constant variable } } const foo = new Foo(); Foo = 'Fol'; // it's ok 54. 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组 Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{ return a-b}) 55. JS 异步解决方案的发展历程以及优缺点。 1. 回调函数（callback） setTimeout(() => { // callback 函数体 }, 1000) 缺点：回调地狱，不能用 try catch 捕获错误，不能 return 回调地狱的根本问题在于： 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符； 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）； 嵌套函数过多的多话，很难处理错误。 ajax('XXX1', () => { // callback 函数体 ajax('XXX2', () => { // callback 函数体 ajax('XXX3', () => { // callback 函数体 }) }) }) 优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行）。 2. Promise Promise 就是为了解决 callback 的问题而产生的。 Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装。 优点：解决了回调地狱的问题。 ajax('XXX1') .then(res => { // 操作逻辑 return ajax('XXX2') }).then(res => { // 操作逻辑 return ajax('XXX3') }).then(res => { // 操作逻辑 }) 缺点：无法取消 Promise ，错误需要通过回调函数来捕获。 3. Generator 特点：可以控制函数的执行，可以配合 co 函数库使用。 function *fetch() { yield ajax('XXX1', () => {}) yield ajax('XXX2', () => {}) yield ajax('XXX3', () => {}) } let it = fetch() let result1 = it.next() let result2 = it.next() let result3 = it.next() 4. Async/await async、await 是异步的终极解决方案。 优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题； 缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。 async function test() { // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式 // 如果有依赖性的话，其实就是解决回调地狱的例子了 await fetch('XXX1') await fetch('XXX2') await fetch('XXX3') } 下面来看一个使用 await 的例子： let a = 0 let b = async () => { a = a + await 10 console.log('2', a) // -> '2' 10 } b() a++ console.log('1', a) // -> '1' 1 // 1 1 // 2 10 对于以上代码你可能会有疑惑，让我来解释下原因： 首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来； 因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码； 同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10 上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。 56. 10 个 Ajax 同时发起请求，全部返回展示结果，并且至多允许三次失败，说出设计思路 这个问题相信很多人会第一时间想到 Promise.all ，但是这个函数有一个局限在于如果失败一次就返回了，直接这样实现会有点问题，需要变通下。以下是两种实现思路 // 以下是不完整代码，着重于思路 非 Promise 写法 let successCount = 0 let errorCount = 0 let datas = [] ajax(url, (res) => { if (success) { success++ if (success + errorCount === 10) { console.log(datas) } else { datas.push(res.data) } } else { errorCount++ if (errorCount > 3) { // 失败次数大于3次就应该报错了 throw Error('失败三次') } } }) // Promise 写法 let errorCount = 0 let p = new Promise((resolve, reject) => { if (success) { resolve(res.data) } else { errorCount++ if (errorCount > 3) { // 失败次数大于3次就应该报错了 reject(error) } else { resolve(error) } } }) Promise.all([p]).then(v => { console.log(v); }); 57. 基于 Localstorage 设计一个 1M 的缓存系统，需要实现缓存淘汰机制 设计思路如下： 存储的每个对象需要添加两个属性：分别是过期时间和存储时间。 利用一个属性保存系统中目前所占空间大小，每次存储都增加该属性。当该属性值大于 1M 时，需要按照时间排序系统中的数据，删除一定量的数据保证能够存储下目前需要存储的数据。 每次取数据时，需要判断该缓存数据是否过期，如果过期就删除。 以下是代码实现，实现了思路，但是可能会存在 Bug，但是这种设计题一般是给出设计思路和部分代码，不会需要写出一个无问题的代码 class Store { constructor() { let store = localStorage.getItem('cache') if (!store) { store = { maxSize: 1024 * 1024, size: 0 } this.store = store } else { this.store = JSON.parse(store) } } set(key, value, expire) { this.store[key] = { date: Date.now(), expire, value } let size = this.sizeOf(JSON.stringify(this.store[key])) if (this.store.maxSize { let item1 = this.store[a], item2 = this.store[b]; return item2.date - item1.date; }); while (size + this.store.size > this.store.maxSize) { let index = keys[keys.length - 1] this.store.size -= this.sizeOf(JSON.stringify(this.store[index])) delete this.store[index] } } this.store.size += size localStorage.setItem('cache', JSON.stringify(this.store)) } get(key) { let d = this.store[key] if (!d) { console.log('找不到该属性'); return } if (d.expire > Date.now) { console.log('过期删除'); delete this.store[key] localStorage.setItem('cache', JSON.stringify(this.store)) } else { return d.value } } sizeOf(str, charset) { var total = 0, charCode, i, len; charset = charset ? charset.toLowerCase() : ''; if (charset === 'utf-16' || charset === 'utf16') { for (i = 0, len = str.length; i "},"面试/综合2.html":{"url":"面试/综合2.html","title":"综合2","keywords":"","body":"js面试题（二） 1. 如何创建一个ajax请求 2. javascript 连等赋值问题 3. 使用正则实现trim函数删除字符串前后空格 4. 找出数组中的最大值 4.1 reduce 4.2 apply 4.3 ES6 5. 打乱数组的方法 6. 数组扁平化 7. 简单的字符串模板 8. js实现循环 setTimeout输出 0, 1, 2, 3, 4 8.1 解决办法 8.2 如果要让0-4一秒一秒地输出来呢？ 9. 谈谈对this的理解 10. eval是做什么的？ 11. ['1', '2', '3'].map(parseInt)答案是多少？ 12. 什么是闭包(closure)，为什么要用它？ 13. JS延迟加载的方式有哪些？ 14. 页面编码和被请求的资源编码不一致如何处理？ 15. 渐进增强与优雅降级 16. 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？ 17. 事件的代理/委托 18. 说说循环数组和对象，你用过哪些方法？ 19. 哪些操作会引起浏览器重绘(repaint)和重排(reflow), 延伸：重绘和重排谁更消耗性能？ 20. 如何进行网站性能优化 21. 如何提高webpack的编译速度？ 22. 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例) 23. 冒泡排序 24. 快速排序 25. 查找字符串中出现次数最多的字符和次数 26. 计算数组中每个元素出现的次数 27. for(var i=0,j=0;i 1. 如何创建一个ajax请求 创建Ajax的过程： 创建XMLHttpRequest对象（异步调用对象） var xhr = new XMLHttpRequest(); 创建新的Http请求（方法、URL、是否异步） xhr.open('get', 'example.php', false); 设置响应HTTP请求状态变化的函数 onreadystatechange事件中readyState属性等于4。响应的HTTP状态为 200(OK)或者304(Not Modified)。 发送http请求 xhr.send(data); 获取异步调用返回的数据 详细过程： const xhr = new XMLHttpRequest(); xhr.open(method, url, async); // send 方法发送请求，并接受一个可选参数 // 当请求方式为 post 时，可以将请求体的参数传入 // 当请求方式为 get 时，可以不传或传入 null // 不管是 get 还是 post，参数都需要通过 encodeURIComponent 编码后拼接 xhr.send(data); xhr.onreadystatechange = () => { if (xhr.readyState === 4) { // HTTP 状态在 200 -300 之间表示请求成功 // HTTP 状态为 304 表示内容未发生改变，可直接从缓存中获取 if (xhr.status >= 200 && xhr.status console.log('请求超时') 2. javascript 连等赋值问题 var a = { n: 1 }; var b = a; a.x = a = { n: 2 } console.log(a.x); // undefined console.log(b.x); // {n:2} 解析： 解析器在接收到 a = a.x = { n: 2 } 这个语句后，会这样子做： 在找到 a 和 a.x 的指针。如果已有指针,那么不改变它。如果没有指针, 即那个变量还没被申明，那么就创建它，指向 null。 a 是有指针的，指向 {n: 1}; a.x 是没有指针的，所以创建它，指向 null。 然后把上面找到的指针，都指向最右赋值的那个指，即是 {n: 2}。 3. 使用正则实现trim函数删除字符串前后空格 function trim(str) { return str.replace(/(^\\s*)|(\\s*$)/g, ''); } if (!String.prototype.trim) { String.prototype.trim = function () { return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''); }; } 4. 找出数组中的最大值 4.1 reduce var arr = [6, 4, 1, 8, 2, 11, 3]; function max (prev, next) { return Math.max(prev, next) } console.log(arr.reduce(max)); 4.2 apply var arr = [6, 4, 1, 8, 2, 11, 3]; console.log(Math.max.apply(null, arr)); // 11 4.3 ES6 var arr = [6, 4, 1, 8, 2, 11, 3]; function max (arr) { return Math.max(...arr); } console.log(max(arr)); 5. 打乱数组的方法 var arr = []; for(var i = 0; i 6. 数组扁平化 var arr = [1, [2, [3, 4]]] function flatten(arr) { while(arr.some(item => Array.isArray(item))) { arr = [].concat(...arr); } return arr; } console.log(flatten(arr)); // [1, 2, 3, 4] 7. 简单的字符串模板 var TemplateEngine = function(tpl, data) { var re = /]+)?%>/g, match; while(match = re.exec(tpl)) { console.log('match0: ', match[0]); console.log('match1: ', match[1]); tpl = tpl.replace(match[0], data[match[1]]) } return tpl; } var template = 'Hello, my name is . I\\'m years old.'; console.log(TemplateEngine(template, { name: 'ly2011', age: 16 })) 8. js实现循环 setTimeout输出 0, 1, 2, 3, 4 for(var i = 0; i 结果为： 5,5,5,5,5 8.1 解决办法 第一种：闭包 for(var i = 0; i 第二种：值类型传递 ```js var output = function(i) { setTimeout(function() { console.log(i) }, 1000) } for(var i = 0; i 3. 第三种：es6 let ```js for(let i = 0; i 8.2 如果要让0-4一秒一秒地输出来呢？ 第一种： for(var i = 0; i 第二种： const tasks= [] const output = (i) => new Promise((resolve) => { setTimeout(() => { console.log(i) resolve() // 这里一定要 resolve, 否则代码不会按预期 work }, 1000 * i) }) // 生成全部的异步操作 for(var i = 0; i { setTimeout(() => { console.log(i) }, 1000) }) 第三种 ```js // 模拟其他语言中的 sleep，实际上可以是任何异步操作 const sleep = (timeountMS) => new Promise((resolve) => { setTimeout(resolve, timeountMS); }); (async () => { // 声明即执行的 async 函数表达式 for (var i = 0; i await sleep(1000); console.log(new Date, i); })(); ## 9. 谈谈对this的理解 1. this总是指向函数的直接调用者（而非间接调用者） 2. 如果有new关键字，this指向new出来的那个对象 3. 在事件中，this指向目标元素，特殊的是IE的attachEvent中的this总是指向全局对象window。 ## 10. eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） ## 11. ['1', '2', '3'].map(parseInt)答案是多少？ [1, NaN, NaN] 解析： 1. Array.prototype.map() array.map(callback[, thisArg]) callback函数的执行规则 参数：自动传入三个参数 currentValue(当前被传递的元素) index(当前被传递的元素的索引) array(调用map方法的数组) 2. parseInt parseInt方法接收两个参数 第三个参数['1', '2', '3']将被忽略。parseInt方法将会通过以下方式被调用 parseInt('1', 0) parseInt('2', 1) parseInt('3', 2) - parseInt的第二个参数radix为0时，ECMAScript5将string作为十进制数字的字符串解析。 - parseInt的第二个参数radix为1时，解析结果为NaN; - parseInt的第二个参数radix在2-36之间时，如果string参数的第一个字符（除空白以外），不属于radix指定进制下的字符，解析结果为NaN。 - parseInt('3', 2)执行时，由于 '3' 不属于二进制字符，解析结果为 NaN。 ## 12. 什么是闭包(closure)，为什么要用它？ 闭包指的是一个函数可以访问另一个函数作用域中变量。常见的构造方法，是在一个函数内部定义另外一个函数。内部函数可以引用外层的变量；外层变量不会被垃圾回收机制回收。 注意：闭包的原理是作用域链，所以闭包访问的上级作用域中的变量是个对象，其值为其运算结束后的左后一个值。 - 优点：避免全局变量污染。 - 缺点：容易造成内存泄漏。 例子： ```js function makeFunc() { var name = 'Mozilla' function displayName() { console.log(name) } return displayName } var myFunc = makeFunc() myFunc() // 输出Mozilla myFunc变成一个闭包。闭包是一种特殊的对象。它由两部分构成： 函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，myFunc是一个闭包，由displayName函数和闭包创建时存在的 'Mozilla' 字符串组成。 13. JS延迟加载的方式有哪些？ defer async 动态创建DOM方式 按需异步载入JS defer和async、动态创建DOM方式、按需异步载入JS defer: 延迟脚本。立即下载，但延迟执行（延迟到整个页面都解析完毕后再运行），按照脚本出现的先后顺序执行。 async: 异步脚本。下载完立即执行，但不保证按照脚本出现的先后顺序执行。 14. 页面编码和被请求的资源编码不一致如何处理？ 若请求的资源编码，如外引js文件编码与页面编码不同。可根据外引资源编码方式定义为 charset=\"utf-8\"或\"gbk\"。 比如：http://www.yyy.com/a.html 中嵌入了一个http://www.xxx.com/test.js a.html 的编码是gbk或gb2312的。 而引入的js编码为utf-8的 ，那就需要在引入的时候 15. 渐进增强与优雅降级 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进，达到更好的用户体验。 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 16. 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？ 该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数） 如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获 如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡 17. 事件的代理/委托 事件委托是指将事件绑定目标元素到父元素上，利用冒泡机制触发该事件 优点： 可以减少事件注册，节省大量内存占用 可以将事件应用于动态添加的子元素上 缺点： 使用不当会造成事件在不应该触发时触发 18. 说说循环数组和对象，你用过哪些方法？ for forEach map filter some every 对象循环: for ... in 19. 哪些操作会引起浏览器重绘(repaint)和重排(reflow), 延伸：重绘和重排谁更消耗性能？ postion:absolute; left:100px;会不会引起？ translateX:100px;会不会引起？ getBoundingClientRect会不会引起？ getClientWidth、getClientHeight会不会引起？ 原理： 触发重排: 页面布局和元素几何属性的改变就会导致重排 下列情况会发生重排: 页面初始渲染 添加/删除可见DOM元素 改变元素位置 改变元素尺寸（宽、高、内外边距、边框等） 改变元素内容（文本或图片等） 改变窗口尺寸 以下属性或方法会刷新渲染队列: offsetTop、offsetLeft、offsetWidth、offsetHeight clientTop、clientLeft、clientWidth、clientHeight scrollTop、scrollLeft、scrollWidth、scrollHeight getComputedStyle()（IE中currentStyle） 减少重绘和重排的原理很简单: 元素脱离文档 改变样式 元素回归文档 20. 如何进行网站性能优化 content 方面 减少 HTTP 请求：合并文件、CSS 精灵、inline Image 减少 DNS 查询： DNS 缓存、将资源分布到恰当数量的主机名 减少 DOM 元素数量 server 方面 使用 CDN 配置 ETag 对组件使用 Gzip 压缩 cookie 方面 减少 Cookie 大小 css 方面 将样式表放到页面顶部 不使用 CSS 表达式 使用 不使用 @import javascript 方面 将脚本放到页面底部 将 javascript 和 css 从外部引入 压缩 javascript和css 删除不需要的脚本 减少 DOM 访问 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化 css 精灵 不要在 HTML 中拉伸图片 21. 如何提高webpack的编译速度？ 版本升级 利用多核(happypack) 利用缓存(dll) 开发环境去掉组件懒加载、不压缩图片、不分离css文件 22. 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例) 主要过程是：浏览器解析 -> 查询缓存 -> dns查询 -> 建立链接 -> 服务器处理请求 -> 服务器发送响应 -> 客户端收到页面 -> 解析HTML -> 构建渲染树 -> 开始显示内容(白屏时间) -> 首屏内容加载完成(首屏时间) -> 用户可交户(DOMContentLoaded) -> 加载完成(load) 在浏览器地址栏输入URL 浏览器查看 缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制 Expires 和 Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择 关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构建DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析如下： 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面） 23. 冒泡排序 解析： 比较相邻的两个元素，如果前一个比后一个大，则交换位置。 第一轮的时候最后一个元素应该是最大的一个。 按照步骤一的方法进行相邻两个元素的比较，这个时候由于最后一个元素已经是最大的了，所以最后一个元素不用比较。 function sort(elements) { for(var i = 0; i elements[j + 1]) { var swap = elements[j]; elements[j] = elements[j + 1]; elements[j + 1] = swap; } } } } var elements = [3, 1, 5, 7, 2, 4, 9, 6, 10, 8]; console.log('before: ', elements) sort(elements) console.log('after: ', elements) 24. 快速排序 解析：快速排序是对冒泡排序的一种改进，第一趟排序时将数据分成两部分，一部分比另一部分的所有数据都要小。然后递归调用，在两边都实行快速排序。 function quickSort(elements) { if (elements.length 25. 查找字符串中出现次数最多的字符和次数 例如：sdddrtkjsfkasjdddj中出现最多的字符是d,出现了6次 var str = \"sdddrtkjsfkkkasjdddj\"; var max = 0; var char; function Search(str) { var json = {}; for (var i = 0; i max) { max = json[str[i]].length; char = str[i]; } } console.log('json: ', json) console.log(\"出现次数最多的字符是\" + char + \",出现了\" + max + \"次\") } Search(str); 26. 计算数组中每个元素出现的次数 // 计算数组中每个元素出现的次数 var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'] var countedNames = names.reduce(function(allNames, name) { if(name in allNames) { allNames[name]++ } else { allNames[name] = 1 } return allNames; }, {}) console.log(countedNames) 27. for(var i=0,j=0;i var sum = 0; for(var i=0,j=0;i 解析：答案是: 10, 首先每次for循环的i和j值是相等的：第一次：i=0, j =0; 符合条件, sum = i + j = 0;第二次：i=1,j=1;符合条件, sum = i + j = 2;第三次：i=2,j=2;符合条件, sum = i + j = 4;第四次：i=3,j=3;符合条件，sum = i + j = 6;第五次：i=4,j=4;符合条件, sum = i + j = 8;第六次：i=5,j=5;符合条件,sum = i + j =10;第七次：i=6,j=6;不符合条件（(这里需要注意，循环继续的判断依据以分号前的最后一项为准，即判断j 注意：这里值得一提的是 如果把条件i结果将完全不同，此时循环执行到j参考地址 说下你所知道的排序方法？ 冒泡排序、快排、二分法、广度遍历、深度遍历... "},"面试/综合3.html":{"url":"面试/综合3.html","title":"综合3","keywords":"","body":"js面试题（三） 1. JavaScript中的数据类型都有哪些? 2. 如何判断一个变量是否为数组？ 3. undefined 和 null 的相同与不同？ 4. 隐式类型转换的时候，JavaScript底层都做了哪些处理？ 5. 有哪些值转化为布尔值后为false？ 6. 讲讲ES6中的Symbol？ 7. 如何把字符串转换为数组？ 8. 如何把类数组变量转换为数组，如函数内部的 arguments 对象，selector 返回的 DOM 列表。 9. 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组 10. 简单讲解一下http2的多路复用 11. 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？ 1. npm 模块安装机制： 2. npm 实现原理 12. 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣Object.prototype.toString.call() 、 instanceof 以及 Array.isArray() 1. Object.prototype.toString.call() 2. instanceof 3. Array.isArray() 13. 如何判断一个变量是否为数组？ 14. 数组的原生方法有哪些？ 会改变自身的方法： 不会改变自身的方法： 遍历方法： 15. 如何将一个类数组变量转为数组？ 16. 说一说ES6中对于数组有哪些扩展？ 17. 数组去重，你能说出多少种方法？ 实现一 补充 3.1 普通版 复杂度 O(n^2) 3.2 进阶版 3.3 时间复杂度为O(n) 3.4 终极版 18. 你知道Array.prototype的类型是什么吗？ [19. 如何\"打平\"一个嵌套数组， 如[1, [2, [3]], 4, [5]] => 1, 2, 3, 4, 5]？你能说出多少种方法？ 1. 利用 Array.prototype.toString()方法（元素为数字） 2. 利用Array.prototype.join()方法（元素为数字） 3. 利用JSON.parse()方法（元素为数字） 20. 如何克隆一个数组？你能说出多少种？ 21. 说一说Array.prototype.sort()方法的原理？（追问：不传递参数会如何？） 22. 找出Array中的最大元素，你能说出几种方法？ 23. mouseover 和 mouseenter 两个事件有何区别？ 24. 移动端的click时间行为与PC端有什么不同？如何屏蔽这个不同？ 25. Event对象中, target和currentTarget的区别？ 26. 说一说什么是事件冒泡，如何阻止事件冒泡？如何阻止默认事件？ 27. 是否了解移动端的点击穿透，原理及解决方法？ 28. 是否了解事件委托？ 29. 什么是事件循环？ 30. css3中有哪些属性可以直接影响JS中的事件？（可以讲一下pointer-events和touch-action属性吗？） 31. 怎么去设计一个组件封装 32. js 异步加载的方式 33. css 动画和 js 动画的差异 34. XSS 与 CSRF 两种跨站攻击 35. 事件委托，目的，功能，写法 36. 线程，进程 37. 负载均衡 38. 什么是CDN缓存 39. javascript 中常见的内存泄露陷阱 40. babel把ES6转成ES5或者ES3之类的原理是什么 41. Promise 模拟终止 42. promise 放在try catch里面有什么结果 43. get与post 通讯的区别 44. 有没有去研究webpack的一些原理和机制，怎么实现的 45. ES6模块与CommonJS模块的差异 46. 模块加载AMD，CMD，CommonJS Modules/2.0 规范 47. Node 事件循环，js 事件循环差异 1. JavaScript中的数据类型都有哪些? 数据类型有两种：原始数据类型（又称基础数据类型、可变数据类型）和复杂数据类型（又称对象、不可变数据类型）。原始数据类型包括：undefined,null,数字,字符串,布尔类型,Symbol(ES6 新加入的类型)复杂数据类型包括：对象其中对象包括：内部对象（Array、String等），宿主对象(window)和自定义对象。 2. 如何判断一个变量是否为数组？ Object.prototype.toString.call() Array.isArray() 3. undefined 和 null 的相同与不同？ 相同点： 这两个数据类型都只有一个值 都没有方法 都表示\"无\" 转化为布尔值时，都是false 不同点： null 是一个关键字，而 undefined 不是一个关键字。所以 var undefined = 1; 这是可以的，虽然这里 undefined 的值是不会改变的。 var null = 1; // 这样是报错的。 null的实质是一个空的对象，而undefined是window的一个属性。 进行数字类型转换时，null 返回 0, undefined 返回 NaN。 4. 隐式类型转换的时候，JavaScript底层都做了哪些处理？ 对象转成原始数据类型时，先调用对象的 valueOf 方法，如果返回结果不是原始数据类型的值，再调用 toString 方法。 原始类型转原始类型时，直接调用对应的构造函数进行转换。 5. 有哪些值转化为布尔值后为false？ 包括下面这六种：0, -0, undefined, null, 空字符串, NaN 6. 讲讲ES6中的Symbol？ Symbol 是 ES6 新加的一个原始类型，它的每个值都是唯一的，即使是用两个完全一样的变量构建出来的Symbol也不相等。 原始类型传入 Symbol 方法时，会进行转换成 字符串 再转成 Symbol 类型值; 如果是对象的话，会先调用对象的 toString 方法再转成 Symbol 类型的值。 Symbol最大的用处是用来消除 \"魔术字符串\" 的。 7. 如何把字符串转换为数组？ split() Array.from() 8. 如何把类数组变量转换为数组，如函数内部的 arguments 对象，selector 返回的 DOM 列表。 Array.prototype.slice.call() Array.from() Array.from()的详解： Set类型的转换 let s = new Set(['foo', window]) Array.from(s); // [\"foo\", window] Map类型的转换 let m = new Map([[1, 2], [2, 4], [4, 8]]) Array.from(m) // [[1, 2], [2, 4], [4, 8]] 类数组的值 function f() { console.log(arguments) return Array.from(arguments) } f(1, 2, 3) Array.from() 的第二个参数 mapFn 也很有用处，可以对传入的类数组值进行定定制化修改 ```js Array.from([1, 2, 3], x => x + x); // [2, 4, 6] Array.from({length: 5}, (v, i) => i) // [0, 1, 2, 3, 4, 5] ## 9. 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组 ```js var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; Array.from(new Set(arr.toString().split(\",\").sort((a,b)=>{ return a-b}))) // [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 12, 13, 14] 10. 简单讲解一下http2的多路复用 HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。 多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。 HTTP2中 同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。 单个连接上可以并行交错的请求和响应，之间互不干扰 在 HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题： 第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输） 第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。 HTTP/2的多路复用就是为了解决上述的两个性能问题。在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。 简单来说， 就是在同一个TCP连接，同一时刻可以传输多个HTTP请求之前是同一个连接只能用一次， 如果开启了keep-alive，虽然可以用多次，但是同一时刻只能有一个HTTP请求 11. 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？ 1. npm 模块安装机制： 发出npm install命令 查询node_modules目录之中是否已经存在指定模块 若存在，不再重新安装 若不存在 npm 向 registry 查询模块压缩包的网址 下载压缩包，存放在根目录下的.npm目录里 解压压缩包到当前项目的node_modules目录 2. npm 实现原理 输入 npm install 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）： 执行工程自身 preinstall当前 npm 工程如果定义了 preinstall 钩子此时会被执行。 确定首层依赖模块 首先需要做的是确定工程中的首层依赖，也就是 dependencies 和 devDependencies 属性中直接指定的模块（假设此时没有添加 npm install 参数）。工程本身是整棵依赖树的根节点，每个首层依赖模块都是根节点下面的一棵子树，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。 获取模块 获取模块是一个递归的过程，分为以下几步： 获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 packaeg.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。 获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。 查找该模块依赖，如果有依赖则回到第1步，如果没有则停止。 模块扁平化（dedupe） 上一步获取到的是一棵完整的依赖树，其中可能包含大量重复模块。比如 A 模块依赖于 loadsh，B 模块同样依赖于 lodash。在 npm3 以前会严格按照依赖树的结构进行安装，因此会造成模块冗余。 从 npm3 开始默认加入了一个 dedupe 的过程。它会遍历所有节点，逐个将模块放在根节点下面，也就是 node-modules 的第一层。当发现有重复模块时，则将其丢弃。 这里需要对重复模块进行一个定义，它指的是模块名相同且 semver 兼容。每个 semver 都对应一段版本允许范围，如果两个模块的版本允许范围存在交集，那么就可以得到一个兼容版本，而不必版本号完全一致，这可以使更多冗余模块在 dedupe 过程中被去掉。 比如 node-modules 下 foo 模块依赖 lodash@^1.0.0，bar 模块依赖 lodash@^1.1.0，则 ^1.1.0 为兼容版本。 而当 foo 依赖 lodash@^2.0.0，bar 依赖 lodash@^1.1.0，则依据 semver 的规则，二者不存在兼容版本。会将一个版本放在 node_modules 中，另一个仍保留在依赖树里。 举个例子，假设一个依赖树原本是这样： node_modules -- foo ---- lodash@version1 -- bar ---- lodash@version2 假设 version1 和 version2 是兼容版本，则经过 dedupe 会成为下面的形式： node_modules -- foo -- bar -- lodash（保留的版本为兼容版本） 假设 version1 和 version2 为非兼容版本，则后面的版本保留在依赖树中： node_modules -- foo -- lodash@version1 -- bar ---- lodash@version2 安装模块 这一步将会更新工程中的 node_modules，并执行模块中的生命周期函数（按照 preinstall、install、postinstall 的顺序）。 执行工程自身生命周期 当前 npm 工程如果定义了钩子此时会被执行（按照 install、postinstall、prepublish、prepare 的顺序）。 最后一步是生成或更新版本描述文件，npm install 过程完成。 12. 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣Object.prototype.toString.call() 、 instanceof 以及 Array.isArray() 1. Object.prototype.toString.call() 每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [Object type]，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 toString 方法时，会直接返回都是内容的字符串，所以我们需要使用call或者apply方法来改变toString方法的执行上下文。 const an = ['Hello','An']; an.toString(); // \"Hello,An\" Object.prototype.toString.call(an); // \"[object Array]\" 这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。 Object.prototype.toString.call('An') // \"[object String]\" Object.prototype.toString.call(1) // \"[object Number]\" Object.prototype.toString.call(Symbol(1)) // \"[object Symbol]\" Object.prototype.toString.call(null) // \"[object Null]\" Object.prototype.toString.call(undefined) // \"[object Undefined]\" Object.prototype.toString.call(function(){}) // \"[object Function]\" Object.prototype.toString.call({name: 'An'}) // \"[object Object]\" Object.prototype.toString.call() 常用于判断浏览器内置对象时。 2. instanceof instanceof 的内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 使用 instanceof判断一个对象是否为数组，instanceof 会判断这个对象的原型链上是否会找到对应的 Array 的原型，找到返回 true，否则返回 false。 [] instanceof Array; // true 但 instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。 [] instanceof Object; // true 3. Array.isArray() 功能：用来判断对象是否为数组 instanceof 与 isArray 当检测Array实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes var iframe = document.createElement('iframe'); document.body.appendChild(iframe); xArray = window.frames[window.frames.length-1].Array; var arr = new xArray(1,2,3); // [1,2,3] // Correctly checking for Array Array.isArray(arr); // true Object.prototype.toString.call(arr); // true // Considered harmful, because doesn't work though iframes arr instanceof Array; // false Array.isArray() 与 Object.prototype.toString.call() Array.isArray()是ES5新增的方法，当不存在 Array.isArray() ，可以用 Object.prototype.toString.call() 实现。 if (!Array.isArray) { Array.isArray = function(arg) { return Object.prototype.toString.call(arg) === '[object Array]'; }; } 13. 如何判断一个变量是否为数组？ 不可靠的检测数组方式： 为什么不用 typeof ? var list = [1, 2, 3] typeof list // 'object' Array继承于Object, 所以 typeof 会直接返回 object, 所以不可以用 typeof 来检测 为什么不用 instanceof ? var list = [1, 2, 3] list instanceof Array // true instanceof 表面上看确实是返回了true,但其实并不可靠。原因是Array实质是一个引用，用instanceof方法（包括下面的constructor）都是利用引用地址进行比较的方法来确定的，但是在iframe嵌套的情况下，每一个Array的引用地址都是不同的，比较起来结果也是不确定的，所以这种方法有其局限性。 为什么不同 constructor 方法？ var list = [1, 2, 3] list.constructor === Array // true 原因同上 可靠的检测数组方式: 利用Object的toString方法 var list = [1, 2, 3] Object.prototype.toString.call(list) // [object Array] 利用ES6的Array.isArray()方法 var list = [1, 2, 3] Array.isArray(list) // true 14. 数组的原生方法有哪些？ 会改变自身的方法： Array.prototype.copyWithin()：在数组内部，将一段元素序列拷贝到另外一段元素序列上，覆盖原有的值。 Array.prototype.fill()：将数组中指定区间的所有元素的值，都替换成某个固定的值。 Array.prototype.pop()：删除数组最后一个元素，并返回这个元素。 Array.prototype.push()：在数组的尾部增加一个或多个元素，并返回数组的新长度。 Array.prototype.reverse()：颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，最后一个变为第一个。 Array.prototype.shift()：删除数组的第一个元素，返回这个元素。 Array.prototype.sort()：对数组元素进行排序，并返回当前数组。 Array.prototype.splice()：在任意的位置给数组添加或删除任意个元素。 Array.prototype.unshift()：在数组的开头增加一个或多个元素，并返回数组的新长度。 不会改变自身的方法： Array.prototype.concat()：返回一个由当前数组和其他若干个数组或若干个非数组值组合而成的新数组。 Array.prototype.includes()：判断当前数组是否包含某指定的值，如果是返回true,否则返回false。 Array.prototype.join()：连接所有数组元素组成一个字符串。 Array.prototype.slice()：抽取当前数组中的一段元素组合成一个新的数组。 Array.prototype.toSource()：返回一个表示当前数组字面了的字符串。 Array.prototype.toString()：返回一个由所有数组元素组合而成的字符串。 Array.prototype.toLocaleString()：返回一个由数组元素组合而成的本地化后的字符串。 Array.prototype.indexOf()：返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 Array.prototype.lastIndexOf()：返回数组中最后一个（从右边第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 遍历方法： Array.prototype.forEach()：为数组中的每个元素执行一次回调函数。 Array.prototype.entries()：返回一个对象迭代器对象，该迭代器会包含所有数组元素的键值对。 Array.prototype.every()：如果数组中的每个元素都满足测试函数，则返回true,否则返回 false。 Array.prototype.some()：如果数组中至少有一个元素满足测试函数，则返回true，否则返回false。 Array.prototype.filter()：将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。 Array.prototype.find()：找到第一个满足测试函数的元素并返回那个元素的值。如果找不到，则返回undefined。 Array.prototype.findIndex()：找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。 Array.prototype.keys()：返回数组迭代器对象，该迭代器会包含所有数组元素的健。 Array.prototype.map()：返回一个由回调函数的返回值组成的新数组。 Array.prototype.reduce()：从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 Array.prototype.reduceRight()：从右到左为每个元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 Array.prototype.values()：返回数组迭代器，该迭代器会包含所有数组元素的值。 Array.prototype[@@iterator]()： 和上面的 values() 方法是同一个函数。 15. 如何将一个类数组变量转为数组？ Array.prototype.slice.call() Array.from() 16. 说一说ES6中对于数组有哪些扩展？ 增加了扩展运算符(spread) ... 增加了两个方法，Array.from() 和 Array.of() 方法 增加了一些实例方法，如 copyWithin()、fill()、entries()、keys()、values()、includes() 等。 17. 数组去重，你能说出多少种方法？ 实现一 // A.方法1：使用Set + Array function uniqueArray(arr){ return Array.from(new Set(arr)); } // B.方法2：使用splice function uniqueArray(arr){ for(var i = 0; i 补充 注：暂不考虑对象字面量，函数等引用类型的去重，也不考虑 NaN, undefined, null等特殊类型情况。 数组样本：[1, 1, '1', '2', 1] 3.1 普通版 复杂度 O(n^2) 无需思考，我们可以得到 O(n^2) 复杂度的解法。定义一个变量数组 res 保存结果，遍历需要去重的数组，如果该元素已经存在在 res 中了，则说明是重复的元素，如果没有，则放入 res 中。 var a = [1, 1, '1', '2', 1] function unique(arr) { var res = [] for (var i = 0, len = arr.length; i 优点： 没有任何兼容性问题，通俗易懂，没有任何理解成本 缺点： 看起来比较臃肿比较繁琐，时间复杂度比较高O(n^2) 3.2 进阶版 var a = [1, 1, '1', '2', 1] function unique(arr) { return arr.filter(function(ele,index,array){ return array.indexOf(ele) === index//很巧妙,这样筛选一对一的,过滤掉重复的 }) } console.log(unique(a)) // [1, 2, \"1\"] 优点：很简洁，思维也比较巧妙，直观易懂。 缺点：不支持 IE9 以下的浏览器，时间复杂度还是O(n^2) 3.3 时间复杂度为O(n) var a = [1, 1, '1', '2', 1] function unique(arr) { var obj = {} return arr.filter(function(item, index, array){ return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) }) } console.log(unique(a)) // [1, 2, \"1\"] 优点：hasOwnProperty 是对象的属性(名称)存在性检查方法。对象的属性可以基于 Hash 表实现，因此对属性进行访问的时间复杂度可以达到O(1); filter 是数组迭代的方法，内部还是一个 for 循环，所以时间复杂度是 O(n)。 缺点：不兼容 IE9 以下浏览器，其实也好解决，把 filter 方法用 for 循环代替或者自己模拟一个 filter 方法。 3.4 终极版 以 Set 为例，ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 const unique = a => [...new Set(a)] 优点：ES6 语法，简洁高效，我们可以看到，去重方法从原始的 14 行代码到 ES6 的 1 行代码，其实也说明了 JavaScript 这门语言在不停的进步，相信以后的开发也会越来越高效。 缺点：兼容性问题，现代浏览器才支持，有 babel 这些都不是问题。 18. 你知道Array.prototype的类型是什么吗？ Array.prototype 是一个数组，不过 length 为 0 19. 如何\"打平\"一个嵌套数组， 如[1, [2, [3]], 4, [5]] => [1, 2, 3, 4, 5]？你能说出多少种方法？ 1. 利用 Array.prototype.toString()方法（元素为数字） var list = [1, [2, [3]], 4, [5]] console.log(list.toString()) // 1, 2, 3, 4, 5 原理：toString 方法返回一个字符串，该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。 2. 利用Array.prototype.join()方法（元素为数字） var list = [1, [2, [3]], 4, [5]] console.log(list.join()) // 1, 2, 3, 4, 5 原理：join 方法会让所有的数组元素转换成字符串，再用一个分隔符将这些字符串连接起来。如果元素是undefined或null，则会转化成空字符串。 3. 利用JSON.parse()方法（元素为数字） var list = [1, [2, [3]], 4, [5]] JSON.parse(`[${arr}]`) // [1, 2, 3, 4, 5] PS: 如果觉得上面输出的不是一个数组，可以稍微加工一下。 var list = [1, [2, [3]], 4, [5]] JSON.parse(`[${list.toString()}]`) JSON.parse(`[${list.join()}]`) JSON.parse(`[${arr}]`) 20. 如何克隆一个数组？你能说出多少种？ concat() var arr1 = [1, 2, 3] var arr2 = arr1.concat(); slice var arr1 = [1, 2, 3] var arr2 = arr1.join(); 原理：数组本质上也是Object，直接赋值的话，只是将引用赋值给另一个变量，最终会导致被复制的变量也会随着原来的数组变化而变化。 21. 说一说Array.prototype.sort()方法的原理？（追问：不传递参数会如何？） 语法：sort方法接收一个 \"比较参数\" 作为参数。 如果调用该参数时没有使用参数, 将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），再以便进行比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这个两个值得相对顺序的数字。比较函数应该具有两个参数 a 和 b,其返回值如下： 若 a 小于 b,在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b, 则返回 0。 若 a 大于 b, 则返回一个大于 0 的值。 22. 找出Array中的最大元素，你能说出几种方法？ 实现一个冒泡算法 循环遍历一遍 var list = [1, 100, 23, 65, 43, 2, 9] var max = list[0] for(var i = 1; i reduce var list = [1, 100, 23, 65, 43, 2, 9] function Max(prev, next) { return Math.max(prev, next) } console.log(list.reduce(Max)) // 100 apply var list = [1, 100, 23, 65, 43, 2, 9] Math.max.apply(null, list) // 100 ES6 ... 使用ES6的扩展运算符 var list = [1, 100, 23, 65, 43, 2, 9] Math.max(...list) // 100 利用Array的sort方法先排序再取值 var list = [1, 100, 23, 65, 43, 2, 9] list.sort((a, b) => {return a - b}) list[list.length - 1] // 100 evalMath.max 支持传多个参数来进行比较，那么我们如何将一个数组转换成参数传进 Math.max 函数呢？ eval 便是一种： var list = [1, 100, 23, 65, 43, 2, 9] var max = eval(\"Math.max(\" + list+ \")\") console.log(max) // 100 解析：因为 发生了隐式类型转换例如： var list = [1, 100, 23, 65, 43, 2, 9] console.log(list+'') // 1,100,23,65,43,2,9 其实 var max = eval(\"Math.max(\"+ list+\")\") 就相当于 var max = eval(\"Math.max(1,100,23,65,43,2,9)\") 23. mouseover 和 mouseenter 两个事件有何区别？ 二者的区别是 mouseenter 不会冒泡(bubble)。 详细解析一下： 当两者绑定的元素都没有子元素时，两者的行为是一直的。但是当两者内部都包含子元素时，行为就不一样了。 在 mouseover 绑定的元素中，鼠标每次进入一个子元素就会触发一次 mouseover 事件，而 mouseenter 只会触发一次。 mouseover 事件对应 mouseout事件mouseenter 事件对应 mouseleave 事件 demo: * { margin: 0; padding: 0; } .container { overflow: hidden; } .over { background-color: lightgray; padding: 20px; width: 40%; float: left; } .enter { background-color: lightgray; padding: 20px; width: 40%; float: right; } .over h2, .enter h2 { background-color: #fff; } --> --> function $(ele) { return document.querySelector(ele) } var x = 0, y = 0; var $over = $('.over'); var $enter = $('.enter'); $over.addEventListener('mouseover', function(e) { $over.innerText = ++x; // $('.over-counter').innerText = ++x; }); $enter.addEventListener('mouseenter', function(e) { $enter.innerText = ++y; // $('.enter-counter').innerText = ++y; }); 24. 移动端的click时间行为与PC端有什么不同？如何屏蔽这个不同？ 移动端的click事件会延迟300ms触发事件回调(只在部分手机浏览器上出现)。 解决办法：引入 fastclick.js 来解决。它的原理是 fastlick 在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即触发一个模拟 click 事件，并把浏览器在 300 毫秒之后真正触发的click事件阻止掉。 25. Event对象中, target和currentTarget的区别？ currentTarget是当前事件遍历DOM时，标识事件的当前目标。它总是引用事件处理程序附加到的元素（事件代理对象上），而不是 event.target, event.target标识事件发生的元素。 有个简单的验证方法，你会在下面的例子中看到 e.currentTarget 一直返回的是 body元素，而e.target则随着你点击的位置的不同而变化。 item 1-1 item 1-2 item 2-1 item 2-2 document.body.addEventListener('click', function (e) { console.log(e.target, e.currentTarget) }) 26. 说一说什么是事件冒泡，如何阻止事件冒泡？如何阻止默认事件？ 事件冒泡是指事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接受，然后逐级向上传播到较为不具体的节点（文档）。 阻止事件冒泡的方法： 调用当前时间对象的 stopPropagation() 方法 IE10及其以下 cancelBubble = true function cancelBubble(e) { var evt = e ? e : window.event; if (evt.stopPropagation) { // W3C evt.stopPropagation(); }else { // IE evt.cancelBubble = true; } } 阻止默认事件： 调用当前事件对象的 preventDefault() 方法 IE下：returnValue = false function preventDefaultAction(event){ var event = window.event || event; if(document.all){ // 支持IE event.returnValue = false; }else{ // IE不支持 event.preventDefault(); } } 27. 是否了解移动端的点击穿透，原理及解决方法？ 点击穿透是指在移动端，由于click事件延迟300ms触发，那么如果300ms内，页面显示变化（主要是指DOM的隐藏和显示）的话，会出现实际点击元素触发了touch事件，而300ms后该位置的实际元素又被再次触发了click事件的情况。 避免方法： 引入 fastclick.js 28. 是否了解事件委托？ 事件委托是指利用 \"事件冒泡\"，指定一个事件处理程序，来管理某一类型的所有事件。 29. 什么是事件循环？ 为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。 事件循环的职责，就是不断得等待事件的发生，然后将这个事件的所有处理器，以它们订阅这个事件的时间顺序，依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。 事件循环的机制： 一个事件循环有一个或者多个任务队列（task queues）。任务队列是task的有序列表，这些task是以下工作的对应算法：Events，Parsing，Callbacks，Using a resource，Reacting to DOM manipulation。 每一个任务都来自一个特定的任务源（task source）。所有来自一个特定任务源并且属于特定事件循环的任务，通常必须被加入到同一个任务队列中，但是来自不同任务源的任务可能会放在不同的任务队列中。 举个例子，用户代理有一个处理鼠标和键盘事件的任务队列。用户代理可以给这个队列比其他队列多3/4的执行时间，以确保交互的响应而不让其他任务队列饿死（starving），并且不会乱序处理任何一个任务队列的事件。 每个事件循环都有一个进入microtask检查点（performing a microtask checkpoint）的flag标志，这个标志初始为false。它被用来组织反复调用‘进入microtask检查点’的算法。 一个事件循环里有很多个任务队列（task queues）来自不同任务源，每一个任务队列里的任务是严格按照先进先出的顺序执行的，但是不同任务队列的任务的执行顺序是不确定的。按我的理解就是，浏览器会自己调度不同任务队列。 在事件循环中，用户代理会不断从task队列中按顺序取task执行，每执行完一个task都会检查microtask队列是否为空（执行完一个task的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去task队列中取下一个task执行... 30. css3中有哪些属性可以直接影响JS中的事件？（可以讲一下pointer-events和touch-action属性吗？） css3中有两个属性是可以直接影响到JS中的事件的，他们是pointer-events和touch-action。 pointer-events CSS 属性指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target。当该属性值设定为none时 表示鼠标事件“穿透”该元素并且指定该元素“下面”的任何东西。 需要注意的是，如果当前元素的pointer-events属性指定位none，但是当其后代元素的pointer-events属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶段触发父元素的事件侦听器。 touch-action 用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）。 最常见的用法是禁用元素（及其不可滚动的后代）上的所有手势，以使用自己提供的拖放和缩放行为（如地图或游戏表面）。 #map { touch-action: none; } 31. 怎么去设计一个组件封装 组件封装的目的是为了重用，提高开发效率和代码质量 低耦合，单一职责，可复用性，可维护性 32. js 异步加载的方式 渲染引擎遇到 script 标签会停下来，等到执行完脚本，继续向下渲染 defer 是“渲染完再执行”，async 是“下载完就执行”，defer 如果有多个脚本，会按照在页面中出现的顺序加载，多个async 脚本不能保证加载顺序 加载 es6模块的时候设置 type=module，异步加载不会造成阻塞浏览器，页面渲染完再执行，可以同时加上async属性，异步执行脚本（利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中） 33. css 动画和 js 动画的差异 代码复杂度，js 动画代码相对复杂一些 动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件 动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好 34. XSS 与 CSRF 两种跨站攻击 xss 跨站脚本攻击，主要是前端层面的，用户在输入层面插入攻击脚本，改变页面的显示，或则窃取网站 cookie，预防方法：不相信用户的所有操作，对用户输入进行一个转义，不允许 js 对 cookie 的读写 csrf 跨站请求伪造，以你的名义，发送恶意请求，通过 cookie 加参数等形式过滤 我们没法彻底杜绝攻击，只能提高攻击门槛 35. 事件委托，目的，功能，写法 把一个或者一组元素的事件委托到它的父层或者更外层元素上 优点，减少内存消耗，动态绑定事件 target 是触发事件的最具体的元素，currenttarget是绑定事件的元素(在函数中一般等于this) 36. 线程，进程 线程是最小的执行单元，进程是最小的资源管理单元 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程 37. 负载均衡 当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向扩展，使用集群和负载均衡提高整个系统的处理能力 38. 什么是CDN缓存 CDN 是一种部署策略，根据不同的地区部署类似nginx 这种服务服务，会缓存静态资源。前端在项目优化的时候，习惯在讲台资源上加上一个 hash 值，每次更新的时候去改变这个 hash，hash 值变化的时候，服务会去重新取资源 (CDN)是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件 39. javascript 中常见的内存泄露陷阱 内存泄露会导致一系列问题，比如：运行缓慢，崩溃，高延迟 内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来 意外的全局变量，这些都是不会被回收的变量（除非设置 null 或者被重新赋值），特别是那些用来临时存储大量信息的变量 周期函数一直在运行，处理函数并不会被回收，jq 在移除节点前都会，将事件监听移除 js 代码中有对 DOM 节点的引用，dom 节点被移除的时候，引用还维持 JavaScript 中 4 种常见的内存泄露陷阱 意外的全局变量 被遗漏的定时器和回调函数 DOM 之外的引用 闭包 40. babel把ES6转成ES5或者ES3之类的原理是什么 它就是个编译器，输入语言是ES6+，编译目标语言是ES5 babel 官方工作原理 解析：将代码字符串解析成抽象语法树 变换：对抽象语法树进行变换操作 再建：根据变换后的抽象语法树再生成代码字符串 41. Promise 模拟终止 当新对象保持“pending”状态时，原Promise链将会中止执行。 return new Promise(()=>{}); // 返回“pending”状态的Promise对象 42. promise 放在try catch里面有什么结果 Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止，也即是说，错误总会被下一个catch语句捕获 当Promise链中抛出一个错误时，错误信息沿着链路向后传递，直至被捕获 43. get与post 通讯的区别 Get 请求能缓存，Post 不能 Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。 Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术 URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的 Post 支持更多的编码类型且不对数据类型限制 44. 有没有去研究webpack的一些原理和机制，怎么实现的 解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。 注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。 从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。 在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。 递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。 输出所有chunk到文件系统。 45. ES6模块与CommonJS模块的差异 CommonJs 模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用 CommonJS 模块是运行时加载，ES6模块是编译时输出接口 ES6输入的模块变量，只是一个符号链接，所以这个变量是只读的，对它进行重新赋值就会报错 46. 模块加载AMD，CMD，CommonJS Modules/2.0 规范 这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行 CMD 推崇依赖就近，AMD 推崇依赖前置 47. Node 事件循环，js 事件循环差异 Node.js 的事件循环分为6个阶段 浏览器和Node 环境下，microtask 任务队列的执行时机不同 Node.js中，microtask 在事件循环的各个阶段之间执行 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行 递归的调用process.nextTick()会导致I/O starving，官方推荐使用setImmediate() "},"面试/综合4-vue.html":{"url":"面试/综合4-vue.html","title":"综合4","keywords":"","body":"js面试题（vue） js面试题（vue） 1. 请详细说下你对vue生命周期的理解 2. vue 生命周期图 3. 谈谈你对vue的双向数据绑定的原理的理解 4. 谈谈你对vue组件间数据传递 5. vue里面父组件如何修改子组件样式 1. 请详细说下你对vue生命周期的理解 vue的生命周期总共分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/后。 创建前/后：在beforeCreate阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段,vue实例的数据对象data有了，$el还没有。 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法。 销毁前/后：在执行destoryed方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。 2. vue 生命周期图 实例代码： 3. 谈谈你对vue的双向数据绑定的原理的理解 vue是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter,getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体步骤： 第一步：通过Observer提供的接口，对需要observe的数据对象进行递归遍历，给对象的每个属性、子属性对象的属性，都加上setter和getter（都绑定了一个专用的 Dep对象，这里的状态对象主要指组件当中的data属性）。 这样的话，给这个对象的某个值赋值，就会触发setter,那么就能监听到了数据变化。 第二步：compile解析模版指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是： 在自身实例化时往属性订阅器(dep)里面添加自己 自身必须有一个update()方法 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模版指令，最终利用Watcher搭起Observer和Compiler之间的通信桥梁，达到数据变化->视图更新；视图交互变化(input)->数据model变更的双向绑定效果。 4. 谈谈你对vue组件间数据传递 通过 props 的方式向子组件传递（父子组件） vuex进行状态管理（父子组件和非父子组件） 非父子组件的通信传递 Vue Event Bus($emit)，使用Vue的实例，实现事件的监听和发布，实现组件之间数据的传递。 inheritAttrs + $attrs + $listeners 5. vue里面父组件如何修改子组件样式 在使用 vue 的开发中，我们有时会引用外部组件，包括UI组件。当 标签有 scoped 属性时，它的css只作用于当前组件中的元素。但是在父组件中添加了 scoped 之后，父组件的样式将不会渗透到子组件中，所以在父组件中书写子组件的样式是无效的。 解决方案: 去掉scoped 在父组件的 中去掉 scoped 后，父组件中可以书写子组件的样式，但是需要注意避免污染了全局样式。 混用本地和全局样式 可以在同一个组件中同时使用有作用域和无作用域的样式： /* ...全局样式...*/ /* ...本地样式... */ 使用深度作用选择器 如果你希望 scoped 样式中的一个选择器能够作用得 “更深“，例如影响子组件，你可以使用 >>> 操作符： .parent >>> .child { /* ... */ } 有些像SASS之类的预处理器无法正确解析 >>> 。这种情况下你可以用 /deep/ 操作符取而代之，deep 是 >>> 的别名，同样可以正常工作。 需要额外补充的是： 通过 v-html 创建的 DOM 内容不受作用域内的样式影响，但是你仍然可以通过深度作用选择器来为他们设置样式 CSS 作用域不能代替 class 在递归组件中小心使用后代选择器 "},"面试/综合5.html":{"url":"面试/综合5.html","title":"综合5","keywords":"","body":"js (五) 1. 为什么form表单提交没有跨域问题，但ajax提交有跨域问题？ 2. 移动端适配1px问题 3. 居中为什么要使用transform(为什么不使用marginLeft/Top) 4. JavaScript (a ==1 && a== 2 && a==3) 可能为 true 吗？ 5. 何为受控组件(controlled component) 6. 在 React 中，refs 的作用是什么 7. 何为高阶组件(higher order component) 8. 使用箭头函数(arrow functions)的优点是什么 9. 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象 10. 何为 JSX 11. 怎么用 React.createElement 重写下面的代码 12. 何为 Children 13. 何为 redux 14. 在 Redux 中，何为 store 15. redux中间件 16. redux有什么缺点 17. react组件的划分业务组件技术组件？ 18. 为什么虚拟dom会提高性能? 19. react性能优化方案 20. 简述flux 思想 21. React项目用过什么脚手架？Mern? Yeoman? 22. JSX引入React 23. prop 和 state 的对比 1. 为什么form表单提交没有跨域问题，但ajax提交有跨域问题？ ajax跨域是因为浏览器需要保护用户的安全和隐私而给js设定的限制。如果你自己写个浏览器去掉这个限制那js就可以任意跨域访问了 form表单可以跨域一个是历史原因要保持兼容性，一个是form表单会刷新页面不会把结果返回给js，所以相对安全 用jsonp跨域其实也是利用了浏览器的历史兼容性，而最新的font资源就不允许直接跨域引用 2. 移动端适配1px问题 构建1个伪元素，将它的长宽放大到2倍，边框宽度设置为1px,再以transform缩放到50% .radius-border { position: relative; } @media screen and (-webkit-min-device-pixel-ratio: 2) { .radius-border:before { content: \"\"; pointer-events: none; /* 防止点击触发 */ box-sizing: border-box; position: absolute; width: 200%; height: 200%; left: 0; top: 0; border-radius: 8px; border: 1px solid #999; -webkit-transform(scale(0.5)); -webkit-transform-origin: 0 0; transform(scale(0.5)); transform-origin: 0 0; } } 3. 居中为什么要使用transform(为什么不使用marginLeft/Top) top/left花了大量的时间去绘制每一帧。所有的css包括box-shadow都是在CPU上计算的。在translate版本中，却让这个 macbook 在自己新的图层在GPU中得到提升。此时此元素的macbook是在自己单独的一层上，任何2D transform, 3D transform或者opacity的变化都可以完全的使用GPU，GPU可以保持非常快并且可以给我们提供非常快的帧速率。 4. JavaScript (a ==1 && a== 2 && a==3) 可能为 true 吗？ 自定义 toString（或者 valueOf）方法，每次调用改变一次返回值，从而满足判断条件。 const a = { i: 1, toString: function () { return a.i++; } } if(a == 1 && a == 2 && a == 3) { console.log('Hello World!'); } 当使用 == 时，如果两个参数的类型不一样，那么 JS 会尝试将其中一个的类型转换为和另一个相同。在这里左边对象，右边数字的情况下，会首先尝试调用 valueOf（如果可以调用的话）来将对象转换为数字，如果失败，再调用 toString。 比如，我比较喜欢这个： with({ get a() { return Math.floor(Math.random()*4); } }){ for(var i=0;i stackoverflow var aﾠ = 1; var a = 2; var ﾠa = 3; if(aﾠ==1 && a== 2 &&ﾠa==3) { console.log(\"Why hello there!\") } a = [1,2,3]; a.join = a.shift; console.log(a == 1 && a == 2 && a == 3); // true let i = 0; let a = { [Symbol.toPrimitive]: () => ++i }; console.log(a == 1 && a == 2 && a == 3); // true var a = { r: /\\d/g, valueOf: function(){ return this.r.exec(123)[0] } } if (a == 1 && a == 2 && a == 3) { console.log(\"!\") } 5. 何为受控组件(controlled component) 在 HTML 中，类似 , 和 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为\"受控元素\"。 6. 在 React 中，refs 的作用是什么 Refs 可以用于获取一个 DOM 节点或者 React 组件的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String 类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。 7. 何为高阶组件(higher order component) 高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。 8. 使用箭头函数(arrow functions)的优点是什么 作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 this 值(在构造函数中是新对象；在严格模式下，函数调用中的 this 是未定义的；如果函数被称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的 this 值。 简单：箭头函数易于阅读和书写 清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 this 的值 9. 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象 因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。 10. 何为 JSX JSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React \"元素\"，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 if 语句和 for 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它 11. 怎么用 React.createElement 重写下面的代码 Question： const element = ( Hello, rdhub.cn! ); Answer： const element = React.createElement( 'h1', {className: 'greeting'}, 'Hello, rdhub.cn!' ); 12. 何为 Children 在JSX表达式中，一个开始标签(比如)和一个关闭标签(比如)之间的内容会作为一个特殊的属性props.children被自动传递给包含着它的组件。 这个属性有许多可用的方法，包括 React.Children.map，React.Children.forEach， React.Children.count， React.Children.only，React.Children.toArray。 13. 何为 redux Redux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该有任何副作用。 14. 在 Redux 中，何为 store Store 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责： 允许通过 getState() 访问 state 运行通过 dispatch(action) 改变 state 通过 subscribe(listener) 注册 listeners 通过 subscribe(listener) 返回的函数处理 listeners 的注销 15. redux中间件 中间件提供第三方插件的模式，自定义拦截 action -> reducer 的过程。变为 action -> middlewares -> reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能。 常见的中间件： redux-logger：提供日志输出 redux-thunk：处理异步操作 redux-promise：处理异步操作，actionCreator的返回值是promise 16. redux有什么缺点 一个组件所需要的数据，必须由父组件传过来，而不能像flux中直接从store取。 当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的shouldComponentUpdate进行判断。 17. react组件的划分业务组件技术组件？ 根据组件的职责通常把组件分为UI组件和容器组件。 UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。 两者通过React-Redux 提供connect方法联系起来。 18. 为什么虚拟dom会提高性能? 虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。具体实现步骤如下：用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。 19. react性能优化方案 重写shouldComponentUpdate来避免不必要的dom操作。 使用 production 版本的react.js。 使用key来帮助React识别列表中所有子组件的最小变化。 20. 简述flux 思想 Flux 的最大特点，就是数据的\"单向流动\"。 用户访问 View View 发出用户的 Action Dispatcher 收到 Action，要求 Store 进行相应的更新 Store 更新后，发出一个\"change\"事件 View 收到\"change\"事件后，更新页面 21. React项目用过什么脚手架？Mern? Yeoman? Mern：MERN是脚手架的工具，它可以很容易地使用Mongo, Express, React and NodeJS生成同构JS应用。它最大限度地减少安装时间，并得到您使用的成熟技术来加速开发。 22. JSX引入React 在使用JSX的范围内必须要有React, 在使用JSX的代码文件中，即使代码中并没有直接使用React，也一定要导入这个React，这是因为JSX最终会被转义成依赖于React的表达式 23. prop 和 state 的对比 prop 用于定义外部接口， state 用于记录内部状态 prop 的赋值在外部世界使用组件时， state 的赋值在组件内部 组件不应该改变prop的值，而 state存在的目的就是让组件来改变的 "},"面试/综合6.html":{"url":"面试/综合6.html","title":"综合6","keywords":"","body":"js (六) 1. new 2. instanceof 3. 对于 CommonJS 和 ES6 中的模块化的两者区别是 4. 防抖 5. 节流 6. call, apply, bind 区别 7. 模拟实现 call 和 apply 和 bind 8. Promise 实现 9. Generator 实现 10. Map、FlatMap 和 Reduce 11. Proxy 1. new 新生成了一个对象 链接到原型 绑定 this 返回新对象 在调用 new 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 new function create() { // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === 'object' ? result : obj } 2. instanceof instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 我们也可以试着实现一下 instanceof function instanceof(left, right) { // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) { if (left === null) return false if (prototype === left) return true left = left.__proto__ } } 3. 对于 CommonJS 和 ES6 中的模块化的两者区别是 前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案 前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化 后者会编译成 require/exports 来执行的 4. 防抖 你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。 这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。 PS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。 我们先来看一个袖珍版的防抖理解一下防抖的实现： // func是用户传入需要防抖的函数 // wait是等待时间 const debounce = (func, wait = 50) => { // 缓存一个定时器id let timer = 0 // 这里返回的函数是每次用户实际调用的防抖函数 // 如果已经设定过定时器了就清空上一次的定时器 // 开始一个新的定时器，延迟执行用户传入的方法 return function(...args) { if (timer) clearTimeout(timer) timer = setTimeout(() => { func.apply(this, args) }, wait) } } // 不难看出如果用户调用该函数的间隔小于wait的情况下，上一次的时间还未到就被清除了，并不会执行函数 这是一个简单版的防抖，但是有缺陷，这个防抖只能在最后调用。一般的防抖会有immediate选项，表示是否立即调用。这两者的区别，举个栗子来说： 例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用延迟执行的防抖函数，它总是在一连串（间隔小于wait的）函数触发之后调用。 例如用户给interviewMap点star的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变star按钮的样子，用户就可以立马得到反馈是否star成功了，这个情况适用立即执行的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于wait才会触发。 下面我们来实现一个带有立即执行选项的防抖函数 // 这个是用来获取当前时间戳的 function now() { return +new Date() } /** * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param {function} func 回调函数 * @param {number} wait 表示时间窗口的间隔 * @param {boolean} immediate 设置为ture时，是否立即调用函数 * @return {function} 返回客户调用函数 */ function debounce (func, wait = 50, immediate = true) { let timer, context, args // 延迟执行函数 const later = () => setTimeout(() => { // 延迟函数执行完毕，清空缓存的定时器序号 timer = null // 延迟执行的情况下，函数会在延迟函数中执行 // 使用到之前缓存的参数和上下文 if (!immediate) { func.apply(context, args) context = args = null } }, wait) // 这里返回的函数是每次实际调用的函数 return function(...params) { // 如果没有创建延迟执行函数（later），就创建一个 if (!timer) { timer = later() // 如果是立即执行，调用函数 // 否则缓存参数和调用上下文 if (immediate) { func.apply(this, params) } else { context = this args = params } // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个 // 这样做延迟函数会重新计时 } else { clearTimeout(timer) timer = later() } } } 整体函数实现的不难，总结一下。 对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 null，就可以再次点击了。 对于延时执行函数来说的实现：清除定时器ID，如果是延迟调用就调用函数 5. 节流 防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。 /** * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait * * @param {function} func 回调函数 * @param {number} wait 表示时间窗口的间隔 * @param {object} options 如果想忽略开始函数的的调用，传入{leading: false}。 * 如果想忽略结尾函数的调用，传入{trailing: false} * 两者不能共存，否则函数不能执行 * @return {function} 返回客户调用函数 */ _.throttle = function(func, wait, options) { var context, args, result; var timeout = null; // 之前的时间戳 var previous = 0; // 如果 options 没传则设为空对象 if (!options) options = {}; // 定时器回调函数 var later = function() { // 如果设置了 leading，就将 previous 设为 0 // 用于下面函数的第一个 if 判断 previous = options.leading === false ? 0 : _.now(); // 置空一是为了防止内存泄漏，二是为了下面的定时器判断 timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; }; return function() { // 获得当前时间戳 var now = _.now(); // 首次进入前者肯定为 true // 如果需要第一次不执行函数 // 就将上次时间戳设为当前的 // 这样在接下来计算 remaining 的值时会大于0 if (!previous && options.leading === false) previous = now; // 计算剩余时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果当前调用已经大于上次调用时间 + wait // 或者用户手动调了时间 // 如果设置了 trailing，只会进入这个条件 // 如果没有设置 leading，那么第一次会进入这个条件 // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了 // 其实还是会进入的，因为定时器的延时 // 并不是准确的时间，很可能你设置了2秒 // 但是他需要2.2秒才触发，这时候就会进入这个条件 if (remaining wait) { // 如果存在定时器就清理掉否则会调用二次回调 if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; result = func.apply(context, args); if (!timeout) context = args = null; } else if (!timeout && options.trailing !== false) { // 判断是否设置了定时器和 trailing // 没有的话就开启一个定时器 // 并且不能不能同时设置 leading 和 trailing timeout = setTimeout(later, remaining); } return result; }; }; 6. call, apply, bind 区别 首先说下前两者的区别。 call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。 除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。 bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。 7. 模拟实现 call 和 apply 和 bind 可以从以下几点来考虑如何实现 不传入第一个参数，那么默认为 window 改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？ Function.prototype.myCall = function (context) { var context = context || window // 给 context 添加一个属性 // getValue.call(a, 'yck', '24') => a.fn = getValue context.fn = this // 将 context 后面的参数取出来 var args = [...arguments].slice(1) // getValue.call(a, 'yck', '24') => a.fn('yck', '24') var result = context.fn(...args) // 删除 fn delete context.fn return result } 以上就是 call 的思路，apply 的实现也类似 Function.prototype.myApply = function (context) { var context = context || window context.fn = this var result // 需要判断是否存储第二个参数 // 如果存在，就将第二个参数展开 if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。 Function.prototype.myBind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } var _this = this var args = [...arguments].slice(1) // 返回一个函数 return function F() { // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) { return new _this(...args, ...arguments) } return _this.apply(context, args.concat(...arguments)) } } 8. Promise 实现 Promise 是 ES6 新增的语法，解决了回调地狱的问题。 可以把 Promise 看成一个状态机。初始是 pending 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化。 then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 then 调用就失去意义了。 对于 then 来说，本质上可以把它看成是 flatMap // 三种状态 const PENDING = \"pending\"; const RESOLVED = \"resolved\"; const REJECTED = \"rejected\"; // promise 接收一个函数参数，该函数会立即执行 function MyPromise(fn) { let _this = this; _this.currentState = PENDING; _this.value = undefined; // 用于保存 then 中的回调，只有当 promise // 状态为 pending 时才会缓存，并且每个实例至多缓存一个 _this.resolvedCallbacks = []; _this.rejectedCallbacks = []; _this.resolve = function (value) { if (value instanceof MyPromise) { // 如果 value 是个 Promise，递归执行 return value.then(_this.resolve, _this.reject) } setTimeout(() => { // 异步执行，保证执行顺序 if (_this.currentState === PENDING) { _this.currentState = RESOLVED; _this.value = value; _this.resolvedCallbacks.forEach(cb => cb()); } }) }; _this.reject = function (reason) { setTimeout(() => { // 异步执行，保证执行顺序 if (_this.currentState === PENDING) { _this.currentState = REJECTED; _this.value = reason; _this.rejectedCallbacks.forEach(cb => cb()); } }) } // 用于解决以下问题 // new Promise(() => throw Error('error)) try { fn(_this.resolve, _this.reject); } catch (e) { _this.reject(e); } } MyPromise.prototype.then = function (onResolved, onRejected) { var self = this; // 规范 2.2.7，then 必须返回一个新的 promise var promise2; // 规范 2.2.onResolved 和 onRejected 都为可选参数 // 如果类型不是函数需要忽略，同时也实现了透传 // Promise.resolve(4).then().then((value) => console.log(value)) onResolved = typeof onResolved === 'function' ? onResolved : v => v; onRejected = typeof onRejected === 'function' ? onRejected : r => throw r; if (self.currentState === RESOLVED) { return (promise2 = new MyPromise(function (resolve, reject) { // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行 // 所以用了 setTimeout 包裹下 setTimeout(function () { try { var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (reason) { reject(reason); } }); })); } if (self.currentState === REJECTED) { return (promise2 = new MyPromise(function (resolve, reject) { setTimeout(function () { // 异步执行onRejected try { var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (reason) { reject(reason); } }); })); } if (self.currentState === PENDING) { return (promise2 = new MyPromise(function (resolve, reject) { self.resolvedCallbacks.push(function () { // 考虑到可能会有报错，所以使用 try/catch 包裹 try { var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (r) { reject(r); } }); self.rejectedCallbacks.push(function () { try { var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (r) { reject(r); } }); })); } }; // 规范 2.3 function resolutionProcedure(promise2, x, resolve, reject) { // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用 if (promise2 === x) { return reject(new TypeError(\"Error\")); } // 规范 2.3.2 // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行 if (x instanceof MyPromise) { if (x.currentState === PENDING) { x.then(function (value) { // 再次调用该函数是为了确认 x resolve 的 // 参数是什么类型，如果是基本类型就再次 resolve // 把值传给下个 then resolutionProcedure(promise2, value, resolve, reject); }, reject); } else { x.then(resolve, reject); } return; } // 规范 2.3.3.3.3 // reject 或者 resolve 其中一个执行过得话，忽略其他的 let called = false; // 规范 2.3.3，判断 x 是否为对象或者函数 if (x !== null && (typeof x === \"object\" || typeof x === \"function\")) { // 规范 2.3.3.2，如果不能取出 then，就 reject try { // 规范 2.3.3.1 let then = x.then; // 如果 then 是函数，调用 x.then if (typeof then === \"function\") { // 规范 2.3.3.3 then.call( x, y => { if (called) return; called = true; // 规范 2.3.3.3.1 resolutionProcedure(promise2, y, resolve, reject); }, e => { if (called) return; called = true; reject(e); } ); } else { // 规范 2.3.3.4 resolve(x); } } catch (e) { if (called) return; called = true; reject(e); } } else { // 规范 2.3.4，x 为基本类型 resolve(x); } } 9. Generator 实现 Generator 是 ES6 中新增的语法，和 Promise 一样，都可以用来异步编程 // 使用 * 表示这是一个 Generator 函数 // 内部可以通过 yield 暂停代码 // 通过调用 next 恢复执行 function* test() { let a = 1 + 2; yield 2; yield 3; } let b = test(); console.log(b.next()); // > { value: 2, done: false } console.log(b.next()); // > { value: 3, done: false } console.log(b.next()); // > { value: undefined, done: true } 从以上代码可以发现，加上 * 的函数执行后拥有了 next 函数，也就是说函数执行后返回了一个对象。每次调用 next 函数可以继续执行被暂停的代码。以下是 Generator 函数的简单实现 // cb 也就是编译过的 test 函数 function generator(cb) { return (function() { var object = { next: 0, stop: function() {} }; return { next: function() { var ret = cb(object); if (ret === undefined) return { value: undefined, done: true }; return { value: ret, done: false }; } }; })(); } // 如果你使用 babel 编译后可以发现 test 函数变成了这样 function test() { var a; return generator(function(_context) { while (1) { switch ((_context.prev = _context.next)) { // 可以发现通过 yield 将代码分割成几块 // 每次执行 next 函数就执行一块代码 // 并且表明下次需要执行哪块代码 case 0: a = 1 + 2; _context.next = 4; return 2; case 4: _context.next = 6; return 3; // 执行完毕 case 6: case \"end\": return _context.stop(); } } }); } 10. Map、FlatMap 和 Reduce Map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后 append 到新的数组中。 [1, 2, 3].map((v) => v + 1) // -> [2, 3, 4] Map 有三个参数，分别是当前索引元素，索引，原数组 ['1','2','3'].map(parseInt) // parseInt('1', 0) -> 1 // parseInt('2', 1) -> NaN // parseInt('3', 2) -> NaN FlatMap 和 map 的作用几乎是相同的，但是对于多维数组来说，会将原数组降维。可以将 FlatMap 看成是 map + flatten ，目前该函数在浏览器中还不支持。 [1, [2], 3].flatMap((v) => v + 1) // -> [2, 3, 4] 如果想将一个多维数组彻底的降维，可以这样实现 const flattenDeep = (arr) => Array.isArray(arr) ? arr.reduce( (a, b) => [...a, ...flattenDeep(b)] , []) : [arr] flattenDeep([1, [[2], [3, [4]], 5]]) Reduce 作用是数组中的值组合起来，最终得到一个值 function a() { console.log(1); } function b() { console.log(2); } [a, b].reduce((a, b) => a(b())) // -> 2 1 11. Proxy Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作 let p = new Proxy(target, handler); // `target` 代表需要添加代理的对象 // `handler` 用来自定义对象中的操作 可以很方便的使用 Proxy 来实现一个数据绑定和监听 let onWatch = (obj, setBind, getLogger) => { let handler = { get(target, property, receiver) { getLogger(target, property) return Reflect.get(target, property, receiver); }, set(target, property, value, receiver) { setBind(value); return Reflect.set(target, property, value); } }; return new Proxy(obj, handler); }; let obj = { a: 1 } let value let p = onWatch(obj, (v) => { value = v }, (target, property) => { console.log(`Get '${property}' = ${target[property]}`); }) p.a = 2 // bind `value` to `2` p.a // -> Get 'a' = 2 "},"面试/Js基础.html":{"url":"面试/Js基础.html","title":"6.JS基础","keywords":"","body":"Js基础 Js基础 1.内置类型 2.Typeof 3.类型转换 3.1.转Boolean 3.2.对象转基本类型 3.3.四则运算符 3.4.== 操作符 3.5.比较运算符 4.原型 5.new 6.instanceof 7.this 8.执行上下文 9.闭包 10.深浅拷贝 1.内置类型 JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。 基本类型有六种： null undefined boolean number string symbol 其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。NaN 也属于 number 类型，并且 NaN 不等于自身。 对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型 let a = 111 // 这只是字面量，不是 number 类型 a.toString() // 使用时候才会转换为对象类型 对象（Object）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。 let a = { name: 'FE' } let b = a b.name = 'EF' console.log(a.name) // EF 2.Typeof typeof 对于基本类型，除了 null 都可以显示正确的类型 typeof 1 // 'number' typeof '1' // 'string' typeof undefined // 'undefined' typeof true // 'boolean' typeof Symbol() // 'symbol' typeof b // b 没有声明，但是还会显示 undefined typeof 对于对象，除了函数都会显示 object typeof [] // 'object' typeof {} // 'object' typeof console.log // 'function' 对于 null 来说，虽然它是基本类型，但是会显示 object，这是一个存在很久了的 Bug typeof null // 'object' PS：为什么会出现这种情况呢？因为在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。 如果我们想获得一个变量的正确类型，可以通过 Object.prototype.toString.call(xx)。这样我们就可以获得类似 [object Type] 的字符串。 let a // 我们也可以这样判断 undefined a === undefined // 但是 undefined 不是保留字，能够在低版本浏览器被赋值 let undefined = 1 // 这样判断就会出错 // 所以可以用下面的方式来判断，并且代码量更少 // 因为 void 后面随便跟上一个组成表达式 // 返回就是 undefined a === void 0 3.类型转换 3.1.转Boolean 在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。 3.2.对象转基本类型 对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。并且这两个方法你是可以重写的。 let a = { valueOf() { return 0 } } 当然你也可以重写 Symbol.toPrimitive ，该方法在转基本类型时调用优先级最高。 let a = { valueOf() { return 0; }, toString() { return '1'; }, [Symbol.toPrimitive]() { return 2; } } 1 + a // => 3 '1' + a // => '12' 3.3.四则运算符 只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。 1 + '1' // '11' 2 * '2' // 4 [1, 2] + [2, 1] // '1,22,1' // [1, 2].toString() -> '1,2' // [2, 1].toString() -> '2,1' // '1,2' + '2,1' = '1,22,1' 对于加号需要注意这个表达式 'a' + + 'b' 'a' + + 'b' // -> \"aNaN\" // 因为 + 'b' -> NaN // 你也许在一些代码中看到过 + '1' -> 1 3.4.== 操作符 上图中的 toPrimitive 就是对象转基本类型。 这里来解析一道题目 [] == ![] // -> true ，下面是这个表达式为何为 true 的步骤 // [] 转成 true，然后取反变成 false [] == false // 根据第 8 条得出 [] == ToNumber(false) [] == 0 // 根据第 10 条得出 ToPrimitive([]) == 0 // [].toString() -> '' '' == 0 // 根据第 6 条得出 0 == 0 // -> true 3.5.比较运算符 如果是对象，就通过 toPrimitive 转换对象 如果是字符串，就通过 unicode 字符索引来比较 4.原型 每个函数都有 prototype 属性，除了 Function.prototype.bind()，该属性指向原型。 每个对象都有 __proto__属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 _proto_ 来访问。 对象可以通过 __proto__来寻找不属于该对象的属性，__proto__将对象连接起来组成了原型链。 5.new 新生成了一个对象 链接到原型 绑定 this 返回新对象 在调用 new 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 new function create() { // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === 'object' ? result : obj } 对于实例对象来说，都是通过 new 产生的，无论是 function Foo() 还是 let a = { b : 1 } 。 对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题。 function Foo() {} // function 就是个语法糖 // 内部等同于 new Function() let a = { b: 1 } // 这个字面量内部也是使用了 new Object() 对于 new 来说，还需要注意下运算符优先级。 function Foo() { return this; } Foo.getName = function () { console.log('1'); }; Foo.prototype.getName = function () { console.log('2'); }; new Foo.getName(); // -> 1 new Foo().getName(); // -> 2 从上图可以看出，new Foo() 的优先级大于 new Foo ，所以对于上述代码来说可以这样划分执行顺序 new (Foo.getName()); (new Foo()).getName(); 对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；对于后者来说，先执行 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。 6.instanceof instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 我们也可以试着实现一下 instanceof function instanceof(left, right) { // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) { if (left === null) return false if (prototype === left) return true left = left.__proto__ } } 7.this this 是很多人会混淆的概念，但是其实他一点都不难，你只需要记住几个规则就可以了。 function foo() { console.log(this.a) } var a = 1 foo() var obj = { a: 2, foo: foo } obj.foo() // 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况 // 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向 var c = new foo() c.a = 3 console.log(c.a) // 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new 以上几种情况明白了，很多代码中的 this 应该就没什么问题了，下面让我们看看箭头函数中的 this function a() { return () => { return () => { console.log(this) } } } console.log(a()()()) 箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是箭头函数的函数的 this。在这个例子中，因为调用 a 符合前面代码中的第一个情况，所以 this 是 window。并且 this 一旦绑定了上下文，就不会被任何代码改变。 8.执行上下文 当执行 JS 代码时，会产生三种执行上下文 全局执行上下文 函数执行上下文 eval 执行上下文 每个执行上下文中都有三个重要的属性 变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问 作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定了） this var a = 10 function foo(i) { var b = 20 } foo() 对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文。 stack = [ globalContext, fooContext ] 对于全局上下文来说，VO 大概是这样的 globalContext.VO === globe globalContext.VO = { a: undefined, foo: , } 对于函数 foo 来说，VO 不能访问，只能访问到活动对象（AO） fooContext.VO === foo.AO fooContext.AO { i: undefined, b: undefined, arguments: <> } // arguments 是函数独有的对象(箭头函数没有) // 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素 // 该对象中的 `callee` 属性代表函数本身 // `caller` 属性代表函数的调用者 对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过 [[Scope]] 属性查找上级变量 fooContext.[[Scope]] = [ globalContext.VO ] fooContext.Scope = fooContext.[[Scope]] + fooContext.VO fooContext.Scope = [ fooContext.VO, globalContext.VO ] 接下来让我们看一个老生常谈的例子，var b() // call b console.log(a) // undefined var a = 'Hello world' function b() { console.log('call b') } 想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 VO），JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升 b() // call b second function b() { console.log('call b fist') } function b() { console.log('call b second') } var b = 'Hello world' var 会产生很多错误，所以在 ES6中引入了 let。let 不能在声明前使用，但是这并不是常说的 let 不会提升，let 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使用。 对于非匿名的立即执行函数需要注意以下一点 var foo = 1 (function foo() { foo = 10 console.log(foo) }()) // -> ƒ foo() { foo = 10 ; console.log(foo) } 因为当 JS 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 foo，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。 specialObject = {}; Scope = specialObject + Scope; foo = new FunctionExpression; foo.[[Scope]] = Scope; specialObject.foo = foo; // {DontDelete}, {ReadOnly} delete Scope[0]; // remove specialObject from the front of scope chain 9.闭包 闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。 function A() { let a = 1 function B() { console.log(a) } return B } 你是否会疑惑，为什么函数 A 已经弹出调用栈了，为什么函数 B 还能引用到函数 A 中的变量。因为函数 A 中的变量这时候是存储在堆上的。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。 经典面试题，循环中使用闭包解决 var 定义函数的问题 for ( var i=1; i 首先因为 setTimeout 是个异步函数，所有会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。 解决办法两种，第一种使用闭包 for (var i = 1; i 第二种就是使用 setTimeout 的第三个参数 for ( var i=1; i 第三种就是使用 let 定义 i 了 for ( let i=1; i 因为对于 let 来说，他会创建一个块级作用域，相当于 { // 形成块级作用域 let i = 0 { let ii = i setTimeout( function timer() { console.log( ii ); }, i*1000 ); } i++ { let ii = i } i++ { let ii = i } ... } 10.深浅拷贝 这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。 let a = { age: 1, jobs: { first: 'FE' } } let b = JSON.parse(JSON.stringify(a)) a.jobs.first = 'native' console.log(b.jobs.first) // FE 但是该方法也是有局限性的： 会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 let obj = { a: 1, b: { c: 2, d: 3, }, } obj.c = obj.b obj.e = obj.a obj.b.c = obj.c obj.b.d = obj.b obj.b.e = obj.b.c let newObj = JSON.parse(JSON.stringify(obj)) console.log(newObj) 如果你有这么一个循环引用对象，你会发现你不能通过该方法深拷贝 在遇到函数、 undefined 或者 symbol 的时候，该对象也不能正常的序列化 let a = { age: undefined, sex: Symbol('male'), jobs: function() {}, name: 'yck' } let b = JSON.parse(JSON.stringify(a)) console.log(b) // {name: \"yck\"} 你会发现在上述情况中，该方法会忽略掉函数和 undefined 。 但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 lodash 的深拷贝函数。 如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel function structuralClone(obj) { return new Promise(resolve => { const {port1, port2} = new MessageChannel(); port2.onmessage = ev => resolve(ev.data); port1.postMessage(obj); }); } var obj = {a: 1, b: { c: b }} // 注意该方法是异步的 // 可以处理 undefined 和循环引用对象 (async () => { const clone = await structuralClone(obj) })() "},"手撸代码无敌/":{"url":"手撸代码无敌/","title":"7.手撸代码无敌","keywords":"","body":"手撸代码无敌 new instanceof 防抖和节流 Promise 实现 Generator 实现 Proxy call, apply, bind curry Template 封装Ajax和Promise js-tree "},"手撸代码无敌/new.html":{"url":"手撸代码无敌/new.html","title":"new","keywords":"","body":"new 新生成了一个对象 链接到原型 绑定 this 返回新对象 在调用 new 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 new function create() { // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === 'object' ? result : obj } 对于实例对象来说，都是通过 new 产生的，无论是 function Foo() 还是 let a = { b : 1 } 。 对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题。 function Foo() {} // function 就是个语法糖 // 内部等同于 new Function() let a = { b: 1 } // 这个字面量内部也是使用了 new Object() 对于 new 来说，还需要注意下运算符优先级。 function Foo() { return this; } Foo.getName = function () { console.log('1'); }; Foo.prototype.getName = function () { console.log('2'); }; new Foo.getName(); // -> 1 new Foo().getName(); // -> 2 从上图可以看出，new Foo() 的优先级大于 new Foo ，所以对于上述代码来说可以这样划分执行顺序 new (Foo.getName()); (new Foo()).getName(); 对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；对于后者来说，先执行 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。 "},"手撸代码无敌/instanceof.html":{"url":"手撸代码无敌/instanceof.html","title":"instanceof","keywords":"","body":"instanceof instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 我们也可以试着实现一下 instanceof function instanceof(left, right) { // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) { if (left === null) return false if (prototype === left) return true left = left.__proto__ } } "},"手撸代码无敌/防抖和节流.html":{"url":"手撸代码无敌/防抖和节流.html","title":"防抖和节流","keywords":"","body":"防抖和节流 防抖和节流 防抖 节流 防抖 你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。 这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。 PS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。 我们先来看一个袖珍版的防抖理解一下防抖的实现： // func是用户传入需要防抖的函数 // wait是等待时间 const debounce = (func, wait = 50) => { // 缓存一个定时器id let timer = 0 // 这里返回的函数是每次用户实际调用的防抖函数 // 如果已经设定过定时器了就清空上一次的定时器 // 开始一个新的定时器，延迟执行用户传入的方法 return function(...args) { if (timer) clearTimeout(timer) timer = setTimeout(() => { func.apply(this, args) }, wait) } } // 不难看出如果用户调用该函数的间隔小于wait的情况下，上一次的时间还未到就被清除了，并不会执行函数 这是一个简单版的防抖，但是有缺陷，这个防抖只能在最后调用。一般的防抖会有immediate选项，表示是否立即调用。这两者的区别，举个栗子来说： 例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用延迟执行的防抖函数，它总是在一连串（间隔小于wait的）函数触发之后调用。 例如用户给interviewMap点star的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变star按钮的样子，用户就可以立马得到反馈是否star成功了，这个情况适用立即执行的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于wait才会触发。 下面我们来实现一个带有立即执行选项的防抖函数 // 这个是用来获取当前时间戳的 function now() { return +new Date() } /** * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param {function} func 回调函数 * @param {number} wait 表示时间窗口的间隔 * @param {boolean} immediate 设置为ture时，是否立即调用函数 * @return {function} 返回客户调用函数 */ function debounce (func, wait = 50, immediate = true) { let timer, context, args // 延迟执行函数 const later = () => setTimeout(() => { // 延迟函数执行完毕，清空缓存的定时器序号 timer = null // 延迟执行的情况下，函数会在延迟函数中执行 // 使用到之前缓存的参数和上下文 if (!immediate) { func.apply(context, args) context = args = null } }, wait) // 这里返回的函数是每次实际调用的函数 return function(...params) { // 如果没有创建延迟执行函数（later），就创建一个 if (!timer) { timer = later() // 如果是立即执行，调用函数 // 否则缓存参数和调用上下文 if (immediate) { func.apply(this, params) } else { context = this args = params } // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个 // 这样做延迟函数会重新计时 } else { clearTimeout(timer) timer = later() } } } 整体函数实现的不难，总结一下。 对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 null，就可以再次点击了。 对于延时执行函数来说的实现：清除定时器ID，如果是延迟调用就调用函数 节流 防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。 /** * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait * * @param {function} func 回调函数 * @param {number} wait 表示时间窗口的间隔 * @param {object} options 如果想忽略开始函数的的调用，传入{leading: false}。 * 如果想忽略结尾函数的调用，传入{trailing: false} * 两者不能共存，否则函数不能执行 * @return {function} 返回客户调用函数 */ _.throttle = function(func, wait, options) { var context, args, result; var timeout = null; // 之前的时间戳 var previous = 0; // 如果 options 没传则设为空对象 if (!options) options = {}; // 定时器回调函数 var later = function() { // 如果设置了 leading，就将 previous 设为 0 // 用于下面函数的第一个 if 判断 previous = options.leading === false ? 0 : _.now(); // 置空一是为了防止内存泄漏，二是为了下面的定时器判断 timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; }; return function() { // 获得当前时间戳 var now = _.now(); // 首次进入前者肯定为 true // 如果需要第一次不执行函数 // 就将上次时间戳设为当前的 // 这样在接下来计算 remaining 的值时会大于0 if (!previous && options.leading === false) previous = now; // 计算剩余时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果当前调用已经大于上次调用时间 + wait // 或者用户手动调了时间 // 如果设置了 trailing，只会进入这个条件 // 如果没有设置 leading，那么第一次会进入这个条件 // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了 // 其实还是会进入的，因为定时器的延时 // 并不是准确的时间，很可能你设置了2秒 // 但是他需要2.2秒才触发，这时候就会进入这个条件 if (remaining wait) { // 如果存在定时器就清理掉否则会调用二次回调 if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; result = func.apply(context, args); if (!timeout) context = args = null; } else if (!timeout && options.trailing !== false) { // 判断是否设置了定时器和 trailing // 没有的话就开启一个定时器 // 并且不能不能同时设置 leading 和 trailing timeout = setTimeout(later, remaining); } return result; }; }; "},"手撸代码无敌/Proxy.html":{"url":"手撸代码无敌/Proxy.html","title":"Proxy","keywords":"","body":"Proxy Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作 let p = new Proxy(target, handler); // `target` 代表需要添加代理的对象 // `handler` 用来自定义对象中的操作 可以很方便的使用 Proxy 来实现一个数据绑定和监听 let onWatch = (obj, setBind, getLogger) => { let handler = { get(target, property, receiver) { getLogger(target, property) return Reflect.get(target, property, receiver); }, set(target, property, value, receiver) { setBind(value); return Reflect.set(target, property, value); } }; return new Proxy(obj, handler); }; let obj = { a: 1 } let value let p = onWatch(obj, (v) => { value = v }, (target, property) => { console.log(`Get '${property}' = ${target[property]}`); }) p.a = 2 // bind `value` to `2` p.a // -> Get 'a' = 2 "},"手撸代码无敌/Promise实现.html":{"url":"手撸代码无敌/Promise实现.html","title":"Promise 实现","keywords":"","body":"Promise 实现 Promise 是 ES6 新增的语法，解决了回调地狱的问题。 可以把 Promise 看成一个状态机。初始是 pending 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化。 then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 then 调用就失去意义了。 对于 then 来说，本质上可以把它看成是 flatMap 根据 Promise / A+ 规范来实现 // 三种状态 const PENDING = \"pending\"; const RESOLVED = \"resolved\"; const REJECTED = \"rejected\"; // promise 接收一个函数参数，该函数会立即执行 function MyPromise(fn) { let _this = this; _this.currentState = PENDING; _this.value = undefined; // 用于保存 then 中的回调，只有当 promise // 状态为 pending 时才会缓存，并且每个实例至多缓存一个 _this.resolvedCallbacks = []; _this.rejectedCallbacks = []; _this.resolve = function (value) { if (value instanceof MyPromise) { // 如果 value 是个 Promise，递归执行 return value.then(_this.resolve, _this.reject) } setTimeout(() => { // 异步执行，保证执行顺序 if (_this.currentState === PENDING) { _this.currentState = RESOLVED; _this.value = value; _this.resolvedCallbacks.forEach(cb => cb()); } }) }; _this.reject = function (reason) { setTimeout(() => { // 异步执行，保证执行顺序 if (_this.currentState === PENDING) { _this.currentState = REJECTED; _this.value = reason; _this.rejectedCallbacks.forEach(cb => cb()); } }) } // 用于解决以下问题 // new Promise(() => throw Error('error)) try { fn(_this.resolve, _this.reject); } catch (e) { _this.reject(e); } } MyPromise.prototype.then = function (onResolved, onRejected) { var self = this; // 规范 2.2.7，then 必须返回一个新的 promise var promise2; // 规范 2.2.onResolved 和 onRejected 都为可选参数 // 如果类型不是函数需要忽略，同时也实现了透传 // Promise.resolve(4).then().then((value) => console.log(value)) onResolved = typeof onResolved === 'function' ? onResolved : v => v; onRejected = typeof onRejected === 'function' ? onRejected : r => throw r; if (self.currentState === RESOLVED) { return (promise2 = new MyPromise(function (resolve, reject) { // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行 // 所以用了 setTimeout 包裹下 setTimeout(function () { try { var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (reason) { reject(reason); } }); })); } if (self.currentState === REJECTED) { return (promise2 = new MyPromise(function (resolve, reject) { setTimeout(function () { // 异步执行onRejected try { var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (reason) { reject(reason); } }); })); } if (self.currentState === PENDING) { return (promise2 = new MyPromise(function (resolve, reject) { self.resolvedCallbacks.push(function () { // 考虑到可能会有报错，所以使用 try/catch 包裹 try { var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (r) { reject(r); } }); self.rejectedCallbacks.push(function () { try { var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (r) { reject(r); } }); })); } }; // 规范 2.3 function resolutionProcedure(promise2, x, resolve, reject) { // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用 if (promise2 === x) { return reject(new TypeError(\"Error\")); } // 规范 2.3.2 // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行 if (x instanceof MyPromise) { if (x.currentState === PENDING) { x.then(function (value) { // 再次调用该函数是为了确认 x resolve 的 // 参数是什么类型，如果是基本类型就再次 resolve // 把值传给下个 then resolutionProcedure(promise2, value, resolve, reject); }, reject); } else { x.then(resolve, reject); } return; } // 规范 2.3.3.3.3 // reject 或者 resolve 其中一个执行过得话，忽略其他的 let called = false; // 规范 2.3.3，判断 x 是否为对象或者函数 if (x !== null && (typeof x === \"object\" || typeof x === \"function\")) { // 规范 2.3.3.2，如果不能取出 then，就 reject try { // 规范 2.3.3.1 let then = x.then; // 如果 then 是函数，调用 x.then if (typeof then === \"function\") { // 规范 2.3.3.3 then.call( x, y => { if (called) return; called = true; // 规范 2.3.3.3.1 resolutionProcedure(promise2, y, resolve, reject); }, e => { if (called) return; called = true; reject(e); } ); } else { // 规范 2.3.3.4 resolve(x); } } catch (e) { if (called) return; called = true; reject(e); } } else { // 规范 2.3.4，x 为基本类型 resolve(x); } } "},"手撸代码无敌/Generator实现.html":{"url":"手撸代码无敌/Generator实现.html","title":"Generator实现","keywords":"","body":"Generator 实现 Generator 是 ES6 中新增的语法，和 Promise 一样，都可以用来异步编程 // 使用 * 表示这是一个 Generator 函数 // 内部可以通过 yield 暂停代码 // 通过调用 next 恢复执行 function* test() { let a = 1 + 2; yield 2; yield 3; } let b = test(); console.log(b.next()); // > { value: 2, done: false } console.log(b.next()); // > { value: 3, done: false } console.log(b.next()); // > { value: undefined, done: true } 从以上代码可以发现，加上 * 的函数执行后拥有了 next 函数，也就是说函数执行后返回了一个对象。每次调用 next 函数可以继续执行被暂停的代码。以下是 Generator 函数的简单实现 // cb 也就是编译过的 test 函数 function generator(cb) { return (function() { var object = { next: 0, stop: function() {} }; return { next: function() { var ret = cb(object); if (ret === undefined) return { value: undefined, done: true }; return { value: ret, done: false }; } }; })(); } // 如果你使用 babel 编译后可以发现 test 函数变成了这样 function test() { var a; return generator(function(_context) { while (1) { switch ((_context.prev = _context.next)) { // 可以发现通过 yield 将代码分割成几块 // 每次执行 next 函数就执行一块代码 // 并且表明下次需要执行哪块代码 case 0: a = 1 + 2; _context.next = 4; return 2; case 4: _context.next = 6; return 3; // 执行完毕 case 6: case \"end\": return _context.stop(); } } }); } "},"手撸代码无敌/call-apply-bind.html":{"url":"手撸代码无敌/call-apply-bind.html","title":"call, apply, bind","keywords":"","body":"call, apply, bind call, apply, bind 区别 首先说下前两者的区别。 call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。 除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。 let a = { value: 1 } function getValue(name, age) { console.log(name) console.log(age) console.log(this.value) } getValue.call(a, 'yck', '24') getValue.apply(a, ['yck', '24']) 模拟实现 call 和 apply 可以从以下几点来考虑如何实现 不传入第一个参数，那么默认为 window 改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？ call Function.prototype.myCall = function (context) { var context = context || window // 给 context 添加一个属性 // getValue.call(a, 'yck', '24') => a.fn = getValue context.fn = this // 将 context 后面的参数取出来 var args = [...arguments].slice(1) // getValue.call(a, 'yck', '24') => a.fn('yck', '24') var result = context.fn(...args) // 删除 fn delete context.fn return result } apply Function.prototype.myApply = function (context) { var context = context || window context.fn = this var result // 需要判断是否存储第二个参数 // 如果存在，就将第二个参数展开 if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } bind bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。 Function.prototype.myBind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } var _this = this var args = [...arguments].slice(1) // 返回一个函数 return function F() { // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) { return new _this(...args, ...arguments) } return _this.apply(context, args.concat(...arguments)) } } "},"手撸代码无敌/curry.html":{"url":"手撸代码无敌/curry.html","title":"curry","keywords":"","body":"深入详解函数的柯里化 深入详解函数的柯里化 简单实现 柯里化的题 柯里化通用式 柯里化与bind 柯里化的特点 柯里化是指这样一个函数(假设叫做createCurry)，他接收函数A作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数。 简单实现 // 简单实现，参数只能从右到左传递 function createCurry(func, args) { var arity = func.length; var args = args || []; return function() { var _args = [].slice.call(arguments); [].push.apply(_args, args); // 如果参数个数小于最初的func.length，则递归调用，继续收集参数 if (_args.length 柯里化的题 // 实现一个add方法，使计算结果能够满足如下预期： add(1)(2)(3) = 6; add(1, 2, 3)(4) = 10; add(1)(2)(3)(4)(5) = 15; 实现 function add() { // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = [].slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var adder = function () { var _adder = function() { // [].push.apply(_args, [].slice.call(arguments)); _args.push(...arguments); return _adder; }; // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () { return _args.reduce(function (a, b) { return a + b; }); } return _adder; } // return adder.apply(null, _args); return adder(..._args); } var a = add(1)(2)(3)(4); // f 10 var b = add(1, 2, 3, 4); // f 10 var c = add(1, 2)(3, 4); // f 10 var d = add(1, 2, 3)(4); // f 10 // 可以利用隐式转换的特性参与计算 console.log(a + 10); // 20 console.log(b + 20); // 30 console.log(c + 30); // 40 console.log(d + 40); // 50 // 也可以继续传入参数，得到的结果再次利用隐式转换参与计算 console.log(a(10) + 100); // 120 console.log(b(10) + 100); // 120 console.log(c(10) + 100); // 120 console.log(d(10) + 100); // 120 柯里化通用式 ar currying = function(fn) { var args = [].slice.call(arguments, 1); return function() { // 主要还是收集所有需要的参数到一个数组中，便于统一计算 var _args = args.concat([].slice.call(arguments)); return fn.apply(null, _args); } } var sum = currying(function() { var args = [].slice.call(arguments); return args.reduce(function(a, b) { return a + b; }) }, 10) console.log(sum(20, 10)); // 40 console.log(sum(10, 5)); // 25 柯里化与bind Object.prototype.bind = function(context) { var _this = this; var args = [].slice.call(arguments, 1); return function() { return _this.apply(context, args) } } 柯里化的特点 接收单一参数，将更多的参数通过回调函数来搞定 返回一个新函数，用于处理所有的想要传入的参数； 需要利用call/apply与arguments对象收集参数； 返回的这个函数正是用来处理收集起来的参数。 "},"手撸代码无敌/Template.html":{"url":"手撸代码无敌/Template.html","title":"Template","keywords":"","body":"一行代码实现一个简单的模板字符串替换 一行代码实现一个简单的模板字符串替换 起始 实现 1. 基本实现(有缺陷) 2. 基本实现 3. 基本实现 +1 4. 实现完整 for/in 循环获取 obj 的 key 值 、 Object.key()、 Object.getOwnPropertyNames()、 Reflect.ownKeys()区别 demo 理解 最后实现 MDN str.replace(regexp|substr, newSubStr|function) 实现code 分析 起始 主要是思路，可以使用 ES6 语法模拟 ES6的模板字符串的这个功能。后端返回的一般都是 JSON 的数据格式，所以我们按照下面的规则进行模拟。 需求描述 实现一个 render(template, context) 方法，将 template 中的占位符用 context 填充。 要求： 不需要有控制流成分（如 循环、条件 等等），只要有变量替换功能即可级联的变量也可以展开被转义的的分隔符 { 和 } 不应该被渲染，分隔符与变量之间允许有空白字符 var obj = {name:\"二月\",age:\"15\"}; var str = \"{{name}}很厉害，才{{age}}岁\"; // 输出：二月很厉害，才15岁。 实现 1. 基本实现(有缺陷) let str = \"{{name}}很厉害，才{{age}}岁\" let obj = {name: '二月', age: 15} function test(str, obj){ let _s = str.replace(/\\{\\{(\\w+)\\}\\}/g, '$1') let result for(let k in obj) { _s = _s.replace(new RegExp(k, 'g'), obj[k]) } return _s } const s = test(str, obj) 最基本的是实现了，但是代码还是有很多问题没考虑到，首先 Object 的 key 值不一定只是 \\w， 还有就是如果字符串是这种的： let str = \"{{name}}很name厉害，才{{age}}岁\"` 会输出 ：二月很厉害二月害，才15岁 思路 代码的作用目标是 str，先用正则匹配出 和，然后用分组获取括号的 name,age,最后用 replace 方法把 和 替换成 name 和 age，最后字符串就成了 name很name厉害，才age岁，最后 for in 循环的时候才导致一起都被替换掉了。 用 for in 循环完全没必要，能不用 for in 尽量不要用 for in，for in 会遍历自身以及原型链所有的属性。 2. 基本实现 var str = \"{{name}}很厉害，才{{age}}岁\"; var str2 = \"{{name}}很厉name害，才{{age}}岁{{name}}\"; var obj = {name: '周杰伦', age: 15}; function fun(str, obj) { var arr; arr = str.match(/{{[a-zA-Z\\d]+}}/g); for(var i=0;i 3. 基本实现 +1 function a(str, obj) { var str1 = str; for (var key in obj) { var re = new RegExp(\"{{\" + key + \"}}\", \"g\"); str1 = str1.replace(re, obj[key]); } console.log(str1); } const str = \"{{name}}很厉name害{{name}}，才{{age}}岁\"; const obj = { name: \"jawil\", age: \"15\" }; a(str, obj); 把 obj 的 key 值遍历，然后拼成 ，最后用 `obj[key]` 也就是 `value` 把 整个给替换了 4. 实现完整 function parseString(str, obj) { Object.keys(obj).forEach(key => { str = str.replace(new RegExp(`{{${key}}}`,'g'), obj[key]); }); return str; } const str = \"{{name}}很厉name害{{name}}，才{{age}}岁\"; const obj = { name: \"jawil\", age: \"15\" }; console.log(parseString(str, obj)); 没用 for...in 循环就是为了考虑不必要的循环，因为 for...in 循环会遍历原型链所有的可枚举属性，造成不必要的循环。 for/in 循环获取 obj 的 key 值 、 Object.key()、 Object.getOwnPropertyNames()、 Reflect.ownKeys()区别 for...in循环：会遍历对象自身的属性，以及原型属性，for...in 循环只遍历可枚举(不包括 enumerable为 false )属性。像 Array 和 Object 使用内置构造函数所创建的对象都会继承自 Object.prototype 和 String.prototype 的不可枚举属性; Object.key()：可以得到自身可枚举的属性,但得不到原型链上的属性; Object.getOwnPropertyNames()：可以得到自身所有的属性(包括不可枚举),但得不到原型链上的属性, Symbols 属性也得不到. Reflect.ownKeys()：该方法用于返回对象的所有属性，基本等同于 Object.getOwnPropertyNames() 与 Object.getOwnPropertySymbols 之和。 demo 理解 const parent = { a: 1, b: 2, c: 3 }; const child = { d: 4, e: 5, [Symbol()]: 6 }; child.__proto__ = parent; Object.defineProperty(child, \"d\", { enumerable: false }); for (var attr in child) { console.log(\"for...in:\", attr);// a,b,c,e } console.log(\"Object.keys:\", Object.keys(child));// [ 'e' ] console.log(\"Object.getOwnPropertyNames:\", Object.getOwnPropertyNames(child)); // [ 'd', 'e' ] console.log(\"Reflect.ownKeys:\", Reflect.ownKeys(child)); // [ 'd', 'e', Symbol() ] 最后实现 MDN str.replace(regexp|substr, newSubStr|function) 通过 MDN 文档里面写的 str.replace(regexp|substr, newSubStr|function) ，我们可以发现 replace 方法可以传入 function 回调函数， function (replacement) 一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果 参考这个指定一个函数作为参数。 你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后， 该函数就会执行。 函数的返回值作为替换字符串。 (注意: 上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是， 如果第一个参数是正则表达式， 并且其为全局匹配模式， 那么这个方法将被多次调用， 每次匹配都会被调用。 下面是该函数的参数： 变量名 代表的值 match 匹配的子串。（对应于上述的$&。） p1,p2, ... 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）例如, 如果是用 /(\\a+)(\\b+)/这个来匹配， p1就是匹配的 \\a+, p2 就是匹配的 \\b+。 offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） string 被匹配的原字符串。 (精确的参数个数依赖于replace()的第一个参数是否是一个正则表达式对象， 以及这个正则表达式中指定了多少个括号子串。) 下面的例子将会使 newString 变成'abc - 12345 - #$*%'： function replacer(match, p1, p2, p3, offset, string) { // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(' - '); } var newString = 'abc12345#$*%'.replace(/([^\\d]*)(\\d*)([^\\w]*)/, replacer); console.log(newString); // abc - 12345 - #$*% 依据上边最终实现 function render(template, context) { return template.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => context[key]); } const template = \"{{name}}很厉name害，才{{age}}岁\"; const context = { name: \"jawil\", age: \"15\" }; console.log(render(template, context)); 实现code function render(template, context) { return template.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => context[key]); } // 最终挂到String String.prototype.render = function (context) { return this.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => context[key.trim()]); }; 分析 该函数的返回值(obj[key]=jawil)将替换掉第一个参数(match==)匹配到的结果。 简单分析一下：.*? 是正则固定搭配用法，表示非贪婪匹配模式，尽可能匹配少的，什么意思呢？举个简单的例子。 举个🌰： 源字符串：aatest1bbtest2cc 正则表达式一：.* 匹配结果一：test1bbtest2 正则表达式二：.*? 匹配结果二：test1（这里指的是一次匹配结果，不使用/g，所以没包括test2） 所以：正则匹配到，分组获取 `name`，然后把 替换成 obj[name](jawil) 发现还有一个小问题，如果有空格的话就会匹配失败，类似这种写法： const template = \"{{name }}很厉name害，才{{age }}岁\"; 所以在上面的基础上还要去掉空格，其实也很简单，用正则或者 String.prototype.trim() 方法都行 function render(template, context) { return template.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => context[key.trim()]); } const template = \"{{name }}很厉name害，才{{age }}岁\"; const context = { name: \"jawil\", age: \"15\" }; console.log(render(template, context)); 将函数挂到 String 的原型链，得到最终版本 甚至，我们可以通过修改原型链，实现一些很酷的效果： String.prototype.render = function (context) { return this.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => context[key.trim()]); }; 如果{}中间不是数字，则{}本身不需要转义，所以最终最简洁的代码： String.prototype.render = function (context) { return this.replace(/{{(.*?)}}/g, (match, key) => context[key.trim()]); }; 之后，我们便可以这样调用啦： \"{{name}}很厉name害，才{{ age }}岁\".render({ name: \"jawil\", age: \"15\" }); "},"手撸代码无敌/封装Ajax和Promise.html":{"url":"手撸代码无敌/封装Ajax和Promise.html","title":"封装Ajax和Promise","keywords":"","body":"封装Ajax 和 Promise 原生js (一) function getJSON(url) { return new Promise(function(resolve, reject) { var XHR = new XMLHttpRequest(); XHR.open('GET', url, true); XHR.send(); XHR.onreadystatechange = function() { if (XHR.readyState == 4) { if (XHR.status == 200) { try { var response = JSON.parse(XHR.responseText); resolve(response); } catch (e) { reject(e); } } else { reject(new Error(XHR.statusText)); } } } }) } getJSON(url).then(resp => console.log(resp)); 原生js (二) // (原生js)封装Promise对象二 var jsGetAjaxPromise = function(param){ return new Promise(function(resolve, reject ){ var xhr = new XMLHttpRequest(); xhr.open('get', param.url, true); xhr.onload = resolve; xhr.onerror = reject; xhr.send(); }) } // 调用示例 var p1 = jsGetAjaxPromise({ // 启动第一个任务 url: 'cross-domain1.txt' // 要获取的文件地址 }); p1.then(function(response){ // 处理第一个异步任务的结果(每次调用then都会返回一个新创建的Promise对象) console.log(response); return jsGetAjaxPromise({ // 启动第二个任务 url: 'cross-domain2.txt' }) }).then(function(response2){ // 处理第二个任务的结果 console.log(response2); return jsGetAjaxPromise({ // 启动第三个任务 url: 'cross-domain3.txt' }) }).then(function(response3){ // 处理第二个任务的结果 console.log(response3); }).catch(function(err){ console.log(err); }); 改写成jquery实现 // (jquery)封装Promise对象和ajax过程 var jqGetAjaxPromise = function(param){ return new Promise(function(resolve, reject){ $.ajax({ url: param.url, type: 'get', data: param.data || '', success: function(data){ resolve(data); }, error: function(error){ reject(error) } }); }); }; // 调用示例 var p2 = jqGetAjaxPromise({ url: 'cross-domain1.txt' }); p2.then(function(data){ console.log(data); return jqGetAjaxPromise({ url:'cross-domain2.txt' }); }).then(function(data2){ console.log(data2); }).catch(function(err){ console.log(err); }); axios function myGet(url, params) { return new Promise((resolve, reject) => { axios.get(url, params).then(function (response) { resolve(response.data) }) .catch(function (err) { reject(err) }) }) } myGet(url,params).then(function(data){console.log(data)}).catch(function(){}) XMLHttpRequest 的 readystatechange 事件和 load 事件的区别 分别在 onreadystatechange 和 onload 里写入代码： xhr.onload = function () { console.log(`load:xhr.readyState == ${xhr.readyState} ,xhr.status=${xhr.status}`); } xhr.onreadystatechange = function () { console.log(`readystatechange:xhr.readyState == ${xhr.readyState} ,xhr.status=${xhr.status}`); } xhr.open(...); xhr.send(...); 输出结果如下： readystatechange : xhr.readyState == 1 ,xhr.status=200 readystatechange : xhr.readyState == 2 ,xhr.status=200 readystatechange : xhr.readyState == 3 ,xhr.status=200 readystatechange : xhr.readyState == 4 ,xhr.status=200 load : xhr.readyState == 4 ,xhr.status=200 可以看到，readystatechange 事件先于 load 事件执行。load 事件就相当于 readyState 的值为 4 后触发的事件。如果不需要跟踪请求返回之前的过程时，用 load 事件更省事儿。 然而... load 事件并不总是被触发。比如当网络错误时，目标地址访问不了时，会触发 error 事件，load 事件就不会被触发。404 之类的错误只是服务器返回的状态代码，并不是请求过程错误，所以 load 事件会触发，而 error 事件反而不会触发。 如果需要无论哪种情况都被触发的话，请用 loadend 事件。 OK！既然有 loadend 事件，当然还会有 loadstart 事件！ 这些事件的触发顺序是： readystatechange > loadstart > readystatechange > readystatechange > progress > readystatechange > load / error > loadend readystatechange 每次触发时 readyState 值不同。 "},"手撸代码无敌/js-tree.html":{"url":"手撸代码无敌/js-tree.html","title":"js-tree","keywords":"","body":"js 无限分类递归树 js数据集生成tree var data = [ { id: 1, name: \"一级分类：1\", pid: 0, }, { id: 2, name: \"二级分类：1\", pid: 1, }, { id: 3, name: \"三级分类：3\", pid: 2, }, { id: 4, name: \"一级分类：2\", pid: 0, }, { id: 7, name: \"f级分类：2\", pid: 4, }, { id: 10, name: \"f级分类：2\", pid: 7, }, { id: 9, name: \"f级分类：2\", pid: 10, }, { id: 12, name: \"f级分类：2\", pid: 9, }, { id: 15, name: \"f级分类：2\", pid: 12, }, { id: 13, name: \"f级分类：2\", pid: 15, }, ]; function toTree(data) { // 删除 所有 children,以防止多次调用 data.forEach(function (item) { delete item.children; }); // 将数据存储为 以 id 为 KEY 的 map 索引数据列 var map = {}; data.forEach(function (item) { map[item.id] = item; }); // console.log(map); var val = []; data.forEach(function (item) { // 以当前遍历项，的pid,去map对象中找到索引的id var parent = map[item.pid]; // 好绕啊，如果找到索引，那么说明此项不在顶级当中,那么需要把此项添加到，他对应的父级中 if (parent) { (parent.children || ( parent.children = [] )).push(item); } else { //如果没有在map中找到对应的索引ID,那么直接把 当前的item添加到 val结果集中，作为顶级 val.push(item); } }); return val; } console.log(toTree(data)) js 对象数组 根据某个共同字段 分组 var arr = [ {\"id\":\"1001\", \"name\":\"值1\", \"value\":\"111\" }, {\"id\":\"1001\", \"name\":\"值1\", \"value\":\"11111\"}, {\"id\":\"1002\", \"name\":\"值2\", \"value\":\"25462\"}, {\"id\":\"1002\", \"name\":\"值2\", \"value\":\"23131\"}, {\"id\":\"1002\", \"name\":\"值2\", \"value\":\"2315432\"}, {\"id\":\"1003\", \"name\":\"值3\", \"value\":\"333333\"} ]; var getTree = arr => { let map = {}, result = []; for(let i = 0; i work instance const { groupids } = this.props.orgDepartment; const provinceOptions = [], cityData = [], cityOptions = []; const getStationCities = arr => { let obj = {}, result = []; for(let i = 0, len = arr.length; i "},"React/React基础/react基础.html":{"url":"React/React基础/react基础.html","title":"React基础","keywords":"","body":"React 基础 reactjs 获取真实dom，并获取dom css 三种方法 方法1： let senderName = ReactDOM.findDOMNode(this.refs['sender-name']); let nleft = senderName.style.left; let ntop = senderName.style.top; let nwidth = senderName.style.width; let nheight = senderName.style.height; console.log(nleft,ntop,nwidth,nheight); 方法2： let rstyle = this.refs['sender-name'].style; let rleft = rstyle.left; let rtop = rstyle.top; let rwidth = rstyle.width; let rheight = rstyle.height; console.log(rleft,rtop,rwidth,rheight); 方法3： let computedStyle=document.defaultView.getComputedStyle(ReactDOM.findDOMNode(this.refs['sender-name']),null); let cleft = computedStyle.left; let ctop = computedStyle.top; console.log(cleft,ctop); "},"React/React基础/React生命周期分析.html":{"url":"React/React基础/React生命周期分析.html","title":"React生命周期分析","keywords":"","body":"React 生命周期分析 V16 生命周期函数用法建议 在 V16 版本中引入了 Fiber 机制。这个机制一定程度上的影响了部分生命周期的调用，并且也引入了新的 2 个 API 来解决问题。 在之前的版本中，如果你拥有一个很复杂的复合组件，然后改动了最上层组件的 state，那么调用栈可能会很长 调用栈过长，再加上中间进行了复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。Fiber 就是为了解决该问题而生。 Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。 对于如何区别优先级，React 有自己的一套逻辑。对于动画这种实时性很高的东西，也就是 16 ms 必须渲染一次保证不卡顿的情况下，React 会每 16 ms（以内） 暂停一下更新，返回来继续渲染动画。 对于异步渲染，现在渲染有两个阶段：reconciliation 和 commit 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。 Reconciliation 阶段 componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate Commit 阶段 componentDidMount componentDidUpdate componentWillUnmount 因为 reconciliation 阶段是可以被打断的，所以 reconciliation 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 Bug。所以对于 reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 以外，其他都应该避免去使用，并且 V16 中也引入了新的 API 来解决这个问题。 getDerivedStateFromProps 用于替换 componentWillReceiveProps ，该函数会在初始化和 update 时被调用 class ExampleComponent extends React.Component { // Initialize state in constructor, // Or with a property initializer. state = {} static getDerivedStateFromProps(nextProps, prevState) { if (prevState.someMirroredValue !== nextProps.someValue) { return { derivedData: computeDerivedState(nextProps), someMirroredValue: nextProps.someValue } } // Return null to indicate no change to state. return null } } getSnapshotBeforeUpdate 用于替换 componentWillUpdate ，该函数会在 update 后 DOM 更新前被调用，用于读取最新的 DOM 数据。 V16 生命周期函数用法建议 class ExampleComponent extends React.Component { // 用于初始化 state constructor() {} // 用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用 // 因为该函数是静态函数，所以取不到 `this` // 如果需要对比 `prevProps` 需要单独在 `state` 中维护 static getDerivedStateFromProps(nextProps, prevState) {} // 判断是否需要更新组件，多用于组件性能优化 shouldComponentUpdate(nextProps, nextState) {} // 组件挂载后调用 // 可以在该函数中进行请求或者订阅 componentDidMount() {} // 用于获得最新的 DOM 数据 getSnapshotBeforeUpdate() {} // 组件即将销毁 // 可以在此处移除订阅，定时器等等 componentWillUnmount() {} // 组件销毁后调用 componentDidUnMount() {} // 组件更新后调用 componentDidUpdate() {} // 渲染组件函数 render() {} // 以下函数不建议使用 UNSAFE_componentWillMount() {} UNSAFE_componentWillUpdate(nextProps, nextState) {} UNSAFE_componentWillReceiveProps(nextProps) {} } "},"React/React基础/setState.html":{"url":"React/React基础/setState.html","title":"setState","keywords":"","body":"setState setState 在 React 中是经常使用的一个 API，但是它存在一些问题，可能会导致犯错，核心原因就是因为这个 API 是异步的。 首先 setState 的调用并不会马上引起 state 的改变，并且如果你一次调用了多个 setState ，那么结果可能并不如你期待的一样。 handle() { // 初始化 `count` 为 0 console.log(this.state.count) // -> 0 this.setState({ count: this.state.count + 1 }) this.setState({ count: this.state.count + 1 }) this.setState({ count: this.state.count + 1 }) console.log(this.state.count) // -> 0 } 第一，两次的打印都为 0，因为 setState 是个异步 API，只有同步代码运行完毕才会执行。setState 异步的原因我认为在于，setState 可能会导致 DOM 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。 第二，虽然调用了三次 setState ，但是 count 的值还是为 1。因为多次调用会合并为一次，只有当更新结束后 state 才会改变，三次调用等同于如下代码 Object.assign( {}, { count: this.state.count + 1 }, { count: this.state.count + 1 }, { count: this.state.count + 1 } ) 当然也可以通过以下方式来实现调用三次 setState 使得 count 为 3 handle() { this.setState((prevState) => ({ count: prevState.count + 1 })) this.setState((prevState) => ({ count: prevState.count + 1 })) this.setState((prevState) => ({ count: prevState.count + 1 })) } 如果想在每次调用 setState 后获得正确的 state ，可以通过如下代码实现 handle() { this.setState((prevState) => ({ count: prevState.count + 1 }), () => { console.log(this.state) }) } "},"React/dva/React+DvaJS之hook路由权限控制.html":{"url":"React/dva/React+DvaJS之hook路由权限控制.html","title":"React+DvaJS 之 hook 路由权限控制","keywords":"","body":"React+DvaJS 之 hook 路由权限控制 在model的subscriptions中进行匹配，分发到effects中进行判断和跳转 effects 有三个参数: put 用于触发 action 。 yield put({ type: 'todos/add', payload: 'Learn Dva' }); call 用于调用异步逻辑，支持 promise 。 const result = yield call(fetch, '/todos'); select 用于从 state 里获取数据。 const todos = yield select(state => state.todos); 基于 action 进行页面跳转 import { routerRedux } from 'dva/router'; // Inside Effects yield put(routerRedux.push('/logout')); // Outside Effects dispatch(routerRedux.push('/logout')); // With query routerRedux.push({ pathname: '/logout', query: { page: 2, }, }); 除 push(location) 外还有更多方法，详见这里 示例如下： state: { isLogin: false, loginfail:false, }, subscriptions: { setup({ dispatch, history }) { history.listen(location => { if (location.pathname.includes('app')) { dispatch({ type: 'loginhook', }); } }); }, }, effects: { * login({ payload },{call, put}) { const { data } = yield call(login, payload); if (data && data.success) { yield put({ type: 'checklogin', payload:{ isLogin:true, } }); yield put(routerRedux.push('/app/users')); }else{ yield put({ type: 'loginfail', payload:{ loginfail:true, } }); } }, * loginhook({ payload },{select,call, put}){ const isLogin = yield select(({session}) => session.isLogin); console.log('logincheck',isLogin); if(isLogin === false){ yield put((routerRedux.push('/login'))); } }, }, reducers: { checklogin(state,action) { return {...state,isLogin:action.payload.isLogin }; }, loginfail(state,action) { return {...state, loginfail:action.payload.loginfail}; }, } "},"React/源码分析/Redux源码分析.html":{"url":"React/源码分析/Redux源码分析.html","title":"Redux源码分析","keywords":"","body":"Redux 源码分析 首先让我们来看下 combineReducers 函数 // 传入一个 object export default function combineReducers(reducers) { // 获取该 Object 的 key 值 const reducerKeys = Object.keys(reducers) // 过滤后的 reducers const finalReducers = {} // 获取每一个 key 对应的 value // 在开发环境下判断值是否为 undefined // 然后将值类型是函数的值放入 finalReducers for (let i = 0; i combineReducers 函数总的来说很简单，总结来说就是接收一个对象，将参数过滤后返回一个函数。该函数里有一个过滤参数后的对象 finalReducers，遍历该对象，然后执行对象中的每一个 reducer 函数，最后将新的 state 返回。 接下来让我们来看看 combinrReducers 中用到的两个函数 // 这是执行的第一个用于抛错的函数 function assertReducerShape(reducers) { // 将 combineReducers 中的参数遍历 Object.keys(reducers).forEach(key => { const reducer = reducers[key] // 给他传入一个 action const initialState = reducer(undefined, { type: ActionTypes.INIT }) // 如果得到的 state 为 undefined 就抛错 if (typeof initialState === 'undefined') { throw new Error( `Reducer \"${key}\" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined. If you don't want to set a value for this reducer, ` + `you can use null instead of undefined.` ) } // 再过滤一次，考虑到万一你在 reducer 中给 ActionTypes.INIT 返回了值 // 传入一个随机的 action 判断值是否为 undefined const type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random() .toString(36) .substring(7) .split('') .join('.') if (typeof reducer(undefined, { type }) === 'undefined') { throw new Error( `Reducer \"${key}\" returned undefined when probed with a random type. ` + `Don't try to handle ${ ActionTypes.INIT } or other actions in \"redux/*\" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined, but can be null.` ) } }) } function getUnexpectedStateShapeWarningMessage( inputState, reducers, action, unexpectedKeyCache ) { // 这里的 reducers 已经是 finalReducers const reducerKeys = Object.keys(reducers) const argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer' // 如果 finalReducers 为空 if (reducerKeys.length === 0) { return ( 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.' ) } // 如果你传入的 state 不是对象 if (!isPlainObject(inputState)) { return ( `The ${argumentName} has unexpected type of \"` + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + `\". Expected argument to be an object with the following ` + `keys: \"${reducerKeys.join('\", \"')}\"` ) } // 将参入的 state 于 finalReducers 下的 key 做比较，过滤出多余的 key const unexpectedKeys = Object.keys(inputState).filter( key => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key] ) unexpectedKeys.forEach(key => { unexpectedKeyCache[key] = true }) if (action && action.type === ActionTypes.REPLACE) return // 如果 unexpectedKeys 有值的话 if (unexpectedKeys.length > 0) { return ( `Unexpected ${unexpectedKeys.length > 1 ? 'keys' : 'key'} ` + `\"${unexpectedKeys.join('\", \"')}\" found in ${argumentName}. ` + `Expected to find one of the known reducer keys instead: ` + `\"${reducerKeys.join('\", \"')}\". Unexpected keys will be ignored.` ) } } 接下来让我们先来看看 compose 函数 // 这个函数设计的很巧妙，通过传入函数引用的方式让我们完成多个函数的嵌套使用，术语叫做高阶函数 // 通过使用 reduce 函数做到从右至左调用函数 // 对于上面项目中的例子 compose( applyMiddleware(thunkMiddleware), window.devToolsExtension ? window.devToolsExtension() : f => f ) // 经过 compose 函数变成了 applyMiddleware(thunkMiddleware)(window.devToolsExtension()()) // 所以在找不到 window.devToolsExtension 时你应该返回一个函数 export default function compose(...funcs) { if (funcs.length === 0) { return arg => arg } if (funcs.length === 1) { return funcs[0] } return funcs.reduce((a, b) => (...args) => a(b(...args))) } 然后我们来解析 createStore 函数的部分代码 export default function createStore(reducer, preloadedState, enhancer) { // 一般 preloadedState 用的少，判断类型，如果第二个参数是函数且没有第三个参数，就调换位置 if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') { enhancer = preloadedState preloadedState = undefined } // 判断 enhancer 是否是函数 if (typeof enhancer !== 'undefined') { if (typeof enhancer !== 'function') { throw new Error('Expected the enhancer to be a function.') } // 类型没错的话，先执行 enhancer，然后再执行 createStore 函数 return enhancer(createStore)(reducer, preloadedState) } // 判断 reducer 是否是函数 if (typeof reducer !== 'function') { throw new Error('Expected the reducer to be a function.') } // 当前 reducer let currentReducer = reducer // 当前状态 let currentState = preloadedState // 当前监听函数数组 let currentListeners = [] // 这是一个很重要的设计，为的就是每次在遍历监听器的时候保证 currentListeners 数组不变 // 可以考虑下只存在 currentListeners 的情况，如果我在某个 subscribe 中再次执行 subscribe // 或者 unsubscribe，这样会导致当前的 currentListeners 数组大小发生改变，从而可能导致 // 索引出错 let nextListeners = currentListeners // reducer 是否正在执行 let isDispatching = false // 如果 currentListeners 和 nextListeners 相同，就赋值回去 function ensureCanMutateNextListeners() { if (nextListeners === currentListeners) { nextListeners = currentListeners.slice() } } // ...... } 接下来先来介绍 applyMiddleware 函数 在这之前我需要先来介绍一下函数柯里化，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。 function add(a,b) { return a + b } add(1, 2) => 3 // 对于以上函数如果使用柯里化可以这样改造 function add(a) { return b => { return a + b } } add(1)(2) => 3 // 你可以这样理解函数柯里化，通过闭包保存了外部的一个变量， // 然后返回一个接收参数的函数，在该函数中使用了保存的变量， // 然后再返回值。 // 这个函数应该是整个源码中最难理解的一块了 // 该函数返回一个柯里化的函数 // 所以调用这个函数应该这样写 applyMiddleware(...middlewares)(createStore)(...args) export default function applyMiddleware(...middlewares) { return createStore => (...args) => { // 这里执行 createStore 函数，把 applyMiddleware 函数最后次调用的参数传进来 const store = createStore(...args) let dispatch = () => { throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) } let chain = [] // 每个中间件都应该有这两个函数 const middlewareAPI = { getState: store.getState, dispatch: (...args) => dispatch(...args) } // 把 middlewares 中的每个中间件都传入 middlewareAPI chain = middlewares.map(middleware => middleware(middlewareAPI)) // 和之前一样，从右至左调用每个中间件，然后传入 store.dispatch dispatch = compose(...chain)(store.dispatch) // 这里只看这部分代码有点抽象，我这里放入 redux-thunk 的代码来结合分析 // createThunkMiddleware返回了3层函数，第一层函数接收 middlewareAPI 参数 // 第二次函数接收 store.dispatch // 第三层函数接收 dispatch 中的参数 {function createThunkMiddleware(extraArgument) { return ({ dispatch, getState }) => next => action => { // 判断 dispatch 中的参数是否为函数 if (typeof action === 'function') { // 是函数的话再把这些参数传进去，直到 action 不为函数，执行 dispatch({tyep: 'XXX'}) return action(dispatch, getState, extraArgument); } return next(action); }; } const thunk = createThunkMiddleware(); export default thunk;} // 最后把经过中间件加强后的 dispatch 于剩余 store 中的属性返回，这样你的 dispatch return { ...store, dispatch } } } 好了，我们现在将困难的部分都攻克了，来看一些简单的代码 // 这个没啥好说的，就是把当前的 state 返回，但是当正在执行 reducer 时不能执行该方法 function getState() { if (isDispatching) { throw new Error( 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.' ) } return currentState } // 接收一个函数参数 function subscribe(listener) { if (typeof listener !== 'function') { throw new Error('Expected listener to be a function.') } // 这部分最主要的设计 nextListeners 已经讲过，其他基本没什么好说的 if (isDispatching) { throw new Error( 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See http://redux.js.org/docs/api/Store.html##subscribe for more details.' ) } let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) // 返回一个取消订阅函数 return function unsubscribe() { if (!isSubscribed) { return } if (isDispatching) { throw new Error( 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See http://redux.js.org/docs/api/Store.html##subscribe for more details.' ) } isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) } } function dispatch(action) { // 原生的 dispatch 会判断 action 是否为对象 if (!isPlainObject(action)) { throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) } if (typeof action.type === 'undefined') { throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ) } // 注意在 Reducers 中是不能执行 dispatch 函数的 // 因为你一旦在 reducer 函数中执行 dispatch，会引发死循环 if (isDispatching) { throw new Error('Reducers may not dispatch actions.') } // 执行 combineReducers 组合后的函数 try { isDispatching = true currentState = currentReducer(currentState, action) } finally { isDispatching = false } // 然后遍历 currentListeners，执行数组中保存的函数 const listeners = (currentListeners = nextListeners) for (let i = 0; i "},"Vue/vueRouter使用query和params传参的使用和区别.html":{"url":"Vue/vueRouter使用query和params传参的使用和区别.html","title":"vueRouter使用query和params传参的使用和区别","keywords":"","body":"vueRouter使用query和params传参的使用和区别 基础 router-link跳转router1 params：/router1/:id ，/router1/123，/router1/789 ,这里的id叫做params query：/router1?id=123 ,/router1?id=456 ,这里的id叫做query。 params传参和query传参有什么区别： 用法上的刚query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。注意接收参数的时候，已经是$route而不是$router了哦！！ 展示上的query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示 params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。params一旦设置在路由，params就是路由的一部分，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。 比如：跳转/router1/:id 正确 错误 params、query不设置也可以传参，params不设置的时候，刷新页面或者返回参数会丢失，这一点的在上面说过了 "},"Vue/NextTick原理分析.html":{"url":"Vue/NextTick原理分析.html","title":"NextTick原理分析","keywords":"","body":"NextTick 原理分析 nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。 在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。 对于实现 macrotasks ，会先判断是否能使用 setImmediate ，不能的话降级为 MessageChannel ，以上都不行的话就使用 setTimeout if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) { macroTimerFunc = () => { setImmediate(flushCallbacks) } } else if ( typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) || // PhantomJS MessageChannel.toString() === '[object MessageChannelConstructor]') ) { const channel = new MessageChannel() const port = channel.port2 channel.port1.onmessage = flushCallbacks macroTimerFunc = () => { port.postMessage(1) } } else { /* istanbul ignore next */ macroTimerFunc = () => { setTimeout(flushCallbacks, 0) } } nextTick 同时也支持 Promise 的使用，会判断是否实现了 Promise export function nextTick(cb?: Function, ctx?: Object) { let _resolve // 将回调函数整合进一个数组中 callbacks.push(() => { if (cb) { try { cb.call(ctx) } catch (e) { handleError(e, ctx, 'nextTick') } } else if (_resolve) { _resolve(ctx) } }) if (!pending) { pending = true if (useMacroTask) { macroTimerFunc() } else { microTimerFunc() } } // 判断是否可以使用 Promise // 可以的话给 _resolve 赋值 // 这样回调函数就能以 promise 的方式调用 if (!cb && typeof Promise !== 'undefined') { return new Promise(resolve => { _resolve = resolve }) } } "},"Vue/Vue生命周期.html":{"url":"Vue/Vue生命周期.html","title":"Vue生命周期分析","keywords":"","body":"生命周期分析 生命周期函数就是组件在初始化或者数据更新时会触发的钩子函数。 在初始化时，会调用以下代码，生命周期就是通过 callHook 调用的 Vue.prototype._init = function(options) { initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') // 拿不到 props data initInjections(vm) initState(vm) initProvide(vm) callHook(vm, 'created') } 可以发现在以上代码中，beforeCreate 调用的时候，是获取不到 props 或者 data 中的数据的，因为这些数据的初始化都在 initState 中。 接下来会执行挂载函数 export function mountComponent { callHook(vm, 'beforeMount') // ... if (vm.$vnode == null) { vm._isMounted = true callHook(vm, 'mounted') } } beforeMount 就是在挂载前执行的，然后开始创建 VDOM 并替换成真实 DOM，最后执行 mounted 钩子。这里会有个判断逻辑，如果是外部 new Vue({}) 的话，不会存在 $vnode ，所以直接执行 mounted 钩子了。如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。 接下来是数据更新时会调用的钩子函数 function flushSchedulerQueue() { // ... for (index = 0; index MAX_UPDATE_COUNT) { warn( 'You may have an infinite update loop ' + (watcher.user ? `in watcher with expression \"${watcher.expression}\"` : `in a component render function.`), watcher.vm ) break } } } callUpdatedHooks(updatedQueue) } function callUpdatedHooks(queue) { let i = queue.length while (i--) { const watcher = queue[i] const vm = watcher.vm if (vm._watcher === watcher && vm._isMounted) { callHook(vm, 'updated') } } } 上图还有两个生命周期没有说，分别为 activated 和 deactivated ，这两个钩子函数是 keep-alive 组件独有的。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。 最后就是销毁组件的钩子函数了 Vue.prototype.$destroy = function() { // ... callHook(vm, 'beforeDestroy') vm._isBeingDestroyed = true // remove self from parent const parent = vm.$parent if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) { remove(parent.$children, vm) } // teardown watchers if (vm._watcher) { vm._watcher.teardown() } let i = vm._watchers.length while (i--) { vm._watchers[i].teardown() } // remove reference from data ob // frozen object may not have observer. if (vm._data.__ob__) { vm._data.__ob__.vmCount-- } // call the last hook... vm._isDestroyed = true // invoke destroy hooks on current rendered tree vm.__patch__(vm._vnode, null) // fire destroyed hook callHook(vm, 'destroyed') // turn off all instance listeners. vm.$off() // remove __vue__ reference if (vm.$el) { vm.$el.__vue__ = null } // release circular reference (##6759) if (vm.$vnode) { vm.$vnode.parent = null } } 在执行销毁操作前会调用 beforeDestroy 钩子函数，然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 destroyed 钩子函数。 "},"Vue/VueRouter源码分析.html":{"url":"Vue/VueRouter源码分析.html","title":"VueRouter源码分析","keywords":"","body":"VueRouter 源码解析 VueRouter 源码解析 路由注册 VueRouter 实例化 创建路由匹配对象 路由初始化 路由跳转 路由注册 使用路由之前，需要调用 Vue.use(VueRouter)，这是因为让插件可以使用 Vue export function initUse(Vue: GlobalAPI) { Vue.use = function(plugin: Function | Object) { // 判断重复安装插件 const installedPlugins = this._installedPlugins || (this._installedPlugins = []) if (installedPlugins.indexOf(plugin) > -1) { return this } const args = toArray(arguments, 1) // 插入 Vue args.unshift(this) // 一般插件都会有一个 install 函数 // 通过该函数让插件可以使用 Vue if (typeof plugin.install === 'function') { plugin.install.apply(plugin, args) } else if (typeof plugin === 'function') { plugin.apply(null, args) } installedPlugins.push(plugin) return this } } 接下来看下 install 函数的部分实现 export function install(Vue) { // 确保 install 调用一次 if (install.installed && _Vue === Vue) return install.installed = true // 把 Vue 赋值给全局变量 _Vue = Vue const registerInstance = (vm, callVal) => { let i = vm.$options._parentVnode if ( isDef(i) && isDef((i = i.data)) && isDef((i = i.registerRouteInstance)) ) { i(vm, callVal) } } // 给每个组件的钩子函数混入实现 // 可以发现在 `beforeCreate` 钩子执行时 // 会初始化路由 Vue.mixin({ beforeCreate() { // 判断组件是否存在 router 对象，该对象只在根组件上有 if (isDef(this.$options.router)) { // 根路由设置为自己 this._routerRoot = this this._router = this.$options.router // 初始化路由 this._router.init(this) // 很重要，为 _route 属性实现双向绑定 // 触发组件渲染 Vue.util.defineReactive(this, '_route', this._router.history.current) } else { // 用于 router-view 层级判断 this._routerRoot = (this.$parent && this.$parent._routerRoot) || this } registerInstance(this, this) }, destroyed() { registerInstance(this) } }) // 全局注册组件 router-link 和 router-view Vue.component('RouterView', View) Vue.component('RouterLink', Link) } 对于路由注册来说，核心就是调用 Vue.use(VueRouter)，使得 VueRouter 可以使用 Vue。然后通过 Vue 来调用 VueRouter 的 install 函数。在该函数中，核心就是给组件混入钩子函数和全局注册两个路由组件。 VueRouter 实例化 在安装插件后，对 VueRouter 进行实例化。 const Home = { template: 'home' } const Foo = { template: 'foo' } const Bar = { template: 'bar' } // 3. Create the router const router = new VueRouter({ mode: 'hash', base: __dirname, routes: [ { path: '/', component: Home }, // all paths are defined without the hash. { path: '/foo', component: Foo }, { path: '/bar', component: Bar } ] }) 来看一下 VueRouter 的构造函数 constructor(options: RouterOptions = {}) { // ... // 路由匹配对象 this.matcher = createMatcher(options.routes || [], this) // 根据 mode 采取不同的路由方式 let mode = options.mode || 'hash' this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false if (this.fallback) { mode = 'hash' } if (!inBrowser) { mode = 'abstract' } this.mode = mode switch (mode) { case 'history': this.history = new HTML5History(this, options.base) break case 'hash': this.history = new HashHistory(this, options.base, this.fallback) break case 'abstract': this.history = new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !== 'production') { assert(false, `invalid mode: ${mode}`) } } } 在实例化 VueRouter 的过程中，核心是创建一个路由匹配对象，并且根据 mode 来采取不同的路由方式。 创建路由匹配对象 export function createMatcher( routes: Array, router: VueRouter ): Matcher { // 创建路由映射表 const { pathList, pathMap, nameMap } = createRouteMap(routes) function addRoutes(routes) { createRouteMap(routes, pathList, pathMap, nameMap) } // 路由匹配 function match( raw: RawLocation, currentRoute?: Route, redirectedFrom?: Location ): Route { //... } return { match, addRoutes } } createMatcher 函数的作用就是创建路由映射表，然后通过闭包的方式让 addRoutes 和 match 函数能够使用路由映射表的几个对象，最后返回一个 Matcher 对象。 接下来看 createMatcher 函数时如何创建映射表的 export function createRouteMap( routes: Array, oldPathList?: Array, oldPathMap?: Dictionary, oldNameMap?: Dictionary ): { pathList: Array, pathMap: Dictionary, nameMap: Dictionary } { // 创建映射表 const pathList: Array = oldPathList || [] const pathMap: Dictionary = oldPathMap || Object.create(null) const nameMap: Dictionary = oldNameMap || Object.create(null) // 遍历路由配置，为每个配置添加路由记录 routes.forEach(route => { addRouteRecord(pathList, pathMap, nameMap, route) }) // 确保通配符在最后 for (let i = 0, l = pathList.length; i , pathMap: Dictionary, nameMap: Dictionary, route: RouteConfig, parent?: RouteRecord, matchAs?: string ) { // 获得路由配置下的属性 const { path, name } = route const pathToRegexpOptions: PathToRegexpOptions = route.pathToRegexpOptions || {} // 格式化 url，替换 / const normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict) // 生成记录对象 const record: RouteRecord = { path: normalizedPath, regex: compileRouteRegex(normalizedPath, pathToRegexpOptions), components: route.components || { default: route.component }, instances: {}, name, parent, matchAs, redirect: route.redirect, beforeEnter: route.beforeEnter, meta: route.meta || {}, props: route.props == null ? {} : route.components ? route.props : { default: route.props } } if (route.children) { // 递归路由配置的 children 属性，添加路由记录 route.children.forEach(child => { const childMatchAs = matchAs ? cleanPath(`${matchAs}/${child.path}`) : undefined addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs) }) } // 如果路由有别名的话 // 给别名也添加路由记录 if (route.alias !== undefined) { const aliases = Array.isArray(route.alias) ? route.alias : [route.alias] aliases.forEach(alias => { const aliasRoute = { path: alias, children: route.children } addRouteRecord( pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs ) }) } // 更新映射表 if (!pathMap[record.path]) { pathList.push(record.path) pathMap[record.path] = record } // 命名路由添加记录 if (name) { if (!nameMap[name]) { nameMap[name] = record } else if (process.env.NODE_ENV !== 'production' && !matchAs) { warn( false, `Duplicate named routes definition: ` + `{ name: \"${name}\", path: \"${record.path}\" }` ) } } } 以上就是创建路由匹配对象的全过程，通过用户配置的路由规则来创建对应的路由映射表。 路由初始化 当根组件调用 beforeCreate 钩子函数时，会执行以下代码 beforeCreate () { // 只有根组件有 router 属性，所以根组件初始化时会初始化路由 if (isDef(this.$options.router)) { this._routerRoot = this this._router = this.$options.router this._router.init(this) Vue.util.defineReactive(this, '_route', this._router.history.current) } else { this._routerRoot = (this.$parent && this.$parent._routerRoot) || this } registerInstance(this, this) } 接下来看下路由初始化会做些什么 init(app: any /* Vue component instance */) { // 保存组件实例 this.apps.push(app) // 如果根组件已经有了就返回 if (this.app) { return } this.app = app // 赋值路由模式 const history = this.history // 判断路由模式，以哈希模式为例 if (history instanceof HTML5History) { history.transitionTo(history.getCurrentLocation()) } else if (history instanceof HashHistory) { // 添加 hashchange 监听 const setupHashListener = () => { history.setupListeners() } // 路由跳转 history.transitionTo( history.getCurrentLocation(), setupHashListener, setupHashListener ) } // 该回调会在 transitionTo 中调用 // 对组件的 _route 属性进行赋值，触发组件渲染 history.listen(route => { this.apps.forEach(app => { app._route = route }) }) } 在路由初始化时，核心就是进行路由的跳转，改变 URL 然后渲染对应的组件。接下来来看一下路由是如何进行跳转的。 路由跳转 transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) { // 获取匹配的路由信息 const route = this.router.match(location, this.current) // 确认切换路由 this.confirmTransition(route, () => { // 以下为切换路由成功或失败的回调 // 更新路由信息，对组件的 _route 属性进行赋值，触发组件渲染 // 调用 afterHooks 中的钩子函数 this.updateRoute(route) // 添加 hashchange 监听 onComplete && onComplete(route) // 更新 URL this.ensureURL() // 只执行一次 ready 回调 if (!this.ready) { this.ready = true this.readyCbs.forEach(cb => { cb(route) }) } }, err => { // 错误处理 if (onAbort) { onAbort(err) } if (err && !this.ready) { this.ready = true this.readyErrorCbs.forEach(cb => { cb(err) }) } }) } 在路由跳转中，需要先获取匹配的路由信息，所以先来看下如何获取匹配的路由信息 function match( raw: RawLocation, currentRoute?: Route, redirectedFrom?: Location ): Route { // 序列化 url // 比如对于该 url 来说 /abc?foo=bar&baz=qux##hello // 会序列化路径为 /abc // 哈希为 ##hello // 参数为 foo: 'bar', baz: 'qux' const location = normalizeLocation(raw, currentRoute, false, router) const { name } = location // 如果是命名路由，就判断记录中是否有该命名路由配置 if (name) { const record = nameMap[name] // 没找到表示没有匹配的路由 if (!record) return _createRoute(null, location) const paramNames = record.regex.keys .filter(key => !key.optional) .map(key => key.name) // 参数处理 if (typeof location.params !== 'object') { location.params = {} } if (currentRoute && typeof currentRoute.params === 'object') { for (const key in currentRoute.params) { if (!(key in location.params) && paramNames.indexOf(key) > -1) { location.params[key] = currentRoute.params[key] } } } if (record) { location.path = fillParams( record.path, location.params, `named route \"${name}\"` ) return _createRoute(record, location, redirectedFrom) } } else if (location.path) { // 非命名路由处理 location.params = {} for (let i = 0; i 接下来看看如何创建路由 // 根据条件创建不同的路由 function _createRoute( record: ?RouteRecord, location: Location, redirectedFrom?: Location ): Route { if (record && record.redirect) { return redirect(record, redirectedFrom || location) } if (record && record.matchAs) { return alias(record, location, record.matchAs) } return createRoute(record, location, redirectedFrom, router) } export function createRoute( record: ?RouteRecord, location: Location, redirectedFrom?: ?Location, router?: VueRouter ): Route { const stringifyQuery = router && router.options.stringifyQuery // 克隆参数 let query: any = location.query || {} try { query = clone(query) } catch (e) {} // 创建路由对象 const route: Route = { name: location.name || (record && record.name), meta: (record && record.meta) || {}, path: location.path || '/', hash: location.hash || '', query, params: location.params || {}, fullPath: getFullPath(location, stringifyQuery), matched: record ? formatMatch(record) : [] } if (redirectedFrom) { route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery) } // 让路由对象不可修改 return Object.freeze(route) } // 获得包含当前路由的所有嵌套路径片段的路由记录 // 包含从根路由到当前路由的匹配记录，从上至下 function formatMatch(record: ?RouteRecord): Array { const res = [] while (record) { res.unshift(record) record = record.parent } return res } 至此匹配路由已经完成，我们回到 transitionTo 函数中，接下来执行 confirmTransition transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) { // 确认切换路由 this.confirmTransition(route, () => {} } confirmTransition(route: Route, onComplete: Function, onAbort?: Function) { const current = this.current // 中断跳转路由函数 const abort = err => { if (isError(err)) { if (this.errorCbs.length) { this.errorCbs.forEach(cb => { cb(err) }) } else { warn(false, 'uncaught error during route navigation:') console.error(err) } } onAbort && onAbort(err) } // 如果是相同的路由就不跳转 if ( isSameRoute(route, current) && route.matched.length === current.matched.length ) { this.ensureURL() return abort() } // 通过对比路由解析出可复用的组件，需要渲染的组件，失活的组件 const { updated, deactivated, activated } = resolveQueue( this.current.matched, route.matched ) function resolveQueue( current: Array, next: Array ): { updated: Array, activated: Array, deactivated: Array } { let i const max = Math.max(current.length, next.length) for (i = 0; i = [].concat( // 失活的组件钩子 extractLeaveGuards(deactivated), // 全局 beforeEach 钩子 this.router.beforeHooks, // 在当前路由改变，但是该组件被复用时调用 extractUpdateHooks(updated), // 需要渲染组件 enter 守卫钩子 activated.map(m => m.beforeEnter), // 解析异步路由组件 resolveAsyncComponents(activated) ) // 保存路由 this.pending = route // 迭代器，用于执行 queue 中的导航守卫钩子 const iterator = (hook: NavigationGuard, next) => { // 路由不相等就不跳转路由 if (this.pending !== route) { return abort() } try { // 执行钩子 hook(route, current, (to: any) => { // 只有执行了钩子函数中的 next，才会继续执行下一个钩子函数 // 否则会暂停跳转 // 以下逻辑是在判断 next() 中的传参 if (to === false || isError(to)) { // next(false) this.ensureURL(true) abort(to) } else if ( typeof to === 'string' || (typeof to === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) ) { // next('/') 或者 next({ path: '/' }) -> 重定向 abort() if (typeof to === 'object' && to.replace) { this.replace(to) } else { this.push(to) } } else { // 这里执行 next // 也就是执行下面函数 runQueue 中的 step(index + 1) next(to) } }) } catch (e) { abort(e) } } // 经典的同步执行异步函数 runQueue(queue, iterator, () => { const postEnterCbs = [] const isValid = () => this.current === route // 当所有异步组件加载完成后，会执行这里的回调，也就是 runQueue 中的 cb() // 接下来执行 需要渲染组件的导航守卫钩子 const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid) const queue = enterGuards.concat(this.router.resolveHooks) runQueue(queue, iterator, () => { // 跳转完成 if (this.pending !== route) { return abort() } this.pending = null onComplete(route) if (this.router.app) { this.router.app.$nextTick(() => { postEnterCbs.forEach(cb => { cb() }) }) } }) }) } export function runQueue (queue: Array, fn: Function, cb: Function) { const step = index => { // 队列中的函数都执行完毕，就执行回调函数 if (index >= queue.length) { cb() } else { if (queue[index]) { // 执行迭代器，用户在钩子函数中执行 next() 回调 // 回调中判断传参，没有问题就执行 next()，也就是 fn 函数中的第二个参数 fn(queue[index], () => { step(index + 1) }) } else { step(index + 1) } } } // 取出队列中第一个钩子函数 step(0) } 接下来介绍导航守卫 const queue: Array = [].concat( // 失活的组件钩子 extractLeaveGuards(deactivated), // 全局 beforeEach 钩子 this.router.beforeHooks, // 在当前路由改变，但是该组件被复用时调用 extractUpdateHooks(updated), // 需要渲染组件 enter 守卫钩子 activated.map(m => m.beforeEnter), // 解析异步路由组件 resolveAsyncComponents(activated) ) 第一步是先执行失活组件的钩子函数 function extractLeaveGuards(deactivated: Array): Array { // 传入需要执行的钩子函数名 return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true) } function extractGuards( records: Array, name: string, bind: Function, reverse?: boolean ): Array { const guards = flatMapComponents(records, (def, instance, match, key) => { // 找出组件中对应的钩子函数 const guard = extractGuard(def, name) if (guard) { // 给每个钩子函数添加上下文对象为组件自身 return Array.isArray(guard) ? guard.map(guard => bind(guard, instance, match, key)) : bind(guard, instance, match, key) } }) // 数组降维，并且判断是否需要翻转数组 // 因为某些钩子函数需要从子执行到父 return flatten(reverse ? guards.reverse() : guards) } export function flatMapComponents( matched: Array, fn: Function ): Array { // 数组降维 return flatten( matched.map(m => { // 将组件中的对象传入回调函数中，获得钩子函数数组 return Object.keys(m.components).map(key => fn(m.components[key], m.instances[key], m, key) ) }) ) } 第二步执行全局 beforeEach 钩子函数 beforeEach(fn: Function): Function { return registerHook(this.beforeHooks, fn) } function registerHook(list: Array, fn: Function): Function { list.push(fn) return () => { const i = list.indexOf(fn) if (i > -1) list.splice(i, 1) } } 在 VueRouter 类中有以上代码，每当给 VueRouter 实例添加 beforeEach 函数时就会将函数 push 进 beforeHooks 中。 第三步执行 beforeRouteUpdate 钩子函数，调用方式和第一步相同，只是传入的函数名不同，在该函数中可以访问到 this 对象。 第四步执行 beforeEnter 钩子函数，该函数是路由独享的钩子函数。 第五步是解析异步组件。 export function resolveAsyncComponents(matched: Array): Function { return (to, from, next) => { let hasAsync = false let pending = 0 let error = null // 该函数作用之前已经介绍过了 flatMapComponents(matched, (def, _, match, key) => { // 判断是否是异步组件 if (typeof def === 'function' && def.cid === undefined) { hasAsync = true pending++ // 成功回调 // once 函数确保异步组件只加载一次 const resolve = once(resolvedDef => { if (isESModule(resolvedDef)) { resolvedDef = resolvedDef.default } // 判断是否是构造函数 // 不是的话通过 Vue 来生成组件构造函数 def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef) // 赋值组件 // 如果组件全部解析完毕，继续下一步 match.components[key] = resolvedDef pending-- if (pending { const msg = `Failed to resolve async component ${key}: ${reason}` process.env.NODE_ENV !== 'production' && warn(false, msg) if (!error) { error = isError(reason) ? reason : new Error(msg) next(error) } }) let res try { // 执行异步组件函数 res = def(resolve, reject) } catch (e) { reject(e) } if (res) { // 下载完成执行回调 if (typeof res.then === 'function') { res.then(resolve, reject) } else { const comp = res.component if (comp && typeof comp.then === 'function') { comp.then(resolve, reject) } } } } }) // 不是异步组件直接下一步 if (!hasAsync) next() } } 以上就是第一个 runQueue 中的逻辑，第五步完成后会执行第一个 runQueue 中回调函数 // 该回调用于保存 `beforeRouteEnter` 钩子中的回调函数 const postEnterCbs = [] const isValid = () => this.current === route // beforeRouteEnter 导航守卫钩子 const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid) // beforeResolve 导航守卫钩子 const queue = enterGuards.concat(this.router.resolveHooks) runQueue(queue, iterator, () => { if (this.pending !== route) { return abort() } this.pending = null // 这里会执行 afterEach 导航守卫钩子 onComplete(route) if (this.router.app) { this.router.app.$nextTick(() => { postEnterCbs.forEach(cb => { cb() }) }) } }) 第六步是执行 beforeRouteEnter 导航守卫钩子，beforeRouteEnter 钩子不能访问 this 对象，因为钩子在导航确认前被调用，需要渲染的组件还没被创建。但是该钩子函数是唯一一个支持在回调中获取 this 对象的函数，回调会在路由确认执行。 beforeRouteEnter (to, from, next) { next(vm => { // 通过 `vm` 访问组件实例 }) } 下面来看看是如何支持在回调中拿到 this 对象的 function extractEnterGuards( activated: Array, cbs: Array, isValid: () => boolean ): Array { // 这里和之前调用导航守卫基本一致 return extractGuards( activated, 'beforeRouteEnter', (guard, _, match, key) => { return bindEnterGuard(guard, match, key, cbs, isValid) } ) } function bindEnterGuard( guard: NavigationGuard, match: RouteRecord, key: string, cbs: Array, isValid: () => boolean ): NavigationGuard { return function routeEnterGuard(to, from, next) { return guard(to, from, cb => { // 判断 cb 是否是函数 // 是的话就 push 进 postEnterCbs next(cb) if (typeof cb === 'function') { cbs.push(() => { // 循环直到拿到组件实例 poll(cb, match.instances, key, isValid) }) } }) } } // 该函数是为了解决 issus ##750 // 当 router-view 外面包裹了 mode 为 out-in 的 transition 组件 // 会在组件初次导航到时获得不到组件实例对象 function poll( cb: any, // somehow flow cannot infer this is a function instances: Object, key: string, isValid: () => boolean ) { if ( instances[key] && !instances[key]._isBeingDestroyed // do not reuse being destroyed instance ) { cb(instances[key]) } else if (isValid()) { // setTimeout 16ms 作用和 nextTick 基本相同 setTimeout(() => { poll(cb, instances, key, isValid) }, 16) } } 第七步是执行 beforeResolve 导航守卫钩子，如果注册了全局 beforeResolve 钩子就会在这里执行。 第八步就是导航确认，调用 afterEach 导航守卫钩子了。 以上都执行完成后，会触发组件的渲染 history.listen(route => { this.apps.forEach(app => { app._route = route }) }) 以上回调会在 updateRoute 中调用 updateRoute(route: Route) { const prev = this.current this.current = route this.cb && this.cb(route) this.router.afterHooks.forEach(hook => { hook && hook(route, prev) }) } 至此，路由跳转已经全部分析完毕。核心就是判断需要跳转的路由是否存在于记录中，然后执行各种导航守卫函数，最后完成 URL 的改变和组件的渲染。 "},"git/git基本使用.html":{"url":"git/git基本使用.html","title":"git基本使用","keywords":"","body":"git基本使用 git基本使用 开始 基本命令 使用合并流程 分支命名 注意事项 alias 别名 git合并一个分支上改动的部分文件到另外一个分支 git远程分支强制覆盖本地文件 公共远程分支版本回退的方法 6. 附： 开始 git config --global user.name xxx git config --global user.email xxx 基本命令 git checkout -b xxx ： 创建分支并切换到分支xxx git status ： 查看当前分支状态 git add . : 将新添加的文件加入暂存区 git commit -am “注释” ：添加并提交所有修改文件 git merge xxx : 将xxx(本地)分支的代码合并到当前分支 git pull : 从远端获取, 或git pull origin xxx(分支名) git push : 更新到远端, 或git push origin xxx(分支名) git add filename : 添加未跟踪的文件到暂存区 git add . : 添加所有未跟踪的文件到暂存区 git log : 日志 git reflog git reset --hard 139dcfaa git push -f -u origin master 使用合并流程 [master下]创建分支: git checkout -b xxx [分支下] 开发代码并不断commit, 开发完毕 [分支下] 切换到master: git checkout master [master下] 更新代码: git pull [master下] 切换到分支xxx: git checkout xxx [分支下] 合并master到分支： git merge master [分支下] 切换master: git checkout master [master下] 合并分支xxx到master: git merge xxx [master下] 更新到远端 git push 分支命名 建议采用git-flow规范： 新项目，新功能： feature/xxx 快速更改，修复bug: hotfix/xxx 注意事项 windows下客户端: sourcetree(注册需翻墙), tortoiseGit, mac下客户端: sourcetree, tower master分支尽量不要进行耗时项目开发，远端master要保持随时可以上线版本 push之前要先pull 所有命令操作都在根目录下执行。 不建议单文件commit， 每次commit都是提交当前所有的修改 alias 别名 使用命令行的同学可以在git bash里 vi ~/.gitconfig, 将下面别名加入文件末尾: [alias] cm = commit co = checkout ac = !git add -A && git commit st = status -sb tags = tag -l branches = branch -a cleanup = git config --global alias.cleanup \"git branch --merged | grep -v '*' | xargs git branch -d\" remotes = remote -v lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit -- git合并一个分支上改动的部分文件到另外一个分支 $ git checkeout master $ git checkout --path branchXX file git远程分支强制覆盖本地文件 $ git reset --hard origin/master 公共远程分支版本回退的方法 $ git revert HEAD # 撤销最近一次提交 $ git revert HEAD~1 # 撤销上上次的提交，注意：数字从0开始 $ git revert 0ffaacc # 撤销0ffaacc这次提交 git revert 命令意思是撤销某次提交。它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的，所以,当你用revert回退之后，所有人pull之后，他们的代码也自动的回退了。但是，要注意以下几点： revert 是撤销一次提交，所以后面的commit id是你需要回滚到的版本的前一次提交 使用revert HEAD是撤销最近的一次提交，如果你最近一次提交是用revert命令产生的，那么你再执行一次，就相当于撤销了上次的撤销操作，换句话说，你连续执行两次revert HEAD命令，就跟没执行是一样的 使用revert HEAD~1 表示撤销最近2次提交，这个数字是从0开始的，如果你之前撤销过产生了commi id，那么也会计算在内的。 如果使用 revert 撤销的不是最近一次提交，那么一定会有代码冲突，需要你合并代码，合并代码只需要把当前的代码全部去掉，保留之前版本的代码就可以了. 自己的分支回滚直接用reset公共分支回滚用revert 6. 附： git配置，供参考（~/.gitconfig） [user] name = Lu jingce email = lujingce@163.com [alias] st = status br = branch bra = branch -a cm = commit -m cam = commit -a -m co = checkout cf = checkout -f diffn = diff --numstat diffs = diff --shortstat diffd = diff --dirstat lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit -- [push] default = simple "},"git/git分支管理策略.html":{"url":"git/git分支管理策略.html","title":"git分支管理策略","keywords":"","body":"git工作流 工作流 基于gitflow, 简化版本 参考文档: http://nvie.com/posts/a-successful-git-branching-model/ 区别： 不设release, develop分支， 暂不打tag， 保留master, feature/*, hotfix/* 项目 feprogram/taoche等项目锁定master, 不允许直接在master下改动，需要提交merge request进行review act等项目进行敏捷开发, 不锁定master, 分支自行管理 crm等项目设立develop分支，特性分支开发完成后合并入develop, master分支从develop单向merge 工作流程 基于最新master建立分支，功能分支feature/xxx 或 线上bug修复分支 hotfix/xxx 在分支下开发 开发完成， merge master到当前分支，release灰度/上线。 推荐工作流程 切换到release分支；pull最新代码；建立自己的工作分支（新功能开发、快速验证，bug修复建议都建分支）：git checkout -b dev_xmli；或者创建开发同一功能几个人公用的分支(如：dev-insurance, change-price)；在自己的分支上提交（commit）；开发完毕，做测试；切换到release分支，pull;切换到工作分支，merge代码： git merge release，合并线上最新更改，测试一下自己的更改；切换到release, 然后 git merge dev_xmli，把自己的更改合并到线上分支；提交代码到服务器-- git push;如有必要告知其他同事更新代码，尤其是项目文件的改动；如果是发布的release，打tag；git tag -a v1.8.0提交tag:git push --tags "},"git/publish脚本.html":{"url":"git/publish脚本.html","title":"publish脚本","keywords":"","body":"为了每次自动发布gitbook书籍到github.io上去，自定义脚本： #!/bin/bash cd doc # gitbook install # install the plugins and build the static site gitbook build cd .. # checkout to the gh-pages branch git checkout gh-pages # pull the latest updates git pull origin gh-pages if [[ \"$?\" != \"0\" ]]; then exit 1 fi # copy the static site files into the current directory. \\cp -Rf doc/_book/* . # remove 'node_modules' and '_book' directory # git clean -fx gitbook/node_modules # git clean -fx gitbook/_book rm -rf doc/_book/ # remove website css files, except last one ccount=`ls website-* | wc -w` if [[ \"$ccount\" > 1 ]];then allcss=($(ls website-*)) c=0 for css in \"${allcss[@]}\"; do let \"c=c+1\" if [[ $c -ge $ccount ]]; then break; fi rm -f $css done fi # add all files git add --all # commit git commit -a -m \"Update docs\" # push to the origin git push origin gh-pages # checkout to the master branch git checkout master "},"git/gitbook.html":{"url":"git/gitbook.html","title":"gitbook","keywords":"","body":"发布到github pages 构建书籍 首先，使用 gitbook build 将书籍内容输出到默认目录，也就是当前目录下的 _book 目录。 $ gitbook build Starting build ... Successfully built! $ ls _book GLOSSARY.html chapter1 chapter2 gitbook glossary_index.json index.html search_index.json 创建 gh-pages 分支 执行如下命令来创建分支，并且删除不需要的文件： $ git checkout --orphan gh-pages $ git rm --cached -r . $ git clean -df $ rm -rf *~ 现在，目录下应该只剩下 _book 目录了，首先，忽略一些文件： $ echo \"*~\" > .gitignore $ echo \"_book\" >> .gitignore $ git add .gitignore $ git commit -m \"Ignore some files\" 然后，加入 _book 下的内容到分支中： $ cp -r _book/* . $ git add . $ git commit -m \"Publish book\" 上传书籍内容到 GitHub 现在，可以将编译好的书籍内容上传到 GitHub 中 test 项目的 gh-pages 分支了，虽然这里还没有创建分支，上传和创建会一步完成！ $ git push -u origin gh-pages 部署到 gh-pages 分支 这个步骤我使用了 gh-pages 这个工具，它可以将文件夹一键发布到 GitHub 项目下的 gh-pages 分支中（其他分支也可以发布，但是在本文下用到的就是 gh-pages 这个分支） 安装 gh-pages 工具 $ npm install -g gh-pages 输入以下指令 $ gh-pages -d _book 然后 _book 下的所有文档都会部署到 gh-pages 分支 GitHub Pages 的静态资源支持下面 3 个来源： master 分支 master 分支的 /docs 目录 gh-pages 分支 执行下面命令，将 _book 目录推送到 GitHub 仓库的 gh-pages 分支。 $ git subtree push --prefix=_book origin gh-pages 或者在生成静态网页时，将保存的目录指定为 ./docs $ gitbook build ./ ./docs 然后直接推送到 GitHub 仓库的 git push origin master "},"规范/分支开发规范.html":{"url":"规范/分支开发规范.html","title":"分支开发规范","keywords":"","body":"分支开发规范 master分支 大部分项目都不要直接在master下直接开发 master分支需要确保是完全同步线上的状态， 任何时间点打包master分支都可以直接上线 分支创建规范 feature/xxx: 新需求，功能性开发 hotfix/xxx: bug修复 分支生命周期 分支上线前merge master, 上线后第一时间将分支合并入master 分支开发完成并合入master之后, 说明该分支生命周期已经完结，请删除分支 关于删除分支 方法一： gitlab中删除 方法二： 命令行执行git push origin --delete [branch_name] 分支删除后本地查看仍然可以看到 方法一： sourcetree pull/fetch操作时有个选项，勾选同步远程分支 方法二： 命令行执行git remote prune origin 方法三: 任意分支下执行git pull -p 日志 严禁使用空日志提交项目 不要使用没有任何内容的日志， 比如 'up' 'update' '更新' 'nomessage' 等等 日志体现相关项目及改动内容 "},"规范/es6编码规范.html":{"url":"规范/es6编码规范.html","title":"ES6编码规范","keywords":"","body":"es6编码规范 Airbnb JavaScript 代码规范（ES6） 1：关键字import // ES5 var MyComponent = require('./MyComponent.js'); // ES6 import MyComponent from './MyComponent'; 2：关键字exports // ES5 var Mycomponent = React.createClass({}); module.exports = MyComponent; // ES6,用export default来实现相同的功能 // ES6 export default class MyComponent extends React.Component {} 3：定义组件 // ES5 var Phono = { name, age, getAge: function() { return age } } // ES6 //名字：function() 的写法了，而是直接使用 名字()，在方法的最后也不能在有逗号了 class Photo { name age getAge() { return this.age } getName() { return this.name; } } 4：箭头函数 arrow function 注意：箭头函数中不能使用arguments对象 //ES5与ES6对比 //ES5： function name(参数) {运算表达式;return 表达式} //ES6： (参数) => {运算表达式;return 表达式} // 箭头函数的例子 () => 1; v => v + 1; (a, b) => a + b; () => { alert(\"foo\"); } e => { if (e == 0) { return 0; } return 1000 / e; } //例如 (x, y) => { x++; y--; return x + y } // 等同于 s = function(x, y) { x++; y--; return x + y; }; //例如 f = v => v; //上面的箭头函数等同于： f = function(v) { return v; }; f = () => 5; // 等同于 f = function() { return 5 }; sum = (num1, num2) => num1 + num2; // 等同于 sum = function(num1, num2) { return num1 + num2; }; //如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 sum = (num1, num2) => { return num1 + num2; } //由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。 getTempItem = id => ({ id: id, name: \"Temp\" }); //箭头函数可以与变量解构结合使用 const full = ({ first, last }) => first + ' ' + last; // 等同于 function full(person) { return person.first + ' ' + person.last; } //click clickBtn = (event) => { event.stopPropagation() } $('btn').on('click', (event => event.stopPropagation())) $('btn').on('click', (event) => { return event.stopPropagation() }) 5：class, extends和super class Animal { constructor() { this.type = 'animal' } says(say) { console.log(this.type + ' says ' + say) } } let animal = new Animal() animal.says('hello') //animal says hello class Cat extends Animal { constructor() { //super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。 //ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 super() this.type = 'cat' } } let cat = new Cat() cat.says('hello') //cat says hello 定义类时，方法的顺序如下： constructor public get/set 公用访问器，set只能传一个参数 public methods 公用方法，以函数命名区分，不带下划线 private get/set 私有访问器，私有相关命名应加上下划线_为前缀 private methods 私有方法 class SomeClass { constructor() { // constructor } get aval() { // public getter } set aval(val) { // public setter } doSth() { // 公用方法 } get _aval() { // private getter } set _aval() { // private setter } _doSth() { // 私有方法 } } 6 ：声明变量 // 可以初始化变量 let a = obj || {} 7 ：for循环 var arr = ['val1', 'val2', 'val3']; for (var i = 0; i { console.log(val); console.log(index); console.log(array); }) arr.forEach((val, index, array) => { console.log(val); console.log(index); console.log(array); }) for (let i = 0; i 8 ：赋值的方法 this.str = \"CH\"; var str = this.str && this.str.toLowerCase(); //输出 \"ch\" this.str = null; var str = this.str && this.str.toLowerCase(); //输出 null //相当于 if (this.str) { //当this.str字符串存在，则把他转为小写赋值给str str = this.str.toLowerCase(); } else { //否则把他自己赋值给str str = this.str; } if (a == 1) { b() } //可以写成 a == 1 && b() // ES5 var a = arr[0], b = arr[1], c = arr[2]; // ES6 let [a,b,c]=arr; 嵌套数组解构 var arr = [[1, 2, [3, 4]], 5, 6]; var [[d, e, [f, g]], h, i] = arr; console.log(d);//1 console.log(f);//3 console.log(i);//6 函数传参解构 var arr = ['this is a string', 2, 3]; function fn1([a, b, c]) { console.log(a); console.log(b); console.log(c); } fn1(arr); //this is a string //2 //3 for循环解构 var arr = [[11, 12], [21, 22], [31, 32]]; for (let [a, b] of arr) { console.log(a); console.log(b); } //11 //12 //21 //22 //31 //32 对象赋值解构 var obj = { name: 'chris', sex: 'male', age: 26, son: { sonname: '大熊', sonsex: 'male', sonage: 1 } }; var {name, sex, age, son} = obj; console.log(name + ' ' + sex + ' ' + age); //chris male 26 console.log(son); // { sonname: '大熊', sonsex: 'male', sonage: 1 } 对象传参解构 var obj = { name: 'chris', sex: 'male', age: 26, son: { sonname: '大熊', sonsex: 'male', sonage: 1 } }; function fn2({sex, age, name}) { console.log(name + ' ' + sex + ' ' + age); } fn2(obj); //chris male 26 变量名与对象属性名不一致解构 var obj = { name: 'chris', sex: 'male', age: 26 }; var {name: nickname, age: howold} = obj; console.log(nickname + ' ' + howold); //chris 26 嵌套对象解构 var obj = { name: 'chris', sex: 'male', age: 26, son: { sonname: '大熊', sonsex: 'male', sonage: 1 } }; var {name, sex, age, son: {sonname, sonsex, sonage}} = obj; console.log(sonname + ' ' + sonsex + ' ' + sonage); //大熊 male 1 //Babel暂不支持这种嵌套解构 obj = { name: 'chris', sex: 'male', age: [1, 2, 3] } {name, sex, age: [a, b, c]} = obj; console.log(c); 嵌套对象属性重名，解构时需要更改变量名 var obj = { name: 'chris', sex: 'male', age: 26, son: { name: '大熊', sex: 'male', age: 1 } }; //赋值解构 var {name: fathername, son: {name, sex, age}} = obj; console.log(fathername); //chris console.log(name); //大熊 //传参解构 function fn3({sex, age, name, son: {name: sonname}}) { console.log(name + ' ' + sex + ' ' + age + ' ' + sonname); } fn3(obj); //chris male 26 大熊 循环解构对象 var arr = [{name: 'chris', age: 26}, {name: 'jack', age: 27}, {name: 'peter',age: 28}]; for (let {age, name} of arr) { console.log(name + ' ' + age); } //chris 26 //jack 27 //peter 28 解构的特殊应用场景 //变量互换 var x = 1, y = 2; var [x, y] = [y, x]; console.log(x); //2 console.log(y); //1 //字符串解构 var str = 'love'; var [a, b, c, d] = str; console.log(a);//l console.log(b);//o console.log(c);//v console.log(d);//e 9：短路求值简写方式 if (variable1 !== null || variable1 !== undefined || variable1 !== '') { let variable2 = variable1; } const variable2 = variable1 || 'new'; 10： if存在条件简写方法 if (likeJavaScript === true) {} //简写： if (likeJavaScript) {} let a; if (a !== true) { // do something... } //简写： let a; if (!a) { // do something... } 11： 默认参数值 function volume(l, w, h) { if (w === undefined) w = 3; if (h === undefined) h = 4; return l * w * h; } //简写： volume = (l, w = 3, h = 4) => (l * w * h); volume(2) //output: 24 12：模板字符串 const welcome = 'You have logged in as ' + first + ' ' + last + '.' const db = 'http://' + host + ':' + port + '/' + database; //推荐 const welcome = `You have logged in as ${first} ${last}`; const db = `http://${host}:${port}/${database}`; 13：扩展运算符简写 // joining arrays const odd = [1, 3, 5]; const nums = [2, 4, 6].concat(odd); // cloning arrays const arr = [1, 2, 3, 4]; const arr2 = arr.slice() //简写： // joining arrays const odd = [1, 3, 5]; const nums = [2, 4, 6, ...odd]; console.log(nums); // [ 2, 4, 6, 1, 3, 5 ] // cloning arrays const arr = [1, 2, 3, 4]; const arr2 = [...arr]; //不像concat()函数，可以使用扩展运算符来在一个数组中任意处插入另一个数组。 const odd = [1, 3, 5]; const nums = [2, ...odd, 4, 6]; //也可以使用扩展运算符解构： const { a, b, ...z } = { a: 1, b: 2, c: 3, d: 4 }; console.log(a) // 1 console.log(b) // 2 console.log(z) // { c: 3, d: 4 } 14 ：强制参数简写 function foo(bar) { if (bar === undefined) { throw new Error('Missing parameter!'); } return bar; } //简写： mandatory = () => { throw new Error('Missing parameter!'); } foo = (bar = mandatory()) => { return bar; } 15： Array.find简写 const pets = [ { type: 'Dog', name: 'Max' }, { type: 'Cat', name: 'Karl' }, { type: 'Dog', name: 'Tommy' }, ] function findDog(name) { for (let i = 0; i pet.type === 'Dog' && pet.name === 'Tommy'); 16 ：Object[key]简写 //考虑一个验证函数 function validate(values) { if (!values.first) return false; if (!values.last) return false; return true; } console.log(validate({ first: 'Bruce', last: 'Wayne' })); // true //假设当需要不同域和规则来验证，能否编写一个通用函数在运行时确认？ // 对象验证规则 const schema = { first: { required: true }, last: { required: true } } // 通用验证函数 const validate = (schema, values) => { for (field in schema) { if (schema[field].required) { if (!values[field]) { return false; } } } return true; } console.log(validate(schema, { first: 'Bruce' })); // false console.log(validate(schema, { first: 'Bruce', last: 'Wayne' })); // true "},"规范/vue编码规范.html":{"url":"规范/vue编码规范.html","title":"vue编码规范","keywords":"","body":"VUE组件编码规范 相关文档 vue 1.x: [http://v1.vuejs.org/api/] vue-ressource 1.x: [https://github.com/pagekit/vue-resource/blob/develop/docs/http.md] vue-router 0.x: [https://github.com/vuejs/vue-router/tree/1.0/docs/zh-cn] 请注意区分项目使用的库版本及相关文档，以上三个包都在vue.dll.js依赖包里 项目通过组件来规划 // 示例项目aaa aaa/ components/ : 项目内组件 pages/ : 项目视图存放目录 html/: 项目页面存放目录 index.hbs index.js: 项目入口文件 // index.hbs , 尽量只用一个标记，无其他内容 // 如果有seo相关内容，凡在里面，作为slot插入组件内 // index.js // 若项目不复杂，可直接使用template new Vue({ el: '#main', template: ` `, components: {componentA,componentB,componentC} }) // 相对复杂的项目或使用路由的项目，建立页面级别的组件 new Vue({ el : '#main', template: ``, components: {Index} }) // pages/index.vue export default { name: 'index' } 目录划分 libs/vue-components ： 用于存放全项目公用的vue组件 xxx/components: 比如xinche.m/components, 用于存放单一项目公用的vue组件, 或跟此单一项目业务强相关的vue组件 xxx/yyy/components: 比如xinche.m/about/components, 用于存放子项目自己使用的vue组件，一般不提供给外部其他项目使用 公用组件目录结构 xxx/ index.vue : 主组件文件 *.png/*.gif : 组件使用的图片（公用组件尽量不要使用大于10k的图片） README.md: 组件使用说明文档 组件命名 有意义的， 简短，具有可读性。2-3个单词 符合自定义元素规范，使用-连字符分隔单词， 如app-header 组件单一原则 每一个vue组件专注于解决单一的问题，独立，可复用 一个组件尽量不要超过100行，如果组件太臃肿，需要拆分成更小的组件 props原子化 组件的props尽量使用原始数据类型，避免使用复杂对象 // 不适用复杂对象 const option = {title:'xxx', inApp: true} // 使用原始数据类型 // 注意inApp驼峰的props书写在组件标记内需要改成in-app类型 // 注意props值传入的如果不是字符串，需要v-bind:props来绑定 验证组件的props // 尽量不使用简写props export default { props: ['title', 'isApp'] } // 验证props export default { props: { title: { type: String, default: , required: true }, isApp: { type: Boolean, default: false } } } 合理使用this // 组件内不要出现如下之类 const self = this // 充分利用es6特性，使用this created(){ this.title = 123 } 组件使用name // 单一组件的导出不建议指定名称, 直接使用default导出 export default {} // 组件建议添加name属性 export default { name: 'appHeader\" } 组件不要使用双向绑定的props // 不要使用.sync类型的props export default { props: { type: String, twoway: true } } // 子组件通知父级数据变更，应采用调用父级传入的函数型props回调，或者事件通知的方式 避免使用this.$parent 直接访问上下文降低了组建的复用性，应避免使用，尽量通过事件通知 尽量使用this.$http而不是jquery.ajax vue组件应尽量使用自己的resource插件，符合promise规范 // 最外层需要将插件引入 import Vue from 'vue' import VueResource from 'vue-resource' Vue.use(VueResource) 组件内尽量不要直接使用window上的全局变量 // 不要使用window上的全局变量，降低组件复用性和增加维护成本 this.$http.get(APIURL, {}) // 通过props传入组件的所有外部依赖 this.$http.get(this.api, {}) props向下传递，事件向上传递 当必须要操作dom时，才使用this.$refs, 而不是jQuery 组件顶级class规范化，建议component-xxx开头命名 xxx 提供api文档 建议组件api文档写到组件同目录README.md里 "},"规范/Airbnb-React-JSX编码规范.html":{"url":"规范/Airbnb-React-JSX编码规范.html","title":"Airbnb-React-JSX编码规范","keywords":"","body":"Airbnb React/JSX 编码规范 算是最合理的React/JSX编码规范之一了 此编码规范主要基于目前流行的JavaScript标准，尽管某些其他约定(如async/await，静态class属性)可能在不同的项目中被引入或者被禁用。目前的状态是任何stage-3之前的规范都不包括也不推荐使用。 内容目录 基本规范 Class vs React.createClass vs stateless Mixins 命名 声明模块 代码对齐 单引号还是双引号 空格 属性 Refs引用 括号 标签 函数/方法 模块生命周期 isMounted Basic Rules 基本规范 每个文件只写一个模块. 但是多个无状态模块可以放在单个文件中. eslint: react/no-multi-comp. 推荐使用JSX语法. 不要使用 React.createElement，除非从一个非JSX的文件中初始化你的app. 创建模块 Class vs React.createClass vs stateless 如果你的模块有内部状态或者是refs, 推荐使用 class extends React.Component 而不是 React.createClass. eslint: react/prefer-es6-class react/prefer-stateless-function // bad const Listing = React.createClass({ // ... render() { return {this.state.hello}; } }); // good class Listing extends React.Component { // ... render() { return {this.state.hello}; } } 如果你的模块没有状态或是没有引用refs， 推荐使用普通函数（非箭头函数）而不是类: // bad class Listing extends React.Component { render() { return {this.props.hello}; } } // bad (relying on function name inference is discouraged) const Listing = ({ hello }) => ( {hello} ); // good function Listing({ hello }) { return {hello}; } Mixins 不要使用 mixins. 为什么? Mixins 会增加隐式的依赖，导致命名冲突，并且会以雪球式增加复杂度。在大多数情况下Mixins可以被更好的方法替代，如：组件化，高阶组件，工具模块等。 Naming 命名 扩展名: React模块使用 .jsx 扩展名. 文件名: 文件名使用帕斯卡命名. 如, ReservationCard.jsx. 引用命名: React模块名使用帕斯卡命名，实例使用骆驼式命名. eslint: react/jsx-pascal-case // bad import reservationCard from './ReservationCard'; // good import ReservationCard from './ReservationCard'; // bad const ReservationItem = ; // good const reservationItem = ; 模块命名: 模块使用当前文件名一样的名称. 比如 ReservationCard.jsx 应该包含名为 ReservationCard的模块. 但是，如果整个文件夹是一个模块，使用 index.js作为入口文件，然后直接使用 index.js 或者文件夹名作为模块的名称: // bad import Footer from './Footer/Footer'; // bad import Footer from './Footer/index'; // good import Footer from './Footer'; 高阶模块命名: 对于生成一个新的模块，其中的模块名 displayName 应该为高阶模块名和传入模块名的组合. 例如, 高阶模块 withFoo(), 当传入一个 Bar 模块的时候， 生成的模块名 displayName 应该为 withFoo(Bar). 为什么？一个模块的 displayName 可能会在开发者工具或者错误信息中使用到，因此有一个能清楚的表达这层关系的值能帮助我们更好的理解模块发生了什么，更好的Debug. // bad export default function withFoo(WrappedComponent) { return function WithFoo(props) { return ; } } // good export default function withFoo(WrappedComponent) { function WithFoo(props) { return ; } const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component'; WithFoo.displayName = `withFoo(${wrappedComponentName})`; return WithFoo; } 属性命名: 避免使用DOM相关的属性来用作其他的用途。 为什么？对于style 和 className这样的属性名，我们都会默认它们代表一些特殊的含义，如元素的样式，CSS class的名称。在你的应用中使用这些属性来表示其他的含义会使你的代码更难阅读，更难维护，并且可能会引起bug。 // bad // good Declaration 声明模块 不要使用 displayName 来命名React模块，而是使用引用来命名模块， 如 class 名称. // bad export default React.createClass({ displayName: 'ReservationCard', // stuff goes here }); // good export default class ReservationCard extends React.Component { } Alignment 代码对齐 遵循以下的JSX语法缩进/格式. eslint: react/jsx-closing-bracket-location react/jsx-closing-tag-location // bad // good, 有多行属性的话, 新建一行关闭标签 // 若能在一行中显示, 直接写成一行 // 子元素按照常规方式缩进 Quotes 单引号还是双引号 对于JSX属性值总是使用双引号(\"), 其他均使用单引号('). eslint: jsx-quotes 为什么? HTML属性也是用双引号, 因此JSX的属性也遵循此约定. // bad // good Spacing 空格 总是在自动关闭的标签前加一个空格，正常情况下也不需要换行. eslint: no-multi-spaces, react/jsx-tag-spacing // bad // very bad // bad // good 不要在JSX {} 引用括号里两边加空格. eslint: react/jsx-curly-spacing // bad // good Props 属性 JSX属性名使用骆驼式风格camelCase. // bad // good 如果属性值为 true, 可以直接省略. eslint: react/jsx-boolean-value // bad // good // good 标签总是添加 alt 属性. 如果图片以presentation(感觉是以类似PPT方式显示?)方式显示，alt 可为空, 或者 要包含role=\"presentation\". eslint: jsx-a11y/alt-text // bad // good // good // good 不要在 alt 值里使用如 \"image\", \"photo\", or \"picture\"包括图片含义这样的词， 中文也一样. eslint: jsx-a11y/img-redundant-alt 为什么? 屏幕助读器已经把 img 标签标注为图片了, 所以没有必要再在 alt 里说明了. // bad // good 使用有效正确的 aria role属性值 ARIA roles. eslint: jsx-a11y/aria-role // bad - not an ARIA role // bad - abstract ARIA role // good 不要在标签上使用 accessKey 属性. eslint: jsx-a11y/no-access-key 为什么? 屏幕助读器在键盘快捷键与键盘命令时造成的不统一性会导致阅读性更加复杂. // bad // good 避免使用数组的index来作为属性key的值，推荐使用唯一ID. (为什么?) // bad {todos.map((todo, index) => )} // good {todos.map(todo => ( ))} 对于所有非必须的属性，总是手动去定义defaultProps属性. 为什么? propTypes 可以作为模块的文档说明, 并且声明 defaultProps 的话意味着阅读代码的人不需要去假设一些默认值。更重要的是, 显示的声明默认属性可以让你的模块跳过属性类型的检查. // bad function SFC({ foo, bar, children }) { return {foo}{bar}{children}; } SFC.propTypes = { foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node, }; // good function SFC({ foo, bar, children }) { return {foo}{bar}{children}; } SFC.propTypes = { foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node, }; SFC.defaultProps = { bar: '', children: null, }; 尽可能少地使用扩展运算符 为什么? 除非你很想传递一些不必要的属性。对于React v15.6.1和更早的版本，你可以给DOM传递一些无效的HTML属性 例外情况: 使用了变量提升的高阶组件 function HOC(WrappedComponent) { return class Proxy extends React.Component { Proxy.propTypes = { text: PropTypes.string, isLoading: PropTypes.bool }; render() { return } } } 只有在清楚明白扩展对象时才使用扩展运算符。这非常有用尤其是在使用Mocha测试组件的时候。 export default function Foo { const props = { text: '', isPublished: false } return (); } 特别提醒：尽可能地筛选出不必要的属性。同时，使用prop-types-exact来预防问题出现。 // good render() { const { irrelevantProp, ...relevantProps } = this.props; return } // bad render() { const { irrelevantProp, ...relevantProps } = this.props; return } Refs 总是在Refs里使用回调函数. eslint: react/no-string-refs // bad // good { this.myRef = ref; }} /> Parentheses 括号 将多行的JSX标签写在 ()里. eslint: react/jsx-wrap-multilines // bad render() { return ; } // good render() { return ( ); } // good, 单行可以不需要 render() { const body = hello; return {body}; } Tags 标签 对于没有子元素的标签来说总是自己关闭标签. eslint: react/self-closing-comp // bad // good 如果模块有多行的属性， 关闭标签时新建一行. eslint: react/jsx-closing-bracket-location // bad // good Methods 函数 使用箭头函数来获取本地变量. function ItemList(props) { return ( {props.items.map((item, index) => ( doSomethingWith(item.name, index)} /> ))} ); } 当在 render() 里使用事件处理方法时，提前在构造函数里把 this 绑定上去. eslint: react/jsx-no-bind 为什么? 在每次 render 过程中， 再调用 bind 都会新建一个新的函数，浪费资源. // bad class extends React.Component { onClickDiv() { // do stuff } render() { return ; } } // good class extends React.Component { constructor(props) { super(props); this.onClickDiv = this.onClickDiv.bind(this); } onClickDiv() { // do stuff } render() { return ; } } 在React模块中，不要给所谓的私有函数添加 _ 前缀，本质上它并不是私有的. 为什么？_ 下划线前缀在某些语言中通常被用来表示私有变量或者函数。但是不像其他的一些语言，在JS中没有原生支持所谓的私有变量，所有的变量函数都是共有的。尽管你的意图是使它私有化，在之前加上下划线并不会使这些变量私有化，并且所有的属性（包括有下划线前缀及没有前缀的）都应该被视为是共有的。了解更多详情请查看Issue #1024, 和 #490 。 // bad React.createClass({ _onClickSubmit() { // do stuff }, // other stuff }); // good class extends React.Component { onClickSubmit() { // do stuff } // other stuff } 在 render 方法中总是确保 return 返回值. eslint: react/require-render-return // bad render() { (); } // good render() { return (); } Ordering React 模块生命周期 class extends React.Component 的生命周期函数: 可选的 static 方法 constructor 构造函数 getChildContext 获取子元素内容 componentWillMount 模块渲染前 componentDidMount 模块渲染后 componentWillReceiveProps 模块将接受新的数据 shouldComponentUpdate 判断模块需不需要重新渲染 componentWillUpdate 上面的方法返回 true， 模块将重新渲染 componentDidUpdate 模块渲染结束 componentWillUnmount 模块将从DOM中清除, 做一些清理任务 点击回调或者事件处理器 如 onClickSubmit() 或 onChangeDescription() render 里的 getter 方法 如 getSelectReason() 或 getFooterContent() 可选的 render 方法 如 renderNavigation() 或 renderProfilePicture() render render() 方法 如何定义 propTypes, defaultProps, contextTypes, 等等其他属性... import React from 'react'; import PropTypes from 'prop-types'; const propTypes = { id: PropTypes.number.isRequired, url: PropTypes.string.isRequired, text: PropTypes.string, }; const defaultProps = { text: 'Hello World', }; class Link extends React.Component { static methodsAreOk() { return true; } render() { return {this.props.text}; } } Link.propTypes = propTypes; Link.defaultProps = defaultProps; export default Link; React.createClass 的生命周期函数，与使用class稍有不同: eslint: react/sort-comp displayName 设定模块名称 propTypes 设置属性的类型 contextTypes 设置上下文类型 childContextTypes 设置子元素上下文类型 mixins 添加一些mixins statics defaultProps 设置默认的属性值 getDefaultProps 获取默认属性值 getInitialState 或者初始状态 getChildContext componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount clickHandlers or eventHandlers like onClickSubmit() or onChangeDescription() getter methods for render like getSelectReason() or getFooterContent() Optional render methods like renderNavigation() or renderProfilePicture() render isMounted 不要再使用 isMounted. eslint: react/no-is-mounted 为什么? isMounted 反人类设计模式:(), 在 ES6 classes 中无法使用， 官方将在未来的版本里删除此方法. ⬆ 回到顶部 "},"other/Emoji表情.html":{"url":"other/Emoji表情.html","title":"Emoji表情","keywords":"","body":"Emoji表情 将对应emoji表情的符号码复制后输入你的markdown文本即可显示emoji表情。 如:blush:，显示为:blush: 人物 syntax preview syntax preview syntax preview :bowtie: :bowtie: :smile: :smile: :laughing: :laughing: :blush: :blush: :smiley: :smiley: :relaxed: :relaxed: :smirk: :smirk: :heart_eyes: :heart_eyes: :kissing_heart: :kissing_heart: :kissing_closed_eyes: :kissing_closed_eyes: :flushed: :flushed: :relieved: :relieved: :satisfied: :satisfied: :grin: :grin: :wink: :wink: :stuck_out_tongue_winking_eye: :stuck_out_tongue_winking_eye: :stuck_out_tongue_closed_eyes: :stuck_out_tongue_closed_eyes: :grinning: :grinning: :kissing: :kissing: :kissing_smiling_eyes: :kissing_smiling_eyes: :stuck_out_tongue: :stuck_out_tongue: :sleeping: :sleeping: :worried: :worried: :frowning: :frowning: :anguished: :anguished: :open_mouth: :open_mouth: :grimacing: :grimacing: :confused: :confused: :hushed: :hushed: :expressionless: :expressionless: :unamused: :unamused: :sweat_smile: :sweat_smile: :sweat: :sweat: :disappointed_relieved: :disappointed_relieved: :weary: :weary: :pensive: :pensive: :disappointed: :disappointed: :confounded: :confounded: :fearful: :fearful: :cold_sweat: :cold_sweat: :persevere: :persevere: :cry: :cry: :sob: :sob: :joy: :joy: :astonished: :astonished: :scream: :scream: :neckbeard: :neckbeard: :tired_face: :tired_face: :angry: :angry: :rage: :rage: :triumph: :triumph: :sleepy: :sleepy: :yum: :yum: :mask: :mask: :sunglasses: :sunglasses: :dizzy_face: :dizzy_face: :imp: :imp: :smiling_imp: :smiling_imp: :neutral_face: :neutral_face: :no_mouth: :no_mouth: :innocent: :innocent: :alien: :alien: :yellow_heart: :yellow_heart: :blue_heart: :blue_heart: :purple_heart: :purple_heart: :heart: :heart: :green_heart: :green_heart: :broken_heart: :broken_heart: :heartbeat: :heartbeat: :heartpulse: :heartpulse: :two_hearts: :two_hearts: :revolving_hearts: :revolving_hearts: :cupid: :cupid: :sparkling_heart: :sparkling_heart: :sparkles: :sparkles: :star: :star: :star2: :star2: :dizzy: :dizzy: :boom: :boom: :collision: :collision: :anger: :anger: :exclamation: :exclamation: :question: :question: :grey_exclamation: :grey_exclamation: :grey_question: :grey_question: :zzz: :zzz: :dash: :dash: :sweat_drops: :sweat_drops: :notes: :notes: :musical_note: :musical_note: :fire: :fire: :hankey: :hankey: :poop: :poop: :: :shit: :+1: :+1: :thumbsup: :thumbsup: :-1: :-1: :thumbsdown: :thumbsdown: :ok_hand: :ok_hand: :punch: :punch: :facepunch: :facepunch: :fist: :fist: :v: :v: :wave: :wave: :hand: :hand: :raised_hand: :raised_hand: :open_hands: :open_hands: :point_up: :point_up: :point_down: :point_down: :point_left: :point_left: :point_right: :point_right: :raised_hands: :raised_hands: :pray: :pray: :point_up_2: :point_up_2: :clap: :clap: :muscle: :muscle: :metal: :metal: :fu: :fu: :walking: :walking: :runner: :runner: :running: :running: :couple: :couple: :family: :family: :two_men_holding_hands: :two_men_holding_hands: :two_women_holding_hands: :two_women_holding_hands: :dancer: :dancer: :dancers: :dancers: :ok_woman: :ok_woman: :no_good: :no_good: :information_desk_person: :information_desk_person: :raising_hand: :raising_hand: :bride_with_veil: :bride_with_veil: :person_with_pouting_face: :person_with_pouting_face: :person_frowning: :person_frowning: :bow: :bow: :couplekiss: :couplekiss: :couple_with_heart: :couple_with_heart: :massage: :massage: :haircut: :haircut: :nail_care: :nail_care: :boy: :boy: :girl: :girl: :woman: :woman: :man: :man: :baby: :baby: :older_woman: :older_woman: :older_man: :older_man: :person_with_blond_hair: :person_with_blond_hair: :man_with_gua_pi_mao: :man_with_gua_pi_mao: :man_with_turban: :man_with_turban: :construction_worker: :construction_worker: :cop: :cop: :angel: :angel: :princess: :princess: :smiley_cat: :smiley_cat: :smile_cat: :smile_cat: :heart_eyes_cat: :heart_eyes_cat: :kissing_cat: :kissing_cat: :smirk_cat: :smirk_cat: :scream_cat: :scream_cat: :crying_cat_face: :crying_cat_face: :joy_cat: :joy_cat: :pouting_cat: :pouting_cat: :japanese_ogre: :japanese_ogre: :japanese_goblin: :japanese_goblin: :see_no_evil: :see_no_evil: :hear_no_evil: :hear_no_evil: :speak_no_evil: :speak_no_evil: :guardsman: :guardsman: :skull: :skull: :feet: :feet: :lips: :lips: :kiss: :kiss: :droplet: :droplet: :ear: :ear: :eyes: :eyes: :nose: :nose: :tongue: :tongue: :love_letter: :love_letter: :bust_in_silhouette: :bust_in_silhouette: :busts_in_silhouette: :busts_in_silhouette: :speech_balloon: :speech_balloon: :thought_balloon: :thought_balloon: :feelsgood: :feelsgood: :finnadie: :finnadie: :goberserk: :goberserk: :godmode: :godmode: :hurtrealbad: :hurtrealbad: :rage1: :rage1: :rage2: :rage2: :rage3: :rage3: :rage4: :rage4: :suspect: :suspect: :trollface: :trollface: 自然 syntax preview syntax preview syntax preview :sunny: :sunny: :umbrella: :umbrella: :cloud: :cloud: :snowflake: :snowflake: :snowman: :snowman: :zap: :zap: :cyclone: :cyclone: :foggy: :foggy: :ocean: :ocean: :cat: :cat: :dog: :dog: :mouse: :mouse: :hamster: :hamster: :rabbit: :rabbit: :wolf: :wolf: :frog: :frog: :tiger: :tiger: :koala: :koala: :bear: :bear: :pig: :pig: :pig_nose: :pig_nose: :cow: :cow: :boar: :boar: :monkey_face: :monkey_face: :monkey: :monkey: :horse: :horse: :racehorse: :racehorse: :camel: :camel: :sheep: :sheep: :elephant: :elephant: :panda_face: :panda_face: :snake: :snake: :bird: :bird: :baby_chick: :baby_chick: :hatched_chick: :hatched_chick: :hatching_chick: :hatching_chick: :chicken: :chicken: :penguin: :penguin: :turtle: :turtle: :bug: :bug: :honeybee: :honeybee: :ant: :ant: :beetle: :beetle: :snail: :snail: :octopus: :octopus: :tropical_fish: :tropical_fish: :fish: :fish: :whale: :whale: :whale2: :whale2: :dolphin: :dolphin: :cow2: :cow2: :ram: :ram: :rat: :rat: :water_buffalo: :water_buffalo: :tiger2: :tiger2: :rabbit2: :rabbit2: :dragon: :dragon: :goat: :goat: :rooster: :rooster: :dog2: :dog2: :pig2: :pig2: :mouse2: :mouse2: :ox: :ox: :dragon_face: :dragon_face: :blowfish: :blowfish: :crocodile: :crocodile: :dromedary_camel: :dromedary_camel: :leopard: :leopard: :cat2: :cat2: :poodle: :poodle: :paw_prints: :paw_prints: :bouquet: :bouquet: :cherry_blossom: :cherry_blossom: :tulip: :tulip: :four_leaf_clover: :four_leaf_clover: :rose: :rose: :sunflower: :sunflower: :hibiscus: :hibiscus: :maple_leaf: :maple_leaf: :leaves: :leaves: :fallen_leaf: :fallen_leaf: :herb: :herb: :mushroom: :mushroom: :cactus: :cactus: :palm_tree: :palm_tree: :evergreen_tree: :evergreen_tree: :deciduous_tree: :deciduous_tree: :chestnut: :chestnut: :seedling: :seedling: :blossom: :blossom: :ear_of_rice: :ear_of_rice: :shell: :shell: :globe_with_meridians: :globe_with_meridians: :sun_with_face: :sun_with_face: :full_moon_with_face: :full_moon_with_face: :new_moon_with_face: :new_moon_with_face: :new_moon: :new_moon: :waxing_crescent_moon: :waxing_crescent_moon: :first_quarter_moon: :first_quarter_moon: :full_moon: :full_moon: :waning_gibbous_moon: :waning_gibbous_moon: :last_quarter_moon: :last_quarter_moon: :waning_crescent_moon: :waning_crescent_moon: :last_quarter_moon_with_face: :last_quarter_moon_with_face: :first_quarter_moon_with_face: :first_quarter_moon_with_face: :moon: :moon: :earth_africa: :earth_africa: :earth_americas: :earth_americas: :earth_asia: :earth_asia: :volcano: :volcano: :milky_way: :milky_way: :partly_sunny: :partly_sunny: :octocat: :octocat: :squirrel: :squirrel: :waxing_gibbous_moon: :waxing_gibbous_moon: 物体 syntax preview syntax preview syntax preview :bamboo: :bamboo: :gift_heart: :gift_heart: :dolls: :dolls: :school_satchel: :school_satchel: :mortar_board: :mortar_board: :flags: :flags: :fireworks: :fireworks: :sparkler: :sparkler: :wind_chime: :wind_chime: :rice_scene: :rice_scene: :jack_o_lantern: :jack_o_lantern: :ghost: :ghost: :santa: :santa: :christmas_tree: :christmas_tree: :gift: :gift: :bell: :bell: :no_bell: :no_bell: :tanabata_tree: :tanabata_tree: :tada: :tada: :confetti_ball: :confetti_ball: :balloon: :balloon: :crystal_ball: :crystal_ball: :cd: :cd: :dvd: :dvd: :floppy_disk: :floppy_disk: :camera: :camera: :video_camera: :video_camera: :movie_camera: :movie_camera: :computer: :computer: :tv: :tv: :iphone: :iphone: :phone: :phone: :telephone: :telephone: :telephone_receiver: :telephone_receiver: :pager: :pager: :fax: :fax: :minidisc: :minidisc: :vhs: :vhs: :sound: :sound: :speaker: :speaker: :mute: :mute: :loudspeaker: :loudspeaker: :mega: :mega: :hourglass: :hourglass: :hourglass_flowing_sand: :hourglass_flowing_sand: :alarm_clock: :alarm_clock: :watch: :watch: :radio: :radio: :satellite: :satellite: :loop: :loop: :mag: :mag: :mag_right: :mag_right: :unlock: :unlock: :lock: :lock: :lock_with_ink_pen: :lock_with_ink_pen: :closed_lock_with_key: :closed_lock_with_key: :key: :key: :bulb: :bulb: :flashlight: :flashlight: :high_brightness: :high_brightness: :low_brightness: :low_brightness: :electric_plug: :electric_plug: :battery: :battery: :calling: :calling: :email: :email: :mailbox: :mailbox: :postbox: :postbox: :bath: :bath: :bathtub: :bathtub: :shower: :shower: :toilet: :toilet: :wrench: :wrench: :nut_and_bolt: :nut_and_bolt: :hammer: :hammer: :seat: :seat: :moneybag: :moneybag: :yen: :yen: :dollar: :dollar: :pound: :pound: :euro: :euro: :credit_card: :credit_card: :money_with_wings: :money_with_wings: :e-mail: :e-mail: :inbox_tray: :inbox_tray: :outbox_tray: :outbox_tray: :envelope: :envelope: :incoming_envelope: :incoming_envelope: :postal_horn: :postal_horn: :mailbox_closed: :mailbox_closed: :mailbox_with_mail: :mailbox_with_mail: :mailbox_with_no_mail: :mailbox_with_no_mail: :door: :door: :smoking: :smoking: :bomb: :bomb: :gun: :gun: :hocho: :hocho: :pill: :pill: :syringe: :syringe: :page_facing_up: :page_facing_up: :page_with_curl: :page_with_curl: :bookmark_tabs: :bookmark_tabs: :bar_chart: :bar_chart: :chart_with_upwards_trend: :chart_with_upwards_trend: :chart_with_downwards_trend: :chart_with_downwards_trend: :scroll: :scroll: :clipboard: :clipboard: :calendar: :calendar: :date: :date: :card_index: :card_index: :file_folder: :file_folder: :open_file_folder: :open_file_folder: :scissors: :scissors: :pushpin: :pushpin: :paperclip: :paperclip: :black_nib: :black_nib: :pencil2: :pencil2: :straight_ruler: :straight_ruler: :triangular_ruler: :triangular_ruler: :closed_book: :closed_book: :green_book: :green_book: :blue_book: :blue_book: :orange_book: :orange_book: :notebook: :notebook: :notebook_with_decorative_cover: :notebook_with_decorative_cover: :ledger: :ledger: :books: :books: :bookmark: :bookmark: :microscope: :microscope: :telescope: :telescope: :name_badge: :name_badge: :newspaper: :newspaper: :football: :football: :basketball: :basketball: :soccer: :soccer: :baseball: :baseball: :tennis: :tennis: :8ball: :8ball: :rugby_football: :rugby_football: :bowling: :bowling: :golf: :golf: :mountain_bicyclist: :mountain_bicyclist: :bicyclist: :bicyclist: :horse_racing: :horse_racing: :snowboarder: :snowboarder: :swimmer: :swimmer: :surfer: :surfer: :ski: :ski: :spades: :spades: :hearts: :hearts: :clubs: :clubs: :diamonds: :diamonds: :gem: :gem: :ring: :ring: :trophy: :trophy: :musical_score: :musical_score: :musical_keyboard: :musical_keyboard: :violin: :violin: :space_invader: :space_invader: :video_game: :video_game: :black_joker: :black_joker: :flower_playing_cards: :flower_playing_cards: :game_die: :game_die: :dart: :dart: :mahjong: :mahjong: :clapper: :clapper: :memo: :memo: :pencil: :pencil: :book: :book: :art: :art: :microphone: :microphone: :headphones: :headphones: :trumpet: :trumpet: :saxophone: :saxophone: :guitar: :guitar: :shoe: :shoe: :sandal: :sandal: :high_heel: :high_heel: :lipstick: :lipstick: :boot: :boot: :shirt: :shirt: :tshirt: :tshirt: :necktie: :necktie: :womans_clothes: :womans_clothes: :dress: :dress: :running_shirt_with_sash: :running_shirt_with_sash: :jeans: :jeans: :kimono: :kimono: :bikini: :bikini: :ribbon: :ribbon: :tophat: :tophat: :crown: :crown: :womans_hat: :womans_hat: :mans_shoe: :mans_shoe: :closed_umbrella: :closed_umbrella: :briefcase: :briefcase: :handbag: :handbag: :pouch: :pouch: :purse: :purse: :eyeglasses: :eyeglasses: :fishing_pole_and_fish: :fishing_pole_and_fish: :coffee: :coffee: :tea: :tea: :sake: :sake: :baby_bottle: :baby_bottle: :beer: :beer: :beers: :beers: :cocktail: :cocktail: :tropical_drink: :tropical_drink: :wine_glass: :wine_glass: :fork_and_knife: :fork_and_knife: :pizza: :pizza: :hamburger: :hamburger: :fries: :fries: :poultry_leg: :poultry_leg: :meat_on_bone: :meat_on_bone: :spaghetti: :spaghetti: :curry: :curry: :fried_shrimp: :fried_shrimp: :bento: :bento: :sushi: :sushi: :fish_cake: :fish_cake: :rice_ball: :rice_ball: :rice_cracker: :rice_cracker: :rice: :rice: :ramen: :ramen: :stew: :stew: :oden: :oden: :dango: :dango: :egg: :egg: :bread: :bread: :doughnut: :doughnut: :custard: :custard: :icecream: :icecream: :ice_cream: :ice_cream: :shaved_ice: :shaved_ice: :birthday: :birthday: :cake: :cake: :cookie: :cookie: :chocolate_bar: :chocolate_bar: :candy: :candy: :lollipop: :lollipop: :honey_pot: :honey_pot: :apple: :apple: :green_apple: :green_apple: :tangerine: :tangerine: :lemon: :lemon: :cherries: :cherries: :grapes: :grapes: :watermelon: :watermelon: :strawberry: :strawberry: :peach: :peach: :melon: :melon: :banana: :banana: :pear: :pear: :pineapple: :pineapple: :sweet_potato: :sweet_potato: :eggplant: :eggplant: :tomato: :tomato: :corn: :corn: 地点 syntax preview syntax preview syntax preview :house: :house: :house_with_garden: :house_with_garden: :school: :school: :office: :office: :post_office: :post_office: :hospital: :hospital: :bank: :bank: :convenience_store: :convenience_store: :love_hotel: :love_hotel: :hotel: :hotel: :wedding: :wedding: :church: :church: :department_store: :department_store: :european_post_office: :european_post_office: :city_sunrise: :city_sunrise: :city_sunset: :city_sunset: :japanese_castle: :japanese_castle: :european_castle: :european_castle: :tent: :tent: :factory: :factory: :tokyo_tower: :tokyo_tower: :japan: :japan: :mount_fuji: :mount_fuji: :sunrise_over_mountains: :sunrise_over_mountains: :sunrise: :sunrise: :stars: :stars: :statue_of_liberty: :statue_of_liberty: :bridge_at_night: :bridge_at_night: :carousel_horse: :carousel_horse: :rainbow: :rainbow: :ferris_wheel: :ferris_wheel: :fountain: :fountain: :roller_coaster: :roller_coaster: :ship: :ship: :speedboat: :speedboat: :boat: :boat: :sailboat: :sailboat: :rowboat: :rowboat: :anchor: :anchor: :rocket: :rocket: :airplane: :airplane: :helicopter: :helicopter: :steam_locomotive: :steam_locomotive: :tram: :tram: :mountain_railway: :mountain_railway: :bike: :bike: :aerial_tramway: :aerial_tramway: :suspension_railway: :suspension_railway: :mountain_cableway: :mountain_cableway: :tractor: :tractor: :blue_car: :blue_car: :oncoming_automobile: :oncoming_automobile: :car: :car: :red_car: :red_car: :taxi: :taxi: :oncoming_taxi: :oncoming_taxi: :articulated_lorry: :articulated_lorry: :bus: :bus: :oncoming_bus: :oncoming_bus: :rotating_light: :rotating_light: :police_car: :police_car: :oncoming_police_car: :oncoming_police_car: :fire_engine: :fire_engine: :ambulance: :ambulance: :minibus: :minibus: :truck: :truck: :train: :train: :station: :station: :train2: :train2: :bullettrain_front: :bullettrain_front: :bullettrain_side: :bullettrain_side: :light_rail: :light_rail: :monorail: :monorail: :railway_car: :railway_car: :trolleybus: :trolleybus: :ticket: :ticket: :fuelpump: :fuelpump: :vertical_traffic_light: :vertical_traffic_light: :traffic_light: :traffic_light: :warning: :warning: :construction: :construction: :beginner: :beginner: :atm: :atm: :slot_machine: :slot_machine: :busstop: :busstop: :barber: :barber: :hotsprings: :hotsprings: :checkered_flag: :checkered_flag: :crossed_flags: :crossed_flags: :izakaya_lantern: :izakaya_lantern: :moyai: :moyai: :circus_tent: :circus_tent: :performing_arts: :performing_arts: :round_pushpin: :round_pushpin: :triangular_flag_on_post: :triangular_flag_on_post: :jp: :jp: :kr: :kr: :cn: :cn: :us: :us: :fr: :fr: :es: :es: :it: :it: :ru: :ru: :gb: :gb: :uk: :uk: :de: :de: 符号 syntax preview syntax preview syntax preview :one: :one: :two: :two: :three: :three: :four: :four: :five: :five: :six: :six: :seven: :seven: :eight: :eight: :nine: :nine: :keycap_ten: :keycap_ten: :1234: :1234: :zero: :zero: :hash: :hash: :symbols: :symbols: :arrow_backward: :arrow_backward: :arrow_down: :arrow_down: :arrow_forward: :arrow_forward: :arrow_left: :arrow_left: :capital_abcd: :capital_abcd: :abcd: :abcd: :abc: :abc: :arrow_lower_left: :arrow_lower_left: :arrow_lower_right: :arrow_lower_right: :arrow_right: :arrow_right: :arrow_up: :arrow_up: :arrow_upper_left: :arrow_upper_left: :arrow_upper_right: :arrow_upper_right: :arrow_double_down: :arrow_double_down: :arrow_double_up: :arrow_double_up: :arrow_down_small: :arrow_down_small: :arrow_heading_down: :arrow_heading_down: :arrow_heading_up: :arrow_heading_up: :leftwards_arrow_with_hook: :leftwards_arrow_with_hook: :arrow_right_hook: :arrow_right_hook: :left_right_arrow: :left_right_arrow: :arrow_up_down: :arrow_up_down: :arrow_up_small: :arrow_up_small: :arrows_clockwise: :arrows_clockwise: :arrows_counterclockwise: :arrows_counterclockwise: :rewind: :rewind: :fast_forward: :fast_forward: :information_source: :information_source: :ok: :ok: :twisted_rightwards_arrows: :twisted_rightwards_arrows: :repeat: :repeat: :repeat_one: :repeat_one: :new: :new: :top: :top: :up: :up: :cool: :cool: :free: :free: :ng: :ng: :cinema: :cinema: :koko: :koko: :signal_strength: :signal_strength: :u5272: :u5272: :u5408: :u5408: :u55b6: :u55b6: :u6307: :u6307: :u6708: :u6708: :u6709: :u6709: :u6e80: :u6e80: :u7121: :u7121: :u7533: :u7533: :u7a7a: :u7a7a: :u7981: :u7981: :sa: :sa: :restroom: :restroom: :mens: :mens: :womens: :womens: :baby_symbol: :baby_symbol: :no_smoking: :no_smoking: :parking: :parking: :wheelchair: :wheelchair: :metro: :metro: :baggage_claim: :baggage_claim: :accept: :accept: :wc: :wc: :potable_water: :potable_water: :put_litter_in_its_place: :put_litter_in_its_place: :secret: :secret: :congratulations: :congratulations: :m: :m: :passport_control: :passport_control: :left_luggage: :left_luggage: :customs: :customs: :ideograph_advantage: :ideograph_advantage: :cl: :cl: :sos: :sos: :id: :id: :no_entry_sign: :no_entry_sign: :underage: :underage: :no_mobile_phones: :no_mobile_phones: :do_not_litter: :do_not_litter: :non-potable_water: :non-potable_water: :no_bicycles: :no_bicycles: :no_pedestrians: :no_pedestrians: :children_crossing: :children_crossing: :no_entry: :no_entry: :eight_spoked_asterisk: :eight_spoked_asterisk: :eight_pointed_black_star: :eight_pointed_black_star: :heart_decoration: :heart_decoration: :vs: :vs: :vibration_mode: :vibration_mode: :mobile_phone_off: :mobile_phone_off: :chart: :chart: :currency_exchange: :currency_exchange: :aries: :aries: :taurus: :taurus: :gemini: :gemini: :cancer: :cancer: :leo: :leo: :virgo: :virgo: :libra: :libra: :scorpius: :scorpius: :sagittarius: :sagittarius: :capricorn: :capricorn: :aquarius: :aquarius: :pisces: :pisces: :ophiuchus: :ophiuchus: :six_pointed_star: :six_pointed_star: :negative_squared_cross_mark: :negative_squared_cross_mark: :a: :a: :b: :b: :ab: :ab: :o2: :o2: :diamond_shape_with_a_dot_inside: :diamond_shape_with_a_dot_inside: :recycle: :recycle: :end: :end: :on: :on: :soon: :soon: :clock1: :clock1: :clock130: :clock130: :clock10: :clock10: :clock1030: :clock1030: :clock11: :clock11: :clock1130: :clock1130: :clock12: :clock12: :clock1230: :clock1230: :clock2: :clock2: :clock230: :clock230: :clock3: :clock3: :clock330: :clock330: :clock4: :clock4: :clock430: :clock430: :clock5: :clock5: :clock530: :clock530: :clock6: :clock6: :clock630: :clock630: :clock7: :clock7: :clock730: :clock730: :clock8: :clock8: :clock830: :clock830: :clock9: :clock9: :clock930: :clock930: :heavy_dollar_sign: :heavy_dollar_sign: :copyright: :copyright: :registered: :registered: :tm: :tm: :x: :x: :heavy_exclamation_mark: :heavy_exclamation_mark: :bangbang: :bangbang: :interrobang: :interrobang: :o: :o: :heavy_multiplication_x: :heavy_multiplication_x: :heavy_plus_sign: :heavy_plus_sign: :heavy_minus_sign: :heavy_minus_sign: :heavy_division_sign: :heavy_division_sign: :white_flower: :white_flower: :100: :100: :heavy_check_mark: :heavy_check_mark: :ballot_box_with_check: :ballot_box_with_check: :radio_button: :radio_button: :link: :link: :curly_loop: :curly_loop: :wavy_dash: :wavy_dash: :part_alternation_mark: :part_alternation_mark: :trident: :trident: :black_large_square: :black_large_square: :white_large_square: :white_large_square: :white_check_mark: :white_check_mark: :white_square_button: :white_square_button: :black_square_button: :black_square_button: :black_circle: :black_circle: :white_circle: :white_circle: :red_circle: :red_circle: :large_blue_circle: :large_blue_circle: :large_blue_diamond: :large_blue_diamond: :large_orange_diamond: :large_orange_diamond: :small_blue_diamond: :small_blue_diamond: :small_orange_diamond: :small_orange_diamond: :small_red_triangle: :small_red_triangle: :small_red_triangle_down: :small_red_triangle_down: :shipit: :shipit: "}}