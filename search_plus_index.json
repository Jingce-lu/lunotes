{"./":{"url":"./","title":"Introduction","keywords":"","body":" 世路如今已惯 此心到处悠然 "},"Js/js基础/js基础.html":{"url":"Js/js基础/js基础.html","title":"Js基础","keywords":"","body":"js基础 js基础 自定义模块 随机生成颜色 利用 Object.defineProperty 侦测对象的变化，最简单的可以写出这样的代码 JS中的可枚举属性与不可枚举属性以及扩展 自定义模块 (function(module){ module.exports = function (a, b){ return a + b; } if ('undefined' != typeof window){ window.add = module.exports; } })('undefined' == typeof module ? { module: { exports: {} } } : module); 随机生成颜色 function getRandomColor(){ let rgb = [];: for (let i = 0; i 利用 Object.defineProperty 侦测对象的变化，最简单的可以写出这样的代码 function defineReactive (data, key, val) { Object.defineProperty(data, key, { enumerable: true, configurable: true, get: function () { return val }, set: function (newVal) { if(val === newVal){ return } val = newVal } }) } JS中的可枚举属性与不可枚举属性以及扩展 属性的枚举性会影响以下三个函数的结果： for…in Object.keys() JSON.stringify 先看一个例子，按如下方法创建kxy对象： function Person() { this.name = \"KXY\"; } Person.prototype = { constructor: Person, job: \"student\", }; var kxy = new Person(); Object.defineProperty(kxy, \"sex\", { value: \"female\", enumerable: false }); 其中用defineProperty为对象定义了一个名为”sex”的不可枚举属性 接下来做以下验证： for(var pro in kxy) { console.log(\"kxy.\" + pro + \" = \" + kxy[pro]); } // 结果： // kxy.name = KXY // kxy.constructor = function Person() { // this.name = \"KXY\"; // } // kxy.job = student console.log(Object.keys(kxy)); // 返回结果：[\"name\"] // 只包含”name”属性，说明该方法只能返回对象本身具有的可枚举属性。 console.log(JSON.stringify(kxy)); // 返回结果：{\"name\":\"KXY\"} // 此方法也只能读取对象本身的可枚举属性，并序列化为JSON字符串（通过typeof JSON.stringify(kxy)得到string类型）。 function Person(){ this.name = 'kong'; } Person.prototype = { age : 18, job : 'student' } var a = new Person(); Object.defineProperty(a, 'sex', { value : 'men', enumerable : false //定义该属性不可枚举 }) //for in for(var k in a){ console.log(k); } //name age job //Object.keys() console.log(Object.keys(a)); //['name'] //JSON.stringify() console.log(JSON.stringify(a)); //{'name' : 'kong'} //propertyIsEnumerable方法判断该属性是否可枚举 console.log(a.propertyIsEnumerable('name')); //true console.log(a.propertyIsEnumerable('age')); //false console.log(a.propertyIsEnumerable('sex')); //false for (prop in obj) { if (!obj.hasOwnProperty(prop)) continue; // 跳过继承属性 } 如此一来，可以这样来使用 for...in 循环遍历对象属性： (function () { var getEnumPropertyNames = function (obj) { if (typeof obj !== 'object') throw TypeError(); // 参数必须是对象 var props = []; // 将要返回的数组 for (var prop in obj) { // 遍历所有可枚举的属性 if (obj.hasOwnProperty(prop)) { //判断是否是自有属性 props.push(prop); //将属性名添加到数组中 } } return props; //返回这个数组 } // 实例化 var obj = { 'x': 1, 'y':2 } obj.propertyIsEnumerable('toString') var propertys = getEnumPropertyNames(obj); console.log(propertys.length); //2 console.log(propertys.join(\",\")); //x,y })() "},"Js/js基础/ljc-Js.html":{"url":"Js/js基础/ljc-Js.html","title":"ljc-Js","keywords":"","body":"/** * 作者：路小二 * 开发日期：2016/12/25 * 描述：通用框架 */ //定义一个对象 - 名字是$ var $$ = function() {}; //第二种写法 $$.prototype = { $id: function(id) { return document.getElementById(id); }, //去除左边空格 ltrim: function(str) { return str.replace(/(^\\s*)/g, \"\"); }, //去除右边空格 rtrim: function(str) { return str.replace(/(\\s*$)/g, \"\"); }, //去除空格 trim: function(str) { return str.replace(/(^\\s*)|(\\s*$)/g, \"\"); }, //ajax myAjax: function(URL, fn) { var xhr = createXHR(); //返回了一个对象，这个对象IE6兼容。 xhr.onreadystatechange = function() { if (xhr.readyState === 4) { if ( (xhr.status >= 200 && xhr.status return { left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop }; } return { // 剩下的肯定是怪异模式的 left: document.body.scrollLeft, top: document.body.scrollTop }; }, //封装可视区域大小 client: function() { if (window.innerWidth != null) { // ie9 + 最新浏览器 return { width: window.innerWidth, height: window.innerHeight }; } else if (document.compatMode === \"CSS1Compat\") { // 标准浏览器 return { width: document.documentElement.clientWidth, height: document.documentElement.clientHeight }; } return { // 怪异浏览器 width: document.body.clientWidth, height: document.body.clientHeight }; }, // 多个属性运动框架 添加回调函数 animate: function(obj, json, fn) { // 给谁 json clearInterval(obj.timer); obj.timer = setInterval(function() { var flag = true; // 用来判断是否停止定时器 一定写到遍历的外面 for (var attr in json) { // attr 属性 json[attr] 值 //开始遍历 json // 计算步长 用 target 位置 减去当前的位置 除以 10 // console.log(attr); var current = 0; if (attr == \"opacity\") { current = Math.round(parseInt(getStyle(obj, attr) * 100)) || 0; console.log(current); } else { current = parseInt(getStyle(obj, attr)); // 数值 } // console.log(current); // 目标位置就是 属性值 var step = (json[attr] - current) / 10; // 步长 用目标位置 - 现在的位置 / 10 step = step > 0 ? Math.ceil(step) : Math.floor(step); //判断透明度 if (attr == \"opacity\") { // 判断用户有没有输入 opacity if (\"opacity\" in obj.style) { // 判断 我们浏览器是否支持opacity // obj.style.opacity obj.style.opacity = (current + step) / 100; } else { // obj.style.filter = alpha(opacity = 30) obj.style.filter = \"alpha(opacity = \" + (current + step) * 10 + \")\"; } } else if (attr == \"zIndex\") { obj.style.zIndex = json[attr]; } else { obj.style[attr] = current + step + \"px\"; } if (current != json[attr]) { // 只要其中一个不满足条件 就不应该停止定时器 这句一定遍历里面 flag = false; } } if (flag) { // 用于判断定时器的条件 clearInterval(obj.timer); //alert(\"ok了\"); if (fn) { // 很简单 当定时器停止了。 动画就结束了 如果有回调，就应该执行回调 fn(); // 函数名 + （） 调用函数 执行函数 暂且这样替代 } } }, 30); } }; //在框架中实例化，这样外面使用的使用就不用实例化了 $$ = new $$(); "},"Js/js基础/moveJs.html":{"url":"Js/js基础/moveJs.html","title":"moveJs","keywords":"","body":"// JavaScript Document function startMove(obj, json, endFn) { clearInterval(obj.timer); obj.timer = setInterval(function() { var bBtn = true; for (var attr in json) { var iCur = 0; if (attr == \"opacity\") { if (Math.round(parseFloat(getStyle(obj, attr)) * 100) == 0) { iCur = Math.round(parseFloat(getStyle(obj, attr)) * 100); } else { iCur = Math.round(parseFloat(getStyle(obj, attr)) * 100) || 100; } } else { iCur = parseInt(getStyle(obj, attr)) || 0; } var iSpeed = (json[attr] - iCur) / 8; iSpeed = iSpeed > 0 ? Math.ceil(iSpeed) : Math.floor(iSpeed); if (iCur != json[attr]) { bBtn = false; } if (attr == \"opacity\") { obj.style.filter = \"alpha(opacity=\" + (iCur + iSpeed) + \")\"; obj.style.opacity = (iCur + iSpeed) / 100; } else { obj.style[attr] = iCur + iSpeed + \"px\"; } } if (bBtn) { clearInterval(obj.timer); if (endFn) { endFn.call(obj); } } }, 30); } function getStyle(obj, attr) { if (obj.currentStyle) { return obj.currentStyle[attr]; } else { return getComputedStyle(obj, false)[attr]; } } "},"Js/js基础/移动web.html":{"url":"Js/js基础/移动web.html","title":"移动web","keywords":"","body":"移动web 改变meta视口标签 var meta = document.getElemmentsByTagName('meta'[0])； meta.setAttribute('content', 'width=device-width, initial-scale=1') 分辨率 window.devicePixeRatio 屏幕方向 window.orientation css background-attachment: scroll || fixed || local scroll: 默认值 背景图随页面一起滚动 fixed: 背景图相对于视口固定不动 local: 背景图随元素一起滚动 vh 和 vW尺寸单位代表视口的百分比， 比如 50vw表示50%的视口宽度 触摸事件 touchstart -- 在用户的手指触摸屏幕的瞬间触发 touchmove -- 在用户移动手指的过程中连续触发 touchend -- 在用户的手指离开屏幕的瞬间触发 touchstart、touchmove、touchendpointerdown、pointermove、 pointerup事件在同一时刻触发 //获取兼容浏览器事件坐标的函数 function findCoordinates(e){ //如果需要，用PageX/Y代替clientX/Y var x, y; if(e.changedTouches){ //touch事件 x = e.changedTouches[0].clentX; y = e.changedTouches[0].clentY; }else{ //pointer或mouse事件 x = e.clientX; y = e.clientY; } return [x, y]; } "},"Js/js基础/ICD.html":{"url":"Js/js基础/ICD.html","title":"ICD","keywords":"","body":"﻿ICD.js /** * ICD Library v1.0.0 * * Includes select.js, event.js, animate.js * * Copyright 2014 ICD Foundation * Author XXXXXXX * Tel XXXXXX * Email XXXXXX * * Date: 2014-11-30 */ (function(window){ var ICD = function(str){ if(typeof str == 'function'){ window.onload = str; }else{ return new ICD.init(str); } } ICD.init = function(str){ var sel = '', result = [], context = [], arr = [], that = this; that.length = 0; if(!str){ return that; } if(typeof str === 'string'){ var group = str.split(','); for(var g = 0, glen = group.length; g = 0){ if(context.length){ for(var c = 0, clen = context.length; c = 0){ if(context.length){ for(var c = 0, clen = context.length; c = 0){ arr.push(dom[i]); } } return arr } } function $tag(tag, context){ if(context){ return context.getElementsByTagName(tag); }else{ return document.getElementsByTagName(tag); } } function $class(className, context){ if(context){ if(context.getElementsByClassName){ return context.getElementsByClassName(className); } }else{ if(document.getElementsByClassName){ return document.getElementsByClassName(className); } } var arr = []; if(context){ var dom = context.getElementsByTagName('*'); }else{ var dom = document.getElementsByTagName('*'); } for(var i = 0, len = dom.length; i = 0){ arr.push(dom[i]); } } return arr } return that; } ICD.extend = function() { var key ,arg = arguments ,i = 1 ,len = arg.length ,target = null; if(len === 0){ return; }else if(len === 1){ target = ICD.init.prototype; i--; }else{ target = arg[0]; } for(; i = 0; i--){ this[i].addEventListener(type, fn, false); } }else if(document.attachEvent){ function addEvent(dom){ dom.attachEvent('on' + type, function(){ fn.call(dom); }); } for(; i >= 0; i--){ // IE 下this为window，此解决办法事件不能移除，解决办法详见jQuery un方法 addEvent(this[i]); } }else{ for(; i >= 0; i--){ this[i]['on' + type] = fn; } } return this; } // 解除事件 ,un : function(type, fn){ if (this.length == 0) { return this; }; var i = this.length - 1; if(document.removeEventListener){ for(; i >= 0; i--){ this[i].removeEventListener(type, fn); } }else if(document.detachEvent){ for(; i >= 0; i--){ this[i].detachEvent(type, fn); } }else{ for(; i >= 0; i--){ this[i]['on' + type] = null; } } return this; } }); ICD.extend(ICD, { // 获取事件对象 getEvent : function(event){ return event ? event : window.event; } // 获取元素 ,getTarget : function(event){ var event = this.getEvent(event); return event.target || event.srcElement; } ,getICDTarget : function(event){ var event = this.getEvent(event); return ICD(event.target || event.srcElement); } // 阻止冒泡以及捕获 ,stopPropagation : function(event){ var event = this.getEvent(event); if(event.stopPropagation){ event.stopPropagation(); }else{ event.cancelBubble = true; } } // 阻止默认行为 ,preventDefault : function(event){ var event = this.getEvent(event); if(event.preventDefault){ event.preventDefault(); }else{ event.returnValue = false; } } ,getDetail : function(event){ var event = this.getEvent(event); if(event.wheelDelta){ return event.wheelDelta; }else{ return -event.detail * 40; } } }); //公共方法 ICD.extend(ICD, { camelCase : function(str){ return str.replace(/\\-(\\w)/g, function(all, letter){ return letter.toUpperCase(); }); }, trim : function(str){ return str.replace(/^\\s+|\\s+$/g, '') }, formateString : function(str, data){ return str.replace(/@\\((\\w+)\\)/g, function(match, key){ return typeof data[key] === \"undefined\" ? '' : data[key]}); } }); //元素模块 ICD.extend({ css : function(){ var arg = arguments, len = arg.length; if(this.length = 0; j--){ this[j].style[ICD.camelCase(i)] = arg[0][i]; } } } }else if(len === 2){ for(var j = this.length - 1; j >= 0; j--){ this[j].style[ICD.camelCase(arg[0])] = arg[1]; } } return this; } ,attr : function(){ var arg = arguments, len = arg.length; if(this.length = 0; j--){ this[j].setAttribute(i, arg[0][i]); } } } }else if(len === 2){ for(var j = this.length - 1; j >= 0; j--){ this[j].setAttribute(arg[0], arg[1]); } } return this; } ,html : function(){ var arg = arguments, len = arg.length; if(this.length = 0; i--){ this[i].innerHTML = arg[0]; } }else if(len === 2 && arg[1]){ for(var i = this.length - 1; i >= 0; i--){ this[i].innerHTML += arg[0]; } } return this; } ,hasClass : function(val){ if(!this[0]){ return; } var value = ICD.trim(val); return this[0].className.indexOf(value) >= 0 ? true : false; } ,addClass : function(val){ var value = ICD.trim(val), str = ''; for(var i = 0, len = this.length; i = 0){ this[i].className = this[i].className.replace(value, ''); }else{ this[i].className += ' ' + value; } } return this; } }); //操作模块 ICD.extend(ICD, { create : function(type, value){ var dom = document.createElement(type); return ICD().add(dom).attr(value); } ,directChildren : function(dom, tag){ var result = [], children, tag = tag; if(typeof dom == 'string'){ dom = ICD.init(dom); } if(dom.length){ for(var i = 0, len = dom.length; i = 0; j--){ this[j].appendChild(doms[i]); } } }, appendTo : function(parent){ var doms = ICD(parent); for(var i = 0; i = 0; j--){ doms[i].appendChild(this[j]); } } }, get : function(num){ return this[num] ? this[num] : null; }, eq : function(num){ return ICD(this.get(num)); } }) // 动画模块 var _requestAnimateFrame = (function(w, r){ var _lastTime = 0; return w['r' + r] || w['webkitR' + r] || w['mozR' + r] || w['msR' + r] || w['oR' + r] || function(callback, element) { var _currTime = +new Date(), _timeToCall = Math.max(0, 16 - (_currTime - _lastTime)), _newTime = _currTime + _timeToCall, id = w.setTimeout(function() { callback(_newTime); }, _timeToCall); _lastTime = _newTime; return id; }; })(window, 'equestAnimationFrame'), _cancelAnimateFrame = (function(w, c){ return w['c' + c] || w['webkitC' + c] || w['mozC' + c] || w['msC' + c] || w['oC' + c] || function(t){ clearTimeout(t); }; })(window, 'ancelAnimationFrame'), _setIntervalFram = function(callback, interval){ var id = setInterval(callback, interval); return id; }, _clearIntervalFram = function(id){ clearInterval(id); }; var Animate = function(interval){ this._timer = 0; this._queen = []; this._interval = interval || false; } Animate.prototype = { easing : { def: function (t, b, c, d) { return (c - b) * t / d + b }, linear : function(t, b, c, d){ return this.def(t, b, c, d); } } ,_run : function(){ if(this._timer) return; this._reset(); } ,_clear : function(){ !this._interval ? _cancelAnimateFrame(this._timer) : _clearIntervalFram(this._timer); this._timer = 0; } ,_reset : function(){ this._clear(); this._go(); } ,_go : function(){ var that = this; that._timer = !this._interval ? _requestAnimateFrame(function(){ that._loop(); }) : _setIntervalFram(function(){ that._loop(); }, that._interval); } ,_loop : function(){ if(this._queen.length === 0){ this._clear(); return; } var now = +new Date() ,i = this._queen.length - 1 ,instance = null; for(; i >= 0; i--){ instance = this._queen[i]; instance.passed = now - instance.time; if(instance.passed = instance.duration){ instance.passed = instance.duration; instance.tween = instance.to; this._execute(instance); this._destory(instance); }else{ this._bufferExec(instance); } instance = null; } !this._interval && this._go(); } ,_execute : function(instance){ try{ instance.main(instance.dom, instance.args); }catch(e){ } } ,_bufferExec : function(instance){ instance.tween = typeof instance.step === 'undefined' ? this.easing[instance.type](instance.passed, instance.from, instance.to, instance.duration) : instance.step; this._execute(instance); } ,_adaptInstance : function(instance){ var opinion = ICD.extend({}, { from : 0 ,to : 1 ,type : 'def' ,duration : 400 ,args : null ,dom : null ,main : function(){} ,time : +new Date() ,end : function(){} }); if(instance.type && !(instance.type in this.easing)) instance.type = 'def'; for(var key in opinion){ if(typeof instance[key] === 'undefined') instance[key] = opinion[key]; } return instance; } ,_addInstance : function(instance, shouldReset){ var obj = this._adaptInstance(instance), pos = this._getIndex(obj); if(pos = 0; i--){ if(this._queen[i] === instance){ return i } } return -1; } ,_destory : function(instance){ var that = this; that._queen.splice(that._getIndex(instance), 1); instance.end(instance.dom, instance.args); for(var key in instance){ delete instance[key]; } instance = null; } ,add : function(param, shouldReset){ if(!param) return; var tostring = Object.prototype.toString; if(tostring.call(param) === \"[object Array]\"){ for(var i = 0, len = param.length; i = 0){ this._queen[pos].time += getNewTime(this._queen[pos].time, this._queen[pos].passed); } this._run(); }else{ var i = this._queen.length - 1; for(; i >= 0; i--){ this._queen[i].time += getNewTime(this._queen[i].time, this._queen[i].passed); } this._run(); } function getNewTime(queenTime, passTime){ return +new Date() - queenTime - (!!passTime ? +passTime : 0); } return this; } ,clear : function(){ this._clear(); var i = this._queen.length - 1; for(; i >= 0; i--){ this._destory(this._queen[i]); } return this; } ,remove : function(instance){ this._destory(this._adaptInstance(instance)); return this; } ,changeInterval : function(interval){ this._clear(); if(typeof interval === 'number'){ this._interval = interval; }else if(typeof interval === 'boolean' && !interval){ this._interval = interval; }else if(!interval){ this._interval = !!interval; } this._go(); return this; } // number, object, string, boolean ,create : function(){ var len = arguments.length, _num = null, cout = 1; if(typeof arguments[0] === \"number\"){ _num = arguments[0]; }else{ cont = 0; } if(len > cout){ if(typeof arguments[cout] === \"object\"){ arguments[cout][arguments[cout + 1] && typeof arguments[cout + 1] === \"string\" ? arguments[cout + 1] : 'animate'] = new Animate(_num); if((arguments[cout + 1] && typeof arguments[cout + 1] === \"boolean\") || (arguments[cout + 2] && typeof arguments[cout + 2] === \"boolean\")){ delete w.animate; } }else if(typeof arguments[cout] === \"string\"){ if(typeof arguments[cout] === \"boolean\"){ return new Animate(_num); }else{ try{ if(arguments[cout] in w) return; }catch(e){} w[arguments[cout]] = new Animate(_num); delete w.animate; } }else{ return new Animate(_num); } }else{ if(_num){ w.animate = new Animate(_num); }else{ return new Animate(); } } return this; } } ICD.extend(ICD, { animate : new Animate() }); ICD.extend({ tween : ICD.animate.create(), animate : function(obj){ obj.dom = this; this.tween.add(obj); return this; } }); ICD.noConflict = function(library){ if(library){ window.$ = library; }else{ window.$ = null; delete window.$; } return ICD; } window.ICD = window.$ = ICD; })(window); // 算法扩展 ICD.extend(ICD.animate.easing, { swing: function (t, b, c, d) { return this.easeOutQuad(t, b, c, d); }, easeInQuad: function (t, b, c, d) { return c*(t/=d)*t + b; }, easeOutQuad: function (t, b, c, d) { return -c *(t/=d)*(t-2) + b; }, easeInOutQuad: function (t, b, c, d) { if ((t/=d/2) "},"Js/js基础/js-es6-Map.html":{"url":"Js/js基础/js-es6-Map.html","title":"Js ES6 Map","keywords":"","body":"es6 javascript的map数据类型转换 es6 javascript的map数据类型转换 1. Map定义 | 属性 | 方法 1.1. 定义 1.2. 语法 1.3. 属性 1.4. 方法 示例 2. 数据类型转换 2.1. Map 转为数组 2.2. 数组转为 Map 2.3. Map 转为对象 2.4. 对象转为 Map 2.5. Map 转为 JSON 2.6. JSON 转为 Map 1. Map定义 | 属性 | 方法 1.1. 定义 键/值对的集合 1.2. 语法 mapObj = new Map() 集合中的键和值可以是任何类型。如果使用现有密钥向集合添加值，则新值会替换旧值。 1.3. 属性 下表列出了 Map 对象的属性和描述 构造函数 指定创建映射的函数。 Prototype — 原型 为映射返回对原型的引用。 size 返回映射中的元素数。 1.4. 方法 下表列出了 Map 对象的方法和描述。 clear 从映射中移除所有元素。 delete 从映射中移除指定的元素。 forEach 对映射中的每个元素执行指定操作。 get 返回映射中的指定元素。 has 如果映射包含指定元素，则返回 true。 set 添加一个新建元素到映射。 toString 返回映射的字符串表示形式。 valueOf 返回指定对象的原始值。 示例 var m = new Map(); m.set(1, \"black\"); m.set(2, \"red\"); m.set(\"colors\", 2); m.set({x:1}, 3); m.forEach(function (item, key, mapObj) { document.write(item.toString() + \"\"); }); document.write(\"\"); document.write(m.get(2)); // Output: // black // red // 2 // 3 // // red 2. 数据类型转换 2.1. Map 转为数组 // 使用扩展运算符(...) let myMap = new Map().set(true, 7).set({ foo: 3 }, ['abc']); [...myMap] // [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ] 2.2. 数组转为 Map 将数组转入 Map 构造函数, 就可以转为 Map new Map([ [true, 7], [ { foo: 3 }, ['abc'] ] ]) // Map {true => 7, Object {foo: 3} => ['abc']} 2.3. Map 转为对象 如果所有 Map 的键都是字符串, 它可以转为对象。 function strMapToObj(strMap) { let obj = Object.create(null); for (let [k, v] of strMap) { obj[k] = v; } return obj; } let myMap = new Map().set('yes', true).set('no', false); strMapToObj(myMap) // { yes: true, no: false } 2.4. 对象转为 Map function objToStrMap(obj) { let strMap = new Map(); for (let k of Object.keys(obj)) { strMap.set(k, obj[k]); } return strMap; } objToStrMap({ yes: true, no: false }) // [ [ 'yes', true ], [ 'no', false ] ] 2.5. Map 转为 JSON Map 转为 JSON 要区分两种情况。 一种情况是, Map 的键名都是字符串, 这时可以选择转为对象 JSON。 function strMapToJson(strMap) { return JSON.stringify(strMapToObj(strMap)); } let myMap = new Map().set('yes', true).set('no', false); strMapToJson(myMap) // '{\"yes\":true,\"no\":false}' 另一种情况是, Map 的键名有非字符串, 这时可以选择转为数组 JSON。 function mapToArrayJson(map) { return JSON.stringify([...map]); } let myMap = new Map().set(true, 7).set({ foo: 3 }, ['abc']); mapToArrayJson(myMap) // '[[true,7],[{\"foo\":3},[\"abc\"]]]' 2.6. JSON 转为 Map JSON 转为 Map, 正常情况下, 所有键名都是字符串。 function jsonToStrMap(jsonStr) { return objToStrMap(JSON.parse(jsonStr)); } jsonToStrMap('{\"yes\":true,\"no\":false}') // Map {'yes' => true, 'no' => false} 但是, 有一种特殊情况, 整个 JSON 就是一个数组, 且每个数组成员本身, 又是一个有两个成员的数组。 这时, 它可以一一对应地转为 Map。 这往往是数组转为 JSON 的逆操作。 function jsonToMap(jsonStr) { return new Map(JSON.parse(jsonStr)); } jsonToMap('[[true,7],[{\"foo\":3},[\"abc\"]]]') // Map {true => 7, Object {foo: 3} => ['abc']} "},"Js/js基础/ES6-数组array新增方法.html":{"url":"Js/js基础/ES6-数组array新增方法.html","title":"ES6-数组array新增方法","keywords":"","body":"ES6---数组array新增方法 ES6---数组array新增方法 1. find(fn) 2. findIndex 3. includes 4. keys 5. values 6. entries 7. fill 8. Array.of() 9. Array.from() 10. copyWithin 1. find(fn) find的参数为回调函数，回调函数可以接收3个参数，值x、索引i、数组arr，回调函数默认返回值x。 let arr=[1,2,234,'sdf',-2]; arr.find(function(x){ return x 2. findIndex findIndex和find差不多，不过默认返回的是索引 let arr=[1,2,234,'sdf',-2]; arr.findIndex(function(x){ return x 3. includes includes函数与string的includes一样，接收2参数，查询的项以及查询起始位置。 let arr=[1,2,234,'sdf',-2]; arr.includes(2);// 结果true，返回布尔值 arr.includes(20);// 结果：false，返回布尔值 arr.includes(2,3)//结果：false，返回布尔值 4. keys keys，对数组索引的遍历 let arr=[1,2,234,'sdf',-2]; for(let a of arr.keys()){ console.log(a) }//结果：0,1,2,3,4 遍历了数组arr的索引 5. values values，对数组项的遍历 let arr=[1,2,234,'sdf',-2]; for(let a of arr.values()){ console.log(a) }//结果：1,2,234,sdf,-2 遍历了数组arr的值 6. entries entries，对数组键值对的遍历。 let arr=['w','b']; for(let a of arr.entries()){ console.log(a) }//结果：[0,w],[1,b] for(let [i,v] of arr.entries()){ console.log(i,v) }//结果：0 w,1 b 7. fill fill方法改变原数组，当第三个参数大于数组长度时候，以最后一位为结束位置。 let arr=['w','b']; arr.fill('i')//结果：['i','i']，改变原数组 arr.fill('o',1)//结果：['i','o']改变原数组,第二个参数表示填充起始位置 new Array(3).fill('k').fill('r',1,2)//结果：['k','r','k']，第三个数组表示填充的结束位置 8. Array.of() Array.of()方法永远返回一个数组，参数不分类型，只分数量，数量为0返回空数组。 Array.of('w','i','r')//[\"w\", \"i\", \"r\"]返回数组 Array.of(['w','o'])//[['w','o']]返回嵌套数组 Array.of(undefined)//[undefined]依然返回数组 Array.of()//[]返回一个空数组 9. Array.from() Array.from可以把带有lenght属性类似数组的对象转换为数组，也可以把字符串等可以遍历的对象转换为数组，它接收2个参数，转换对象与回调函数 Array.from({'0':'w','1':'b',length:2})//[\"w\", \"b\"],返回数组的长度取决于对象中的length，故此项必须有！ Array.from({'0':'w','1':'b',length:4})//[\"w\", \"b\", undefined, undefined],数组后2项没有属性去赋值，故undefined Array.from({'0':'w','1':'b',length:1})//[\"w\"],length小于key的数目，按序添加数组 ////////////////////////////// let divs=document.getElementsByTagName('div'); Array.from(divs)//返回div元素数组 Array.from('wbiokr')//[\"w\", \"b\", \"i\", \"o\", \"k\", \"r\"] Array.from([1,2,3],function(x){ return x+1 } )//[2, 3, 4],第二个参数为回调函数 10. copyWithin copyWithin方法接收三个参数，被替换数据的开始处、替换块的开始处、替换块的结束处(不包括);copyWithin(s,m,n). [\"w\", \"i\", \"r\"].copyWithin(0)//此时数组不变 [\"w\", \"i\", \"r\"].copyWithin(1)//[\"w\", \"w\", \"i\"],数组从位置1开始被原数组覆盖，只有1之前的项0保持不变 [\"w\", \"i\", \"r\",\"b\"].copyWithin(1,2)//[\"w\", \"r\", \"b\", \"b\"],索引2到最后的r,b两项分别替换到原数组1开始的各项，当数量不够，变终止 [\"w\", \"i\", \"r\",'b'].copyWithin(1,2,3)//[\"w\", \"r\", \"r\", \"b\"]，强第1项的i替换为第2项的r "},"Js/js基础/require和import区别.html":{"url":"Js/js基础/require和import区别.html","title":"require和import区别","keywords":"","body":"JS 中的require 和 import 区别 这两个都是为了JS模块化编程使用. 1. 遵循规范 require 是 AMD规范引入方式 import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法 2. 调用时间 require是运行时调用，所以require理论上可以运用在代码的任何地方 import是编译时调用，所以必须放在文件开头 3. 本质 require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量 import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require require / exports ： 遵循 CommonJS/AMD，只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化。 用法只有以下三种简单的写法： const fs = require('fs') exports.fs = fs module.exports = fs import / export： 遵循 ES6 规范，支持编译时静态分析，便于JS引入宏和类型检验。动态绑定。 写法就比较多种多样： import fs from 'fs' import {default as fs} from 'fs' import * as fs from 'fs' import {readFile} from 'fs' import {readFile as read} from 'fs' import fs, {readFile} from 'fs' export default fs export const fs export function readFile export {readFile, read} export * from 'fs' ` 通过require引入基础数据类型时，属于复制该变量。 通过require引入复杂数据类型时，数据浅拷贝该对象。 出现模块之间的循环引用时，会输出已经执行的模块，而未执行的模块不输出（比较复杂） CommonJS模块默认export的是一个对象，即使导出的是基础数据类型 加载方式 规范 命令 特点 运行时加载 CommonJS/AMD require 社区方案，提供了服务器/浏览器的模块加载方案。非语言层面的标准。只能在运行时确定模块的依赖关系及输入/输出的变量，无法进行静态优化。 编译时加载 ESMAScript6+ import 语言规格层面支持模块功能。支持编译时静态分析，便于JS引入宏和类型检验。动态绑定 "},"Js/js基础/window.history方法总结.html":{"url":"Js/js基础/window.history方法总结.html","title":"window.history方法总结","keywords":"","body":"window.history 方法总结 一、历史记录概览 window.history.back(); window.history.forward(); window.history.go(-1); window.history.go(1); var numberOfEntries = window.history.length; 二、添加和修改历史记录条目： 1、history.pushState(); 2、history.replaceState(); 两种方法都允许我们添加和更新历史记录，它们的工作原理相同并且可以添加数量相同的参数。 除了方法之外，还有popstate事件。在后文中将介绍怎么使用和什么时候使用popstate事件。 pushState()和replaceState()参数一样，参数说明如下： 1、state：存储JSON字符串，可以用在popstate事件中。 2、title：现在大多数浏览器不支持或者忽略这个参数，最好用null代替 3、url：任意有效的URL，用于更新浏览器的地址栏，并不在乎URL是否已经存在地址列表中。更重要的是，它不会重新加载页面。 两个方法的主要区别就是：pushState()是在history栈中添加一个新的条目，replaceState()是替换当前的记录值。 使用方法： onpopstate window.onpopstate = function(event) { alert(\"location: \" + document.location + \", state: \" + JSON.stringify(event.state)); }; //绑定事件处理函数. history.pushState({page: 1}, \"title 1\", \"?page=1\"); //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1 history.pushState({page: 2}, \"title 2\", \"?page=2\"); //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2 history.replaceState({page: 3}, \"title 3\", \"?page=3\"); //修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3 history.back(); // 弹出 \"location: http://example.com/example.html?page=1, state: {\"page\":1}\" history.back(); // 弹出 \"location: http://example.com/example.html, state: null history.go(2); // 弹出 \"location: http://example.com/example.html?page=3, state: {\"page\":3} pushState 在history栈中添加一个新的条目 var stateObj = { foo: \"bar\" }; history.pushState(stateObj, \"page 2\", \"bar.html\"); replaceState 替换当前的记录值 history.replaceState(stateObj, \"page 2\", \"bar.html\"); 读取当前状态 在页面加载时，可能会包含一个非空的状态对象。这种情况是会发生的，例如，如果页面中使用pushState()或replaceState()方法设置了一个状态对象，然后用户重启了浏览器。当页面重新加载时，页面会触发onload事件，但不会触发popstate事件。但是，如果你读取 history.state 属性，你会得到一个与 popstate 事件触发时得到的一样的状态对象。 你可以直接读取当前历史记录条目的状态，而不需要等待popstate事件： var currentState = history.state; 微信中打开头条新闻， 返回却到头条webApp首页源码，实现PV回流增长！ 这种提高网站流量的方式，各大门户网站都在使用，包括通过App推送push的一些消息，通过浏览器打开的详情页面都做了这种措施。 实现并不困难，重点就在监听了浏览器返回的历史记录。 具体代码： function Goback(url){ setTimeout(function () { if (history.length "},"Js/js基础/fetch.html":{"url":"Js/js基础/fetch.html","title":"fetch","keywords":"","body":"在 JS 中使用 fetch 更加高效地进行网络请求 Why Fetch XMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。 使用 XHR 发送一个 json 请求一般是这样： var xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.responseType = 'json'; xhr.onload = function() { console.log(xhr.response); }; xhr.onerror = function() { console.log(\"Oops, error\"); }; 使用 Fetch： fetch(url).then(function(response) { return response.json(); }).then(function(data) { console.log(data); }).catch(function(e) { console.log(\"Oops, error\"); }); 使用 ES6 的 箭头函数： fetch(url).then(response => response.json()) .then(data => console.log(data)) .catch(e => console.log(\"Oops, error\", e)) 使用 async/await 来做最终优化： try { let response = await fetch(url); let data = response.json(); console.log(data); } catch(e) { console.log(\"Oops, error\", e); } // 注：这段代码如果想运行，外面需要包一个 async function Fetch 常见坑 Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: 'include'}) 服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。 Fetch 和标准 Promise 的不足 没有 Deferred Deferred 可以在创建 Promise 时可以减少一层嵌套，还有就是跨方法使用时很方便。 没有获取状态方法：isRejected，isResolved 标准 Promise 没有提供获取当前状态 rejected 或者 resolved 的方法。只允许外部传入成功或失败后的回调。我认为这其实是优点，这是一种声明式的接口，更简单。 缺少其它一些方法：always，progress，finally always 可以通过在 then 和 catch 里重复调用方法实现。finally 也类似。progress 这种进度通知的功能还没有用过，暂不知道如何替代。 不能中断，没有 abort、terminate、onTimeout 或 cancel 方法 Fetch 和 Promise 一样，一旦发起，不能中断，也不会超时，只能等待被 resolve 或 reject。幸运的是，whatwg 目前正在尝试解决这个问题whatwg/fetch#27 fetch进行post请求为什么会首先发一个options 请求? 不仅仅是fetch，只要你满足以下几种情况，都会去发起一个 Preflighted requests，也就是options请求， It uses methods other than GET, HEAD or POST. Also, if POST is used to send request data with a Content-Type other than application/x-www-form-urlencoded, multipart/form-data, ortext/plain, e.g. if the POST request sends an XML payload to the server using application/xmlor text/xml, then the request is preflighted. It sets custom headers in the request (e.g. the request uses a header such as X-PINGOTHER) 浏览器在发起跨域请求的时候会带着一个Origin header，那么其实就是个custom headers，那么也就会先触发一个Preflighted requests， 最近在用fetch请求接口数据时，会自动加上一次OPTIONS请求，而且还会返回数据。后面发现是因为这次请求在header上加了个Authorization字段（以前的项目如果不在header上加字段的话，是不会看到这次请求的），这样fetch就会默认发送一次OPTIONS检测是否有权限调用，后面后端就判断了下，当请求是OPTIONS，直接设置返回的头部信息就行了，这样虽然每次还会调用OPTIONS接口，但起码不会有数据了 if($_SERVE['REQUEST_METHOD'] === 'OPTIONS') { header(\"Access-Control-Allow-Origin: *\"); header(\"Access-Control-Allow-Origin-Headers: Authorization\"); exit; } "},"Js/js基础/Js判断字符串中是否包含某个字符串.html":{"url":"Js/js基础/Js判断字符串中是否包含某个字符串.html","title":"Js判断字符串中是否包含某个字符串","keywords":"","body":"js 判断字符串中是否包含某个字符串 1. String对象的方法 indexOf() var str = \"123\"; console.log(str.indexOf(\"3\") != -1 ); // true indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。如果要检索的字符串值没有出现，则该方法返回 -1。 search() var str = \"123\"; console.log(str.search(\"3\") != -1 ); // true search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。如果没有找到任何匹配的子串，则返回 -1。 match() var str = \"123\"; var reg = RegExp(/3/); if(str.match(reg)){ // 包含 } match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 2. RegExp 对象方法 test() var str = \"123\"; var reg = RegExp(/3/); console.log(reg.test(str)); // true test() 方法用于检索字符串中指定的值。返回 true 或 false。 exec() var str = \"123\"; var reg = RegExp(/3/); if(reg.exec(str)){ // 包含 } exec() 方法用于检索字符串中的正则表达式的匹配。返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 3. ES6 includes() str.includes(searchString[, position]) searchString：查询的子字符串 position：可选，开始搜索的位置，默认为0 'Blue Whale'.includes('Blue'); // returns true 'Blue Whale'.includes('blue'); // returns false includes方法是会区分大小写。 对于不支持es6的浏览器，可以添加es6-shim，如： require('es6-shim') 4. ES6 startsWith() endsWith() startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 Polyfill /*! http://mths.be/startswith v0.2.0 by @mathias */ if (!String.prototype.startsWith) { (function() { 'use strict'; // needed to support `apply`/`call` with `undefined`/`null` var defineProperty = (function() { // IE 8 only supports `Object.defineProperty` on DOM elements try { var object = {}; var $defineProperty = Object.defineProperty; var result = $defineProperty(object, object, object) && $defineProperty; } catch(error) {} return result; }()); var toString = {}.toString; var startsWith = function(search) { if (this == null) { throw TypeError(); } var string = String(this); if (search && toString.call(search) == '[object RegExp]') { throw TypeError(); } var stringLength = string.length; var searchString = String(search); var searchLength = searchString.length; var position = arguments.length > 1 ? arguments[1] : undefined; // `ToInteger` var pos = position ? Number(position) : 0; if (pos != pos) { // better `isNaN` pos = 0; } var start = Math.min(Math.max(pos, 0), stringLength); // Avoid the `indexOf` call if no match is possible if (searchLength + start > stringLength) { return false; } var index = -1; while (++index "},"Js/js基础/三种js类的实现方法[es5和es6].html":{"url":"Js/js基础/三种js类的实现方法[es5和es6].html","title":"三种js类的实现方法(es5和es6)","keywords":"","body":"1.通过构造函数+原型实现类 /** * 构造器方法/变量和原型中的方法变量之间的区别： * 1. 原型上的方法和变量，是该类所有实例化对象共享的。 * 也就是说，只有一份。 * * 2. 而构造器内的代码块，则是每个实例化对象单独占有- - * ->不管是否用this.**方式，还是私有变量的方式，都是独占的。 * * 所以，在写一个类的时候，需要考虑该新增属性是共享的，还是独占的。 * 以此，决定在构造器还是原型上进行声明。 */ //构造函数，默认大写开头 function Toast(option){ // 类的实例化，一个强制要求的行为，就是需要使用new操作符。 // 如果不使用new操作符，那么构造器内的this指向，将不是当前的实例化对象。 // ES5: 使用instanceof做一层防护。 // ES6： typeof new.target !== \"undefined\" if(!(this instanceof Toast)){ return new Toast(option); } // 这里或者抛出一个错误的信息也可以 // if(typeof new.target !== \"undefined\")){ // throw new Error('Toast instantiation error'); // } this.prompt = ''; //toast中的内容 this.elem = null; //定义元素dom结构 this.init(option); //构造函数的入口； } Toast.prototype = { // 构造器 constructor:Toast, //必须重新定义原型指向 // 初始化方法 init: function(option){ this.prompt = option.prompt || ''; this.render(); this.bindEvent(); return this; //链式操作的核心 }, // 显示 show: function(time){ var that=this; this.changeStyle(this.elem, 'display', 'block'); setTimeout(function(){ that.hide(); },time); }, // 隐藏 hide: function(){ this.changeStyle(this.elem, 'display', 'none'); }, // 画出dom render: function(){ var html = ''; this.elem = document.createElement('div'); this.changeStyle(this.elem, 'display', 'none'); html += 'x' html += ''+ this.prompt +''; this.elem.innerHTML = html; return document.body.appendChild(this.elem); }, // 绑定事件 bindEvent: function(){ var self = this; this.addEvent(this.elem, 'click', function(e){ if(e.target.className.indexOf('J-close') != -1){ console.log('close Toast!'); self.hide(); } }); }, // 添加事件方法 addEvent: function(node, name, fn){ var self = this; node.addEventListener(name,function(){ fn.apply(self,Array.prototype.slice.call(arguments)); },false); }, // 改变样式 changeStyle: function(node, key, value){ node.style[key] = value; } }; var T=new Toast({prompt:'I\\'m Toast!'}).show(2000); //链式操作 2.构造函数+内部函数+对象字面量对外暴露 /** * 在平时开发页面的过程中对于某一块的功能进行内部的封装， * 优点是代码组织简洁，需要提前规划好对外暴露的接口 */ function Toast(){ // 已点歌曲 function init(option){ this.prompt = option.prompt || ''; render(); bindEvent(); } function show(time){ changeStyle(this.elem, 'display', 'block'); setTimeout(function(){ hide(); },time); } function hide(){ changeStyle(this.elem, 'display', 'none'); } function render(){ var html = ''; this.elem = document.createElement('div'); changeStyle(this.elem, 'display', 'none'); html += 'x' html += ''+ this.prompt +''; this.elem.innerHTML = html; return document.body.appendChild(this.elem); } //绑定点击事件 function bindEvent(){ var self = this; addEvent(this.elem,'click',function(e){ if(e.target.className.indexOf('J-close') != -1){ self.hide(); }else{ alert(\"绑定的点击事件生效了\"); } }); } // 添加绑定多种事件的方法 function addEvent(node,name,fn){ var self = this; node.addEventListener(name,function(){ fn.apply(self,Array.prototype.slice.call(arguments)); },false); } // 改变样式 function changeStyle(node,key,value){ node.style[key]=value; } /** * @Desc: 将上述方法综合起来使用， * 这些方法仅仅在构造函数内部进行使用，对外仅仅暴露开启和关闭方法即可 */ var service = { start: function(config){ init(config); //构造函数的入口； show(20000); }, stop: function(){ hide(); } }; return service; //将该组件的接口暴露出去 } // 使用案例 var T= new Toast(); T.start({prompt:'I\\'m Toast!',elem:document.getElementById(\"test\")}); //先创建一个测试元素 3. ES6 class创建 /** * class类实现可以通过extends对类进行方法继承 */ class Toast { // constructor(x, y) { // this.x = x; // this.y = y; // } // 已点歌曲 init(option){ this.prompt = option.prompt || ''; render(); bindEvent(); show(2000); } show(time){ changeStyle(this.elem, 'display', 'block'); setTimeout(function(){ hide(); },time); } hide(){ changeStyle(this.elem, 'display','none'); } render(config){ var html = ''; this.elem = document.createElement('div'); this.changeStyle(this.elem, 'display', 'block'); html += 'x' html += ''+ config.prompt +''; this.elem.innerHTML = html; return document.body.appendChild(this.elem); } //绑定点击事件 bindEvent(){ var self = this; this.addEvent(this.elem,'click',function(e){ if(e.target.className.indexOf('J-close') != -1){ self.hide(); }else{ alert(\"绑定的点击事件生效了\"); } }); } // 添加绑定多种事件的方法 addEvent(node,name,fn){ var self = this; node.addEventListener(name,function(){ fn.apply(self,Array.prototype.slice.call(arguments)); },false); } // 改变样式 changeStyle(node,key,value){ node.style[key]=value; } } var T= new Toast(); T.render({prompt:'I\\'m Toast!',elem:document.getElementById(\"test\")}); //先创建一个测试元素 T.bindEvent(); "},"Js/js基础/async-await.html":{"url":"Js/js基础/async-await.html","title":"async await","keywords":"","body":"async/await async/await Async 与其他异步操作的对比 Promise 方式 Generator 方式 ES7 提出的async 函数，终于让 JavaScript 对于异步操作有了终极解决方案。No more callback hell。 async 函数是 Generator 函数的语法糖。使用 关键字 async 来表示，在函数内部使用 await 来表示异步。 相较于 Generator，Async 函数的改进在于下面四点： 内置执行器。 Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟普通函数的调用一样 更好的语义。 async 和 await 相较于 * 和 yield 更加语义化 更广的适用性。 co 模块约定，yield 命令后面只能是 Thunk 函数或 Promise对象。而 async 函数的 await 命令后面则可以是 Promise 或者 原始类型的值（Number，string，boolean，但这时等同于同步操作） 返回值是 Promise。 async 函数返回值是 Promise 对象，比 Generator 函数返回的 Iterator 对象方便，可以直接使用 then() 方法进行调用 Async 与其他异步操作的对比 先定义一个 Fetch 方法用于获取 github user 的信息： function fetchUser() { return new Promise((resolve, reject) => { fetch('https://api.github.com/users/superman66') .then((data) => { resolve(data.json()); }, (error) => { reject(error); }) }); } Promise 方式 /** * Promise 方式 */ function getUserByPromise() { fetchUser() .then((data) => { console.log(data); }, (error) => { console.log(error); }) } getUserByPromise(); Promise 的方式虽然解决了 callback hell，但是这种方式充满了 Promise的 then() 方法，如果处理流程复杂的话，整段代码将充满 then。语义化不明显，代码流程不能很好的表示执行流程。 Generator 方式 /** * Generator 方式 */ function* fetchUserByGenerator() { const user = yield fetchUser(); return user; } const g = fetchUserByGenerator(); const result = g.next().value; result.then((v) => { console.log(v); }, (error) => { console.log(error); }) Generator 的方式解决了 Promise 的一些问题，流程更加直观、语义化。但是 Generator 的问题在于，函数的执行需要依靠执行器，每次都需要通过 g.next() 的方式去执行。 async 方式 /** * async 方式 */ async function getUserByAsync(){ let user = await fetchUser(); return user; } getUserByAsync() .then(v => console.log(v)); async 函数完美的解决了上面两种方式的问题。流程清晰，直观、语义明显。操作异步流程就如同操作同步流程。同时 async 函数自带执行器，执行的时候无需手动加载。 语法 async 函数返回一个 Promise 对象 async 函数内部 return 返回的值。会成为 then 方法回调函数的参数 async function f() { return 'hello world' }; f().then( (v) => console.log(v)) // hello world 如果 async 函数内部抛出异常，则会导致返回的 Promise 对象状态变为 reject 状态。抛出的错误而会被 catch 方法回调函数接收到。 async function e(){ throw new Error('error'); } e().then(v => console.log(v)) .catch( e => console.log(e)); async 函数返回的 Promise 对象，必须等到内部所有的 await 命令的 Promise 对象执行完，才会发生状态改变 也就是说，只有当 async 函数内部的异步操作都执行完，才会执行 then 方法的回调。 const delay = timeout => new Promise(resolve=> setTimeout(resolve, timeout)); async function f(){ await delay(1000); await delay(2000); await delay(3000); return 'done'; } f().then(v => console.log(v)); // 等待6s后才输出 'done' 正常情况下，await 命令后面跟着的是 Promise ，如果不是的话，也会被转换成一个 立即 resolve 的 Promise 如下面这个例子： async function f() { return await 1 }; f().then( (v) => console.log(v)) // 1 如果返回的是 reject 的状态，则会被 catch 方法捕获。 Async 函数的错误处理 async 函数的语法不难，难在错误处理上。 先来看下面的例子： let a; async function f() { await Promise.reject('error'); a = await 1; // 这段 await 并没有执行 } f().then(v => console.log(a)); 如上面所示，当 async 函数中只要一个 await 出现 reject 状态，则后面的 await 都不会被执行。 解决办法：可以添加 try/catch。 // 正确的写法 let a; async function correct() { try { await Promise.reject('error') } catch (error) { console.log(error); } a = await 1; return a; } correct().then(v => console.log(a)); // 1 如果有多个 await 则可以将其都放在 try/catch 中。 如何在项目中使用 依然是通过 babel 来使用。 只需要设置 presets 为 stage-3 即可。 安装依赖： npm install babel-preset-es2015 babel-preset-stage-3 babel-runtime babel-plugin-transform-runtime 修改.babelrc: \"presets\": [\"es2015\", \"stage-3\"], \"plugins\": [\"transform-runtime\"] "},"Js/js基础/关于移动端,webview监听滚动条的坑.html":{"url":"Js/js基础/关于移动端,webview监听滚动条的坑.html","title":"关于移动端,webview监听滚动条的坑","keywords":"","body":"关于移动端,webview 监听滚动条的坑 最近接到一个需求，中途需要动态设置滚动条的scrolltop值，发现在PC上都没问题，然而上测试环境，各种问题，页面老是不按照设想的那样，最终发现是移动端对滚动条的处理不一致导致。 DEMO： window.onload = function() { window.addEventListener(\"scroll\", function() { var a = document.documentElement.scrollTop; var b = document.body.scrollTop; document.getElementById(\"win\").innerText = a + \"/\" + b; }); document.addEventListener(\"scroll\", function() { var a = document.documentElement.scrollTop; var b = document.body.scrollTop; document.getElementById(\"doc\").innerText = a + \"/\" + b; }) } 监听滚动条事件 body { width: 100%; height: auto; position: relative; } .main { width: 100%; } .fix { position: fixed; left: 0px; top: 0px; width: 100%; height: 200px; background: red; text-align: center; line-height: 50px; font-size: 40px; } window.onload = function() { window.addEventListener(\"scroll\", function() { var a = document.documentElement.scrollTop; var b = document.body.scrollTop; document.getElementById(\"win\").innerText = a + \"/\" + b; }); document.addEventListener(\"scroll\", function() { var a = document.documentElement.scrollTop; var b = document.body.scrollTop; document.getElementById(\"doc\").innerText = a + \"/\" + b; }) } window.addEventListener： document.addEventListenerspan： 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 11111111111 22222222222 33333333333 44444444444 55555555555 PC上： 手机上： 所以移动端需要设置滚动条请使用 document.body.scrollTop PC上使用： document.documentElement.scrollTop "},"Js/js基础/js类型转换.html":{"url":"Js/js基础/js类型转换.html","title":"js类型转换","keywords":"","body":"js 类型转换 js 类型转换 一、JS运算符的优先级 二、JS的类型转化 1. 对于非原始类型的，通过ToPrimitive() 将值转换成原始类型： 2. 通过ToNumber()把值转换成Number 3. 通过ToString()把值转化成字符串 三、步步执行 四、小结 五、 ECMAScript的规范定义的抽象操作 5.1 原始值 5.2 GetValue(v) 5.3 SameValue(x,y) 5.4 ToPrimitive(input [ , PreferredType]) obj.valueOf() 和 obj.toString() toString用来返回对象的字符串表示。 valueOf方法返回对象的原始值，可能是字符串、数值或bool值等，看具体的对象。 5.5 ToNumber(x) 5.6 ToString(x) 5.7 ==转换规则： [六、验证分析++[[]][+[]]++[]]==10? [1.首先++[[]][+[]]++[]]首先拆分一下： 2.先来分析右边的[+[]] [3.再来分析左边边的++[[]]+[]] 4.分析问题错误的原因 5.进一步拆分 // sb (!(~+[])+{})[--[~+\"\"][+[]]*[~+[]] + ~~!+[]]+({}+[])[[~!+[]]*~+[]] // nb ([][[]]+[])[+!![]]+([]+{})[!+[]+!![]] 一、JS运算符的优先级 优先级的排列如下表： 优先级从高到低： 运算符 说明 .[]() 字段访问、数组下标、函数调用以及表达式分组 ++ — - + ~ ! delete new typeof void 一元运算符、返回数据类型、对象创建、未定义值 * / % 相乘、相除、求余数 + - + 相加、 相减、字符串串联 > >>> 移位 >= instanceof 小于、 小于或等于、 大于、 大于或等于、 是否为特定类型的实例 == != === !== & 按位”与\" ^ 按位“异或” \\ 按位“或” && 逻辑“与” \\ \\ 逻辑“或” ?: 条件运算 = OP= 赋值、 赋值运算（ 如 += 和 &= ） ， 多个计算 根据此规则，我们把这一串运算分为以下16个子表达式： 运算符用红色标出，有一点可能大家会意识不到，其实中括号[]也是一个运算符，用来通过索引访问数组项，另外也可以访问字符串的子字符，有点类似charAt方法，如：'abcd'[1] // 返回’b’。而且中括号的优先级还是最高的 二、JS的类型转化 先说说什么情况下需要进行类型转化。当操作符两边的操作数类型不一致或者不是基本类型（也叫原始类型）时，需要进行类型转化。先按运算符来分一下类： 减号-，乘号*，肯定是进行数学运算，所以操作数需转化为number类型。 加号+，可能是字符串拼接，也可能是数学运算，所以可能会转化为number或string 一元运算，如+[]，只有一个操作数的，转化为number类型 下面来看一下转化规则。 1. 对于非原始类型的，通过ToPrimitive() 将值转换成原始类型： ToPrimitive(input, PreferredType?) 可选参数PreferredType是Number或者是String。返回值为任何原始值。如果PreferredType是Number，执行顺序如下： 如果input为primitive，返回 否则，input为Object。调用 obj.valueOf()。如果结果是primitive，返回。 否则，调用obj.toString(). 如果结果是primitive，返回 否则，抛出TypeError 如果 PreferredType是String，步骤2跟3互换，如果PreferredType没有，Date实例被设置成String，其他都是Number 2. 通过ToNumber()把值转换成Number 规则如下： 参数 结果 Undefined NaN Null +0 Boolean true转换为1, false 转换为0 number 无需转换 string 由字符串解析为数字，如\"123\"被转换为123 3. 通过ToString()把值转化成字符串 规则如下： 参数 结果 undefined \"undefined\" null \"null\" boolean \"true\"或者\"false\" number 数字作为字符串，比如，\"1.765\" string 无需转换 三、步步执行 先看最简单的子表达式16：+[] 只有一个操作数[]，肯定是转化为number了，根据上面的规则2，[]是个数组，object类型，即对象。所以得先调用toPrimitive转化为原始类型，并且PreferredType为number，这个参数表示更“倾向于”转化的类型，这里肯定是number了。然后首先调用数组的valueOf方法，数组调用valueOf会返回自身，如下： [].valueOf() // [] 这个时候，我们得到一个空串“”，还没有结束，看上面的规则2描述，继续调用toNumber，转化为number类型，如下： Number('') // 0 子表达式16转化完毕，+[]，最终得到0。 来看子表达式15：[~+””] 空串””前面有两个一元操作符，但是操作数还是只有一个，所以，最终要转化为的类型是number。看规则2吧，空串调用toNumber得到0。接下来是~，这是个什么东东呢？它是位运算符，作用可以记为把数字取负然后减一，所以~0就是-1 。 别忘了，这个子表达式外头还包着中括号，所以最终的值为[-1]，即一个数组，里面只有一个元素-1. 接下来看子表达式13就简单了，把15、16求出来的填进去，就变成了这样：–[-1][0]，取数组的第0个元素，然后自减，结果为-2，是不so easy! 继续往上走，子表达式14： [~+[]] 其实把15、和16的原理用上就非常明显了，答案[-1] 继续来求子表达式9， 此刻它已变成：-2[-1]，有稍许不一样，不过没关系，我们还是按照规则来，运算符是乘号，当然是做数学运算，那后面的[-1]就得转化为number，与16的求法类似，过程如下： 调用toPrimitive，发现是object类型 调用valueOf，返回自身[-1] 因为不是原始类型，继续调用toString，返回”-1″ ”-1″是原始类型了，然后调用toNumber，返回-1 与-2相乘，返回2 子表达式10：~~!+[]，不多说了，答案1. 就是从右往左依次一元计算。 有了9和10，我们来到了子表达式4，此刻它已经长这样了：2+1， 继续看表达式7：!(~+[])，~+[]=-1，这个根据上面已经知道了，那!-1是什么呢？这里要说一下这个感叹号，它是逻辑取非的意思，会把表达式转化为布尔类型，转化规则和js的Truthy和Falsy原则是一样的，后面跟数字的，除0以外都为false，后面跟字符串的，除空串以外都为false。这里的!-1当然就是false了。 接下来这个表达式3：false+{}有点关键。 一个布尔加一个对象，那这个{}应该先转化为原始类型，流程如下： 调用toPrimitive，发现是object类型 调用valueOf，返回自身{}， 不是原始类型，调用toString，返回”[object Object]” false与”[object Object]”相加，false先转化为字符串”false” 相加得结果”false[object Object]” 知道了表达式3和4，我们就可以来看表达式1了，此时它是这样的：”false[object Object]”[3]，因为这个[]可以取字符串的子字符，像charAt一样，所以得到了结果”s” 四、小结 数组下标([])优先级最高， 一元运算符（--，++，+，-）的优先级高于加法或减法运算符（+，-）； ++前增量运算符，就是数值上加 1； 一元运算符（+，-）的后面如果不是数字，会调用 ToNumber 方法按照规则转化成数字类型。 对于加号运算符(+)首先执行代码，调用 ToPrimitive 方法得到原始值①如果原始值是两个数字，则直接相加得出结果。②如果两个原始值都是字符串，把第二个字符串连接到第一个上，也就是相当于调用 concat 方法。③如果只有一个原始值是字符串，调用 ToString 方法把另一个运算数转换成字符串，结果是两个字符串连接成的字符串。 对于减号运算符(-)不知道大家有没有看到ECMAScript规范，这里比+少了一步 ToPrimitive ，所以 - 相对容易理解。①如果是两个数字，则直接相减得出结果 ②如果有一个不是数字，会调用 ToNumber 方法按照规则转化成数字类型，然后进行相减。 分号的插入 ①新行并入当前行将构成非法语句，自动插入分号。 ②在continue,return,break,throw后自动插入分号 ③++、--后缀表达式作为新行的开始，在行首自动插入分号 ④代码块的最后一个语句会自动插入分号 ⑤新行以 ( 、[、\\、+ 、 - 、,、. % 和 *开始都不会插入分号 {}的两种解读 ①当{}的前面有运算符号的时候，+，-，*，/,()等等，{}都会被解析成对象字面量，这无可争议。 ②当{}前面没有运算符时候但有;结尾的时候，或者浏览器的自动分号插入机制给{}后面插入分号(;)时候，此时{}都会被解析成代码块。 ③如果{}前面什么运算符都没有，{}后面也没有分号(;)结尾，Firefox会始终如一的解析为代码块，而chrome有细微的差别，chrome会解析为对象字面量。 五、 ECMAScript的规范定义的抽象操作 前面关于ECMAScript规范的解读，涉及到几个重要的抽象操作： GetValue(v) : 引用规范类型 Type(x) : 获取x的类型 ToNumber(x) : 将x转换为Number类型 ToString(x) : 将x转换为String类型 SameValue(x,y) : 计算非数字类型x,y是否相同 ToPrimitive(x) : 将x转换为原始值 5.1 原始值 原始值(primitives) 1. undefined 2. null 3. boolean 4. number 5. string 对象值(objects)。 除了原始值外，其他的所有值都是对象类型的值，包括数组(array)和函数(function)等。 5.2 GetValue(v) GetValue(v) : 引用规范类型，先看下SameValue()和ToPrimitive()两个操作。 5.3 SameValue(x,y) 这个SameValue操作说的就是，如果x,y两个值类型相同，但又不同时是Number类型时的比较是否相等的操作。 5.4 ToPrimitive(input [ , PreferredType]) ToPrimitive() 方法转换成原始类型方法。 ToPrimitive(obj,preferredType) JS引擎内部转换为原始值ToPrimitive(obj,preferredType)函数接受两个参数，第一个obj为被转换的对象，第二个 preferredType为希望转换成的类型（默认为空，接受的值为Number或String） 在执行ToPrimitive(obj,preferredType)时如果第二个参数为空并且obj为Date的事例时，此时preferredType会 被设置为String，其他情况下preferredType都会被设置为Number如果preferredType为Number，ToPrimitive执 行过程如 下： 1. 如果obj为原始值，直接返回； 2. 否则调用 obj.valueOf()，如果执行结果是原始值，返回之； 3. 否则调用 obj.toString()，如果执行结果是原始值，返回之； 4. 否则抛异常。 如果preferredType为String，将上面的第2步和第3步调换，即： 1. 如果obj为原始值，直接返回； 2. 否则调用 obj.toString()，如果执行结果是原始值，返回之； 3. 否则调用 obj.valueOf()，如果执行结果是原始值，返回之； 4. 否则抛异常。 obj.valueOf() 和 obj.toString() toString用来返回对象的字符串表示。 var obj = {}; console.log(obj.toString());//[object Object] var arr2 = []; console.log(arr2.toString());//\"\"空字符串 var date = new Date(); console.log(date.toString());//Sun Feb 28 2016 13:40:36 GMT+0800 (中国标准时间) valueOf方法返回对象的原始值，可能是字符串、数值或bool值等，看具体的对象。 var obj = { name: \"obj\" }; console.log(obj.valueOf());//Object {name: \"obj\"} var arr1 = [1]; console.log(arr1.valueOf());//[1] var date = new Date(); console.log(date.valueOf());//1456638436303 如代码所示，三个不同的对象实例调用valueOf返回不同的数据 原始值指的是['Null','Undefined','String','Boolean','Number']五种基本数据类型之一，一开始就提到过。 举个简单的例子: var a={}; ToPrimitive(a) 分析:a是对象类型但不是Date实例对象,所以preferredType默认是Number,先调用a.valueOf()不是原始值,继续来调 用a.toString()得到string字符串,此时为原始值,返回之.所以最后ToPrimitive(a)得到就是\"[object Object]\". 如果觉得描述还不好明白,一大堆描述晦涩又难懂,我们用代码说话: const toPrimitive = (obj, preferredType='Number') => { let Utils = { typeOf: function(obj) { return Object.prototype.toString.call(obj).slice(8, -1); }, isPrimitive: function(obj) { let types = ['Null', 'String', 'Boolean', 'Undefined', 'Number']; return types.indexOf(this.typeOf(obj)) !== -1; } }; if (Utils.isPrimitive(obj)) { return obj; } preferredType = (preferredType === 'String' || Utils.typeOf(obj) === 'Date') ? 'String' : 'Number'; if (preferredType === 'Number') { if (Utils.isPrimitive(obj.valueOf())) { return obj.valueOf() }; if (Utils.isPrimitive(obj.toString())) { return obj.toString() }; } else { if (Utils.isPrimitive(obj.toString())) { return obj.toString() }; if (Utils.isPrimitive(obj.valueOf())) { return obj.valueOf() }; } } var a={}; ToPrimitive(a);//\"[object Object]\",与上面文字分析的一致 5.5 ToNumber(x) 这个就比ToPrimitive() 方法好理解多了，就是把其他类型按照一定的规则转化成数字类型，也就是类似Number()和parseInt()的方法。还是继续看看ECMAScipt规范中对于Number的转换 是不是又看到 ToPrimitive() 方法了，是不是看了上面的就好理解多了，如果ToNumber(x)这个x是对象就要调用ToPrimitive方法返回x的原始值，是不是一下子就串起来了。 5.6 ToString(x) 对数值类型应用 ToString ToString 运算符将数字 m 转换为字符串格式的给出如下所示： 如果 m 是 NaN，返回字符串 \"NaN\"。 如果 m 是 +0 或 -0，返回字符串 \"0\"。 如果 m 小于零，返回连接 \"-\" 和 ToString (-m) 的字符串。 如果 m 无限大，返回字符串 \"Infinity\"。 否则，令 n, k, 和 s 是整数，使得 k ≥ 1, 10k-1 ≤ s 如果 k ≤ n ≤ 21，返回由 k 个 s 在十进制表示中的数字组成的字符串（有序的，开头没有零），后面跟随字符 '0' 的 n-k 次出现。 如果 0 如果 -6 否则，如果 k = 1，返回由单个数字 s 组成的字符串，后面跟随小写字母 'e'，根据 n-1 是正或负，再后面是一个加号 '+' 或减号 '-' ，再往后是整数 abs(n-1) 的十进制表示（没有前置的零）。 返回由 s 在十进制表示中的、最多的有效数字组成的字符串，后面跟随一个小数点 '. '，再后面是余下的是 k-1 个 s 在十进制表示中的数字，再往后是小写字母 'e'，根据n-1 是正或负，再后面是一个加号 '+ ' 或减号 '-' ，再往后是整数 abs(n-1) 的十进制表示（没有前置的零）。 5.7 ==转换规则： undefined == null，结果是true。且它俩与所有其他值比较的结果都是false。 String == Boolean，需要两个操作数同时转为Number。 String/Boolean == Number，需要String/Boolean转为Number。 Object == Primitive，需要Object转为Primitive(具体通过valueOf和toString方法)。 一共只有4条规则！很清晰、很简单。 六、验证分析++[[]][+[]]+[+[]]==10? 1.首先++[[]][+[]]+[+[]]首先拆分一下： (++[[]][+[]]) + ([+[]]) 2.先来分析右边的[+[]] ①先看里面的+[] 根据 4.2 ECMAScript 一元运算符（+、-） 可以知道，一元运算符会调用 ToNumber 方法把 ToNumber([]) 转化成数字。 根据 5.5 ToNumber(x) 的转换规则，x为[]是数组对象，因此会调用 ToPrimitive 方法。 根据 5.4 ToPrimitive(input [ , PreferredType]) 的转换规则，空数组先调用 valueOf() 方法，得到[]不是原始值，继续调用 toString() 方法，得到 \"\"空字符串 。 递归的调用之后成了 ToNumber(\"\") ,答案显而易见，根据 5.5 ToNumber(x) 的转换规则对照图片可以看出ToNumber(\"\")===0。 那么[+[]]就变相的成了[0] 。 此时成了(++[[]][+[]])+[0] 3.再来分析左边边的++[[]][+[]] +[]上面已经分析出来了，结果为0，那么此时就成了++[[]][0] 根据 4.2 ECMAScript 一元运算符（+、-） 可以知道，数组下标的优先级高于一元运算符++，那么理所当然成了这样 ++([[]][0]) ,而[[]][0]可以看出数组下标为0也就是第一个元素，此时为[],那么最后成了++[]. ++[]这是什么鬼ghost，根据 4.5 ECMAScript 前自增运算符（++） 没有发现任何有调用 ToNumber 的方法，浏览器试了一下，果然有问题，报错啦，到底哪里出问题了呢，为什么走着走着就走偏了。问题出在哪一步呢？ 4.分析问题错误的原因 首先我们在浏览器输出一下++[]无意之中照着错误搜，搜到了这个后缀自增++： Increment Operator_操作的第5步PutValue(expr, newValue)要求expr是引用。这就是问题的关键 5.进一步拆分 ++[[]][0]可以这么拆分，只要保持引用关系就行： var refence=[[]][0]； ++refence; 再来进一步拆分 var refence=[]; refence=refence+1; 最后就成了 refence=[]+1; 根据 4.3 ECMAScript 加法运算符（+） ，[]+1可以看成是ToPrimitive([]）+ToPrimitive（1），根据 5.4 ToPrimitive(input [ , PreferredType]) 的转换规则，空数组先调用valueOf() 方法，得到[]不是原始值，继续调用 toString() 方法，得到 \"\" 空字符串。 于是就成了 \"\"+1 ，根据 4.3 ECMAScript 加法运算符（+） ，有一个字符串，另外一个也会变成字符串，所以\"\"+1===\"1\"。所以 ++[[]][0] === \"1\" ; "},"Js/js基础/js事件轮询、微任务和宏任务.html":{"url":"Js/js基础/js事件轮询、微任务和宏任务.html","title":"js事件轮询、微任务和宏任务","keywords":"","body":"js事件轮询、微任务和宏任务 js事件轮询、微任务和宏任务 事件循环与消息队列 总结 追加 20190301 分别很么样的场景会形成macrotask和microtask呢？ 再根据线程来理解下： 使用MutationObserver实现microtask JavaScript是单线程语言，也就是说同一个事件只能做一件事。JaVaScript的单线程，与它的用途有关，作为浏览器脚本语言，JavaScript的主要用途是与用户交互，以及操作DOM。这决定了它只能是单线程，否则会带来很多复杂的同步问题。为了利用多核CPU的计算能力，虽然HTML5提出了Web Worker，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM和BOM。所以，依然没有改变JavaScript是单线程的本质。 为了解决单线程导致的线程等待资源，cpu空闲，而其他任务一直等待的问题。将所有的任务分为两种，一种是同步任务，一种是异步任务。 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务。 异步任务指的是，不进入主线程，而进入“任务队列”的任务，自由“任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。 主任务和任务队列示意图： 执行过程： 所有的同步任务都在主线程上指向，形成一个执行栈 主线程之外，还存在一个“任务队列”。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，将可执行的任务放在主线程执行。任务队列是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。 主线程不短重复上面的第三步。 只要主线程空了，就会去读取“任务队列”。Event Loop（事件轮询）主线程从“任务队列”中读取事件，这个过程是循环不断的，所以整个过程的这种运行机制又称为Event Loop（事件循环） 除了放置异步任务的队列，“任务队列还放置定时器”，即指定某些代码在多长时间之后执行。定时器功能的主要由setTimeout()和setInterval()这两个函数执行。setTimeout()只执行一次，setInterval()反复执行。 Node规定，process.nextTick和Promise的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。而setTimeout、setInterval、setImmediate的回调函数，追加在次轮循环。 除了广义的同步任务和异步的任务，更精细的定义为： macro-task(宏任务)：包括整体代码script、setTimeout，setInterval micro-task(微任务)：Promise、process.nextTick 下面代码可以帮助理解上面的内容： console.log('1'); setTimeout(function() { console.log('2'); process.nextTick(function() { console.log('3'); }) new Promise(function(resolve) { console.log('4'); resolve(); }).then(function() { console.log('5') }) }) process.nextTick(function() { console.log('6'); }) new Promise(function(resolve) { console.log('7'); resolve(); }).then(function() { console.log('8') }) setTimeout(function() { console.log('9'); process.nextTick(function() { console.log('10'); }) new Promise(function(resolve) { console.log('11'); resolve(); }).then(function() { console.log('12') }) }) js代码都是从上到下，一行一行指向，首先遇到第一行console.log(‘1’)；执行输出1，然后第二行setTimeout异步任务，放入任务队列。下面遇到promise.nextTick是微任务放到本轮循环的结尾，之后遇到new Promise直接指向输出7，then被放到本轮循环的结尾，接着执行又遇到的setTimeout放到任务队列，本轮代码执行完，开始依次执行本轮结尾的代码，输出6,8。然后主线程的任务执行完毕，无任务队列中取出一个setTimeout放入主线程开始执行，输出2，然后遇到process.nextTick，放到本轮循环的结尾，执行new Promise输出4,then放入本轮循环结尾，主线程代码执行完，开始执行本轮结尾输出3,5。然后再去任务队列中取第二个setTimeout执行输出9,11,10,12。 所以输出的顺序为1，7，6，8，2，4，3，5，9，11，10，12。 因为settimeout是宏任务，虽然先执行的他，但是他被放到了宏任务的eventqueue里面，然后代码继续往下检查看有没有微任务，检测到Promise的then函数把他放入了微任务序列。等到主线进程的所有代码执行结束后。先从微任务queue里拿回掉函数，然后微任务queue空了后再从宏任务的queue拿函数。 在node环境下，process.nextTick的优先级高于Promise，也就是说：在宏任务结束后会先执行微任务队列中的nextTickQueue，然后才会执行微任务中的Promise。 请注意，node环境下的事件监听依赖libuv与前端环境不完全相同，输出顺序可能会有误差。 事件循环与消息队列 回到事件循环 event loop 其实 事件循环 机制和 消息队列 的维护是由事件触发线程控制的。 事件触发线程 同样是浏览器渲染引擎提供的，它会维护一个 消息队列。 JS引擎线程遇到异步（DOM事件监听、网络请求、setTimeout计时器等...），会交给相应的线程单独去维护异步任务，等待某个时机（计时器结束、网络请求成功、用户点击DOM），然后由 事件触发线程 将异步对应的 回调函数 加入到消息队列中，消息队列中的回调函数等待被执行。 同时，JS引擎线程会维护一个 执行栈，同步代码会依次加入执行栈然后执行，结束会退出执行栈。 如果执行栈里的任务执行完成，即执行栈为空的时候（即JS引擎线程空闲），事件触发线程才会从消息队列取出一个任务（即异步的回调函数）放入执行栈中执行。 消息队列是类似队列的数据结构，遵循先入先出(FIFO)的规则。 执行完了后，执行栈再次为空，事件触发线程会重复上一步操作，再取出一个消息队列中的任务，这种机制就被称为事件循环（event loop）机制。 总结 执行机制： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取） JavaScript 是单线程语言，决定于它的设计最初是用来处理浏览器网页的交互。浏览器负责解释和执行 JavaScript 的线程只有一个（所有说是单线程），即JS引擎线程，但是浏览器同样提供其他线程，如：事件触发线程、定时器触发线程等。 异步一般是指： 网络请求 计时器 DOM事件监听 事件循环机制： JS引擎线程会维护一个执行栈，同步代码会依次加入到执行栈中依次执行并出栈。 JS引擎线程遇到异步函数，会将异步函数交给相应的Webapi，而继续执行后面的任务。 Webapi会在条件满足的时候，将异步对应的回调加入到消息队列中，等待执行。 执行栈为空时，JS引擎线程会去取消息队列中的回调函数（如果有的话），并加入到执行栈中执行。 完成后出栈，执行栈再次为空，重复上面的操作，这就是事件循环(event loop)机制。 追加 20190301 JS中分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask可称为task 它们的定义？区别？简单点可以按如下理解： macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行） 每一个task会从头到尾将这个任务执行完毕，不会执行其它 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task->渲染->task->...） microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务 也就是说，在当前task任务后，下一个task之前，在渲染之前 所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前） 分别很么样的场景会形成macrotask和microtask呢？ macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask） microtask：Promise，process.nextTick等 补充：在node环境下，process.nextTick的优先级高于Promise，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。 再根据线程来理解下： macrotask中的事件都是放在一个事件队列中的，而这个队列由事件触发线程维护 microtask中的所有微任务都是添加到微任务队列（Job Queues）中，等待当前macrotask执行完毕后执行，而这个队列由JS引擎线程维护 （这点由自己理解+推测得出，因为它是在主线程下无缝执行的） 所以，总结下运行机制： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取） 另外，请注意下Promise的polyfill与官方版本的区别： 官方版本中，是标准的microtask形式 polyfill，一般都是通过setTimeout模拟的，所以是macrotask形式 请特别注意这两点区别 注意，有一些浏览器执行结果不一样（因为它们可能把microtask当成macrotask来执行了）， 但是为了简单，这里不描述一些不标准的浏览器下的场景（但记住，有些浏览器可能并不标准） 使用MutationObserver实现microtask MutationObserver可以用来实现microtask（它属于microtask，优先级小于Promise，一般是Promise不支持时才会这样做） 它是HTML5中的新特性，作用是：监听一个DOM变动，当DOM对象树发生任何变动时，Mutation Observer会得到通知 像以前的Vue源码中就是利用它来模拟nextTick的，具体原理是，创建一个TextNode并监听内容变化，然后要nextTick的时候去改一下这个节点的文本内容， 如下：（Vue的源码，未修改） var counter = 1 var observer = new MutationObserver(nextTickHandler) var textNode = document.createTextNode(String(counter)) observer.observe(textNode, { characterData: true }) timerFunc = () => { counter = (counter + 1) % 2 textNode.data = String(counter) } 对应Vue源码链接 不过，现在的Vue（2.5+）的nextTick实现移除了MutationObserver的方式（据说是兼容性原因）， 取而代之的是使用MessageChannel （当然，默认情况仍然是Promise，不支持才兼容的）。 MessageChannel属于宏任务，优先级是：MessageChannel->setTimeout， 所以Vue（2.5+）内部的nextTick与2.4及之前的实现是不一样的，需要注意下。 "},"Js/js基础/reduce.html":{"url":"Js/js基础/reduce.html","title":"Js reduce","keywords":"","body":"详解JS数组Reduce()方法详解及高级技巧 1. 简单应用 [10, 120, 1000].reduce((a, b) => a + b, 0); // 1130 var items = [10, 120, 1000]; // our reducer function var reducer = function add(sumSoFar, item) { sumSoFar.sum = sumSoFar.sum + item; return sumSoFar; }; // do the job var total = items.reduce(reducer, { sum: 0 }); console.log(total); // {sum:1130} 2. 进阶应用 在下面的方法中，采用分而治之的方法，即将reduce函数第一个参数callback封装为一个数组，由数组中的每一个函数单独进行叠加并完成reduce操作。所有的一切通过一个manager函数来管理流程和传递初始参数。 var manageReducers = function(reducers) { return function(state, item) { return Object.keys(reducers).reduce(function(nextState, key) { reducers[key](state, item); return state; }, {}); }; }; 上面就是manager函数的实现，它需要reducers对象作为参数，并返回一个callback类型的函数，作为reduce的第一个参数。在该函数内部，则执行多维的叠加工作（Object.keys（））。 通过这种分治的思想，可以完成目标对象多个属性的同时叠加，完整代码如下： var reducers = { totalInEuros: function(state, item) { return (state.euros += item.price * 0.897424392); }, totalInYen: function(state, item) { return (state.yens += item.price * 113.852); } }; var manageReducers = function(reducers) { return function(state, item) { return Object.keys(reducers).reduce(function(nextState, key) { reducers[key](state, item); return state; }, {}); }; }; var bigTotalPriceReducer = manageReducers(reducers); var initialState = { euros: 0, yens: 0 }; var items = [{ price: 10 }, { price: 120 }, { price: 1000 }]; var totals = items.reduce(bigTotalPriceReducer, initialState); console.log(totals); 3. 在来一个例子： 某同学的期末成绩如下表示 var result = [ { subject: 'math', score: 88 }, { subject: 'chinese', score: 95 }, { subject: 'english', score: 80 } ]; 如何求该同学的总成绩？ var sum = result.reduce(function(prev, cur) { return cur.score + prev; }, 0); 假设该同学因为违纪被处罚在总成绩总扣10分，只需要将初始值设置为-10即可。 var sum = result.reduce(function(prev, cur) { return cur.score + prev; }, -10); 我们来给这个例子增加一点难度。假如该同学的总成绩中，各科所占的比重不同，分别为50%，30%，20%，我们应该如何求出最终的权重结果呢？ 解决方案如下： var dis = { math: 0.5, chinese: 0.3, english: 0.2 } var sum = result.reduce(function(prev, cur) { return cur.score + prev; }, -10); var qsum = result.reduce(function(prev, cur) { return cur.score * dis[cur.subject] + pre; }, 0) console.log(sum, qsum); 4. 再看一个例子，如何知道一串字符串中每个字母出现的次数？ var arrString = \"abcdaabc\"; arrString.split(\"\").reduce(function(res, cur) { res[cur] ? res[cur]++ : (res[cur] = 1); return res; }, {}); // {a: 3, b: 2, c: 2, d: 1} 由于可以通过第二参数设置叠加结果的类型初始值，因此这个时候reduce就不再仅仅只是做一个加法了，我们可以灵活的运用它来进行各种各样的类型转换，比如将数组按照一定规则转换为对象，也可以将一种形式的数组转换为另一种形式的数组，大家可以动手去尝试一样。 [1, 2].reduce(function(res, cur) { res.push(cur + 1); return res; }, []) // [2, 3] 5. koa的源码中，有一个only模块，整个模块就一个简单的返回reduce方法操作的对象： var only = function(obj, keys){ obj = obj || {}; if ('string' == typeof keys) keys = keys.split(/ +/); return keys.reduce(function(ret, key){ if (null == obj[key]) return ret; ret[key] = obj[key]; return ret; }, {}); }; 通过对reduce概念的理解，这个模块主要是想新建并返回一个obj对象中存在的keys的object对象。 var a = { env : 'development', proxy : false, subdomainOffset : 2 } only(a,['env','proxy']) // {env:'development',proxy : false} "},"Js/正则/正则表达式不要背.html":{"url":"Js/正则/正则表达式不要背.html","title":"正则表达式不要背","keywords":"","body":"正则表达式不要背 正则表达式不要背 从字符出发 单个字符 多个字符 循环与重复 0 | 1 >= 0 >= 1 特定次数 位置边界 单词边界 字符串边界 子表达式 分组 回溯引用 前向查找 后向查找 逻辑处理 最后 从字符出发 正则表达式的基本组成元素可以分为：字符和元字符。 字符很好理解，就是基础的计算机字符编码，通常正则表达式里面使用的就是数字、英文字母。而元字符，也被称为特殊字符，是一些用来表示特殊语义的字符。如^表示非,|表示或等。 利用这些元字符，才能构造出强大的表达式模式(pattern) 单个字符 最简单的正则表达式可以由简单的数字和字母组成，没有特殊的语义，纯粹就是一一对应的关系。如想在'apple'这个单词里找到‘a'这个字符，就直接用/a/这个正则就可以了。 但是如果想要匹配特殊字符的话，就得请出我们第一个元字符**\\**， 它是转义字符字符，顾名思义，就是让其后续的字符失去其本来的含义。举个例子： 我想匹配*这个符号，由于*这个符号本身是个特殊字符，所以我要利用转义元字符\\来让它失去其本来的含义： /\\*/ 如果本来这个字符不是特殊字符，使用转义符号就会让它拥有特殊的含义。我们常常需要匹配一些特殊字符，比如空格，制表符，回车，换行等, 而这些就需要我们使用转义字符来匹配。为了便于记忆，我整理了下面这个表格，并附上记忆方式： 特殊字符 正则表达式 记忆方式 换行符 \\n new line 换页符 \\f form feed 回车符 \\r return 空白符 \\s space 制表符 \\t tab 垂直制表符 \\v vertical tab 回退符 [\\b] backspace,之所以使用[]符号是避免和\\b重复 多个字符 单个字符的映射关系是一对一的，即正则表达式的被用来筛选匹配的字符只有一个。而这显然是不够的，只要引入集合区间和通配符的方式就可以实现一对多的匹配了。 在正则表达式里，集合的定义方式是使用中括号[和]。如/[123]/这个正则就能同时匹配1,2,3三个字符。那如果我想匹配所有的数字怎么办呢？从0写到9显然太过低效，所以元字符-就可以用来表示区间范围，利用/[0-9]/就能匹配所有的数字, /[a-z]/则可以匹配所有的英文小写字母。 即便有了集合和区间的定义方式，如果要同时匹配多个字符也还是要一一列举，这是低效的。所以在正则表达式里衍生了一批用来同时匹配多个字符的简便正则表达式: 匹配区间 正则表达式 记忆方式 除了换行符之外的任何字符 . 句号,除了句子结束符 单个数字, [0-9] \\d digit 除了[0-9] \\D not digit 包括下划线在内的单个字符，[A-Za-z0-9_] \\w word 非单字字符 \\W not word 匹配空白字符,包括空格、制表符、换页符和换行符 \\s space 匹配非空白字符 \\S not space 循环与重复 一对一和一对多的字符匹配都讲完了。接下来，就该介绍如何同时匹配多个字符。要实现多个字符的匹配我们只要多次循环，重复使用我们的之前的正则规则就可以了。那么根据循环次数的多与少，我们可以分为0次，1次，多次，特定次。 0 | 1 元字符?代表了匹配一个字符或0个字符。设想一下，如果你要匹配color和colour这两个单词，就需要同时保证u这个字符是否出现都能被匹配到。所以你的正则表达式应该是这样的：/colou?r/。 >= 0 元字符*用来表示匹配0个字符或无数个字符。通常用来过滤某些可有可无的字符串。 >= 1 元字符+适用于要匹配同个字符出现1次或多次的情况。 特定次数 在某些情况下，我们需要匹配特定的重复次数，元字符{和}用来给重复匹配设置精确的区间范围。如'a'我想匹配3次,那么我就使用/a{3}/这个正则，或者说'a'我想匹配至少两次就是用/a{2,}/这个正则。 以下是完整的语法： - {x}: x次 - {min, max}： 介于min次到max次之间 - {min, }: 至少min次 - {0, max}： 至多max次 由于这些元字符比较抽象，且容易混淆，所以我用了联想记忆的方式编了口诀能保证在用到的时候就能回忆起来。 匹配规则 元字符 联想方式 0次或1次 ? 且问,此事有还无 0次或无数次 * 宇宙洪荒,辰宿列张：宇宙伊始，从无到有，最后星宿布满星空 1次或无数次 + 一加, +1 特定次数 {x}, {min, max} 可以想象成一个数轴，从一个点，到一个射线再到线段。min和max分别表示了左闭右闭区间的左界和右界 位置边界 上面我们把字符的匹配都介绍完了，接着我们还需要位置边界的匹配。在长文本字符串查找过程中，我们常常需要限制查询的位置。比如我只想在单词的开头结尾查找。 单词边界 单词是构成句子和文章的基本单位，一个常见的使用场景是把文章或句子中的特定单词找出来。如： The cat scattered his food all over the room. 我想找到cat这个单词，但是如果只是使用/cat/这个正则，就会同时匹配到cat和scattered这两处文本。这时候我们就需要使用边界正则表达式\\b，其中b是boundary的首字母。在正则引擎里它其实匹配的是能构成单词的字符(\\w)和不能构成单词的字符(\\W)中间的那个位置。 上面的例子改写成/\\bcat\\b/这样就能匹配到cat这个单词了。 字符串边界 匹配完单词，我们再来看一下一整个字符串的边界怎么匹配。元字符^用来匹配字符串的开头。而元字符$用来匹配字符串的末尾。注意的是在长文本里，如果要排除换行符的干扰，我们要使用多行模式。试着匹配I am scq000这个句子： I am scq000. I am scq000. I am scq000. 我们可以使用/^I am scq000\\.$/m这样的正则表达式，其实m是multiple line的首字母。正则里面的模式除了m外比较常用的还有i和g。前者的意思是忽略大小写，后者的意思是找到所有符合的匹配。 最后，总结一下： 边界和标志 正则表达式 记忆方式 单词边界 \\b boundary 非单词边界 \\B not boundary 字符串开头 ^ 小头尖尖那么大个 字符串结尾 $ 终结者，美国科幻电影，美元符$ 多行模式 m标志 multiple of lines 忽略大小写 i标志 ignore case, case-insensitive 全局模式 g标志 global 子表达式 字符匹配我们介绍的差不多了，更加高级的用法就得用到子表达式了。通过嵌套递归和自身引用可以让正则发挥更强大的功能。 从简单到复杂的正则表达式演变通常要采用分组、回溯引用和逻辑处理的思想。利用这三种规则，可以推演出无限复杂的正则表达式。 分组 其中分组体现在：所有以(和)元字符所包含的正则表达式被分为一组，每一个分组都是一个子表达式，它也是构成高级正则表达式的基础。如果只是使用简单的(regex)匹配语法本质上和不分组是一样的，如果要发挥它强大的作用，往往要结合回溯引用的方式。 回溯引用 所谓回溯引用（backreference）指的是模式的后面部分引用前面已经匹配到的子字符串。你可以把它想象成是变量，回溯引用的语法像\\1,\\2,....,其中\\1表示引用的第一个子表达式，\\2表示引用的第二个子表达式，以此类推。而\\0则表示整个表达式。 假设现在要在下面这个文本里匹配两个连续相同的单词，你要怎么做呢？ Hello what what is the first thing, and I am am scq000. 利用回溯引用，我们可以很容易地写出\\b(\\w+)\\s\\1这样的正则。 回溯引用在替换字符串中十分常用，语法上有些许区别，用$1,$2...来引用要被替换的字符串。下面以js代码作演示： var str = 'abc abc 123'; str.replace(/(ab)c/g,'$1g'); // 得到结果 'abg abg 123' 如果我们不想子表达式被引用，可以使用非捕获正则(?:regex)这样就可以避免浪费内存。 var str = 'scq000'. str.replace(/(scq00)(?:0)/, '$1,$2') // 返回scq00,$2 // 由于使用了非捕获正则，所以第二个引用没有值，这里直接替换为$2 有时，我们需要限制回溯引用的适用范围。那么通过前向查找和后向查找就可以达到这个目的。 前向查找 前向查找(lookahead)是用来限制后缀的。凡是以(?=regex)包含的子表达式在匹配过程中都会用来限制前面的表达式的匹配。例如happy happily这两个单词，我想获得以happ开头的副词，那么就可以使用happ(?=ily)来匹配。如果我想过滤所有以happ开头的副词，那么也可以采用负前向查找的正则happ(?!ily)，就会匹配到happy单词的happ前缀。 后向查找 介绍完前向查找，接着我们再来介绍一下它的反向操作：后向查找(lookbehind)。后向查找(lookbehind)是通过指定一个子表达式，然后从符合这个子表达式的位置出发开始查找符合规则的字串。举个简单的例子： apple和people都包含ple这个后缀，那么如果我只想找到apple的ple，该怎么做呢？我们可以通过限制app这个前缀，就能唯一确定ple这个单词了。 /(? 其中(?的语法就是我们这里要介绍的后向查找。regex指代的子表达式会作为限制项进行匹配，匹配到这个子表达式后，就会继续向后查找。另外一种限制匹配是利用(? 语法，这里称为负后向查找。与正前向查找不同的是，被指定的子表达式不能被匹配到。于是，在上面的例子中，如果想要查找apple的ple也可以这么写成/(?ple。 需要注意的，不是每种正则实现都支持后向查找。在javascript中是不支持的，所以如果有用到后向查找的情况，有一个思路是将字符串进行翻转，然后再使用前向查找，作完处理后再翻转回来。看一个简单的例子： // 比如我想替换apple的ple为ply var str = 'apple people'; str.split('').reverse().join('').replace(/elp(?=pa)/, 'ylp').split('').reverse().join(''); 最后回顾一下这部分内容： 回溯查找 正则 记忆方式 引用 \\0,\\1,\\2 和 $0, $1, $2 转义+数字 非捕获组 (?:) 引用表达式(()), 本身不被消费(?),引用(:) 前向查找 (?=) 引用子表达式(())，本身不被消费(?), 正向的查找(=) 前向负查找 (?!) 引用子表达式(())，本身不被消费(?), 负向的查找(!) 后向查找 (? 引用子表达式(())，本身不被消费(?), 后向的( 后向负查找 (? 引用子表达式(())，本身不被消费(?), 后向的( 逻辑处理 计算机科学就是一门包含逻辑的科学。让我们回忆一下编程语言当中用到的三种逻辑关系，与或非。 在正则里面，默认的正则规则都是与的关系所以这里不讨论。 而非关系，分为两种情况：一种是字符匹配，另一种是子表达式匹配。在字符匹配的时候，需要使用^这个元字符。在这里要着重记忆一下：只有在[和]内部使用的^才表示非的关系。子表达式匹配的非关系就要用到前面介绍的前向负查找子表达式(?!regex)或后向负查找子表达式(?。 或关系，通常给子表达式进行归类使用。比如，我同时匹配a,b两种情况就可以使用(a|b)这样的子表达式。 逻辑关系 正则元字符 与 无 非 [^regex]和! 或 丨 最后 在最后，出个常用的正则面试题吧：请写出一个正则来处理数字千分位，如12345替换为12,345 function splitNum(n){ return (`${n}`).replace(/\\B(?=(?:\\d{3})+\\b)/g,','); } splitNum(1234567.333333) // \"1,234,567.333,333\" var num = '12345678'; num.replace(/(\\d)(?=(\\d{3})+$)/g,'$1,'); num.replace(/\\d{1,3}(?=(\\d{3})+$)/g,'$&,'); num.replace(/\\B(?=(\\d{3})+$)/g,','); // 以上三种的 $都可以替换成\\b的形式. "},"Js/正则/RegExp.html":{"url":"Js/正则/RegExp.html","title":"RegExp","keywords":"","body":"RegExp RegExp 一些常用正则验证 验证数字的正则表达式集 金额最多保留两位小数 && . -> 0. ant mobile InputItem ant design FormItem 正则进阶之路 1、获取链接 https://www.baidu.com?name=jawil&age=23 name的value值 2. 数字格式化问题，1234567890 --> 1,234,567,890 3、去掉字符串左右两边的空格，\" jaw il \" --> “jaw il” 4、判断一个数是否是质数 3 --> true 5、字符串数组去重 [\"a\",\"b\",\"c\",\"a\",\"b\",\"c\"] --> [\"a\",\"b\",\"c\"] 一张图快速入门正则表达式： 一些常用正则验证 验证数字的正则表达式集 验证数字：^[0-9]*$ 验证n位的数字：^\\d{n}$ 验证至少n位数字：^\\d{n,}$ 验证m-n位的数字：^\\d{m,n}$ 验证零和非零开头的数字：^(0|[1-9][0-9]*)$ 验证有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 验证有1-3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 验证非零的正整数：^+?[1-9][0-9]*$ 验证非零的负整数：^-[1-9][0-9]*$ 验证非负整数（正整数 + 0） ^\\d+$ 验证非正整数（负整数 + 0） ^((-\\d+)|(0+))$ 验证长度为3的字符：^.{3}$ 验证由26个英文字母组成的字符串：^[A-Za-z]+$ 验证由26个大写英文字母组成的字符串：^[A-Z]+$ 验证由26个小写英文字母组成的字符串：^[a-z]+$ 验证由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 验证由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 验证用户密码:^[a-zA-Z]\\w{5,17}$ 正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。 验证是否含有 ^%&',;=?$\\\" 等字符：%&',;=?$\\x22+ 验证汉字：^[\\u4e00-\\u9fa5],{0,}$ 验证Email地址：/^([a-zA-Z0-9]+[|\\|.]?)[a-zA-Z0-9]+@([a-zA-Z0-9]+[|\\|.]?)[a-zA-Z0-9]+.[a-zA-Z]{2,3}$/ 验证InternetURL：^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&=]*)?$ ；^[a-zA-z]+://(w+(-w+))(.(w+(-w+)))(?S)?$ 验证电话号码：^((\\d{3,4})|\\d{3,4}-)?\\d{7,8}$：--正确格式为：XXXX-XXXXXXX，XXXX-XXXXXXXX，XXX-XXXXXXX，XXX-XXXXXXXX，XXXXXXX，XXXXXXXX。 验证身份证号（15位或18位数字）：^\\d{15}|\\d{}18$ 验证一年的12个月：^(0?[1-9]|1[0-2])$ 正确格式为：“01”-“09”和“1”“12” 验证一个月的31天：^((0?[1-9])|((1|2)[0-9])|30|31)$ 正确格式为：01、09和1、31。 整数：^-?\\d+$ 非负浮点数（正浮点数 + 0）：^\\d+(.\\d+)?$ 正浮点数 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 非正浮点数（负浮点数 + 0） ^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 负浮点数 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数 ^(-?\\d+)(.\\d+)?$ 金额最多保留两位小数 && . -> 0. /^\\d{1,}.{0,1}\\d{0,2}$/ /^([1-9]\\d*|0)(.\\d{1,2})?$/ ant mobile InputItem const isIPhone = new RegExp('\\\\biPhone\\\\b|\\\\biPod\\\\b', 'i').test(window.navigator.userAgent); let moneyKeyboardWrapProps; if (isIPhone) { moneyKeyboardWrapProps = { onTouchStart: e => e.preventDefault(), }; } { if (v && !/^(([1-9]\\d*)|0)(\\.\\d{0,2}?)?$/.test(v)) { if (v === '.') { return '0.'; } return prev; } return v; }, rules: [ { required: true, message: '请输入' }, {validator(rule, value, callback, source, options){ let errors = []; const reg = /^([1-9]\\d*|0)(\\.\\d{1,2})?$/; if(!reg.test(value)){ callback('mileage is error'); }else { callback(errors); } }} ], })} type={type} placeholder=\"money format\" ref={el => this.inputRef = el} onVirtualKeyboardConfirm={v => console.log('onVirtualKeyboardConfirm:', v)} clear moneyKeyboardWrapProps={moneyKeyboardWrapProps} >数字键盘 ant design FormItem {getFieldDecorator('vehiclePrice', {initialValue: yixindata.salePrice?yixindata.salePrice:_vehiclePrice, rules: [{ required: true, message: '请输入车辆成交价', pattern: /^\\d{1,}\\.{0,1}\\d{0,2}$/},]})( )} 正则进阶之路 1、获取链接 https://www.baidu.com?name=jawil&age=23 name的value值 非正则实现： function getParamName(attr) { let search = window.location.search // \"?name=jawil&age=23\" let param_str = search.split('?')[1] // \"name=jawil&age=23\" let param_arr = param_str.split('&') // [\"name=jawil\", \"age=23\"] let filter_arr = param_arr.filter(ele => { // [\"name=jawil\"] return ele.split('=')[0] === attr }) return decodeURIComponent(filter_arr[0].split('=')[1]) } console.log(getParamName('name')) // \"jawil\" 用正则实现： function getParamName(attr) { let match = RegExp(`[?&]${attr}=([^&]*)`) //分组运算符是为了把结果存到exec函数返回的结果里 .exec(window.location.search) //[\"?name=jawil\", \"jawil\", index: 0, input: \"?name=jawil&age=23\"] return match && decodeURIComponent(match[1].replace(/\\+/g, ' ')) // url中+号表示空格,要替换掉 } console.log(getParamName('name')) // \"jawil\" 2. 数字格式化问题，1234567890 --> 1,234,567,890 非正则实现： let test = '1234567890' function formatCash(str) { let arr = [] for (let i = 1; i 用正则实现： let test1 = '1234567890' let format = test1.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',') console.log(format) // 1,234,567,890 下面简单分析下正则/\\B(?=(\\d{3})+(?!\\d))/g： /\\B(?=(\\d{3})+(?!\\d))/g：正则匹配边界\\B，边界后面必须跟着(\\d{3})+(?!\\d); (\\d{3})+：必须是1个或多个的3个连续数字; (?!\\d)：第2步中的3个数字不允许后面跟着数字; (\\d{3})+(?!\\d)：所以匹配的边界后面必须跟着3*n（n>=1）的数字。 最终把匹配到的所有边界换成,即可达成目标。 3、去掉字符串左右两边的空格，\" jaw il \" --> “jaw il” 非正则实现： function trim(str) { let start, end for (let i = 0; i 0; i--) { if (str[i] !== ' ') { end = i break } } return str.substring(start, end + 1) } let str = \" jaw il \" console.log(trim(str)) // \"jaw il\" 用正则实现： function trim(str) { return str.replace(/(^\\s*)|(\\s*$)/g, \"\") } let str = \" jaw il \" console.log(trim(str)) // \"jaw il\" 4、判断一个数是否是质数 3 --> true 质数又称素数。指在一个大于1的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。 非正则实现： function isPrime(num){ // 不是数字或者数字小于2 if(typeof num !== \"number\" || !Number.isInteger(num)){　　　　　　 // Number.isInterget 判断是否为整数 return false } //2是质数 if(num == 2){ return true }else if(num % 2 == 0){ //排除偶数 return false } //依次判断是否能被奇数整除，最大循环为数值的开方 let squareRoot = Math.sqrt(num) //因为2已经验证过，所以从3开始；且已经排除偶数，所以每次加2 for(let i = 3; i 用正则实现： function isPrime(num) { return !/^1?$|^(11+?)\\1+$/.test(Array(num+1).join('1')) } console.log(isPrime(19)) // true 要使用这个正规则表达式，你需要把自然数转成多个1的字符串，如：2 要写成 “11”， 3 要写成 “111”, 17 要写成“11111111111111111”，这种工作使用一些脚本语言可以轻松的完成，JS实现也很简单，我用Array(num+1).join('1')这种方式实现了一下。 一开始我对这个表达式持怀疑态度，但仔细研究了一下这个表达式，发现是非常合理的，下面，让我带你来细细剖析一下是这个表达式的工作原理。 首先，我们看到这个表达式中有“|”，也就是说这个表达式可以分成两个部分：/^1?$/ 和 /^(11+?)\\1+$/ 第一部分：/^1?$/， 这个部分相信不用我多说了，其表示匹配“空串”以及字串中只有一个“1”的字符串。 第二部分：/^(11+?)\\1+$/ ，这个部分是整个表达式的关键部分。其可以分成两个部分，(11+?) 和 \\1+$ ，前半部很简单了，匹配以“11”开头的并重复0或n个1的字符串，后面的部分意思是把前半部分作为一个字串去匹配还剩下的字符串1次或多次（这句话的意思是——剩余的字串的1的个数要是前面字串1个数的整数倍）。 可见这个正规则表达式是取非素数，要得到素数还得要对整个表达式求反。通过上面的分析，我们知道，第二部分是最重要的，对于第二部分，举几个例子， 示例一：判断自然数8。我们可以知道，8转成我们的格式就是“11111111”，对于 (11+?) ，其匹配了“11”，于是还剩下“111111”，而 \\1+$ 正好匹配了剩下的“111111”，因为，“11”这个模式在“111111”出现了三次，符合模式匹配，返回true。所以，匹配成功，于是这个数不是质数。 示例二：判断自然数11。转成我们需要的格式是“11111111111”（11个1），对于 (11+?) ，其匹配了“11”（前两个1），还剩下“111111111”（九个1），而 \\1+$无法为“11”匹配那“九个1”，因为“11”这个模式并没有在“九个1”这个串中正好出现N次。于是，我们的正则表达式引擎会尝试下一种方法，先匹配“111”（前三个1），然后把“111”作为模式去匹配剩下的“11111111”（八个1），很明显，那“八个1”并没有匹配“三个1”多次。所以，引擎会继续向下尝试……直至尝试所有可能都无法匹配成功。所以11是素数。 通过示例二，我们可以得到这样的等价数算算法，正则表达式会匹配这若干个1中有没有出现“二个1”的整数倍，“三个1”的整数倍，“四个1”的整数倍……，而，这正好是我们需要的算素数的算法。现在大家明白了吧。 5、字符串数组去重 [\"a\",\"b\",\"c\",\"a\",\"b\",\"c\"] --> [\"a\",\"b\",\"c\"] 这里只考虑最简单字符串的数组去重，暂不考虑，对象，函数，NaN等情况，这种用正则实现起来就吃力不讨好了。 非正则实现： // ES6 let str_arr=[\"a\",\"b\",\"c\",\"a\",\"b\",\"c\"] function unique(arr){ return [...new Set(arr)] } console.log(unique(str_arr)) // [\"a\",\"b\",\"c\"] // ES5 var str_arr = [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\"] function unique(arr) { return arr.filter(function(ele, index, array) { return array.indexOf(ele) === index }) } console.log(unique(str_arr)) // [\"a\",\"b\",\"c\"] // ES3 var str_arr = [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\"] function unique(arr) { var obj = {}, array = [] for (var i = 0, len = arr.length; i 正则实现： var str_arr = [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\"] function unique(arr) { return arr.sort().join(\",,\"). replace(/(,|^)([^,]+)(,,\\2)+(,|$)/g, \"$1$2$4\"). replace(/,,+/g, \",\"). replace(/,$/, \"\"). split(\",\") } console.log(unique(str_arr)) // [\"a\",\"b\",\"c\"] 一张图快速入门正则表达式： "},"Js/面向对象/面向对象之组件开发之弹窗.html":{"url":"Js/面向对象/面向对象之组件开发之弹窗.html","title":"面向对象之组件开发之弹窗","keywords":"","body":" 面向对象之组件开发之弹窗练习 *{margin:0; padding:0;} .btn{width:50px; height:30px; background:yellowgreen; margin-left:30px;} .div1{border:1px solid black; position:absolute; left:0px; top:100px;z-index:2;} .title{height:30px; line-height:30px; background:lightgray;} .close{display:inline-block; width:28px; height:28px;border:1px solid white; float:right; text-align:center;border-radius:50%; line-height:28px; color:red; } .close:hover{background:red; color:#fff;} #mark{z-index:1;position:absolute; left:0; top:0; background:gray; filter:alpha(opacity=50); opacity:0.5;} X --> window.onload = function(){ var aBtn = document.getElementsByClassName('btn'); aBtn[1].onclick = function(){ var win2 = new Wind(); win2.init({//配置参数 iNow:1, w:200, h:300, dir:'right', title:\"公告\" }); } aBtn[0].onclick = function(){ var win1 = new Wind(); win1.init({//配置参数 iNow:0, title:\"登录\" }); } aBtn[2].onclick = function(){//配置参数 var win1 = new Wind(); win1.init({ iNow:2, mark:true }); } } function Wind(){ this.oDiv = null; this.setting = {//默认参数 w:300, h:300, dir:'center', title:'', mark:false } } Wind.prototype.json={}; Wind.prototype.init = function(opt){ extend(this.setting,opt); if(this.json[opt.iNow]==undefined){ this.json[opt.iNow]=true; } if(this.json[opt.iNow]){ this.fnCreate(); this.fnClose(); if(this.setting.mark){ this.fnMark(); } } this.json[opt.iNow]=false; } Wind.prototype.fnCreate = function(){ this.oDiv = document.createElement('div'); this.oDiv.className = 'div1'; this.oDiv.innerHTML = ''+ this.setting.title+'X'; document.body.appendChild(this.oDiv); this.setStyle(); } Wind.prototype.fnMark = function(){ var oMark = document.createElement('div'); oMark.id = 'mark'; document.body.appendChild(oMark); this.oMark = oMark; oMark.style.width=veiwWidth()+'px'; oMark.style.height=veiwHeight()+'px'; } Wind.prototype.setStyle = function(){ this.oDiv.style.width = this.setting.w+'px'; this.oDiv.style.height = this.setting.h +'px'; if(this.setting.dir=='center'){ this.oDiv.style.left = (veiwWidth() - this.oDiv.offsetWidth)/2 +'px'; this.oDiv.style.top = (veiwHeight() - this.oDiv.offsetHeight)/2 +'px'; } if(this.setting.dir=='right'){ this.oDiv.style.left = (veiwWidth() - this.oDiv.offsetWidth)+'px'; this.oDiv.style.top = (veiwHeight() - this.oDiv.offsetHeight) +'px'; } } Wind.prototype.fnClose = function(){ var oClose = this.oDiv.getElementsByClassName('close')[0]; var This = this; oClose.onclick = function(){ document.body.removeChild(This.oDiv); if(This.setting.mark){ document.body.removeChild(This.oMark); } This.json[This.setting.iNow] = true; }; } function extend(obj1,obj2){ for(var attr in obj2){ obj1[attr] = obj2[attr]; } } function veiwWidth(){ return document.documentElement.clientWidth; } function veiwHeight(){ return document.documentElement.clientHeight; } 面向对象之组件开发之弹窗练习 *{margin:0; padding:0;} .btn{width:50px; height:30px; background:yellowgreen; margin-left:30px;} .div1{border:1px solid black; position:absolute; left:0px; top:100px;z-index:2;} .title{height:30px; line-height:30px; background:lightgray;} .close{display:inline-block; width:28px; height:28px;border:1px solid white; float:right; text-align:center;border-radius:50%; line-height:28px; color:red; } .close:hover{background:red; color:#fff;} #mark{z-index:1;position:absolute; left:0; top:0; background:gray; filter:alpha(opacity=50); opacity:0.5;} X --> window.onload = function(){ var aBtn = document.getElementsByClassName('btn'); aBtn[1].onclick = function(){ var win2 = new Wind(); win2.init({//配置参数 iNow:1, w:200, h:300, dir:'right', title:\"公告\" }); } aBtn[0].onclick = function(){ var win1 = new Wind(); win1.init({//配置参数 iNow:0, title:\"登录\" }); } aBtn[2].onclick = function(){//配置参数 var win1 = new Wind(); win1.init({ iNow:2, mark:true }); } } function Wind(){ this.oDiv = null; this.setting = {//默认参数 w:300, h:300, dir:'center', title:'', mark:false } } Wind.prototype.json={}; Wind.prototype.init = function(opt){ extend(this.setting,opt); if(this.json[opt.iNow]==undefined){ this.json[opt.iNow]=true; } if(this.json[opt.iNow]){ this.fnCreate(); this.fnClose(); if(this.setting.mark){ this.fnMark(); } } this.json[opt.iNow]=false; } Wind.prototype.fnCreate = function(){ this.oDiv = document.createElement('div'); this.oDiv.className = 'div1'; this.oDiv.innerHTML = ''+ this.setting.title+'X'; document.body.appendChild(this.oDiv); this.setStyle(); } Wind.prototype.fnMark = function(){ var oMark = document.createElement('div'); oMark.id = 'mark'; document.body.appendChild(oMark); this.oMark = oMark; oMark.style.width=veiwWidth()+'px'; oMark.style.height=veiwHeight()+'px'; } Wind.prototype.setStyle = function(){ this.oDiv.style.width = this.setting.w+'px'; this.oDiv.style.height = this.setting.h +'px'; if(this.setting.dir=='center'){ this.oDiv.style.left = (veiwWidth() - this.oDiv.offsetWidth)/2 +'px'; this.oDiv.style.top = (veiwHeight() - this.oDiv.offsetHeight)/2 +'px'; } if(this.setting.dir=='right'){ this.oDiv.style.left = (veiwWidth() - this.oDiv.offsetWidth)+'px'; this.oDiv.style.top = (veiwHeight() - this.oDiv.offsetHeight) +'px'; } } Wind.prototype.fnClose = function(){ var oClose = this.oDiv.getElementsByClassName('close')[0]; var This = this; oClose.onclick = function(){ document.body.removeChild(This.oDiv); if(This.setting.mark){ document.body.removeChild(This.oMark); } This.json[This.setting.iNow] = true; }; } function extend(obj1,obj2){ for(var attr in obj2){ obj1[attr] = obj2[attr]; } } function veiwWidth(){ return document.documentElement.clientWidth; } function veiwHeight(){ return document.documentElement.clientHeight; } "},"Js/面向对象/面向对象的微博登录提示邮箱.html":{"url":"Js/面向对象/面向对象的微博登录提示邮箱.html","title":"面向对象的微博登录提示邮箱","keywords":"","body":"\">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"> 无标题文档 *{ margin:0; padding:0;} body{ font:12px/1.125 Arial,Helvetica,sans-serif;} li{ list-style:none;} #login{ width:252px; height:385px; background:url(bg.jpg) no-repeat; margin:20px auto; position:relative;} .detail{margin:0 0 5px 30px; position:relative; top:110px;} .detail input{ color: #999999; border:1px solid #74C8E5; border-radius:3px 3px 3px 3px; height:15px; line-height:14px; padding:8px 5px 7px; width:184px;} #suggest{ background:none repeat scroll 0 0 #FFFFFF; border:1px solid #CCCCCC; left:30px; margin:0; overflow:hidden; padding:0; position:absolute; text-align:left; top:142px; visibility:visible; width:194px ;z-index:1; display:none;} .note, .item{ clear: both; color: #999999; cursor: pointer; font-size: 12px; height: 20px; line-height: 20px; list-style: none outside none; margin: 0 1px; padding: 0 5px; white-space: nowrap;} .active{ white-space:nowrap; clear:both; color:rgb(153, 153, 153); cursor:pointer; font-size:12px; height:20px; line-height:20px; list-style:none outside none; margin:0pt 1px; padding:0pt 5px; background:none repeat scroll 0% 0% rgb(232, 244, 252);} window.onload = function(){ var s1 = new Suggest(); s1.init(); //初始化程序 }; function Suggest(){ this.oInput = document.getElementById('input1'); this.oUl = document.getElementById('suggest'); this.aLi = this.oUl.getElementsByTagName('li'); } Suggest.prototype = { init : function(){ this.toChange(); this.toBlur(); }, toChange : function(){ //ie : onpropertychange //标准 : oninput var ie = !-[1,]; var This = this; if(ie){ this.oInput.onpropertychange = function(){ if(This.oInput.value==''){ This.tips(); return; } This.thowUl(); This.tips(); This.sel(0); }; } else{ this.oInput.oninput = function(){ This.thowUl(); This.tips(); This.sel(0); }; } }, thowUl : function(){ this.oUl.style.display = 'block'; }, toBlur : function(){ var This = this; this.oInput.onblur = function(){ This.oUl.style.display = 'none'; }; }, tips : function(){ var value = this.oInput.value; var re = new RegExp('@'+value.substring(value.indexOf('@')+1)+''); for(var i=1;i 请选择邮箱类型 @sina.com @163.com @qq.com @126.com @vip.sina.com @sina.cn @hotmail.com @gmail.com @sohu.com @yahoo.cn @139.com @wo.com.cn @189.cn 无标题文档 *{ margin:0; padding:0;} body{ font:12px/1.125 Arial,Helvetica,sans-serif;} li{ list-style:none;} #login{ width:252px; height:385px; background:url(bg.jpg) no-repeat; margin:20px auto; position:relative;} .detail{margin:0 0 5px 30px; position:relative; top:110px;} .detail input{ color: #999999; border:1px solid #74C8E5; border-radius:3px 3px 3px 3px; height:15px; line-height:14px; padding:8px 5px 7px; width:184px;} #suggest{ background:none repeat scroll 0 0 #FFFFFF; border:1px solid #CCCCCC; left:30px; margin:0; overflow:hidden; padding:0; position:absolute; text-align:left; top:142px; visibility:visible; width:194px ;z-index:1; display:none;} .note, .item{ clear: both; color: #999999; cursor: pointer; font-size: 12px; height: 20px; line-height: 20px; list-style: none outside none; margin: 0 1px; padding: 0 5px; white-space: nowrap;} .active{ white-space:nowrap; clear:both; color:rgb(153, 153, 153); cursor:pointer; font-size:12px; height:20px; line-height:20px; list-style:none outside none; margin:0pt 1px; padding:0pt 5px; background:none repeat scroll 0% 0% rgb(232, 244, 252);} window.onload = function(){ var s1 = new Suggest(); s1.init(); //初始化程序 }; function Suggest(){ this.oInput = document.getElementById('input1'); this.oUl = document.getElementById('suggest'); this.aLi = this.oUl.getElementsByTagName('li'); } Suggest.prototype = { init : function(){ this.toChange(); this.toBlur(); }, toChange : function(){ //ie : onpropertychange //标准 : oninput var ie = !-[1,]; var This = this; if(ie){ this.oInput.onpropertychange = function(){ if(This.oInput.value==''){ This.tips(); return; } This.thowUl(); This.tips(); This.sel(0); }; } else{ this.oInput.oninput = function(){ This.thowUl(); This.tips(); This.sel(0); }; } }, thowUl : function(){ this.oUl.style.display = 'block'; }, toBlur : function(){ var This = this; this.oInput.onblur = function(){ This.oUl.style.display = 'none'; }; }, tips : function(){ var value = this.oInput.value; var re = new RegExp('@'+value.substring(value.indexOf('@')+1)+''); for(var i=1;i 请选择邮箱类型 @sina.com @163.com @qq.com @126.com @vip.sina.com @sina.cn @hotmail.com @gmail.com @sohu.com @yahoo.cn @139.com @wo.com.cn @189.cn "},"浏览器/事件机制.html":{"url":"浏览器/事件机制.html","title":"事件机制","keywords":"","body":"事件机制 事件触发三阶段 注册事件 事件代理 事件触发三阶段 事件触发有三个阶段 window 往事件触发处传播，遇到注册的捕获事件会触发 传播到事件触发处时触发注册的事件 从事件触发处往 window 传播，遇到注册的冒泡事件会触发 事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。 // 以下会先打印冒泡然后是捕获 node.addEventListener( 'click', event => { console.log('冒泡') }, false ) node.addEventListener( 'click', event => { console.log('捕获 ') }, true ) 注册事件 通常我们使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false 。useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性 capture，布尔值，和 useCapture 作用一样 once，布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听 passive，布尔值，表示永远不会调用 preventDefault 一般来说，我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。 node.addEventListener( 'click', event => { event.stopImmediatePropagation() console.log('冒泡') }, false ) // 点击 node 只会执行上面的函数，该函数不会执行 node.addEventListener( 'click', event => { console.log('捕获 ') }, true ) 事件代理 如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上 1 2 3 4 5 let ul = document.querySelector('##ul') ul.addEventListener('click', event => { console.log(event.target) }) 事件代理的方式相对于直接给目标注册事件来说，有以下优点 节省内存 不需要给子节点注销事件 "},"浏览器/跨域.html":{"url":"浏览器/跨域.html","title":"跨域","keywords":"","body":"跨域 JSONP CORS document.domain postMessage 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。 我们可以通过以下几种常用方法解决跨域的问题 JSONP JSONP 的原理很简单，就是利用 标签没有跨域限制的漏洞。通过 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。 function jsonp(data) { console.log(data) } JSONP 使用简单且兼容性不错，但是只限于 get 请求。 在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现 function jsonp(url, jsonpCallback, success) { let script = document.createElement('script') script.src = url script.async = true script.type = 'text/javascript' window[jsonpCallback] = function(data) { success && success(data) } document.body.appendChild(script) } jsonp('http://xxx', 'callback', function(value) { console.log(value) }) CORS CORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 document.domain 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域 postMessage 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息 // 发送消息端 window.parent.postMessage('message', 'http://test.com') // 接收消息端 var mc = new MessageChannel() mc.addEventListener('message', event => { var origin = event.origin || event.originalEvent.origin if (origin === 'http://test.com') { console.log('验证通过') } }) "},"浏览器/Event-loop.html":{"url":"浏览器/Event-loop.html","title":"Event loop","keywords":"","body":"Event loop Event loop Node 中的 Event loop timer I/O idle, prepare check close callbacks Event loop 众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点），当然可以引入读写锁解决这个问题。 JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。 console.log('script start') setTimeout(function() { console.log('setTimeout') }, 0) console.log('script end') 以上代码虽然 setTimeout 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 setTimeout 还是会在 script end 之后打印。 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task。 console.log('script start') setTimeout(function() { console.log('setTimeout') }, 0) new Promise(resolve => { console.log('Promise') resolve() }) .then(function() { console.log('promise1') }) .then(function() { console.log('promise2') }) console.log('script end') // script start => Promise => script end => promise1 => promise2 => setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务，所以会有以上的打印。 微任务包括 process.nextTick ，promise ，Object.observe ，MutationObserver 宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering 很多人有个误区，认为微任务快于宏任务，其实是错误的。因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。 所以正确的一次 Event loop 顺序是这样的 执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的 界面响应，我们可以把操作 DOM 放入微任务中。 Node 中的 Event loop Node 中的 Event loop 和浏览器中的不相同。 Node 的 Event loop 分为 6 个阶段，它们会按照顺序反复运行 ┌───────────────────────┐ ┌─>│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │timer timers 阶段会执行 setTimeout 和 setInterval 一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟。 下限的时间有一个范围：[1, 2147483647] ，如果设定的时间不在这个范围，将被设置为 1。 I/O I/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调 idle, prepare poll 阶段很重要，这一阶段中，系统会做两件事情 执行到点的定时器 执行 poll 队列中的事件 并且当 poll 中没有定时器的情况下，会发现以下两件事情 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制 如果 poll 队列为空，会有两件事发生 如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate 如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调 如果有别的定时器需要被执行，会回到 timer 阶段执行回调。 check check 阶段执行 setImmediate close callbacks close callbacks 阶段执行 close 事件 并且在 Node 中，有些情况下的定时器执行顺序是随机的 setTimeout(() => { console.log('setTimeout') }, 0) setImmediate(() => { console.log('setImmediate') }) // 这里可能会输出 setTimeout，setImmediate // 可能也会相反的输出，这取决于性能 // 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate // 否则会执行 setTimeout 当然在这种情况下，执行顺序是相同的 var fs = require('fs') fs.readFile(__filename, () => { setTimeout(() => { console.log('timeout') }, 0) setImmediate(() => { console.log('immediate') }) }) // 因为 readFile 的回调在 poll 中执行 // 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调 // 再去 timer 阶段执行 setTimeout // 所以以上输出一定是 setImmediate，setTimeout 上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行。 setTimeout(() => { console.log('timer1') Promise.resolve().then(function() { console.log('promise1') }) }, 0) setTimeout(() => { console.log('timer2') Promise.resolve().then(function() { console.log('promise2') }) }, 0) // 以上代码在浏览器和 node 中打印情况是不同的 // 浏览器中一定打印 timer1, promise1, timer2, promise2 // node 中可能打印 timer1, timer2, promise1, promise2 // 也可能打印 timer1, promise1, timer2, promise2 Node 中的 process.nextTick 会先于其他 microtask 执行。 setTimeout(() => { console.log('timer1') Promise.resolve().then(function() { console.log('promise1') }) }, 0) process.nextTick(() => { console.log('nextTick') }) // nextTick, timer1, promise1 "},"浏览器/存储.html":{"url":"浏览器/存储.html","title":"存储","keywords":"","body":"存储 cookie，localStorage，sessionStorage，indexDB Service Worker cookie，localStorage，sessionStorage，indexDB 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 不参与 从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。 对于 cookie，我们还需要注意安全性。 sessionStorage indexDB value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 Service Worker Service workers 本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步 API。 目前该技术通常用来做缓存文件，提高首屏速度，可以试着来实现这个功能。 // index.js if (navigator.serviceWorker) { navigator.serviceWorker .register('sw.js') .then(function(registration) { console.log('service worker 注册成功') }) .catch(function(err) { console.log('servcie worker 注册失败') }) } // sw.js // 监听 `install` 事件，回调中缓存所需文件 self.addEventListener('install', e => { e.waitUntil( caches.open('my-cache').then(function(cache) { return cache.addAll(['./index.html', './index.js']) }) ) }) // 拦截所有请求事件 // 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据 self.addEventListener('fetch', e => { e.respondWith( caches.match(e.request).then(function(response) { if (response) { return response } console.log('fetch source') }) ) }) 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了 在 Cache 中也可以发现我们所需的文件已被缓存 当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的 "},"浏览器/渲染机制.html":{"url":"浏览器/渲染机制.html","title":"渲染机制","keywords":"","body":"渲染机制 浏览器的渲染机制 Load 和 DOMContentLoaded 区别 图层 重绘（Repaint）和回流（Reflow） 减少重绘和回流 浏览器的渲染机制 浏览器的渲染机制一般分为以下几个步骤 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上。 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢。 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。 Load 和 DOMContentLoaded 区别 Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。 DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。 图层 一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。 通过以下几个常用属性可以生成新图层 3D 变换：translate3d、translateZ will-change video、iframe 标签 通过动画实现的 opacity 动画转换 position: fixed 重绘（Repaint）和回流（Reflow） 重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。 所以以下几个动作可能会导致性能问题： 改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 很多人不知道的是，重绘和回流其实和 Event loop 有关。 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。 减少重绘和回流 使用 translate 替代 top .test { position: absolute; top: 10px; width: 100px; height: 100px; background: red; } setTimeout(() => { // 引起回流 document.querySelector('.test').style.top = '100px' }, 1000) 使用 visibility 替换display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量 for (let i = 0; i 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免 DOM 深度过深 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层。 "},"Js/小程序/性能更优越的小程序图片懒加载方式.html":{"url":"Js/小程序/性能更优越的小程序图片懒加载方式.html","title":"性能更优越的小程序图片懒加载方式","keywords":"","body":"性能更优越的小程序图片懒加载方式 性能更优越的小程序图片懒加载方式 意义 实现方式 createIntersectionObserver lazyload.js 意义 懒加载或者可以说是延迟加载，针对非首屏或者用户\"看不到\"的地方延迟加载，有利于页面首屏加载速度快、节约了流量,用户体验好 实现方式 传统H5的懒加载方式都是通过监听页面的scroll事件来实现的，结合viewport的高度来判断。 小程序也类似，通过监听页面onPageScroll事件获取当前滚动的数据，结合getSystemInfo获取设备信息来判断。由于scroll事件密集发生，计算量很大，经常会造成FPS降低、页面卡顿等问题。 这里说的是通过另外一种方式来实现 createIntersectionObserver 小程序基础库 1.9.3 开始支持 节点布局交叉状态API可用于监听两个或多个组件节点在布局位置上的相交状态。这一组API常常可以用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见。 API涉及到的概念总共有5个 参照节点：监听的参照节点，取它的布局区域作为参照区域。如果有多个参照节点，则会取它们布局区域的 交集 作为参照区域。页面显示区域也可作为参照区域之一。 目标节点：监听的目标，默认只能是一个节点（使用 selectAll 选项时，可以同时监听多个节点）。 相交区域：目标节点的布局区域与参照区域的相交区域。 相交比例：相交区域占参照区域的比例。 阈值：相交比例如果达到阈值，则会触发监听器的回调函数。阈值可以有多个。 通过以上API和概念的了解，可以获取到图片是否可以被用户看见或者即将被看见，通过回调将图片加载显示出来，然后监听下一组即将被显示的图片，这样就可以达到懒加载图片的方式，以下是代码展示 //index.js //获取应用实例 const app = getApp() let lazyload; Page({ data: { classNote: 'item-', //循环节点前缀 count: 0, //总共加载到多少张 img: [] //图片列表 }, onReady: function () { //可以先初始化首屏需要展示的图片 that.setData({ count: 5 }) //开始监听节点，注意需要在onReady才能监听，此时节点才渲染 lazyload.observe(); }, viewPort: function () { const that = this; var intersectionObserver = wx.createIntersectionObserver(); //这里bottom：100，是指显示区域以下 100px 时，就会触发回调函数。 intersectionObserver.relativeToViewport({bottom: 100}).observe(this.data.classNote + this.data.count, (res) => { if(res.boundingClientRect.top > 0){ intersectionObserver.disconnect() that.setData({ count: that.data.count + 5 }) that.viewPort(); } }) } }) //page.wxml 这里有2点需要注意的 监听的节点需要先渲染，也就是说监听这个动作需要在onReady的时候 上述示例监听是依赖循环节点的class，最少需要先渲染一个节点才能监听 每次监听完一个循环节点后，结束监听，然后继续监听下一个节点 lazyload.js /src/libs/lazyload.js ```js export default class LazyLoad{ constructor(context, opt = {}){ this.page = context; this.classNote = opt.classNote || 'item-'; this.initNum = opt.initNum || 5; this.limit = opt.limit || 5; this.intersectionObserver = {}; this.page.setData({ __LAZT_LOAD_COUNT: this.initNum }) if(!this.isSupport()) console.error('wx.createIntersectionObserver is not a function') } observe(){ if(!this.isSupport()) return; const that = this; this.intersectionObserver = wx.createIntersectionObserver(); this.intersectionObserver.relativeToViewport({bottom: 100}).observe(this.classNote + this.page.data.__LAZT_LOAD_COUNT, (res) => { if(res.boundingClientRect.top > 0){ that.intersectionObserver.disconnect() that.page.setData({ __LAZT_LOAD_COUNT: that.page.data.__LAZT_LOAD_COUNT + that.limit }) that.observe(); } }) } isSupport(){ return !!wx.createIntersectionObserver } } > src/pages/index/index.js ```js //index.js //获取应用实例 const app = getApp() import lazyLoad from '../../libs/lazyload'; let lazyload; Page({ data: { img: [ \"https://images.freeimages.com/images/small-previews/851/poppies-1369329.jpg\", \"https://images.freeimages.com/images/small-previews/53b/montenegro-sky-1370598.jpg\", \"https://images.freeimages.com/images/small-previews/6d5/lake-at-the-cottage-1372381.jpg\", \"https://images.freeimages.com/images/small-previews/e5f/pink-lotus-1396744.jpg\", \"https://images.freeimages.com/images/small-previews/b45/spring-colours-1375388.jpg\", \"https://images.freeimages.com/images/small-previews/773/koldalen-4-1384902.jpg\", \"https://images.freeimages.com/images/small-previews/6e4/cemetary-1387449.jpg\", \"https://images.freeimages.com/images/small-previews/bf2/fields-1-1370990.jpg\", \"https://images.freeimages.com/images/small-previews/950/serious-grasshopper-1-1056340.jpg\", \"https://images.freeimages.com/images/small-previews/002/two-gerbers-1408523.jpg\", \"https://images.freeimages.com/images/small-previews/c53/yellowstone-river-1361768.jpg\", \"https://images.freeimages.com/images/small-previews/256/spring-1376144.jpg\", \"https://images.freeimages.com/images/small-previews/e51/tokyo05-2-1447803.jpg\", \"https://images.freeimages.com/images/small-previews/0db/tropical-bird-1390996.jpg\", \"https://images.freeimages.com/images/small-previews/901/butterfly-dress-1520606.jpg\", \"https://images.freeimages.com/images/small-previews/ffa/water-lilly-1368676.jpg\", \"https://images.freeimages.com/images/small-previews/fec/sunset-rays-1391805.jpg\", \"https://images.freeimages.com/images/small-previews/176/mansion-in-the-canyon-1575490.jpg\", \"https://images.freeimages.com/images/small-previews/48d/marguerite-1372118.jpg\", \"https://images.freeimages.com/images/small-previews/99b/sunflowers-3-1393020.jpg\", \"https://images.freeimages.com/images/small-previews/9b6/among-giants-1375605.jpg\", \"https://images.freeimages.com/images/small-previews/03e/wild-flowers-1628445.jpg\", \"https://images.freeimages.com/images/small-previews/fb3/grass-1379193.jpg\", \"https://images.freeimages.com/images/small-previews/e71/frog-1371919.jpg\", \"https://images.freeimages.com/images/small-previews/981/cow-1380252.jpg\", \"https://images.freeimages.com/images/small-previews/5b7/on-the-road-7-1384791.jpg\", \"https://images.freeimages.com/images/small-previews/58f/double-bass-1423720.jpg\", \"https://images.freeimages.com/images/small-previews/e0c/hawaiin-sunset-1368289.jpg\", \"https://images.freeimages.com/images/small-previews/b74/wild-poppies-1384853.jpg\", \"https://images.freeimages.com/images/small-previews/241/night-fog-1521028.jpg\", \"https://images.freeimages.com/images/small-previews/bfd/clouds-1371838.jpg\", \"https://images.freeimages.com/images/small-previews/1e7/japanese-food-1327425.jpg\", \"https://images.freeimages.com/images/small-previews/716/flower-1372780.jpg\", \"https://images.freeimages.com/images/small-previews/85a/daisy-s-1375598.jpg\", \"https://images.freeimages.com/images/small-previews/8ee/multicolor-drop-2-1056473.jpg\", \"https://images.freeimages.com/images/small-previews/8a5/red-tulip-2-1401227.jpg\", \"https://images.freeimages.com/images/small-previews/859/burning-trees-1391193.jpg\", \"https://images.freeimages.com/images/small-previews/7c7/tulips-1531279.jpg\", \"https://images.freeimages.com/images/small-previews/615/corcovado-sunset-1527899.jpg\", \"https://images.freeimages.com/images/small-previews/700/road-to-nowhere-1383109.jpg\", \"https://images.freeimages.com/images/small-previews/0d6/blue-flowers-with-macro-4-1400913.jpg\", \"https://images.freeimages.com/images/small-previews/efb/lotus-flower-1382251.jpg\", \"https://images.freeimages.com/images/small-previews/b2d/kiwi-fruit-macros-1313905.jpg\", \"https://images.freeimages.com/images/small-previews/b85/bay-lrt-station-1626400.jpg\", \"https://images.freeimages.com/images/small-previews/9a4/large-pumpkin-1387927.jpg\", \"https://images.freeimages.com/images/small-previews/0cf/tulips-1-1377350.jpg\", \"https://images.freeimages.com/images/small-previews/f13/factory-1446641.jpg\", \"https://images.freeimages.com/images/small-previews/e2a/boise-downtown-1387405.jpg\" ] }, onLoad: function () { lazyload = new lazyLoad(this, { classNote: '.item-', //循环节点 initNum: 5, //初始化展示多少个节点 limit: 5 //每次加载多少个节点 }) }, onReady: function () { lazyload.observe(); }, }) /src/pages/index/index.wxml "},"Js/基础/错误处理机制.html":{"url":"Js/基础/错误处理机制.html","title":"错误处理机制","keywords":"","body":"错误处理机制 错误处理机制 Error 实例对象 原生错误类型 SyntaxError 对象 ReferenceError 对象 RangeError 对象 TypeError 对象 URIError 对象 EvalError 对象 总结 自定义错误 throw 语句 try...catch 结构 finally 代码块 Error 实例对象 JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供Error构造函数，所有抛出的错误都是这个构造函数的实例。 var err = new Error('出错了'); err.message // \"出错了\" 上面代码中，我们调用Error构造函数，生成一个实例对象err。Error构造函数接受一个参数，表示错误提示，可以从实例的message属性读到这个参数。抛出Error实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。 JavaScript 语言标准只提到，Error实例对象必须有message属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。 message：错误提示信息 name：错误名称（非标准属性） stack：错误的堆栈（非标准属性） 使用name和message这两个属性，可以对发生什么错误有一个大概的了解。 if (error.name) { console.log(error.name + ': ' + error.message); } stack属性用来查看错误发生时的堆栈。 function throwit() { throw new Error(''); } function catchit() { try { throwit(); } catch(e) { console.log(e.stack); // print stack trace } } catchit() // Error // at throwit (~/examples/throwcatch.js:9:11) // at catchit (~/examples/throwcatch.js:3:9) // at repl:1:5 上面代码中，错误堆栈的最内层是throwit函数，然后是catchit函数，最后是函数的运行环境。 原生错误类型 Error实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在Error的6个派生对象。 SyntaxError 对象 SyntaxError对象是解析代码时发生的语法错误。 // 变量名错误 var 1a; // Uncaught SyntaxError: Invalid or unexpected token // 缺少括号 console.log 'hello'); // Uncaught SyntaxError: Unexpected string 上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出SyntaxError。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。 ReferenceError 对象 ReferenceError对象是引用一个不存在的变量时发生的错误。 // 使用一个不存在的变量 unknownVariable // Uncaught ReferenceError: unknownVariable is not defined 另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。 // 等号左侧不是变量 console.log() = 1 // Uncaught ReferenceError: Invalid left-hand side in assignment // this 对象不能手动赋值 this = 1 // ReferenceError: Invalid left-hand side in assignment 上面代码对函数console.log的运行结果和this赋值，结果都引发了ReferenceError错误。 RangeError 对象 RangeError对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。 // 数组长度不得为负数 new Array(-1) // Uncaught RangeError: Invalid array length TypeError 对象 TypeError对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。 new 123 // Uncaught TypeError: number is not a func var obj = {}; obj.unknownMethod() // Uncaught TypeError: obj.unknownMethod is not a function 上面代码的第二种情况，调用对象不存在的方法，也会抛出TypeError错误，因为obj.unknownMethod的值是undefined，而不是一个函数。 URIError 对象 URIError对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。 decodeURI('%2') // URIError: URI malformed EvalError 对象 eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。 总结 以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。 var err1 = new Error('出错了！'); var err2 = new RangeError('出错了，变量超出有效范围！'); var err3 = new TypeError('出错了，变量类型无效！'); err1.message // \"出错了！\" err2.message // \"出错了，变量超出有效范围！\" err3.message // \"出错了，变量类型无效！\" 自定义错误 除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。 function UserError(message) { this.message = message || '默认信息'; this.name = 'UserError'; } UserError.prototype = new Error(); UserError.prototype.constructor = UserError; 上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了。 new UserError('这是自定义的错误！'); throw 语句 throw语句的作用是手动中断程序执行，抛出一个错误。 if (x 上面代码中，如果变量x小于等于0，就手动抛出一个错误，告诉用户x的值不正确，整个程序就会在这里中断执行。可以看到，throw抛出的错误就是它的参数，这里是一个Error实例。 throw也可以抛出自定义错误。 function UserError(message) { this.message = message || '默认信息'; this.name = 'UserError'; } throw new UserError('出错了！'); // Uncaught UserError {message: \"出错了！\", name: \"UserError\"} 上面代码中，throw抛出的是一个UserError实例。 实际上，throw可以抛出任何类型的值。也就是说，它的参数可以是任何值。 // 抛出一个字符串 throw 'Error！'; // Uncaught Error！ // 抛出一个数值 throw 42; // Uncaught 42 // 抛出一个布尔值 throw true; // Uncaught true // 抛出一个对象 throw { toString: function () { return 'Error!'; } }; // Uncaught {toString: ƒ} 对于 JavaScript 引擎来说，遇到throw语句，程序就中止了。引擎会接收到throw抛出的信息，可能是一个错误实例，也可能是其他类型的值。 try...catch 结构 一旦发生错误，程序就中止执行了。JavaScript 提供了try...catch结构，允许对错误进行处理，选择是否往下执行。 try { throw new Error('出错了!'); } catch (e) { console.log(e.name + \": \" + e.message); console.log(e.stack); } // Error: 出错了! // at :3:9 // ... 上面代码中，try代码块抛出错误（上例用的是throw语句），JavaScript 引擎就立即把代码的执行，转到catch代码块，或者说错误被catch代码块捕获了。catch接受一个参数，表示try代码块抛出的值。 如果你不确定某些代码是否会报错，就可以把它们放在try...catch代码块之中，便于进一步对错误进行处理。 try { f(); } catch(e) { // 处理错误 } 上面代码中，如果函数f执行报错，就会进行catch代码块，接着对错误进行处理。 catch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。 try { throw \"出错了\"; } catch (e) { console.log(111); } console.log(222); // 111 // 222 上面代码中，try代码块抛出的错误，被catch代码块捕获后，程序会继续向下执行。 catch代码块之中，还可以再抛出错误，甚至使用嵌套的try...catch结构。 var n = 100; try { throw n; } catch (e) { if (e 上面代码中，catch代码之中又抛出了一个错误。 为了捕捉不同类型的错误，catch代码块之中可以加入判断语句。 try { foo.bar(); } catch (e) { if (e instanceof EvalError) { console.log(e.name + \": \" + e.message); } else if (e instanceof RangeError) { console.log(e.name + \": \" + e.message); } // ... } 上面代码中，catch捕获错误之后，会判断错误类型（EvalError还是RangeError），进行不同的处理。 finally 代码块 try...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。 function cleansUp() { try { throw new Error('出错了……'); console.log('此行不会执行'); } finally { console.log('完成清理工作'); } } cleansUp() // 完成清理工作 // Uncaught Error: 出错了…… // at cleansUp (:3:11) // at :10:1 上面代码中，由于没有catch语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行finally代码块，然后再向用户提示报错信息。 function idle(x) { try { console.log(x); return 'result'; } finally { console.log('FINALLY'); } } idle('hello') // hello // FINALLY 上面代码中，try代码块没有发生错误，而且里面还包括return语句，但是finally代码块依然会执行。而且，这个函数的返回值还是result。 下面的例子说明，return语句的执行是排在finally代码之前，只是等finally代码执行完毕后才返回。 var count = 0; function countUp() { try { return count; } finally { count++; } } countUp() // 0 count // 1 上面代码说明，return语句里面的count的值，是在finally代码块运行之前就获取了。 下面是finally代码块用法的典型场景。 openFile(); try { writeFile(Data); } catch(e) { handleError(e); } finally { closeFile(); } 上面代码首先打开一个文件，然后在try代码块中写入文件，如果没有发生错误，则运行finally代码块关闭文件；一旦发生错误，则先使用catch代码块处理错误，再使用finally代码块关闭文件。 下面的例子充分反映了try...catch...finally这三者之间的执行顺序。 function f() { try { console.log(0); throw 'bug'; } catch(e) { console.log(1); return true; // 这句原本会延迟到 finally 代码块结束再执行 console.log(2); // 不会运行 } finally { console.log(3); return false; // 这句会覆盖掉前面那句 return console.log(4); // 不会运行 } console.log(5); // 不会运行 } var result = f(); // 0 // 1 // 3 result // false 上面代码中，catch代码块结束执行之前，会先执行finally代码块。 catch代码块之中，触发转入finally代码快的标志，不仅有return语句，还有throw语句。 function f() { try { throw '出错了！'; } catch(e) { console.log('捕捉到内部错误'); throw e; // 这句原本会等到finally结束再执行 } finally { return false; // 直接返回 } } try { f(); } catch(e) { // 此处不会执行 console.log('caught outer \"bogus\"'); } // 捕捉到内部错误 上面代码中，进入catch代码块之后，一遇到throw语句，就会去执行finally代码块，其中有return false语句，因此就直接返回了，不再会回去执行catch代码块剩下的部分了。 try { try { console.log('Hello world!'); // 报错 } finally { console.log('Finally'); } console.log('Will I run?'); } catch(error) { console.error(error.message); } // Finally // console is not defined 上面代码中，try里面还有一个try。内层的try报错，这时会执行内层的finally代码块，然后抛出错误，被外层的catch捕获。 "},"Js/基础/HTTPS协议.html":{"url":"Js/基础/HTTPS协议.html","title":"HTTPS协议","keywords":"","body":"用信鸽传送来解释 HTTPS 协议，让 HTTPS 不再难懂！ 用信鸽传送来解释 HTTPS 协议，让 HTTPS 不再难懂！ 00 引言 01 爱丽丝、鲍伯和 ... 信鸽？ 02 初级交流 03 隐蔽的密码 04 我们如何决定密匙？ 05 通过信鸽传递盒子 06 如何信任盒子 07 沉重的盒子 00 引言 密码学是一门难以理解的学科，因为它充满了数学定理。但是除非你要实际开发出一套加密算法系统，否则你是没必要强制理解那些深奥的数学定理的。 如果你阅读本文的目的是想设计下一套 HTTPS 协议，那我只能抱歉的说本文的知识还远远不够；如果不是的话，那么就煮杯咖啡，轻松愉悦的阅读本文吧。 01 爱丽丝、鲍伯和 ... 信鸽？ 你在互联网上从事的任何活动（阅读这篇文章、在亚马逊上购物、上传图片等）归结到底都是从某台服务器上发送和接收信息。 这个说起来可能有点抽象，不如让我们假设这些消息都是由信鸽来传递的。我知道这个假设有些太过随意，但相信我 HTTPS 就是这样工作的，尽管它的速度快的多。 我们先不谈服务器、客户端或者黑客攻击，先来聊一下爱丽丝、鲍伯和马洛里。如果这已不是你第一次接触密码学理论，你应该会认识这些名字，因为他们经常在各种密码学文献中被提及。 02 初级交流 如果爱丽丝想要给鲍勃发送一段信息，她会把信息绑在信鸽的腿上然后送往鲍勃那里。鲍勃收到了信息，并阅读了信息，非常完美。 但如果马洛里拦截了爱丽丝的鸽子并且篡改了信息呢？鲍勃就没有办法去知道爱丽丝发出的信息在传递过程中遭到了修改。 这就是 HTTP 如何运作的。看起来很可怕对吧？我是不会通过 HTTP 来发送我的银行资信证明的，并且你也不应如此。 03 隐蔽的密码 那么如果爱丽丝和鲍勃都非常的机智。他们一致认同使用一种隐蔽的密码来书写他们的信息。他们会将信息中的每个字母按照字母表中的顺序前移三位。比如，D→A，E→B，F→C。如此一来，原文为 “secret message” 的信息就变成了 “pbzobq jbppxdb” 。 那现在如果马洛里再截获了信鸽，她既不能做出有意义的修改同时也不会知道信息的内容，因为她不知道隐蔽的密码到底是什么。然而鲍勃却可以很容易反转密码，依靠 A → D, B → E, C → F 之类的规则破译信息的内容。加密后的信息 “pbzobq jbppxdb” 会被破解还原为 “secret message” 。 搞定！ 这就是对称密匙加密，因为如果你知道如何加密一段信息那么你同样可以解密这段信息。 上述的密码通常被称为凯撒码。在现实生活中，我们会使用更为奇特和复杂的密码，但原理相同。 04 我们如何决定密匙？ 如果除了发信者和收信者之外没有人知道使用的是什么密匙，对称密匙加密是非常安全的。在凯撒加密中，密匙就是每个字母变到加密字母需要移动多少位的偏移量。我之前的距离中，使用的偏移量是 3 ，但是也可以用 4 或者 12 。 问题是如果爱丽丝和鲍勃在开始用信鸽传信之前没有碰过头，他们没有一个安全的方式来确立密匙。如果他们自己来在信中传递密匙，马洛里就会截获信息并发现密匙。这就使得马洛里可以在爱丽丝和鲍勃开始加密他们的信息之前或之后，阅读到他们信息的内容并按照她的意愿来篡改信息。 这是一个中间人攻击的典型例子，避免这个问题的唯一方法就是收发信的两方一起修改他们的编码系统。 05 通过信鸽传递盒子 所以爱丽丝和鲍勃就想出了一个更好的系统。当鲍勃想要给爱丽丝发送信息时，他会按照如下的步骤来进行： 鲍勃向爱丽丝送一只没有携带任何信息的鸽子。 爱丽丝给鲍勃送回鸽子，并且这只鸽子带有一个有开着的锁的盒子，爱丽丝保管着锁的钥匙。 鲍勃把信放进盒子中，把锁锁上然后把盒子送给爱丽丝。 爱丽丝收到盒子，用钥匙打开然后阅读信息。 这样马洛里就不能通过截获鸽子来篡改信息了，因为她没有打开盒子的钥匙。当爱丽丝要给鲍勃发送消息的时候同样按照上述的流程。 爱丽丝和鲍勃所使用的流程通常被称为非对称密钥加密。之所以称之为非对称，是因为即使是你把信息编码（锁上盒子）也不能破译信息（打开锁住的盒子）。 在术语中，盒子被称为公匙而用来打开盒子的钥匙被称为私匙。 06 如何信任盒子 如果你稍加注意你就会发现还是存在问题。当鲍勃收到盒子时他如何能确定这个盒子来自爱丽丝而不是马洛里截获了鸽子然后换了一个她有钥匙能打开的盒子呢？ 爱丽丝决定签名标记一下盒子，这样鲍勃收到盒子的时候就可以检查签名来确定是爱丽丝送出的盒子了。 那么你们之中的一些人可能就会想了，鲍勃如何打一开始就能识别出爱丽丝的签名呢？这是个好问题。爱丽丝和鲍勃也确实有这个问题，所以他们决定让泰德代替爱丽丝来标记这个盒子。 那么谁是泰德呢？泰德很有名的，是一个值得信任的家伙。他会给任何人签名并且所有人都信任他只会给合法的人签名标记盒子。 如果泰德可以确认索要签名的人是爱丽丝，他就会在爱丽丝的盒子上签名。因此马洛里就不可能搞到一个有着泰德代表爱丽丝签了名的盒子，因为鲍勃知道泰德只会给他确认过的人签名，从而识破马洛里的诡计。 泰德的角色在术语中被称为认证机构。而你阅读此文时所用的浏览器打包存有许多认证机构的签名。 所以当你首次接入一个网站的时候你可以信任来自这个站点的盒子因为你信任泰德而泰德会告诉你盒子是合法的。 07 沉重的盒子 现在爱丽丝和鲍勃有了一个可靠的系统来进行交流，然他们也意识到让鸽子携带盒子比原本只携带信件要慢一些。 因此他们决定只有在选择用对称加密来给信息编码（还记得凯撒加密法吧？）的密匙时，使用传递盒子的方法（非对称加密）。 这样就可以二者的优点兼具了，非对称加密的可靠性和对称加密的高效性。 现实世界中我们不会用信鸽这样慢的送信手段，但用非对称加密来编码信息仍要慢于使用对称加密技术，所以我们只有在交换编码密匙的时候会使用非对称加密技术。 "},"Js/基础/cookie与session.html":{"url":"Js/基础/cookie与session.html","title":"cookie与session","keywords":"","body":"cookie与session cookie与session cookie cookie原理 cookie的不可跨域名性 cookie属性 name value domain path Expires/Max-Age secure HttpOnly 关于JavaScript操作cookie 服务端如何去设置cookie cookie与session session对浏览器的要求 session中不使用cookie cookie session 区别 session理解 1. session的概念 2. cookie与session的关系 3. 创建 session和销毁session的时机 cookie cookie原理 第一次访问网站的时候，浏览器发出请求，服务器响应请求后，会将 cookie 放入到响应请求中，在浏览器第二次发请求的时候，会把 cookie 带过去，服务端会辨别用户身份，当然服务器也可以修改 cookie 内容（后面会谈到这点）。cookie 的产生是通过扩展 HTTP 协议来实现的，服务器通过在 HTTP 响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的 cookie。然而纯粹的客户端脚本如 JavaScript 也可以生成 cookie。而 cookie 的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的 cookie ，如果某个 cookie 所声明的作用范围（这个作用范围由 cookie 的 path 和 domain 同时决定）大于等于将要请求的资源所在的位置，则把该 cookie 附在请求资源的 HTTP 请求头上发送给服务器。 cookie的不可跨域名性 cookie具有不可跨域名性。根据 cookie 规范，浏览器访问 Google 只会携带 Google 的 cookie，而不会携带 Baidu 的 cookie。Google 也只能操作 Google 的 cookie，而不能操作 Baidu 的 cookie。 cookie 在客户端是由浏览器来管理的。浏览器能够保证 Google 只会操作 Google 的 cookie 而不会操作 Baidu的 cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站 cookie 的依据是域名。Google 与 Baidu 的域名不一样，因此 Google 不能操作 Baidu 的 cookie。 需要注意的是，虽然网站 images.google.com与网站 www.google.com 同属于Google，但是域名不一样，二者同样不能互相操作彼此的 cookie。 注意：用户登录网站 www.google.com 之后会发现访问 images.google.com 时登录信息仍然有效，而普通的 cookie 是做不到的。这是因为 Google在后端进行了相关处理。 cookie属性 cookie 的属性比较多，我们可以看下下面这张图 name 这个显而易见，就是代表 cookie 的名字的意思，一个域名下绑定的 cookie ，name 不能相同，相同的 name 的值会被覆盖掉 value 这个就是每个 cookie 拥有的一个属性，它表示该属性的值 domain 这个是指的域名，这个代表的是，cookie 绑定的域名，如果没有设置，就会自动绑定到执行语句的当前域，还有值得注意的点，统一个域名下的二级域名也是不可以交换使用 cookie 的，比如，你设置 www.baidu.com 和 image.baidu.com ，依旧是不能公用的 path path这个属性默认是/，当你设置成比如/blog的时候，其实它会给 “domain+path” 范围内绑定 cookie Expires/Max-Age 该属性决定 cookie 的有效期，一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除，这就是上图中的—— session (会话储存)。 如果你想要 cookie 存在一段时间，那么你可以通过设置 Expires 属性为未来的一个时间节点，Expires 这个是代表当前时间的，这个属性已经逐渐被我们下面这个主人公所取代——Max-Age。 Max-Age，是以秒为单位的，Max-Age 为正数时，cookie 会在 Max-Age 秒之后被删除。在 Max-Age 之前 cookie 是保存到硬盘上，即使关闭浏览器后再次打开，这些 cookie 仍然有效直到超过设定的过期时间。存储在硬盘上的 cookie 可以在不同的浏览器进程间共享，比如两个 IE 窗口。当 Max-Age 为负数时，表示的是临时储存，不会生出 cookie 文件，只会存在浏览器内存中，且只会在打开的浏览器窗口或者子窗口有效，一旦浏览器关闭， cookie 就会消失，当 Max-Age 为 0 时，又会发生什么呢，删除 cookie ，因为cookie 机制本身没有设置删除 cookie ，失效的 cookie 会被浏览器自动从内存中删除，所以，它实现的就是让 cookie 失效。 secure 这个属性译为安全，http 不仅是无状态的，还是不安全的协议，容易被劫持。所以当这个属性设置为 true 时，此 cookie 只会在 https 和 ssl 等安全协议下传输。但需要强调一下这个属性并不能对客户端的cookie进行加密，不能保证绝对的安全性 HttpOnly 这个属性是面试的时候常考的，如果这个属性设置为 true，就不能通过 JavaScript 脚本来获取 cookie 的值，能有效的防止xss 攻击,看 MDN 的官方文档： 为避免跨域脚本 (XSS) 攻击，通过JavaScript的 Document.cookie API无法访问有HttpOnly 标记的Cookie，Cookie只需要发送给服务端。如果包含服务端session信息的Cookie不想被客户端Javascript使用，那么就需要使用HttpOnly 标记 关于JavaScript操作cookie document.cookie 可以对 cookie 进行读写： console.log(document.cookie); //读取浏览器中的cookie document.cookie='myname=liuzhiyu;path=/;domain=.baidu.com'; // 写入 cookie 服务端如何去设置cookie 服务端就是通过 setCookie 来设置 cookie 的，注意点，要设置多个 cookie 时，得多写几个 setCookie ，我们还可以从上图看到，请求可以携带 cookie 给后端。 cookie与session 本片开头已说过 HTTP 是一个不保存状态的协议。session 是服务器端使用的一种记录客户端状态的机制，不同的是 cookie 保存在客户端浏览器中，而 session 保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是 session。客户端浏览器再次访问时只需要从该 session 中查找该客户的状态就可以了。如果说 cookie 机制是通过检查客户身上的“通行证”来确定客户身份的话，那么 session 机制就是通过检查服务器上的“客户明细表”来确认客户身份。session 相当于程序在服务器上建立的一份客户档案，客户来访的时候只需要查询客户档案表就可以了。 session对浏览器的要求 虽然 session 保存在服务器中，对客户端是透明的，它的正常运行仍然需要客户端浏览器的支持。这是因为 session 需要使用 cookie 作为识别标志。HTTP 协议是无状态的，session 不能依据 HTTP 连接来判断是否为同一客户，因此服务器向客户端浏览器发送一个名为 JSESSIONID 的 cookie，它的值为该 session 的 id。session 依据该cookie 来识别是否为同一用户。该 cookie 为服务器自动生成的，它的 MaxAge 属性一般为–1，表示仅当前浏览器内有效，并且各浏览器窗口间不共享，关闭浏览器就会失效。 session中不使用cookie URL 地址重写是对客户端不支持 cookie 的解决方案。URL 地址重写的原理是将该用户 session 的 id 信息重写到 URL 地址中。服务器能够解析重写后的 URL 获取 session 的 id。这样即使客户端不支持 cookie，也可以使用 session 来记录用户状态。 cookie session 区别 cookie 数据存放在客户的浏览器上，session数据放在服务器上 cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗考虑到安全应当使用 session session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用 COOKIE 单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存20个 cookie。 鉴于上述区别我们建议 将登陆信息等重要信息存放为 SESSION 其他信息如果需要保留，可以放在 COOKIE 中 session理解 1. session的概念 session 是服务器端使用的一种记录客户端状态的机制，不同的是 cookie 保存在客户端浏览器中，而 session 保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上。这就是 session。客户端浏览器再次访问时只需要从该 session 中查找该客户的状态就可以了 2. cookie与session的关系 cookie和session的方案虽然分别属于客户端和服务端，但是服务端的session的实现对客户端的cookie有依赖关系的；步骤大概如下： 服务端执行Session机制 生成对应而唯一的session_id(通过对这个session_id的解析和处理，服务端可以找到，该session保存的文件；再从文件中提取出session的信息) 服务端会将这个session_id发送给客户端 客户端接受到session_id,以cookie作为保存的容器保存起来 客户端在每次请求的时候都会带这个session_id给服务端 服务端自行解析session 注意：session保存信息的手段是多种的：缓存，数据库，文件等；但是默认是文件形式保存。。 3. 创建 session和销毁session的时机 创建session的时候会附带着创建一个cookie，它的MaxAge为-1，也就是说只能存在于内存中。当浏览器端禁用cookie时，这个cookie依然会被创建。 当浏览器提交的请求中有jsessionid参数或cookie报头时，容器不再新建session，而只是找到先前的session进行关联。这里又分为两种情况： 使用jsessionid。该值若能与现有的session对应，就不创建新的session，否则，仍然创建新的session。 使用cookie。该值若能与现有的session对应，也不创建新的session；但若没有session与之对应（就如上面的重启服务器之后）容器会根据cookie信息恢复这个与之对应的session，就好像是以前有过一样。 session何时被销毁？当我们关闭浏览器，再打开它，连接服务器时，服务器端会分配一个新的session，也就是说会启动一个新的会话。那么原来的session是不是被销毁了呢？我做了个小实验： 创建一个session： //启动session的初始化 session_start(); //注册session变量，并且赋值 $_SESSION[\"username\"] = \"hello\" //输出生成的session_id echo session_id(); 访问页面创建session,获取session_id,关闭浏览器; 根据session_id创建session对象 //上面输出的session_id $session_id = \"qpk6onnn3husvotnke030ftcm4\"; session_id($session_id); session_start(); echo $_SESSION[\"username\"]; 结果可以取出 \"hello\" 由此可以看出: 当浏览器关闭时，原session并没有被销毁（destory方法没有执行），而是等到timeout到期，才销毁这个session。关闭浏览器只是在客户端的内存中清除了与原会话相关的cookie，再次打开浏览器进行连接时，浏览器无法发送cookie信息，所以服务器会认为是一个新的会话。因此，如果有某些与session关联的资源想在关闭浏览器时就进行清理（如临时文件等），那么应该发送特定的请求到服务器端，而不是等到session的自动清理。 "},"Js/基础/实用的60个CSS代码片段.html":{"url":"Js/基础/实用的60个CSS代码片段.html","title":"实用的60个CSS代码片段","keywords":"","body":"实用的60个CSS代码片段 实用的60个CSS代码片段 1、垂直对齐 2、伸展一个元素到窗口高度 3、基于文件格式使用不同的样式 4、创建跨浏览器的图像灰度 5、背景渐变动画 6、CSS：表格列宽自适用 7、只在一边或两边显示盒子阴影 8、包裹长文本 9、制造模糊文本 10、用CSS动画实现省略号动画 11、样式重置 12、典型的CSS清除浮动 13、新版清除浮动（2011） 14、跨浏览器的透明 15、CSS引用模板 16、个性圆角 17、通用媒体查询 18、现代字体栈 19、自定义文本选择 20、为logo隐藏H1 21、图片边框偏光 22、锚链接伪类 23、奇特的CSS引用 24、CSS3：全屏背景 25、内容垂直居中 26、强制出现垂直滚动条 27、CSS3渐变模板 28、@font-face模板 29、缝合CSS3元素 30、CSS3 斑马线 31、有趣的& 32、大字段落 33、内部CSS3 盒阴影 34、外部CSS3 盒阴影 35、三角形列表项目符号 36、固定宽度的居中布局 37、CSS3 列文本 38、CSS固定页脚 39、IE6的PNG透明修复 40、跨浏览器设置最小高度 41、CSS3 鲜艳的输入 42、基于文件类型的链接样式 43、强制换行 44、在可点击的项目上强制手型 45、网页顶部盒阴影 46、CSS3对话气泡 47、H1-H5默认样式 48、纯CSS背景噪音 49、持久的列表排序 50、CSS悬浮提示文本 51、深灰色的圆形按钮 52、在可打印的网页中显示URLs 53、禁用移动Webkit的选择高亮 54、CSS3 圆点图案 55、CSS3 方格图案 56、Github的fork色带 57、CSS font属性缩写 58、论文页面的卷曲效果 59、鲜艳的锚链接 60、带CSS3特色的横幅显示 1、垂直对齐 如果你用CSS，则你会有困惑：我该怎么垂直对齐容器中的元素？现在，利用CSS3的Transform，可以很优雅的解决这个困惑： .verticalcenter{ position: relative; top: 50%; -webkit-transform: translateY(-50%); -o-transform: translateY(-50%); transform: translateY(-50%); } 使用这个技巧，从单行文本、段落到box，都会垂直对齐。目前浏览器对Transform的支持是需要关注的， Chrome 4, Opera 10, Safari 3, Firefox 3, and Internet Explorer 9均支持该属性 2、伸展一个元素到窗口高度 在具体场景中，你可能想要将一个元素伸展到窗口高度，基本元素的调整只能调整容器的大小,因此要使一个元素伸展到窗口高度， 我们需要伸展顶层元素：html和body: html, body { height: 100%; } 然后将100%应用到任何元素的高 div { height: 100%; } 3、基于文件格式使用不同的样式 为了更容易知道链接的目标，有时你想让一些链接看起来和其它的不同。下面的片段在文本链接前添加一个图标，对不同的资源使用不同的图标或图片： a[href^=\"http://\"]{ padding-right: 20px; background: url(external.gif) no-repeat center right; } /* emails */ a[href^=\"mailto:\"]{ padding-right: 20px; background: url(email.png) no-repeat center right; } /* pdfs */ a[href$=\".pdf\"]{ padding-right: 20px; background: url(pdf.png) no-repeat center right; } 4、创建跨浏览器的图像灰度 灰度有时看起来简约和优雅，能为网站呈现更深层次的色调。在示例中，我们将对一个SVG图像添加灰度过滤： 为了跨浏览器，会用到filter属性： img { filter: url(filters.svg#grayscale); /* Firefox 3.5+ */ filter: gray; /* IE6-9 */ -webkit-filter: grayscale(1); /* Google Chrome, Safari 6+ & Opera 15+ */ } 5、背景渐变动画 CSS中最具诱惑的一个功能是能添加动画效果，除了渐变，你可以给背景色、透明度、元素大小添加动画。目前，你不能为渐变添加动画，但下面的代码可能有帮助。它通过改变背景位置，让它看起来有动画效果。 button { background-image: linear-gradient(#5187c4, #1c2f45); background-size: auto 200%; background-position: 0 100%; transition: background-position 0.5s; } button:hover { background-position: 0 0; } 6、CSS：表格列宽自适用 对于表格，当谈到调整列宽时，是比较痛苦的。然后，这里有一个可以使用的技巧：给td元素添加white-space: nowrap;能让文本正确的换行 td { white-space: nowrap; } 7、只在一边或两边显示盒子阴影 如果你要一个盒阴影，试试这个技巧，能为任一边添加阴影。为了实现这个，首先定义一个有具体宽高的盒子，然后正确定位:after伪类。实现底边阴影的代码如下 .box-shadow { background-color: #FF8020; width: 160px; height: 90px; margin-top: -45px; margin-left: -80px; position: absolute; top: 50%; left: 50%; } .box-shadow:after { content: \"\"; width: 150px; height: 1px; margin-top: 88px; margin-left: -75px; display: block; position: absolute; left: 50%; z-index: -1; -webkit-box-shadow: 0px 0px 8px 2px #000000; -moz-box-shadow: 0px 0px 8px 2px #000000; box-shadow: 0px 0px 8px 2px #000000; } 8、包裹长文本 如果你碰到一个比自身容器长的文本，这个技巧对你很有用。在这个示例中，默认时，不管容器的宽度，文本都将水平填充。 简单的CSS代码就能在容器中调整文本： pre { white-space: pre-line; word-wrap: break-word; } 效果看起来如下： 9、制造模糊文本 想要让文本模糊？可以使用color透明和text-shadow实现 .blurry-text { color: transparent; text-shadow: 0 0 5px rgba(0,0,0,0.5); } 10、用CSS动画实现省略号动画 这个片段将帮助你制造一个ellipsis的动画，对于简单的加载状态是很有用的，而不用去使用gif图像。 .loading:after { overflow: hidden; display: inline-block; vertical-align: bottom; animation: ellipsis 2s infinite; content: \"\\2026\"; /* ascii code for the ellipsis character */ } @keyframes ellipsis { from { width: 2px; } to { width: 15px; } } 11、样式重置 html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video { margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; outline: none; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } html { height: 101%; } body { font-size: 62.5%; line-height: 1; font-family: Arial, Tahoma, sans-serif; } article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section { display: block; } ol, ul { list-style: none; } blockquote, q { quotes: none; } blockquote:before, blockquote:after, q:before, q:after { content: ''; content: none; } strong { font-weight: bold; } table { border-collapse: collapse; border-spacing: 0; } img { border: 0; max-width: 100%; } p { font-size: 1.2em; line-height: 1.0em; color: #333; } 12、典型的CSS清除浮动 .clearfix:after { content: \".\"; display: block; clear: both; visibility: hidden; line-height: 0; height: 0; } .clearfix { display: inline-block; } html[xmlns] .clearfix { display: block; } * html .clearfix { height: 1%; } 13、新版清除浮动（2011） .clearfix:before, .container:after { content: \"\"; display: table; } .clearfix:after { clear: both; } /* IE 6/7 */ .clearfix { zoom: 1; } 14、跨浏览器的透明 .transparent { filter: alpha(opacity=50); /* internet explorer */ -khtml-opacity: 0.5; /* khtml, old safari */ -moz-opacity: 0.5; /* mozilla, netscape */ opacity: 0.5; /* fx, safari, opera */ } 15、CSS引用模板 blockquote { background: #f9f9f9; border-left: 10px solid #ccc; margin: 1.5em 10px; padding: .5em 10px; quotes: \"\\201C\"\"\\201D\"\"\\2018\"\"\\2019\"; } blockquote:before { color: #ccc; content: open-quote; font-size: 4em; line-height: .1em; margin-right: .25em; vertical-align: -.4em; } blockquote p { display: inline; } 16、个性圆角 #container { -webkit-border-radius: 4px 3px 6px 10px; -moz-border-radius: 4px 3px 6px 10px; -o-border-radius: 4px 3px 6px 10px; border-radius: 4px 3px 6px 10px; } /* alternative syntax broken into each line */ #container { -webkit-border-top-left-radius: 4px; -webkit-border-top-right-radius: 3px; -webkit-border-bottom-right-radius: 6px; -webkit-border-bottom-left-radius: 10px; -moz-border-radius-topleft: 4px; -moz-border-radius-topright: 3px; -moz-border-radius-bottomright: 6px; -moz-border-radius-bottomleft: 10px; } 17、通用媒体查询 /* Smartphones (portrait and landscape) ----------- */ @media only screen and (min-device-width : 320px) and (max-device-width : 480px) { /* Styles */ } /* Smartphones (landscape) ----------- */ @media only screen and (min-width : 321px) { /* Styles */ } /* Smartphones (portrait) ----------- */ @media only screen and (max-width : 320px) { /* Styles */ } /* iPads (portrait and landscape) ----------- */ @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) { /* Styles */ } /* iPads (landscape) ----------- */ @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : landscape) { /* Styles */ } /* iPads (portrait) ----------- */ @media only screen and (min-device-width : 768px) and (max-device-width : 1024px) and (orientation : portrait) { /* Styles */ } /* Desktops and laptops ----------- */ @media only screen and (min-width : 1224px) { /* Styles */ } /* Large screens ----------- */ @media only screen and (min-width : 1824px) { /* Styles */ } /* iPhone 4 ----------- */ @media only screen and (-webkit-min-device-pixel-ratio:1.5), only screen and (min-device-pixel-ratio:1.5) { /* Styles */ } 18、现代字体栈 /* Times New Roman-based serif */ font-family: Cambria, \"Hoefler Text\", Utopia, \"Liberation Serif\", \"Nimbus Roman No9 L Regular\", Times, \"Times New Roman\", serif; /* A modern Georgia-based serif */ font-family: Constantia, \"Lucida Bright\", Lucidabright, \"Lucida Serif\", Lucida, \"DejaVu Serif,\" \"Bitstream Vera Serif\", \"Liberation Serif\", Georgia, serif; /*A more traditional Garamond-based serif */ font-family: \"Palatino Linotype\", Palatino, Palladio, \"URW Palladio L\", \"Book Antiqua\", Baskerville, \"Bookman Old Style\", \"Bitstream Charter\", \"Nimbus Roman No9 L\", Garamond, \"Apple Garamond\", \"ITC Garamond Narrow\", \"New Century Schoolbook\", \"Century Schoolbook\", \"Century Schoolbook L\", Georgia, serif; /*The Helvetica/Arial-based sans serif */ font-family: Frutiger, \"Frutiger Linotype\", Univers, Calibri, \"Gill Sans\", \"Gill Sans MT\", \"Myriad Pro\", Myriad, \"DejaVu Sans Condensed\", \"Liberation Sans\", \"Nimbus Sans L\", Tahoma, Geneva, \"Helvetica Neue\", Helvetica, Arial, sans-serif; /*The Verdana-based sans serif */ font-family: Corbel, \"Lucida Grande\", \"Lucida Sans Unicode\", \"Lucida Sans\", \"DejaVu Sans\", \"Bitstream Vera Sans\", \"Liberation Sans\", Verdana, \"Verdana Ref\", sans-serif; /*The Trebuchet-based sans serif */ font-family: \"Segoe UI\", Candara, \"Bitstream Vera Sans\", \"DejaVu Sans\", \"Bitstream Vera Sans\", \"Trebuchet MS\", Verdana, \"Verdana Ref\", sans-serif; /*The heavier \"Impact\" sans serif */ font-family: Impact, Haettenschweiler, \"Franklin Gothic Bold\", Charcoal, \"Helvetica Inserat\", \"Bitstream Vera Sans Bold\", \"Arial Black\", sans-serif; /*The monospace */ font-family: Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", Monaco, \"Courier New\", Courier, monospace; 19、自定义文本选择 ::selection { background: #e2eae2; } ::-moz-selection { background: #e2eae2; } ::-webkit-selection { background: #e2eae2; } 20、为logo隐藏H1 h1 { text-indent: -9999px; margin: 0 auto; width: 320px; height: 85px; background: transparent url(\"images/logo.png\") no-repeat scroll; } 21、图片边框偏光 img.polaroid { background:#000; /*Change this to a background image or remove*/ border:solid #fff; border-width:6px 6px 20px 6px; box-shadow:1px 1px 5px #333; /* Standard blur at 5px. Increase for more depth */ -webkit-box-shadow:1px 1px 5px #333; -moz-box-shadow:1px 1px 5px #333; height:200px; /*Set to height of your image or desired div*/ width:200px; /*Set to width of your image or desired div*/ } 22、锚链接伪类 a:link { color: blue; } a:visited { color: purple; } a:hover { color: red; } a:active { color: yellow; } 23、奇特的CSS引用 .has-pullquote:before { /* Reset metrics. */ padding: 0; border: none; /* Content */ content: attr(data-pullquote); /* Pull out to the right, modular scale based margins. */ float: right; width: 320px; margin: 12px -140px 24px 36px; /* Baseline correction */ position: relative; top: 5px; /* Typography (30px line-height equals 25% incremental leading) */ font-size: 23px; line-height: 30px; } .pullquote-adelle:before { font-family: \"adelle-1\", \"adelle-2\"; font-weight: 100; top: 10px !important; } .pullquote-helvetica:before { font-family: \"Helvetica Neue\", Arial, sans-serif; font-weight: bold; top: 7px !important; } .pullquote-facit:before { font-family: \"facitweb-1\", \"facitweb-2\", Helvetica, Arial, sans-serif; font-weight: bold; top: 7px !important; } 24、CSS3：全屏背景 html { background: url('images/bg.jpg') no-repeat center center fixed; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size: cover; } 25、内容垂直居中 .container { min-height: 6.5em; display: table-cell; vertical-align: middle; } 26、强制出现垂直滚动条 html { height: 101% } 27、CSS3渐变模板 #colorbox { background: #629721; background-image: -webkit-gradient(linear, left top, left bottom, from(#83b842), to(#629721)); background-image: -webkit-linear-gradient(top, #83b842, #629721); background-image: -moz-linear-gradient(top, #83b842, #629721); background-image: -ms-linear-gradient(top, #83b842, #629721); background-image: -o-linear-gradient(top, #83b842, #629721); background-image: linear-gradient(top, #83b842, #629721); } 28、@font-face模板 @font-face { font-family: 'MyWebFont'; src: url('webfont.eot'); /* IE9 Compat Modes */ src: url('webfont.eot?#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('webfont.woff') format('woff'), /* Modern Browsers */ url('webfont.ttf') format('truetype'), /* Safari, Android, iOS */ url('webfont.svg#svgFontName') format('svg'); /* Legacy iOS */ } body { font-family: 'MyWebFont', Arial, sans-serif; } 29、缝合CSS3元素 p { position:relative; z-index:1; padding: 10px; margin: 10px; font-size: 21px; line-height: 1.3em; color: #fff; background: #ff0030; -webkit-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5); -moz-box-shadow: 0 0 0 4px #ff0030, 2px 1px 4px 4px rgba(10,10,0,.5); box-shadow: 0 0 0 4px #ff0030, 2px 1px 6px 4px rgba(10,10,0,.5); -webkit-border-radius: 3px; -moz-border-radius: 3px; border-radius: 3px; } p:before { content: \"\"; position: absolute; z-index: -1; top: 3px; bottom: 3px; left :3px; right: 3px; border: 2px dashed #fff; } p a { color: #fff; text-decoration:none; } p a:hover, p a:focus, p a:active { text-decoration:underline; } 30、CSS3 斑马线 tbody tr:nth-child(odd) { background-color: #ccc; } 31、有趣的& .amp { font-family: Baskerville, 'Goudy Old Style', Palatino, 'Book Antiqua', serif; font-style: italic; font-weight: normal; } 32、大字段落 p:first-letter{ display: block; margin: 5px 0 0 5px; float: left; color: #ff3366; font-size: 5.4em; font-family: Georgia, Times New Roman, serif; } 33、内部CSS3 盒阴影 #mydiv { -moz-box-shadow: inset 2px 0 4px #000; -webkit-box-shadow: inset 2px 0 4px #000; box-shadow: inset 2px 0 4px #000; } 34、外部CSS3 盒阴影 #mydiv { -webkit-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); -moz-box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); box-shadow: 0 2px 2px -2px rgba(0, 0, 0, 0.52); } 35、三角形列表项目符号 ul { margin: 0.75em 0; padding: 0 1em; list-style: none; } li:before { content: \"\"; border-color: transparent #111; border-style: solid; border-width: 0.35em 0 0.35em 0.45em; display: block; height: 0; width: 0; left: -1em; top: 0.9em; position: relative; } 36、固定宽度的居中布局 #page-wrap { width: 800px; margin: 0 auto; } 37、CSS3 列文本 #columns-3 { text-align: justify; -moz-column-count: 3; -moz-column-gap: 12px; -moz-column-rule: 1px solid #c4c8cc; -webkit-column-count: 3; -webkit-column-gap: 12px; -webkit-column-rule: 1px solid #c4c8cc; } 38、CSS固定页脚 #footer { position: fixed; left: 0px; bottom: 0px; height: 30px; width: 100%; background: #444; } /* IE 6 */ * html #footer { position: absolute; top: expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+'px'); } 39、IE6的PNG透明修复 .bg { width:200px; height:100px; background: url(/folder/yourimage.png) no-repeat; _background:none; _filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='/folder/yourimage.png',sizingMethod='crop'); } /* 1px gif method */ img, .png { position: relative; behavior: expression((this.runtimeStyle.behavior=\"none\")&&(this.pngSet?this.pngSet=true:(this.nodeName == \"IMG\" && this.src.toLowerCase().indexOf('.png')>-1?(this.runtimeStyle.backgroundImage = \"none\", this.runtimeStyle.filter = \"progid:DXImageTransform.Microsoft.AlphaImageLoader(src='\" + this.src + \"', sizingMethod='image')\", this.src = \"images/transparent.gif\"):(this.origBg = this.origBg? this.origBg :this.currentStyle.backgroundImage.toString().replace('url(\"','').replace('\")',''), this.runtimeStyle.filter = \"progid:DXImageTransform.Microsoft.AlphaImageLoader(src='\" + this.origBg + \"', sizingMethod='crop')\", this.runtimeStyle.backgroundImage = \"none\")),this.pngSet=true)); } 40、跨浏览器设置最小高度 #container { min-height: 550px; height: auto !important; height: 550px; } 41、CSS3 鲜艳的输入 input[type=text], textarea { -webkit-transition: all 0.30s ease-in-out; -moz-transition: all 0.30s ease-in-out; -ms-transition: all 0.30s ease-in-out; -o-transition: all 0.30s ease-in-out; outline: none; padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid #ddd; } input[type=text]:focus, textarea:focus { box-shadow: 0 0 5px rgba(81, 203, 238, 1); padding: 3px 0px 3px 3px; margin: 5px 1px 3px 0px; border: 1px solid rgba(81, 203, 238, 1); } 42、基于文件类型的链接样式 /* external links */ a[href^=\"http://\"] { padding-right: 13px; background: url('external.gif') no-repeat center right; } /* emails */ a[href^=\"mailto:\"] { padding-right: 20px; background: url('email.png') no-repeat center right; } /* pdfs */ a[href$=\".pdf\"] { padding-right: 18px; background: url('acrobat.png') no-repeat center right; } 43、强制换行 pre { white-space: pre-wrap; /* css-3 */ white-space: -moz-pre-wrap; /* Mozilla, since 1999 */ white-space: -pre-wrap; /* Opera 4-6 */ white-space: -o-pre-wrap; /* Opera 7 */ word-wrap: break-word; /* Internet Explorer 5.5+ */ } 44、在可点击的项目上强制手型 a[href], input[type='submit'], input[type='image'], label[for], select, button, .pointer { cursor: pointer; } 45、网页顶部盒阴影 body:before { content: \"\"; position: fixed; top: -10px; left: 0; width: 100%; height: 10px; -webkit-box-shadow: 0px 0px 10px rgba(0,0,0,.8); -moz-box-shadow: 0px 0px 10px rgba(0,0,0,.8); box-shadow: 0px 0px 10px rgba(0,0,0,.8); z-index: 100; } 46、CSS3对话气泡 .chat-bubble { background-color: #ededed; border: 2px solid #666; font-size: 35px; line-height: 1.3em; margin: 10px auto; padding: 10px; position: relative; text-align: center; width: 300px; -moz-border-radius: 20px; -webkit-border-radius: 20px; -moz-box-shadow: 0 0 5px #888; -webkit-box-shadow: 0 0 5px #888; font-family: 'Bangers', arial, serif; } .chat-bubble-arrow-border { border-color: #666 transparent transparent transparent; border-style: solid; border-width: 20px; height: 0; width: 0; position: absolute; bottom: -42px; left: 30px; } .chat-bubble-arrow { border-color: #ededed transparent transparent transparent; border-style: solid; border-width: 20px; height: 0; width: 0; position: absolute; bottom: -39px; left: 30px; } 47、H1-H5默认样式 h1,h2,h3,h4,h5{ color: #005a9c; } h1{ font-size: 2.6em; line-height: 2.45em; } h2{ font-size: 2.1em; line-height: 1.9em; } h3{ font-size: 1.8em; line-height: 1.65em; } h4{ font-size: 1.65em; line-height: 1.4em; } h5{ font-size: 1.4em; line-height: 1.25em; } 48、纯CSS背景噪音 body { background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAMAAAAp4XiDAAAAUVBMVEWFhYWDg4N3d3dtbW17e3t1dXWBgYGHh4d5eXlzc3OLi4ubm5uVlZWPj4+NjY19fX2JiYl/f39ra2uRkZGZmZlpaWmXl5dvb29xcXGTk5NnZ2c8TV1mAAAAG3RSTlNAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAvEOwtAAAFVklEQVR4XpWWB67c2BUFb3g557T/hRo9/WUMZHlgr4Bg8Z4qQgQJlHI4A8SzFVrapvmTF9O7dmYRFZ60YiBhJRCgh1FYhiLAmdvX0CzTOpNE77ME0Zty/nWWzchDtiqrmQDeuv3powQ5ta2eN0FY0InkqDD73lT9c9lEzwUNqgFHs9VQce3TVClFCQrSTfOiYkVJQBmpbq2L6iZavPnAPcoU0dSw0SUTqz/GtrGuXfbyyBniKykOWQWGqwwMA7QiYAxi+IlPdqo+hYHnUt5ZPfnsHJyNiDtnpJyayNBkF6cWoYGAMY92U2hXHF/C1M8uP/ZtYdiuj26UdAdQQSXQErwSOMzt/XWRWAz5GuSBIkwG1H3FabJ2OsUOUhGC6tK4EMtJO0ttC6IBD3kM0ve0tJwMdSfjZo+EEISaeTr9P3wYrGjXqyC1krcKdhMpxEnt5JetoulscpyzhXN5FRpuPHvbeQaKxFAEB6EN+cYN6xD7RYGpXpNndMmZgM5Dcs3YSNFDHUo2LGfZuukSWyUYirJAdYbF3MfqEKmjM+I2EfhA94iG3L7uKrR+GdWD73ydlIB+6hgref1QTlmgmbM3/LeX5GI1Ux1RWpgxpLuZ2+I+IjzZ8wqE4nilvQdkUdfhzI5QDWy+kw5Wgg2pGpeEVeCCA7b85BO3F9DzxB3cdqvBzWcmzbyMiqhzuYqtHRVG2y4x+KOlnyqla8AoWWpuBoYRxzXrfKuILl6SfiWCbjxoZJUaCBj1CjH7GIaDbc9kqBY3W/Rgjda1iqQcOJu2WW+76pZC9QG7M00dffe9hNnseupFL53r8F7YHSwJWUKP2q+k7RdsxyOB11n0xtOvnW4irMMFNV4H0uqwS5ExsmP9AxbDTc9JwgneAT5vTiUSm1E7BSflSt3bfa1tv8Di3R8n3Af7MNWzs49hmauE2wP+ttrq+AsWpFG2awvsuOqbipWHgtuvuaAE+A1Z/7gC9hesnr+7wqCwG8c5yAg3AL1fm8T9AZtp/bbJGwl1pNrE7RuOX7PeMRUERVaPpEs+yqeoSmuOlokqw49pgomjLeh7icHNlG19yjs6XXOMedYm5xH2YxpV2tc0Ro2jJfxC50ApuxGob7lMsxfTbeUv07TyYxpeLucEH1gNd4IKH2LAg5TdVhlCafZvpskfncCfx8pOhJzd76bJWeYFnFciwcYfubRc12Ip/ppIhA1/mSZ/RxjFDrJC5xifFjJpY2Xl5zXdguFqYyTR1zSp1Y9p+tktDYYSNflcxI0iyO4TPBdlRcpeqjK/piF5bklq77VSEaA+z8qmJTFzIWiitbnzR794USKBUaT0NTEsVjZqLaFVqJoPN9ODG70IPbfBHKK+/q/AWR0tJzYHRULOa4MP+W/HfGadZUbfw177G7j/OGbIs8TahLyynl4X4RinF793Oz+BU0saXtUHrVBFT/DnA3ctNPoGbs4hRIjTok8i+algT1lTHi4SxFvONKNrgQFAq2/gFnWMXgwffgYMJpiKYkmW3tTg3ZQ9Jq+f8XN+A5eeUKHWvJWJ2sgJ1Sop+wwhqFVijqWaJhwtD8MNlSBeWNNWTa5Z5kPZw5+LbVT99wqTdx29lMUH4OIG/D86ruKEauBjvH5xy6um/Sfj7ei6UUVk4AIl3MyD4MSSTOFgSwsH/QJWaQ5as7ZcmgBZkzjjU1UrQ74ci1gWBCSGHtuV1H2mhSnO3Wp/3fEV5a+4wz//6qy8JxjZsmxxy5+4w9CDNJY09T072iKG0EnOS0arEYgXqYnXcYHwjTtUNAcMelOd4xpkoqiTYICWFq0JSiPfPDQdnt+4/wuqcXY47QILbgAAAABJRU5ErkJggg==); background-color: #0094d0; } 49、持久的列表排序 ol.chapters { list-style: none; margin-left: 0; } ol.chapters > li:before { content: counter(chapter) \". \"; counter-increment: chapter; font-weight: bold; float: left; width: 40px; } ol.chapters li { clear: left; } ol.start { counter-reset: chapter; } ol.continue { counter-reset: chapter 11; } 50、CSS悬浮提示文本 a { border-bottom:1px solid #bbb; color:#666; display:inline-block; position:relative; text-decoration:none; } a:hover, a:focus { color:#36c; } a:active { top:1px; } /* Tooltip styling */ a[data-tooltip]:after { border-top: 8px solid #222; border-top: 8px solid hsla(0,0%,0%,.85); border-left: 8px solid transparent; border-right: 8px solid transparent; content: \"\"; display: none; height: 0; width: 0; left: 25%; position: absolute; } a[data-tooltip]:before { background: #222; background: hsla(0,0%,0%,.85); color: #f6f6f6; content: attr(data-tooltip); display: none; font-family: sans-serif; font-size: 14px; height: 32px; left: 0; line-height: 32px; padding: 0 15px; position: absolute; text-shadow: 0 1px 1px hsla(0,0%,0%,1); white-space: nowrap; -webkit-border-radius: 5px; -moz-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px; } a[data-tooltip]:hover:after { display: block; top: -9px; } a[data-tooltip]:hover:before { display: block; top: -41px; } a[data-tooltip]:active:after { top: -10px; } a[data-tooltip]:active:before { top: -42px; } 51、深灰色的圆形按钮 .graybtn { -moz-box-shadow:inset 0px 1px 0px 0px #ffffff; -webkit-box-shadow:inset 0px 1px 0px 0px #ffffff; box-shadow:inset 0px 1px 0px 0px #ffffff; background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #ffffff), color-stop(1, #d1d1d1) ); background:-moz-linear-gradient( center top, #ffffff 5%, #d1d1d1 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#ffffff', endColorstr='#d1d1d1'); background-color:#ffffff; -moz-border-radius:6px; -webkit-border-radius:6px; border-radius:6px; border:1px solid #dcdcdc; display:inline-block; color:#777777; font-family:arial; font-size:15px; font-weight:bold; padding:6px 24px; text-decoration:none; text-shadow:1px 1px 0px #ffffff; } .graybtn:hover { background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #d1d1d1), color-stop(1, #ffffff) ); background:-moz-linear-gradient( center top, #d1d1d1 5%, #ffffff 100% ); filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#d1d1d1', endColorstr='#ffffff'); background-color:#d1d1d1; } .graybtn:active { position:relative; top:1px; } 52、在可打印的网页中显示URLs @media print { a:after { content: \" [\" attr(href) \"] \"; } } 53、禁用移动Webkit的选择高亮 body { -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } 54、CSS3 圆点图案 body { background: radial-gradient(circle, white 10%, transparent 10%), radial-gradient(circle, white 10%, black 10%) 50px 50px; background-size: 100px 100px; } 55、CSS3 方格图案 body { background-color: white; background-image: linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black), linear-gradient(45deg, black 25%, transparent 25%, transparent 75%, black 75%, black); background-size: 100px 100px; background-position: 0 0, 50px 50px; } 56、Github的fork色带 .ribbon { background-color: #a00; overflow: hidden; /* top left corner */ position: absolute; left: -3em; top: 2.5em; /* 45 deg ccw rotation */ -moz-transform: rotate(-45deg); -webkit-transform: rotate(-45deg); /* shadow */ -moz-box-shadow: 0 0 1em #888; -webkit-box-shadow: 0 0 1em #888; } .ribbon a { border: 1px solid #faa; color: #fff; display: block; font: bold 81.25% 'Helvetiva Neue', Helvetica, Arial, sans-serif; margin: 0.05em 0 0.075em 0; padding: 0.5em 3.5em; text-align: center; text-decoration: none; /* shadow */ text-shadow: 0 0 0.5em #444; } 57、CSS font属性缩写 p { font: italic small-caps bold 1.2em/1.0em Arial, Tahoma, Helvetica; } 58、论文页面的卷曲效果 ul.box { position: relative; z-index: 1; /* prevent shadows falling behind containers with backgrounds */ overflow: hidden; list-style: none; margin: 0; padding: 0; } ul.box li { position: relative; float: left; width: 250px; height: 150px; padding: 0; border: 1px solid #efefef; margin: 0 30px 30px 0; background: #fff; -webkit-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; -moz-box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; box-shadow: 0 1px 4px rgba(0, 0, 0, 0.27), 0 0 40px rgba(0, 0, 0, 0.06) inset; } ul.box li:before, ul.box li:after { content: ''; z-index: -1; position: absolute; left: 10px; bottom: 10px; width: 70%; max-width: 300px; /* avoid rotation causing ugly appearance at large container widths */ max-height: 100px; height: 55%; -webkit-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -moz-box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3); -webkit-transform: skew(-15deg) rotate(-6deg); -moz-transform: skew(-15deg) rotate(-6deg); -ms-transform: skew(-15deg) rotate(-6deg); -o-transform: skew(-15deg) rotate(-6deg); transform: skew(-15deg) rotate(-6deg); } ul.box li:after { left: auto; right: 10px; -webkit-transform: skew(15deg) rotate(6deg); -moz-transform: skew(15deg) rotate(6deg); -ms-transform: skew(15deg) rotate(6deg); -o-transform: skew(15deg) rotate(6deg); transform: skew(15deg) rotate(6deg); } 59、鲜艳的锚链接 a { color: #00e; } a:visited { color: #551a8b; } a:hover { color: #06e; } a:focus { outline: thin dotted; } a:hover, a:active { outline: 0; } a, a:visited, a:active { text-decoration: none; color: #fff; -webkit-transition: all .3s ease-in-out; } a:hover, .glow { color: #ff0; text-shadow: 0 0 10px #ff0; } 60、带CSS3特色的横幅显示 .featureBanner { position: relative; margin: 20px } .featureBanner:before { content: \"Featured\"; position: absolute; top: 5px; left: -8px; padding-right: 10px; color: #232323; font-weight: bold; height: 0px; border: 15px solid #ffa200; border-right-color: transparent; line-height: 0px; box-shadow: -0px 5px 5px -5px #000; z-index: 1; } .featureBanner:after { content: \"\"; position: absolute; top: 35px; left: -8px; border: 4px solid #89540c; border-left-color: transparent; border-bottom-color: transparent; } "},"Js/基础/Jquery事件机制.html":{"url":"Js/基础/Jquery事件机制.html","title":"Jquery事件机制","keywords":"","body":"Jquery事件机制 Jquery事件机制中也会调用原生的注册事件和删除事件，回调函数存储跟React的回调函数存储类似，可以阅读代码，感受一下事件机制的相通之处，源码如下： jQuery.fn.extend( { on: function (types, selector, data, fn) { // on 又依托于全局的 on 函数 return on(this, types, selector, data, fn); } } ); //on函数 function on( elem, types, selector, data, fn, one ) { var origFn, type; // 支持 object 的情况 if ( typeof types === \"object\" ) { // ( types-Object, selector, data ) if ( typeof selector !== \"string\" ) { // ( types-Object, data ) data = data || selector; selector = undefined; } // 一次执行 object 的每一个 for ( type in types ) { on( elem, type, selector, data, types[ type ], one ); } return elem; } // 参数为两个的情况 if ( data == null && fn == null ) { // ( types, fn ) fn = selector; data = selector = undefined; } else if ( fn == null ) { if ( typeof selector === \"string\" ) { // ( types, selector, fn ) fn = data; data = undefined; } else { // ( types, data, fn ) fn = data; data = selector; selector = undefined; } } if ( fn === false ) { // returnFalse 是一个返回 false 的函数 fn = returnFalse; } else if ( !fn ) { return elem; } if ( one === 1 ) { origFn = fn; fn = function( event ) { // Can use an empty set, since event contains the info jQuery().off( event ); return origFn.apply( this, arguments ); }; // Use same guid so caller can remove using origFn fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ ); } return elem.each( function() { // 关键 jQuery.event.add( this, types, fn, data, selector ); } ); } //off函数 jQuery.fn.off = function (types, selector, fn) { var handleObj, type; if (types && types.preventDefault && types.handleObj) { // ( event ) dispatched jQuery.Event handleObj = types.handleObj; jQuery(types.delegateTarget).off( handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler ); return this; } if (typeof types === \"object\") { // ( types-object [, selector] ) for (type in types) { this.off(type, selector, types[type]); } return this; } if (selector === false || typeof selector === \"function\") { // ( types [, fn] ) fn = selector; selector = undefined; } if (fn === false) { fn = returnFalse; } return this.each(function() { // 关键 jQuery.event.remove(this, types, fn, selector); }); } "},"Js/基础/JS开发常用工具函数.html":{"url":"Js/基础/JS开发常用工具函数.html","title":"JS开发常用工具函数","keywords":"","body":"JS 开发常用工具函数 JS 开发常用工具函数 1、isStatic：检测数据是不是除了symbol外的原始数据 2、isPrimitive：检测数据是不是原始数据 3、isObject：判断数据是不是引用类型的数据 (例如： arrays, functions, objects, regexes, new Number(0),以及 new String('')) 4、isObjectLike：检查 value 是否是 类对象。 如果一个值是类对象，那么它不应该是 null，而且 typeof 后的结果是 \"object\" 5、getRawType：获取数据类型，返回结果为 Number、String、Object、Array等 6、isPlainObject：判断数据是不是Object类型的数据 7、isArray：判断数据是不是数组类型的数据 8、isRegExp：判断数据是不是正则对象 9、isDate：判断数据是不是时间对象 10、isNative：判断 value 是不是浏览器内置函数 11、isFunction：检查 value 是不是函数 12、isLength：检查 value 是否为有效的类数组长度 13、isArrayLike：检查 value 是否是类数组 14、isEmpty：检查 value 是否为空 15、cached：记忆函数：缓存函数的运算结果 16、camelize：横线转驼峰命名 17、hyphenate：驼峰命名转横线命名：拆分字符串，使用 - 相连，并且转换为小写 18、capitalize：字符串首位大写 19、extend：将属性混合到目标对象中 20、Object.assign：对象属性复制，浅拷贝 21、clone：克隆数据，可深度克隆 22、识别各种浏览器及平台 23、getExplorerInfo：获取浏览器信息 24、isPCBroswer：检测是否为PC端浏览器模式 25、unique：数组去重，返回一个新数组 26、Set简单实现 27、repeat：生成一个重复的字符串，有n个str组成，可修改为填充为数组等 28、dateFormater：格式化时间 29、dateStrForma：将指定字符串由一种时间格式转化为另一种 30、getPropByPath：根据字符串路径获取对象属性 : 'obj[0].count' 31、GetUrlParam：获取Url参数，返回一个对象 32、downloadFile：base64数据导出文件，文件下载 33、toFullScreen：全屏 34、exitFullscreen：退出全屏 35、requestAnimationFrame：window动画 36、_isNaN：检查数据是否是非数字值 37、max：求取数组中非NaN数据中的最大值 38、min：求取数组中非NaN数据中的最小值 39、random：返回一个lower - upper之间的随机数 40、Object.keys：返回一个由一个给定对象的自身可枚举属性组成的数组 41、Object.values：返回一个给定对象自身的所有可枚举属性值的数组 42、arr.fill：使用 value 值来填充 array，从start位置开始, 到end位置结束（但不包含end位置），返回原数组 43、arr.includes：用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false，可指定开始查询的位置 44、arr.find：返回数组中通过测试（函数fn内判断）的第一个元素的值 45、arr.findIndex ：返回数组中通过测试（函数fn内判断）的第一个元素的下标 46、performance.timing：利用performance.timing进行性能分析 47、禁止某些键盘事件 48、禁止右键、选择、复制 1、isStatic：检测数据是不是除了symbol外的原始数据 function isStatic(value) { return( typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || typeof value === 'undefined' || value === null ) } 2、isPrimitive：检测数据是不是原始数据 function isPrimitive(value) { return isStatic(value) || typeof value === 'symbol' } 3、isObject：判断数据是不是引用类型的数据 (例如： arrays, functions, objects, regexes, new Number(0),以及 new String('')) function isObject(value) { let type = typeof value; return value != null && (type == 'object' || type == 'function'); } 4、isObjectLike：检查 value 是否是 类对象。 如果一个值是类对象，那么它不应该是 null，而且 typeof 后的结果是 \"object\" function isObjectLike(value) { return value != null && typeof value == 'object'; } 5、getRawType：获取数据类型，返回结果为 Number、String、Object、Array等 function getRawType(value) { return Object.prototype.toString.call(value).slice(8, -1) } //getoRawType([]) ==> Array 6、isPlainObject：判断数据是不是Object类型的数据 function isPlainObject(obj) { return Object.prototype.toString.call(obj) === '[object Object]' } 7、isArray：判断数据是不是数组类型的数据 function isArray(arr) { return Object.prototype.toString.call(arr) === '[object Array]' } 将isArray挂载到Array上 Array.isArray = Array.isArray || isArray; 8、isRegExp：判断数据是不是正则对象 function isRegExp(value) { return Object.prototype.toString.call(value) === '[object RegExp]' } 9、isDate：判断数据是不是时间对象 function isDate(value) { return Object.prototype.toString.call(value) === '[object Date]' } 10、isNative：判断 value 是不是浏览器内置函数 内置函数toString后的主体代码块为 [native code] ，而非内置函数则为相关代码，所以非内置函数可以进行拷贝(toString后掐头去尾再由Function转) function isNative(value) { return typeof value === 'function' && /native code/.test(value.toString()) } 11、isFunction：检查 value 是不是函数 function isFunction(value) { return Object.prototype.toString.call(value) === '[object Function]' } 12、isLength：检查 value 是否为有效的类数组长度 function isLength(value) { return typeof value == 'number' && value > -1 && value % 1 == 0 && value 13、isArrayLike：检查 value 是否是类数组 如果一个值被认为是类数组，那么它不是一个函数，并且value.length是个整数，大于等于 0，小于或等于 Number.MAX_SAFE_INTEGER。这里字符串也将被当作类数组。 function isArrayLike(value) { return value != null && isLength(value.length) && !isFunction(value); } 14、isEmpty：检查 value 是否为空 如果是null，直接返回true；如果是类数组，判断数据长度；如果是Object对象，判断是否具有属性；如果是其他数据，直接返回false(也可改为返回true) function isEmpty(value) { if (value == null) { return true; } if (isArrayLike(value)) { return !value.length; }else if(isPlainObject(value)){ for (let key in value) { if (hasOwnProperty.call(value, key)) { return false; } } } return false; } 15、cached：记忆函数：缓存函数的运算结果 function cached(fn) { let cache = Object.create(null); return function cachedFn(str) { let hit = cache[str]; return hit || (cache[str] = fn(str)) } } 16、camelize：横线转驼峰命名 let camelizeRE = /-(\\w)/g; function camelize(str) { return str.replace(camelizeRE, function(_, c) { return c ? c.toUpperCase() : ''; }) } //ab-cd-ef ==> abCdEf //使用记忆函数 let _camelize = cached(camelize) 17、hyphenate：驼峰命名转横线命名：拆分字符串，使用 - 相连，并且转换为小写 let hyphenateRE = /\\B([A-Z])/g; function hyphenate(str){ return str.replace(hyphenateRE, '-$1').toLowerCase() } //abCd ==> ab-cd //使用记忆函数 let _hyphenate = cached(hyphenate); 18、capitalize：字符串首位大写 function capitalize(str){ return str.charAt(0).toUpperCase() + str.slice(1) } // abc ==> Abc //使用记忆函数 let _capitalize = cached(capitalize) 19、extend：将属性混合到目标对象中 function extend(to, _from) { for(let key in _from) { to[key] = _from[key]; } return to } 20、Object.assign：对象属性复制，浅拷贝 Object.assign = Object.assign || function(){ if(arguments.length == 0) throw new TypeError('Cannot convert undefined or null to object'); let target = arguments[0], args = Array.prototype.slice.call(arguments, 1), key args.forEach(function(item){ for(key in item){ item.hasOwnProperty(key) && ( target[key] = item[key] ) } }) return target } 使用Object.assign可以浅克隆一个对象： let clone = Object.assign({}, target) 简单的深克隆可以使用JSON.parse()和JSON.stringify()，这两个api是解析json数据的，所以只能解析除symbol外的原始类型及数组和对象 let clone = JSON.parse( JSON.stringify(target) ) 21、clone：克隆数据，可深度克隆 这里列出了原始类型，时间、正则、错误、数组、对象的克隆规则，其他的可自行补充 function clone(value, deep){ if(isPrimitive(value)){ return value } if (isArrayLike(value)) { //是类数组 value = Array.prototype.slice.call(value) return value.map(item => deep ? clone(item, deep) : item) }else if(isPlainObject(value)){ //是对象 let target = {}, key; for (key in value) { value.hasOwnProperty(key) && ( target[key] = deep ? clone(value[key], deep) : value[key] ) } } let type = getRawType(value) switch(type){ case 'Date': case 'RegExp': case 'Error': value = new window[type](value); break; } return value } 22、识别各种浏览器及平台 //运行环境是浏览器 let inBrowser = typeof window !== 'undefined'; //运行环境是微信 let inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform; let weexPlatform = inWeex && WXEnvironment.platform.toLowerCase(); //浏览器 UA 判断 let UA = inBrowser && window.navigator.userAgent.toLowerCase(); let isIE = UA && /msie|trident/.test(UA); let isIE9 = UA && UA.indexOf('msie 9.0') > 0; let isEdge = UA && UA.indexOf('edge/') > 0; let isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android'); let isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios'); let isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge; 23、getExplorerInfo：获取浏览器信息 function getExplorerInfo() { let t = navigator.userAgent.toLowerCase(); return 0 24、isPCBroswer：检测是否为PC端浏览器模式 function isPCBroswer() { let e = navigator.userAgent.toLowerCase() , t = \"ipad\" == e.match(/ipad/i) , i = \"iphone\" == e.match(/iphone/i) , r = \"midp\" == e.match(/midp/i) , n = \"rv:1.2.3.4\" == e.match(/rv:1.2.3.4/i) , a = \"ucweb\" == e.match(/ucweb/i) , o = \"android\" == e.match(/android/i) , s = \"windows ce\" == e.match(/windows ce/i) , l = \"windows mobile\" == e.match(/windows mobile/i); return !(t || i || r || n || a || o || s || l) } 25、unique：数组去重，返回一个新数组 function unique(arr){ if(!isArrayLink(arr)){ //不是类数组对象 return arr } let result = [] let objarr = [] let obj = Object.create(null) arr.forEach(item => { if(isStatic(item)){//是除了symbol外的原始数据 let key = item + '_' + getRawType(item); if(!obj[key]){ obj[key] = true result.push(item) } }else{//引用类型及symbol if(!objarr.includes(item)){ objarr.push(item) result.push(item) } } }) return resulte } 26、Set简单实现 window.Set = window.Set || (function () { function Set(arr) { this.items = arr ? unique(arr) : []; this.size = this.items.length; // Array的大小 } Set.prototype = { add: function (value) { // 添加元素,若元素已存在,则跳过，返回 Set 结构本身。 if (!this.has(value)) { this.items.push(value); this.size++; } return this; }, clear: function () { //清除所有成员，没有返回值。 this.items = [] this.size = 0 }, delete: function (value) { //删除某个值，返回一个布尔值，表示删除是否成功。 return this.items.some((v, i) => { if(v === value){ this.items.splice(i,1) return true } return false }) }, has: function (value) { //返回一个布尔值，表示该值是否为Set的成员。 return this.items.some(v => v === value) }, values: function () { return this.items }, } return Set; }()); 27、repeat：生成一个重复的字符串，有n个str组成，可修改为填充为数组等 function repeat(str, n) { let res = ''; while(n) { if(n % 2 === 1) { res += str; } if(n > 1) { str += str; } n >>= 1; } return res }; //repeat('123',3) ==> 123123123 28、dateFormater：格式化时间 function dateFormater(formater, t){ let date = t ? new Date(t) : new Date(), Y = date.getFullYear() + '', M = date.getMonth() + 1, D = date.getDate(), H = date.getHours(), m = date.getMinutes(), s = date.getSeconds(); return formater.replace(/YYYY|yyyy/g,Y) .replace(/YY|yy/g,Y.substr(2,2)) .replace(/MM/g,(M 2019-06-26 18:30 // dateFormater('YYYYMMDDHHmm', t) ==> 201906261830 29、dateStrForma：将指定字符串由一种时间格式转化为另一种 from的格式应对应str的位置 function dateStrForma(str, from, to){ //'20190626' 'YYYYMMDD' 'YYYY年MM月DD日' str += '' let Y = '' if(~(Y = from.indexOf('YYYY'))){ Y = str.substr(Y, 4) to = to.replace(/YYYY|yyyy/g,Y) }else if(~(Y = from.indexOf('YY'))){ Y = str.substr(Y, 2) to = to.replace(/YY|yy/g,Y) } let k,i ['M','D','H','h','m','s'].forEach(s =>{ i = from.indexOf(s+s) k = ~i ? str.substr(i, 2) : '' to = to.replace(s+s, k) }) return to } // dateStrForma('20190626', 'YYYYMMDD', 'YYYY年MM月DD日') ==> 2019年06月26日 // dateStrForma('121220190626', '----YYYYMMDD', 'YYYY年MM月DD日') ==> 2019年06月26日 // dateStrForma('2019年06月26日', 'YYYY年MM月DD日', 'YYYYMMDD') ==> 20190626 // 一般的也可以使用正则来实现 //'2019年06月26日'.replace(/(\\d{4})年(\\d{2})月(\\d{2})日/, '$1-$2-$3') ==> 2019-06-26 30、getPropByPath：根据字符串路径获取对象属性 : 'obj[0].count' function getPropByPath(obj, path, strict) { let tempObj = obj; path = path.replace(/\\[(\\w+)\\]/g, '.$1'); //将[0]转化为.0 path = path.replace(/^\\./, ''); //去除开头的. let keyArr = path.split('.'); //根据.切割 let i = 0; for (let len = keyArr.length; i 31、GetUrlParam：获取Url参数，返回一个对象 function GetUrlParam(){ let url = document.location.toString(); let arrObj = url.split(\"?\"); let params = Object.create(null) if (arrObj.length > 1){ arrObj = arrObj[1].split(\"&\"); arrObj.forEach(item=>{ item = item.split(\"=\"); params[item[0]] = item[1] }) } return params; } // ?a=1&b=2&c=3 ==> {a: \"1\", b: \"2\", c: \"3\"} 32、downloadFile：base64数据导出文件，文件下载 function downloadFile(filename, data){ let DownloadLink = document.createElement('a'); if ( DownloadLink ){ document.body.appendChild(DownloadLink); DownloadLink.style = 'display: none'; DownloadLink.download = filename; DownloadLink.href = data; if ( document.createEvent ){ let DownloadEvt = document.createEvent('MouseEvents'); DownloadEvt.initEvent('click', true, false); DownloadLink.dispatchEvent(DownloadEvt); } else if ( document.createEventObject ) DownloadLink.fireEvent('onclick'); else if (typeof DownloadLink.onclick == 'function' ) DownloadLink.onclick(); document.body.removeChild(DownloadLink); } } 33、toFullScreen：全屏 function toFullScreen(){ let elem = document.body; elem.webkitRequestFullScreen ? elem.webkitRequestFullScreen() : elem.mozRequestFullScreen ? elem.mozRequestFullScreen() : elem.msRequestFullscreen ? elem.msRequestFullscreen() : elem.requestFullScreen ? elem.requestFullScreen() : alert(\"浏览器不支持全屏\"); } 34、exitFullscreen：退出全屏 function exitFullscreen(){ let elem = parent.document; elem.webkitCancelFullScreen ? elem.webkitCancelFullScreen() : elem.mozCancelFullScreen ? elem.mozCancelFullScreen() : elem.cancelFullScreen ? elem.cancelFullScreen() : elem.msExitFullscreen ? elem.msExitFullscreen() : elem.exitFullscreen ? elem.exitFullscreen() : alert(\"切换失败,可尝试Esc退出\"); } 35、requestAnimationFrame：window动画 window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (callback) { //为了使setTimteout的尽可能的接近每秒60帧的效果 window.setTimeout(callback, 1000 / 60); }; window.cancelAnimationFrame = window.cancelAnimationFrame || Window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame || function (id) { //为了使setTimteout的尽可能的接近每秒60帧的效果 window.clearTimeout(id); } 36、_isNaN：检查数据是否是非数字值 原生的isNaN会把参数转换成数字(valueof)，而null、true、false以及长度小于等于1的数组(元素为非NaN数据)会被转换成数字，这不是我想要的。Symbol类型的数据不具有valueof接口，所以isNaN会抛出错误，这里放在后面，可避免错误 function _isNaN(v){ return !(typeof v === 'string' || typeof v === 'number') || isNaN(v) } 37、max：求取数组中非NaN数据中的最大值 function max(arr){ arr = arr.filter(item => !_isNaN(item)) return arr.length ? Math.max.apply(null, arr) : undefined } //max([1, 2, '11', null, 'fdf', []]) ==> 11 38、min：求取数组中非NaN数据中的最小值 function min(arr){ arr = arr.filter(item => !_isNaN(item)) return arr.length ? Math.min.apply(null, arr) : undefined } //min([1, 2, '11', null, 'fdf', []]) ==> 1 39、random：返回一个lower - upper之间的随机数 lower、upper无论正负与大小，但必须是非NaN的数据 function random(lower, upper){ lower = +lower || 0 upper = +upper || 0 return Math.random() * (upper - lower) + lower; } //random(0, 0.5) ==> 0.3567039135734613 //random(2, 1) ===> 1.6718418553475423 //random(-2, -1) ==> -1.4474325452361945 40、Object.keys：返回一个由一个给定对象的自身可枚举属性组成的数组 Object.keys = Object.keys || function keys(object) { if(object === null || object === undefined){ throw new TypeError('Cannot convert undefined or null to object'); } let result = [] if(isArrayLike(object) || isPlainObject(object)){ for (let key in object) { object.hasOwnProperty(key) && ( result.push(key) ) } } return result } 41、Object.values：返回一个给定对象自身的所有可枚举属性值的数组 Object.values = Object.values || function values(object) { if(object === null || object === undefined){ throw new TypeError('Cannot convert undefined or null to object'); } let result = [] if(isArrayLike(object) || isPlainObject(object)){ for (let key in object) { object.hasOwnProperty(key) && ( result.push(object[key]) ) } } return result } 42、arr.fill：使用 value 值来填充 array，从start位置开始, 到end位置结束（但不包含end位置），返回原数组 Array.prototype.fill = Array.prototype.fill || function fill(value, start, end) { let ctx = this let length = ctx.length; start = parseInt(start) if(isNaN(start)){ start = 0 }else if (start length ? 0 : (length + start); } end = parseInt(end) if(isNaN(end) || end > length){ end = length }else if (end [2, 2, 2] 43、arr.includes：用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false，可指定开始查询的位置 Array.prototype.includes = Array.prototype.includes || function includes(value, start){ let ctx = this let length = ctx.length; start = parseInt(start) if(isNaN(start)){ start = 0 }else if (start length ? 0 : (length + start); } let index = ctx.indexOf(value) return index >= start; } 44、arr.find：返回数组中通过测试（函数fn内判断）的第一个元素的值 Array.prototype.find = Array.prototype.find || function find(fn, ctx){ ctx = ctx || this let result; ctx.some((value, index, arr), thisValue) => { return fn(value, index, arr) ? (result = value, true) : false }) return result } 45、arr.findIndex ：返回数组中通过测试（函数fn内判断）的第一个元素的下标 Array.prototype.findIndex = Array.prototype.findIndex || function findIndex(fn, ctx){ ctx = ctx || this let result; ctx.some((value, index, arr), thisValue) => { return fn(value, index, arr) ? (result = index, true) : false }) return result } 46、performance.timing：利用performance.timing进行性能分析 window.onload = function(){ setTimeout(function(){ let t = performance.timing console.log('DNS查询耗时 ：' + (t.domainLookupEnd - t.domainLookupStart).toFixed(0)) console.log('TCP链接耗时 ：' + (t.connectEnd - t.connectStart).toFixed(0)) console.log('request请求耗时 ：' + (t.responseEnd - t.responseStart).toFixed(0)) console.log('解析dom树耗时 ：' + (t.domComplete - t.domInteractive).toFixed(0)) console.log('白屏时间 ：' + (t.responseStart - t.navigationStart).toFixed(0)) console.log('domready时间 ：' + (t.domContentLoadedEventEnd - t.navigationStart).toFixed(0)) console.log('onload时间 ：' + (t.loadEventEnd - t.navigationStart).toFixed(0)) if(t = performance.memory){ console.log('js内存使用占比 ：' + (t.usedJSHeapSize / t.totalJSHeapSize * 100).toFixed(2) + '%') } }) } 47、禁止某些键盘事件 document.addEventListener('keydown', function(event){ return !( 112 == event.keyCode || //F1 123 == event.keyCode || //F12 event.ctrlKey && 82 == event.keyCode || //ctrl + R event.ctrlKey && 78 == event.keyCode || //ctrl + N event.shiftKey && 121 == event.keyCode || //shift + F10 event.altKey && 115 == event.keyCode || //alt + F4 \"A\" == event.srcElement.tagName && event.shiftKey //shift + 点击a标签 ) || (event.returnValue = false) }); 48、禁止右键、选择、复制 ['contextmenu', 'selectstart', 'copy'].forEach(function(ev){ document.addEventListener(ev, function(event){ return event.returnValue = false }) }); "},"Node/node基础/node命令.html":{"url":"Node/node基础/node命令.html","title":"node命令","keywords":"","body":"Node 命令 npm 查看全局安装过的包 $ npm list -g --depth 0 $ npm view jquery versions $ npm install jquery@1.11.1 # npm查看包的最新版本 $ npm view versions --json # 查看node安装路径 $ which node nvm包管理器 $ nvm alias default $ nvm alias default 9.5.0 16. Yarn >> Npm $ yarn install == npm install $ yarn add koa || yarn global add koa == npm install koa -g $ yarn list $ yarn info koa == npm view koa $ yarn init == npm init $ yarn run == npm run $ yarn remove [package] == npm uninstall --save [package] && npm uninstall --save-dev [package] && npm uninstall --save-optional [package] $ yarn cache clean == npm cache clean $ yarn upgrade == rm -rf node_modules && npm install $ yarn remove [package] == npm uninstall [package] FTP常用命令 $ ftp 60.205.47.38 $ put file $ get file "},"Node/node基础/搭建一个私有的npm仓库.html":{"url":"Node/node基础/搭建一个私有的npm仓库.html","title":"搭建一个私有的npm仓库","keywords":"","body":"搭建一个私有的npm仓库 搭建一个私有的npm仓库 基于npm我们可以做 如何搭建一个私有npm仓库？ 1. Sinopia方案篇 1.1 服务端部署 1.2 客户端配置 1.3 发包 2. cnpmjs.org 方案篇 2.1 服务端部署 基于npm我们可以做 基于npm我们可以做哪些事情呢？简单来说就是： 一行命令，(批量）安装别人写好的模块 一行命令，卸载安装好的模块 一行命令，更新到最新（或指定版本）的模块 私有npm仓库有如下好处： 便于管理企业内的业务组件或者模块 私密性 确保npm服务快速、稳定 控制npm模块质量和安全（防止恶意代码植入） 如何搭建一个私有npm仓库？ 业界主流的私有npm仓库搭建的主流方案有如下几种： 付费购买 使用 git+ssh 这种方式直接引用到 GitHub 项目地址 使用 Sinopia 使用 cnpmjs.org 第一种，一是考虑到公司可能不会提供经费，二npm在国内访问很慢，就是花钱也买不到好的体验。 第二种，不能更新即 npm update， 不能使用semver（语义化版本规范）。 那么较好的选择就只剩下第三种和第四种。 下面将分别使用基于Sinopia和基于 cnpmjs.org 这两种方案来搭建私有npm仓库并进行总结。 1. Sinopia方案篇 1.1 服务端部署 安装前置工作：配置nodejs及npm环境 npm install -g sinopia 启动 sinopia warn --- config file - /home/map/.config/sinopia/config.yaml warn --- http address - http://localhost:4873/ 此时访问localhost:4873,可获取html文件并且服务端响应正常，表示安装成功。 $ curl localhost:4873 服务端响应 $ sinopia ... http 配置运行sinopia，自动生成的工作目录如下(通过第一个warn可以看到具体路径)： $ tree /home/map/.config/sinopia/ /home/map/.config/sinopia/ |-- config.yaml //存放所有配置信息 |-- htpasswd //存放所有账户信息 `-- storage //存放私有npm包及缓存公有包 |-- npm_test | |-- npm_test-1.0.0.tgz | |-- npm_test-1.0.1.tgz | `-- package.json `-- sinopia `-- package.json 3 directories, 6 files config.yaml默认配置 # This is the default config file. It allows all users to do anything, # so don't use it on production systems. # # Look here for more config file examples: # https://github.com/rlidwka/sinopia/tree/master/conf # path to a directory with all packages storage: ./storage //npm包存放的路径 auth: htpasswd: file: ./htpasswd //保存用户的账号密码等信息 # Maximum amount of users allowed to register, defaults to \"+inf\". # You can set this to -1 to disable registration. #max_users: 1000 //默认为1000，改为-1，禁止注册 # a list of other known repositories we can talk to uplinks: npmjs: url: https://registry.npmjs.org/ //拉取公共包的地址源，默认为npm的官网，可以使用淘宝的npm镜像地址 packages: //配置权限管理 '@*/*': # scoped packages access: $all publish: $authenticated '*': # allow all users (including non-authenticated users) to read and # publish all packages # # you can specify usernames/groupnames (depending on your auth plugin) # and three keywords: \"$all\", \"$anonymous\", \"$authenticated\" access: $all # allow all known users to publish packages # (anyone can register by default, remember?) publish: $authenticated # if package is not available locally, proxy requests to 'npmjs' registry proxy: npmjs # log settings logs: - {type: stdout, format: pretty, level: http} #- {type: file, path: sinopia.log, level: info} 外网访问配置通过在config.yaml中修改服务默认的监听端口，从而可以通过外网访问 sinopia 仓库。 listen: 0.0.0.0:4873 外网通过http://[IP | 域名]:[端口]的形式来访问。 账号配置 config.yaml 中auth部分对应账号的管理，默认可以通过客户端npm adduser添加账号。可以通过max_users:-1禁止客户端创建，而通过我们修改htpasswd文件来管理用户。 htpasswd文件示例： lisi:{SHA}????????????????=:autocreated 2016-02-05T15:39:19.960Z wangwu:{SHA}????????????????=:autocreated 2016-02-05T17:59:05.041Z 密码是被加密过的，是简单的SHA1哈稀之后再转换成 Base64 。 1.2 客户端配置 配置npm registry 建议客户端使用nrm 进行npm registry地址管理和切换 安装 npm install -g nrm 添加sinopia仓库地址 nrm add sinopia http://192.168.xx.xx:4873 切换私有仓库 nrm use sinopia 查看所有仓库地址(星标为当前仓库源) nrm ls npm ---- https://registry.npmjs.org/ cnpm --- http://r.cnpmjs.org/ taobao - https://registry.npm.taobao.org/ nj ----- https://registry.nodejitsu.com/ rednpm - http://registry.mirror.cqupt.edu.cn/ npmMirror https://skimdb.npmjs.com/registry/ edunpm - http://registry.enpmjs.org/ * sinopia http://192.168.xx.xx:4873/ 1.3 发包 切换到私有仓库之后，发包的操作跟npm发包基本无差别。 登录账号之后： npm publish + npm_test@1.0.1 ps: 版本号重复的情况再次发布的包不会主动更新，并且发布不会有错误提示，更新包务必更新版本号。 2. cnpmjs.org 方案篇 2.1 服务端部署 官方依赖如下图： 我这边的配置： 服务器Linux version 3.10.0_1-0-0-8 node v8.9.0 npm v5.5.1 mysql 5.1.73 安装 cnpmjs.org npm i -g cnpmjs.org 修改 cnpmjs.org 配置文件 cnpmjs.org 默认安装路径：/usr/local/lib/node_modules/cnpmjs.org 部分配置项说明 /* * server configure //服务器配置 */ registryPort: 7001, //仓库访问端口（执行发布安装） webPort: 7002, //展示查询站点访问端口 bindingHost: '', //监听绑定的 Host，默认127.0.0.1，外网访问注释掉此项即可 /** * database config //数据库相关设置 */ database: { db: 'cnpmjs', //数据库名称 username: 'root', //数据库访问账号 password: '123456', //数据库访问密码 // the sql dialect of the database // - currently supported: 'mysql', 'sqlite', 'postgres', 'mariadb' dialect: 'mysql', //使用数据库，默认sqlite，这里我们改成mysql // custom host; default: 127.0.0.1 host: '127.0.0.1', //数据库访问IP，通常127.0.0.1 // custom port; default: 3306 port: 3306, //数据库访问端口，通常3306 // 模块文件存储，默认将发布的私有模块跟缓存公共模块存储在本地文件系统中，路径~/.cnpmjs.org/nfs ,也就是模块文件都存储在这个目录下；或者可以选择三方储存方式比如七牛等，着这里配置插件；也支持接口开发扩展储存； nfs: require('fs-cnpm')({ dir: path.join(dataDir, 'nfs') }), // registry url name //模块注册列表访问域名，默认r.cnpmjs.org，安装模块时会到这个域名下查找，这个默认设置略坑，建议没有外网域名的先清空回头再配 registryHost: '', // default system admins //默认管理员账号 admins: { // name: email //fengmk2: 'fengmk2@gmail.com', admin: 'admin@cnpmjs.org', //dead_horse: 'dead_horse@qq.com', }, /* * registry mode config 私有模块发布相关配置 */ //是否开启私有模式，默认为 false； //私有模式下只有管理员能发布模块，其他账号只有同步权限 //非私有模式，注册用户都可以发布模块 enablePrivate: false, // registry scopes //若为非私有模式发布则此项必填，非管理员发布模块式命名必须以scopes字段开头，模块命名示例“@cnpm/packagename” //更多了解npm-scope请查阅https://docs.npmjs.com/misc/scope scopes: [ '@cnpm', '@cnpmtest', '@cnpm-test' ], // 私有模块非scopes白名单，各种非以scope方式发布的老模块的白名单管理，数组形式维护 privatePackages: [], /** * sync configs 同步源仓库相关设置 */ //npm官方registry地址，不会直接从这个地址同步模块，但有时会从这里获取模块信息，除非必要请勿更改 officialNpmRegistry: 'https://registry.npmjs.com', officialNpmReplicate: 'https://replicate.npmjs.com', //同步模块上游registry地址 sourceNpmRegistry: 'https://registry.npm.taobao.org', //上游registry是否是cnpm，默认true，若要使用npm官方地址作为同步上游，请设置为false sourceNpmRegistryIsCNpm: true, //若安装时模块不存在，是否向源registry进行同步，默认true syncByInstall: true, // 同步模式选项 // none: 不进行同步，只管理用户上传的私有模块，公共模块直接从上游获取 // exist: 只同步已经存在于数据库的模块 // all: 定时同步所有源registry的模块 syncModel: 'exist', // 'none', 'all', 'exist' // 同步时间间隔，默认10分钟 syncInterval: '10m', // 是否同步模块中devDependencies，默认false syncDevDependencies: false, //用户账号系统接入，可以扩展接入公司的账号系统 //本文暂不涉及，详见https://github.com/cnpm/cnpmjs.org/wiki/Use-Your-Own-User-Authorization userService: null, //另外一个比较坑的默认设置,默认false，踩坑记录里详细说 enableAbbreviatedMetadata: true, 未完... 原文地址 "},"Node/node基础/AnyProxy.html":{"url":"Node/node基础/AnyProxy.html","title":"AnyProxy","keywords":"","body":"前端使用AnyProxy 业界的代理工具已经不少了，windows有fiddler，mac有charles【收费】，跨平台的有腾讯alloy team出品的liver pool。满足特定功能的民间产品更是层出不穷，如代理线上combo文件的flex-combo，clam中的doji等等。 AnyProxy是阿里巴巴基于 Node.js 开发的一款开源代理服务器。做为中间代理服务器，它可以收集所有经过它的http请求流量（包括https明文内容）；它提供了友好的web界面，便于直观的查看经过它的http请求；同时它支持二次开发，可以用javascript控制整个代理的全部流程，便于前端调试和收集http请求页面内容。它可以用于移动app和移动web页面调试、 抓取。 简介 · AnyProxy：http://anyproxy.io/cn/ github：alibaba/anyproxy 安装和启动AnyProxy： npm install -g anyproxy # 启动 # 命令行启动AnyProxy，默认端口号8001 anyproxy 启动后将终端http代理服务器配置为127.0.0.1:8001即可 访问http://127.0.0.1:8002 ，web界面上能看到所有的请求信息 通过上面命令启动AnyProxy代理监听服务服务后，AnyProxy会打开两个端口： 8001端口：即代理服务端口， 本机的IP和8001用于设置代理，如：127.0.0.1:8001 8002端口：AnyProxy的web界面，通过浏览器打开http://127.0.0.1:8002的形式，即可查看所有经过AnyProxy代理的http请求。 其他命令 配置启动端口，如1080端口启动anyproxy --port 1080 作为npm模块使用 AnyProxy可以作为一个npm模块使用，整合进其他工具。 如要启用https解析，请在代理服务器启动前自行调用AnyProxy.utils.certMgr相关方法生成证书，并引导用户信任安装。或引导用户使用anyproxy-ca方法。 引入 npm i anyproxy --save 使用举例 ```js const AnyProxy = require('anyproxy'); const options = { port: 8001, rule: require('myRuleModule'), webInterface: { enable: true, webPort: 8002, wsPort: 8003, }, throttle: 10000, forceProxyHttps: false, silent: false }; const proxyServer = new AnyProxy.ProxyServer(options); proxyServer.on('ready', () => { / / }); proxyServer.on('error', (e) => { / / }); proxyServer.start(); //when finished proxyServer.close(); ``` "},"Node/node基础/Node进程管理器PM2.html":{"url":"Node/node基础/Node进程管理器PM2.html","title":"Node进程管理器PM2","keywords":"","body":"Node进程管理器PM2 Node进程管理器PM2 使用技巧和需要注意的地方 1、基本指令 2、查看服务进程数 3、 是否需要nginx 4、fork与cluster启动模式 5、pm2的监控 6、日志问题 7、高级用法 8、稳定运行建议 9、自动化部署 使用pm2启动Vue项目 启动项目 常使用命令: pm2官网 pm2 github 使用技巧和需要注意的地方 PM2是一个带有负载均衡功能的Node应用的进程管理器。PM2可以利用服务器上的所有CPU，并保证进程永远都活着，0秒的重载，部署管理多个Node项目。PM2是Node线上部署完美的管理工具。 1、基本指令 npm install pm2 -g ： 全局安装。 pm2 start app.js ： 启动服务，入口文件是app.js。 pm2 start app.js -i [n] --name [name] ： 启动n个进程，名字命名为name。 npm restart [name or id] ： 重启服务。 npm reload [name or id] ： 和rastart功能相同，但是可以实现0s的无缝衔接；如果有nginx的使用经验，可以 对比nginx reload指令。 pm2 start app.js --max_memory_restart 1024M ： # 当内存超过1024M时自动重启。 如果工程中有比较棘手的内 存泄露问题，这个算是一个折中方案。 pm2 monit ： 对服务进行监控。 2、查看服务进程数 至于要启动几个进程，可以通过服务器的内核数进行确定，几个内核就启动几个服务。指令如下： # 查看物理CPU个数 cat /proc/cpuinfo| grep \"physical id\" | sort| uniq | wc -l # 查看每个物理CPU中core的个数(即核数) cat /proc/cpuinfo| grep \"cpu cores\"| uniq # 查看逻辑CPU的个数 cat /proc/cpuinfo| grep \"processor\"| wc -l 当然可以启动多个端口，一个端口号对应一个服务，这样的话就需要nignx来做负载均衡了。 3、 是否需要nginx nginx可以做的事情主要有两个： 反向代理，实现简单的负载均衡： 如果有多台服务器或者一台服务器多个端口，可以考虑用nginx。 静态资源缓存：把一些静态资源（如静态页面，js等资源文件）放到nginx里，可以极大的提高服务的性能。 4、fork与cluster启动模式 开发环境中多以fork的方式启动，生产环境中多用cluster方式启动上面的示例图中可以看一“watching”一项，这个项默认是disabled，可以通过如下命令开启 pm2 start app.js --name m --watch 建议：这个适合在开发时用，可以省不少时间，生产环境下最好不要用 cluster是fork的派生，cluster支持所有cluster拥有的特性； fork不支持socket地址端口复用，cluster支持地址端口复用。因为只有node的cluster模块支持socket选项SO_REUSEADDR； fork不可以启动多个实例进程，cluster可以启动多个实例。但node的child_process.fork是可以实现启动多个进程的，但是为什么没有实现呢？就个人理解，node多为提供网络服务，启动多个实例需要地址端口复用，此时便可使用cluster模式实现，但fork模式并不支持地址端口复用，多实例进程启动会产生异常错误。但对于常驻任务脚本而言，不需要提供网络服务，此时多进程启动可以实现，同时也提高了任务处理效率。对于上述需求，可以两种方式实现，一是配置app0,app1,app2方式启动多个进程，二是通过应用实例自身调用child_process.fork多进程编程实现； fork模式可以应用于其他语言，如php，python，perl，ruby，bash，coffee， 而cluster只能应用于node; fork不支持定时重启，cluster支持定时重启。定时重启也就是配置中的cron_restart配置项。 5、pm2的监控 pm2的监控有两种方式： cli方式监控 pm2 monit是专门用来监控的命令，监控项包括cpu与内存 缺点monit展示内容太过粗糙，不够详细 pm2 list展示当前所有pm2的管理项目 可以查看出每个进程的运行状态。 如果需要更详细的监控内容，对于cli而言一般都是可以实现的。 这种监控方式的缺点： a. 不够直观，需要自己去执行命令并分析结果；b. 不便于多台服务器的应用监控管理； 6、日志问题 日志系统对于任意应用而言，通常都是必不可少的一个辅助功能。pm2的相关文件默认存放于$HOME/.pm2/目录下，其日志主要有两类： pm2自身的日志，存放于$HOME/.pm2/pm2.log； pm2所管理的应用的日志，存放于$HOME/.pm2/logs/目录下，标准谁出日志存放于${APP_NAME}_out.log，标准错误日志存放于${APP_NAME}_error.log； 这里之所以把日志单独说明一下是因为，如果程序开发不严谨，为了调试程序，导致应用产生大量标准输出，使服务器本身记录大量的日志，导致服务磁盘满载问题。一般而言，pm2管理的应用本身都有自己日志系统，所以对于这种不必要的输出内容需禁用日志，重定向到/dev/null。 与crontab比较，也有类似情况，crontab自身日志，与其管理的应用本身的输出。应用脚本输出一定需要重定向到/dev/null，因为该输出内容会以邮件的形式发送给用户，内容存储在邮件文件，会产生意向不到的结果，或会导致脚本压根不被执行； 7、高级用法 pm2支持配置文件启动：pm2 ecosystem： 生成配置文件ecosystem.jsonpm2 startOrRestart /file/path/ecosystem.json : 通过配置文件启动服务 如下是开发时ecosystem.json的内容： { /** * Application configuration section * http://pm2.keymetrics.io/docs/usage/application-declaration/ * 多个服务，依次放到apps对应的数组里 */ apps: [ // First application { name: \"nova\", max_memory_restart: \"300M\", script: \"/root/nova/app.js\", out_file: \"/logs/nova_out.log\", error_file: \"/logs/nova_error.log\", instances: 4, exec_mode: \"cluster\", env: { NODE_ENV: \"production\" } } ]; } 上述采用cluster模式启动了4个服务进程；如果服务占用的内存超过300M，会自动进行重启。 配置项 name 应用进程名称； script 启动脚本路径； cwd 应用启动的路径，关于script与cwd的区别举例说明：在/home/polo/目录下运行/data/release/node/ index.js，此处script为/data/release/node/index.js，cwd为/home/polo/； args 传递给脚本的参数； interpreter 指定的脚本解释器； interpreter_args 传递给解释器的参数； instances 应用启动实例个数，仅在cluster模式有效，默认为fork； exec_mode 应用启动模式，支持fork和cluster模式； watch 监听重启，启用情况下，文件夹或子文件夹下变化应用自动重启； ignore_watch 忽略监听的文件夹，支持正则表达式； max_memory_restart 最大内存限制数，超出自动重启； env 环境变量，object类型，如{\"NODE_ENV\":\"production\", \"ID\": \"42\"}； log_date_format 指定日志日期格式，如YYYY-MM-DD HH:mm:ss； error_file 记录标准错误流，$HOME/.pm2/logs/XXXerr.log)，代码错误可在此文件查找； out_file 记录标准输出流，$HOME/.pm2/logs/XXXout.log)，如应用打印大量的标准输出，会导致pm2日志过大； min_uptime 应用运行少于时间被认为是异常启动； max_restarts 最大异常重启次数，即小于min_uptime运行时间重启次数； autorestart 默认为true, 发生异常的情况下自动重启； cron_restart crontab时间格式重启应用，目前只支持cluster模式； force 默认false，如果true，可以重复启动一个脚本。pm2不建议这么做； restart_delay 异常重启情况下，延时重启时间； 8、稳定运行建议 PM2是一款非常优秀的Node进程管理工具，它有着丰富的特性：能够充分利用多核CPU且能够负载均衡、能够帮助应用在崩溃后、指定时间(cluster model)和超出最大内存限制等情况下实现自动重启。 个人几点看法保证常驻应用进程稳定运行： 定时重启，应用进程运行时间久了或许总会产生一些意料之外的问题，定时可以规避一些不可测的情况； 最大内存限制，根据观察设定合理内存限制，保证应用异常运行； 合理min_uptime，min_uptime是应用正常启动的最小持续运行时长，超出此时间则被判定为异常启动； 设定异常重启延时restart_delay，对于异常情况导致应用停止，设定异常重启延迟可防止应用在不可测情况下不断重启的导致重启次数过多等问题； 设置异常重启次数，如果应用不断异常重启，并超过一定的限制次数，说明此时的环境长时间处于不可控状态，服务器异常。此时便可停止尝试，发出错误警告通知等。 关于pm2的使用，主要还是运用于常驻脚本。 9、自动化部署 通过shell脚本实现资源拉取、服务重启、nginx缓存更新等操作，再配合pm2的监控功能，就初步达到了一个后端工程部署的标配了。 使用pm2启动Vue项目 主要特性： 内建负载均衡（使用Node cluster 集群模块）后台运行0秒停机重载，我理解大概意思是维护升级的时候不需要停机.具有Ubuntu和CentOS 的启动脚本停止不稳定的进程（避免无限循环）控制台检测提供 HTTP API 远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 ) 启动项目 Vue项目,进入项目目录 $ pm2 start build/dev-server.js 列出由pm2管理的所有进程信息,还会显示一个进程会被启动多少次，因为没处理的异常。 $ pm2 list $ pm2 monit # 监视每个node进程的CPU和内存的使用情况 常使用命令: $ pm2 logs 显示所有进程日志 $ pm2 stop all 停止所有进程 $ pm2 restart all 重启所有进程 $ pm2 reload all 0秒停机重载进程 (用于 NETWORKED 进程) $ pm2 stop 0 停止指定的进程 $ pm2 restart 0 重启指定的进程 $ pm2 startup 产生 init 脚本 保持进程活着 $ pm2 web 运行健壮的 computer API endpoint $ pm2 delete 0 杀死指定的进程 $ pm2 delete all 杀死全部进程 用法 # 用法 $ npm install pm2 -g # 命令行安装 pm2 $ pm2 start app.js -i 4 #后台运行pm2，启动4个app.js # 也可以把'max' 参数传递给 start # 正确的进程数目依赖于Cpu的核心数目 $ pm2 start app.js --name my-api # 命名进程 $ pm2 list # 显示所有进程状态 $ pm2 monit # 监视所有进程 $ pm2 logs # 显示所有进程日志 $ pm2 stop all # 停止所有进程 $ pm2 restart all # 重启所有进程 $ pm2 reload all # 0秒停机重载进程 (用于 NETWORKED 进程) $ pm2 stop 0 # 停止指定的进程 $ pm2 restart 0 # 重启指定的进程 $ pm2 startup # 产生 init 脚本 保持进程活着 $ pm2 web # 运行健壮的 computer API endpoint (http://localhost:9615) $ pm2 delete 0 # 杀死指定的进程 $ pm2 delete all # 杀死全部进程 # 运行进程的不同方式： $ pm2 start app.js -i max # 根据有效CPU数目启动最大进程数目 $ pm2 start app.js -i 3 # 启动3个进程 $ pm2 start app.js -x #用fork模式启动 app.js 而不是使用 cluster $ pm2 start app.js -x -- -a 23 # 用fork模式启动 app.js 并且传递参数 (-a 23) $ pm2 start app.js --name serverone # 启动一个进程并把它命名为 serverone $ pm2 stop serverone # 停止 serverone 进程 $ pm2 start app.json # 启动进程, 在 app.json里设置选项 $ pm2 start app.js -i max -- -a 23 #在--之后给 app.js 传递参数 $ pm2 start app.js -i max -e err.log -o out.log # 启动 并 生成一个配置文件 你也可以执行用其他语言编写的app ( fork 模式): $ pm2 start my-bash-script.sh -x --interpreter bash $ pm2 start my-python-script.py -x --interpreter python 0秒停机重载: 这项功能允许你重新载入代码而不用失去请求连接。 注意： 仅能用于web应用 运行于Node 0.11.x版本 运行于 cluster 模式（默认模式） $ pm2 reload all CoffeeScript: $ pm2 start my_app.coffee #这就是全部 PM2准备好为产品级服务了吗？ 只需在你的服务器上测试 $ git clone https://github.com/Unitech/pm2.git $ cd pm2 $ npm install # 或者 npm install --dev ，如果devDependencies 没有安装 $ npm test pm2 list列出由pm2管理的所有进程信息，还会显示一个进程会被启动多少次，因为没处理的异常。 pm2 monit监视每个node进程的CPU和内存的使用情况。 "},"Node/node基础/Path对路径操作的Api.html":{"url":"Node/node基础/Path对路径操作的Api.html","title":"Path对路径操作的Api","keywords":"","body":"理解Path对路径进行操作的API 理解Path对路径进行操作的API 一：理解normalize方法 二：理解dirname方法 三：理解basename方法 四：理解extname方法 五：连接路径 path.join([path1][, path2][, ...]) 六：路径解析：path.resolve([from ...], to) 七： path.join() 和 path.resolve() 对比 一：理解normalize方法 该方法将非标准路径字符串转换为标准路径字符串，在转换过程中执行如下处理： 解析路径字符串中的 '..' 字符串与 '.' 字符串，返回解析后的标准路径。 将多个斜杠字符串转换为一个斜杠字符串，比如将 '\\' 转换为 '\\'。 将windows操作系统中的反斜杠字符串转换为正斜杠字符串。 如果路径字符串以斜杠字符串结尾，则在转换后的完整路径字符串末尾保留该斜杠字符串。 该方法使用如下所示： path.normalize(path); 在该方法中，使用一个参数path，该参数值为需要被转换的路径字符串。该方法返回被转换后的路径字符串。 下面我们在项目中根目录下建立一个a子目录，在a子目录下新建一个b子目录，然后在b子目录下新建一个message.txt， 内容为：我喜欢编写代码，我们将使用normalize方法解析 './/a//b//d//..//c/e//..//'路径字符串，解析该路径后，并且读取message.txt文件的内容，如下代码： const fs = require('fs'); const path = require('path'); const myPath = path.normalize('.//a//b//d//../e//..//'); console.log(myPath); // 输出 a/b/ const file = fs.createReadStream(myPath + 'message.txt'); file.on('data', (data) => { console.log(data.toString()); // 输出 我喜欢编写代码 }); 输出如下所示： node index.js a/b/ 二：理解dirname方法 该方法用于获取一个路径中的目录名，使用方法如下所示： path.dirname(p); 该方法使用一个参数，参数值为一个路径，可以是相对路径、绝对路径、也可以为一个目录的路径、也可以是一个文件的路径。 当参数值为目录的路径时：该方法返回该目录的上层目录。当参数值为文件路径时：该方法返回该文件所在的目录。 请看如下demo： const path = require('path'); // 指定相对目录路径 const a = path.dirname('./a/b/c/d'); console.log(a); // 输出 ./a/b/c // 指定相对文件路径 const b = path.dirname('./a/b/c/d/message.txt'); console.log(b); // 输出 ./a/b/c/d // 指定绝对目录路径 const c = path.dirname('/a/b/c/d'); console.log(c); // 输出 /a/b/c // 指定绝对文件路径 const d = path.dirname('/a/b/c/d/message.txt'); console.log(d); // 输出 /a/b/c/d 三：理解basename方法 该方法用于获取一个路径中的文件名，使用方式如下所示： path.basename(p, [ext]); 在该方法中，使用两个参数，p参数为必须的参数，它必须为一个文件的完整路径，可以是相对路径，也可以是一个绝对路径。ext是可选参数，该参数的作用是在方法返回的文件名中去除该文件的扩展名。请看如下所示的基本代码： const path = require('path'); // 默认返回文件名 index.html const a = path.basename('/a/b/c/d/index.html'); console.log(a); // 输出 index.html // 返回index.html后，去除.html扩展名，因此会返回 index const b = path.basename('./a/b/c/d/index.html', '.html'); console.log(b); // 输出 index // 返回index.html后，去除html的扩展名，因此会返回 index. const c = path.basename('./a/b/c/d/index.html', 'html'); console.log(c); // 输出 index. // 如果扩展名不存在的话，什么都不去除 const d = path.basename('./a/b/c/d/index.html', 'ejx'); console.log(d); // 输出 index.html 四：理解extname方法 该方法用于获取一个路径中的扩展名，使用方法如下所示： path.extname(p); 在该方法中，使用一个参数p，参数p必须为一个文件的完整路径，可以为相对路径，也可以为绝对路径，在该参数值中指定文件的扩展名(以'.'开始)，当参数值中指定的文件没有指定扩展名时，会返回一个空字符串。 比如如下代码： const path = require('path'); const a = path.extname('/a/index.html'); console.log(a); // 输出 '.html' const b = path.extname('/a/index.'); console.log(b); // 输出 '.' const c = path.extname('/a/index'); console.log(c); // 输出 '' 五：连接路径 path.join([path1][, path2][, ...]) 该方法将多个参数值字符串结合为一个路径字符串（连接路径），使用方式如下所示： path.join([path1], [path2], [...]); 在该方法中，使用一个或多个字符串值参数，该方法返回将这些字符串值参数结合而成的路径字符串。 请看如下demo, 在项目的根目录下有 a/b/message.txt, 内容还是为 '我喜欢编写代码'， 请看如下代码： const fs = require('fs'); const path = require('path'); const myPath = path.join(__dirname, 'a', 'b'); console.log(myPath); const file = fs.createReadStream(myPath + '/message.txt'); file.on('data', (data) => { console.log(data.toString()); }); /** * 输出 * __dirname/a/b */ path.join()方法可以连接任意多个路径字符串。要连接的多个路径可做为参数传入。 path.join()方法在接边路径的同时也会对路径进行规范化。例如： const path = require('path'); //合法的字符串连接 path.join('/foo', 'bar', 'baz/asdf', 'quux', '..') // 连接后 '/foo/bar/baz/asdf' //不合法的字符串将抛出异常 path.join('foo', {}, 'bar') // 抛出的异常 TypeError: Arguments to path.join must be strings' 六：路径解析：path.resolve([from ...], to) path.resolve()方法可以将多个路径解析为一个规范化的绝对路径。其处理方式类似于对这些路径逐一进行cd操作，与cd操作不同的是，这引起路径可以是文件，并且可不必实际存在（resolve()方法不会利用底层的文件系统判断路径是否存在，而只是进行路径字符串操作）。例如： path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile') // 相当于 cd foo/bar cd /tmp/file/ cd .. cd a/../subfile pwd 例子： path.resolve('/foo/bar', './baz') // 输出结果为 '/foo/bar/baz' path.resolve('/foo/bar', '/tmp/file/') // 输出结果为 '/tmp/file' path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif') // 当前的工作路径是 /home/itbilu/node，则输出结果为 '/home/itbilu/node/wwwroot/static_files/gif/image.gif' 七： path.join() 和 path.resolve() 对比 const path = require('path'); let myPath = path.join(__dirname,'/img/so'); let myPath2 = path.join(__dirname,'./img/so'); let myPath3 = path.resolve(__dirname,'/img/so'); let myPath4 = path.resolve(__dirname,'./img/so'); console.log(__dirname); //D:\\myProgram\\test console.log(myPath); //D:\\myProgram\\test\\img\\so console.log(myPath2); //D:\\myProgram\\test\\img\\so console.log(myPath3); //D:\\img\\so console.log(myPath4); //D:\\myProgram\\test\\img\\so "},"Node/node基础/node.html":{"url":"Node/node基础/node.html","title":"Node","keywords":"","body":"node 1. npm && package.json npm脚本有pre 和 post 两个钩子 举例来说build 脚本命令的钩子就是prebuild 和 postbuild { \"prebuild\": \"echo I run before the build script\", \"build\": \"cross-env NODE_ENV=production webpack\", \"postbuild\": \"echo I run after the build script\", } 执行npm run build的时候，会自动按照下面的顺序执行 npm run prebuild && npm run build && npm run postbuild 因此，可以在两个钩子里面，完成一些准备工作和清理工作，如 { \"clean\": \"rimraf ./dist && mkdir dist\", \"prebuild\": \"npm run clean\", \"build\": \"cross-env NODE_ENV=production webpack\", } npm 默认提供下面这些钩子。 * prepublish，postpublish * preinstall，postinstall * preuninstall，postuninstall * preversion，postversion * pretest，posttest * prestop，poststop * prestart，poststart * prerestart，postrestart 自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。 npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。 const TARGET = process.env.npm_lifecycle_event; if (TARGET === 'test') { console.log(`Running the test task!`); } if (TARGET === 'pretest') { console.log(`Running the pretest task!`); } if (TARGET === 'posttest') { console.log(`Running the posttest task!`); } 变量 npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。 首先，通过npm_package_前缀，npm 脚本可以拿到package.json里面的字段。比如，下面是一个package.json。 { \"name\": \"foo\", \"version\": \"1.2.5\", \"scripts\": { \"view\": \"node view.js\" } } 那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。 // view.js console.log(process.env.npm_package_name); // foo console.log(process.env.npm_package_version); // 1.2.5 常用脚本示例 // 删除目录 \"clean\": \"rimraf dist/*\", // 本地搭建一个 HTTP 服务 \"serve\": \"http-server -p 9090 dist/\", // 打开浏览器 \"open:dev\": \"opener http://localhost:9090\", // 实时刷新 \"livereload\": \"live-reload --port 9091 dist/\", // 构建 HTML 文件 \"build:html\": \"jade index.jade > dist/index.html\", // 只要 CSS 文件有变动，就重新执行构建 \"watch:css\": \"watch 'npm run build:css' assets/styles/\", // 只要 HTML 文件有变动，就重新执行构建 \"watch:html\": \"watch 'npm run build:html' assets/html\", // 部署到 Amazon S3 \"deploy:prod\": \"s3-cli sync ./dist/ s3://example-com/prod-site/\", // 构建 favicon \"build:favicon\": \"node scripts/favicon.js\", 2. path path.resolve([...paths]) 将路径或路径片段处理成绝对路径。 path 从右到左依次处理，直到构造出绝对路径。 例如，指定的路径片段是：/foo、/bar、baz，则调用 path.resolve('/foo', '/bar', 'baz') 会返回 /bar/baz。 如果处理完全部 path 片段后还未产生绝对路径，则加上当前工作目录。 生成的路径会进行规范化，并且删除末尾的斜杠，除非路径是根目录。 空字符串的 path 片段会被忽略。 如果没有指定 path，则返回当前工作目录的绝对路径。 path.resolve('/foo/bar', './baz'); // 返回: '/foo/bar/baz' path.resolve('/foo/bar', '/tmp/file/'); // 返回: '/tmp/file' path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif'); // 如果当前工作目录是 /home/myself/node，则返回 '/home/myself/node/wwwroot/static_files/gif/image.gif' path.dirname(path) 返回 path 的目录名，类似于 Unix 中的 dirname 命令。 path.dirname('/foo/bar/baz/asdf/quux'); // 返回: '/foo/bar/baz/asdf' path.extname(path) 返回 path 的扩展名，即从 path 的最后一部分中的最后一个 .（句号）字符到字符串结束。 如果 path 的最后一部分没有 . 或 path 的文件名（参见 path.basename()）的第一个字符是 .，则返回空字符串。 path.extname('index.html'); // 返回: '.html' path.extname('index.coffee.md'); // 返回: '.md' path.extname('index.'); // 返回: '.' path.extname('index'); // 返回: '' path.extname('.index'); // 返回: '' path.join([...paths]) 使用平台特定的分隔符把所有 path 片段连接到一起，并规范化生成的路径。 空字符串的 path 片段会被忽略。 如果连接后的路径是一个空字符串，则返回 '.'，表示当前工作目录。 path.join('/foo', 'bar', 'baz/asdf', 'quux', '..'); // 返回: '/foo/bar/baz/asdf' path.join('foo', {}, 'bar'); // 抛出 'TypeError: Path must be a string. Received {}' "},"Node/node基础/babel.html":{"url":"Node/node基础/babel.html","title":"Babel","keywords":"","body":"一口（很长的）气了解 babel 一口（很长的）气了解 babel 引言 babel 到底做了什么？怎么做的？ 使用方法 运行方式和插件 配置文件 preset 执行顺序 插件和 preset 的配置项 env (重点) 其他配套工具 babel-cli babel-node babel-register babel-polyfill babel-runtime 和 babel-plugin-transform-runtime (重点) babel-loader 小结一下 Babel 7.x preset 的变更：淘汰 es201x，删除 stage-x，强推 env (重点) npm package 名称的变化 (重点) 不再支持低版本 node only 和 ignore 匹配规则的变化 @babel/node 从 @babel/cli 中独立了 babel-upgrade 引言 说到 babel，一连串名词会蹦出来： babel-cli babel-core babel-runtime babel-node babel-polyfill ... 这些都是 babel 吗？他们分别是做什么的？有区别吗？ babel 到底做了什么？怎么做的？ 简单来说把 JavaScript 中 es2015/2016/2017/2046 的新语法转化为 es5，让低端运行环境(如浏览器和 node )能够认识并执行。本文以 babel 6.x 为基准进行讨论。最近 babel 出了 7.x，放在最后聊。 严格来说，babel 也可以转化为更低的规范。但以目前情况来说，es5 规范已经足以覆盖绝大部分浏览器，因此常规来说转到 es5 是一个安全且流行的做法。 使用方法 总共存在三种方式： 使用单体文件 (standalone script) 命令行 (cli) 构建工具的插件 (webpack 的 babel-loader, rollup 的 rollup-plugin-babel)。 其中后面两种比较常见。第二种多见于 package.json 中的 scripts 段落中的某条命令；第三种就直接集成到构建工具中。 这三种方式只有入口不同而已，调用的 babel 内核，处理方式都是一样的，所以我们先不纠结入口的问题。 运行方式和插件 babel 总共分为三个阶段：解析，转换，生成。 babel 本身不具有任何转化功能，它把转化的功能都分解到一个个 plugin 里面。因此当我们不配置任何插件时，经过 babel 的代码和输入是相同的。 插件总共分为两种： 当我们添加 语法插件 之后，在解析这一步就使得 babel 能够解析更多的语法。(顺带一提，babel 内部使用的解析类库叫做 babylon，并非 babel 自行开发) 举个简单的例子，当我们定义或者调用方法时，最后一个参数之后是不允许增加逗号的，如 callFoo(param1, param2,) 就是非法的。如果源码是这种写法，经过 babel 之后就会提示语法错误。 但最近的 JS 提案中已经允许了这种新的写法(让代码 diff 更加清晰)。为了避免 babel 报错，就需要增加语法插件 babel-plugin-syntax-trailing-function-commas 当我们添加 转译插件 之后，在转换这一步把源码转换并输出。这也是我们使用 babel 最本质的需求。 比起语法插件，转译插件其实更好理解，比如箭头函数 (a) => a 就会转化为 function (a) {return a}。完成这个工作的插件叫做 babel-plugin-transform-es2015-arrow-functions。 同一类语法可能同时存在语法插件版本和转译插件版本。如果我们使用了转译插件，就不用再使用语法插件了。 配置文件 既然插件是 babel 的根本，那如何使用呢？总共分为 2 个步骤： 将插件的名字增加到配置文件中 (根目录下创建 .babelrc 或者 package.json 的 babel 里面，格式相同) 使用 npm install babel-plugin-xxx 进行安装 具体书写格式就不详述了。 preset 比如 es2015 是一套规范，包含大概十几二十个转译插件。如果每次要开发者一个个添加并安装，配置文件很长不说，npm install 的时间也会很长，更不谈我们可能还要同时使用其他规范呢。 为了解决这个问题，babel 还提供了一组插件的集合。因为常用，所以不必重复定义 & 安装。(单点和套餐的差别，套餐省下了巨多的时间和配置的精力) preset 分为以下几种： 官方内容，目前包括 env, react, flow, minify 等。这里最重要的是 env，后面会详细介绍。 stage-x，这里面包含的都是当年最新规范的草案，每年更新。 这里面还细分为 Stage 0 - 稻草人: 只是一个想法，经过 TC39 成员提出即可。 Stage 1 - 提案: 初步尝试。 Stage 2 - 初稿: 完成初步规范。 Stage 3 - 候选: 完成规范和浏览器初步实现。 Stage 4 - 完成: 将被添加到下一年度发布。 例如 syntax-dynamic-import 就是 stage-2 的内容，transform-object-rest-spread 就是 stage-3 的内容。此外，低一级的 stage 会包含所有高级 stage 的内容，例如 stage-1 会包含 stage-2, stage-3 的所有内容。stage-4 在下一年更新会直接放到 env 中，所以没有单独的 stage-4 可供使用。 es201x, latest 这些是已经纳入到标准规范的语法。例如 es2015 包含 arrow-functions，es2017 包含 syntax-trailing-function-commas。但因为 env 的出现，使得 es2016 和 es2017 都已经废弃。所以我们经常可以看到 es2015 被单独列出来，但极少看到其他两个。 latest 是 env 的雏形，它是一个每年更新的 preset，目的是包含所有 es201x。但也是因为更加灵活的 env 的出现，已经废弃。 执行顺序 很简单的几条原则： Plugin 会运行在 Preset 之前。 Plugin 会从前到后顺序执行。 Preset 的顺序则 刚好相反(从后向前)。 preset 的逆向顺序主要是为了保证向后兼容，因为大多数用户的编写顺序是 ['es2015', 'stage-0']。这样必须先执行 stage-0 才能确保 babel 不报错。因此我们编排 preset 的时候，也要注意顺序，其实只要按照规范的时间顺序列出即可。 插件和 preset 的配置项 简略情况下，插件和 preset 只要列出字符串格式的名字即可。但如果某个 preset 或者插件需要一些配置项(或者说参数)，就需要把自己先变成数组。第一个元素依然是字符串，表示自己的名字；第二个元素是一个对象，即配置对象。 最需要配置的当属 env，如下： \"presets\": [ // 带了配置项，自己变成数组 [ // 第一个元素依然是名字 \"env\", // 第二个元素是对象，列出配置项 { \"module\": false } ], // 不带配置项，直接列出名字 \"stage-2\" ] env (重点) 因为 env 最为常用也最重要，所以我们有必要重点关注。 env 的核心目的是通过配置得知目标环境的特点，然后只做必要的转换。例如目标浏览器支持 es2015，那么 es2015 这个 preset 其实是不需要的，于是代码就可以小一点(一般转化后的代码总是更长)，构建时间也可以缩短一些。 如果不写任何配置项，env 等价于 latest，也等价于 es2015 + es2016 + es2017 三个相加(不包含 stage-x 中的插件)。env 包含的插件列表维护在这里 下面列出几种比较常用的配置方法： { \"presets\": [ [\"env\", { \"targets\": { \"browsers\": [\"last 2 versions\", \"safari >= 7\"] } }] ] } 如上配置将考虑所有浏览器的最新2个版本(safari大于等于7.0的版本)的特性，将必要的代码进行转换。而这些版本已有的功能就不进行转化了。这里的语法可以参考 browserslist { \"presets\": [ [\"env\", { \"targets\": { \"node\": \"6.10\" } }] ] } 如上配置将目标设置为 nodejs，并且支持 6.10 及以上的版本。也可以使用 node: 'current' 来支持最新稳定版本。例如箭头函数在 nodejs 6 及以上将不被转化，但如果是 nodejs 0.12 就会被转化了。 另外一个有用的配置项是 modules。它的取值可以是 amd, umd, systemjs, commonjs 和 false。这可以让 babel 以特定的模块化格式来输出代码。如果选择 false 就不进行模块化处理。 其他配套工具 以上讨论了 babel 的核心处理机制和配置方法等，不论任何入口调用 babel 都走这一套。但文章开头提的那一堆 babel- 还是让人一头雾水。实际上这些 babel- 大多是不同的入口(方式)来使用 babel，下面来简单介绍一下。 babel-cli 顾名思义，cli 就是命令行工具。安装了 babel-cli 就能够在命令行中使用 babel 命令来编译文件。 在开发 npm package 时经常会使用如下模式： 把 babel-cli 安装为 devDependencies 在 package.json 中添加 scripts (比如 prepublish)，使用 babel 命令编译文件 npm publish 这样既可以使用较新规范的 JS 语法编写源码，同时又能支持旧版环境。因为项目可能不太大，用不到构建工具 (webpack 或者 rollup)，于是在发布之前用 babel-cli 进行处理。 babel-node babel-node 是 babel-cli 的一部分，它不需要单独安装。 它的作用是在 node 环境中，直接运行 es2015 的代码，而不需要额外进行转码。例如我们有一个 js 文件以 es2015 的语法进行编写(如使用了箭头函数)。我们可以直接使用 babel-node es2015.js 进行执行，而不用再进行转码了。 可以说：babel-node = babel-polyfill + babel-register。那这两位又是谁呢？ babel-register babel-register 模块改写 require 命令，为它加上一个钩子。此后，每当使用 require 加载 .js、.jsx、.es 和 .es6 后缀名的文件，就会先用 babel 进行转码。 使用时，必须首先加载 require('babel-register')。 需要注意的是，babel-register 只会对 require 命令加载的文件转码，而 不会对当前文件转码。 另外，由于它是实时转码，所以 只适合在开发环境使用。 babel-polyfill babel 默认只转换 js 语法，而不转换新的 API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法(比如 Object.assign)都不会转码。 举例来说，es2015 在 Array 对象上新增了 Array.from 方法。babel 就不会转码这个方法。如果想让这个方法运行，必须使用 babel-polyfill。(内部集成了 core-js 和 regenerator) 使用时，在所有代码运行之前增加 require('babel-polyfill')。或者更常规的操作是在 webpack.config.js 中将 babel-polyfill 作为第一个 entry。因此必须把 babel-polyfill 作为 dependencies 而不是 devDependencies babel-polyfill 主要有两个缺点： 使用 babel-polyfill 会导致打出来的包非常大，因为 babel-polyfill 是一个整体，把所有方法都加到原型链上。比如我们只使用了 Array.from，但它把 Object.defineProperty 也给加上了，这就是一种浪费了。这个问题可以通过单独使用 core-js 的某个类库来解决，core-js 都是分开的。 babel-polyfill 会污染全局变量，给很多类的原型链上都作了修改，如果我们开发的也是一个类库供其他开发者使用，这种情况就会变得非常不可控。 因此在实际使用中，如果我们无法忍受这两个缺点(尤其是第二个)，通常我们会倾向于使用 babel-plugin-transform-runtime。 但如果代码中包含高版本 js 中类型的实例方法 (例如 [1,2,3].includes(1))，这还是要使用 polyfill。 babel-runtime 和 babel-plugin-transform-runtime (重点) 我们时常在项目中看到 .babelrc 中使用 babel-plugin-transform-runtime，而 package.json 中的 dependencies (注意不是 devDependencies) 又包含了 babel-runtime，那这两个是不是成套使用的呢？他们又起什么作用呢？ 先说 babel-plugin-transform-runtime。 babel 会转换 js 语法，之前已经提过了。以 async/await 举例，如果不使用这个 plugin (即默认情况)，转换后的代码大概是： // babel 添加一个方法，把 async 转化为 generator function _asyncToGenerator(fn) { return function () {....}} // 很长很长一段 // 具体使用处 var _ref = _asyncToGenerator(function* (arg1, arg2) { yield (0, something)(arg1, arg2); }); 不用过于纠结具体的语法，只需看到，这个 _asyncToGenerator 在当前文件被定义，然后被使用了，以替换源代码的 await。但每个被转化的文件都会插入一段 _asyncToGenerator 这就导致重复和浪费了。 在使用了 babel-plugin-transform-runtime 了之后，转化后的代码会变成 // 从直接定义改为引用，这样就不会重复定义了。 var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator'); var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2); // 具体使用处是一样的 var _ref = _asyncToGenerator3(function* (arg1, arg2) { yield (0, something)(arg1, arg2); }); 从定义方法改成引用，那重复定义就变成了重复引用，就不存在代码重复的问题了。 但在这里，我们也发现 babel-runtime 出场了，它就是这些方法的集合处，也因此，在使用 babel-plugin-transform-runtime 的时候必须把 babel-runtime 当做依赖。 再说 babel-runtime，它内部集成了 core-js: 转换一些内置类 (Promise, Symbols等等) 和静态方法 (Array.from 等)。绝大部分转换是这里做的。自动引入。 regenerator: 作为 core-js 的拾遗补漏，主要是 generator/yield 和 async/await 两组的支持。当代码中有使用 generators/async 时自动引入。 helpers, 如上面的 asyncToGenerator 就是其中之一，其他还有如 jsx, classCallCheck 等等，可以查看 babel-helpers。在代码中有内置的 helpers 使用时(如上面的第一段代码)移除定义，并插入引用(于是就变成了第二段代码)。 babel-plugin-transform-runtime 不支持 实例方法 (例如 [1,2,3].includes(1)) 此外补充一点，把 helpers 抽离并统一起来，避免重复代码的工作还有一个 plugin 也能做，叫做 babel-plugin-external-helpers。但因为我们使用的 transform-runtime 已经包含了这个功能，因此不必重复使用。而且 babel 的作者们也已经开始讨论这两个插件过于类似，正在讨论在 babel 7 中把 external-helpers 删除，讨论在 issue#5699 中。 babel-loader 前面提过 babel 的三种使用方法，并且已经介绍过了 babel-cli。但一些大型的项目都会有构建工具 (如 webpack 或 rollup) 来进行代码构建和压缩 (uglify)。理论上来说，我们也可以对压缩后的代码进行 babel 处理，但那会非常慢。因此如果在 uglify 之前就加入 babel 处理，岂不完美？ 所以就有了 babel 插入到构建工具内部这样的需求。以(我还算熟悉的) webpack 为例，webpack 有 loader 的概念，因此就出现了 babel-loader。 和 babel-cli 一样，babel-loader 也会读取 .babelrc 或者 package.json 中的 babel 段作为自己的配置，之后的内核处理也是相同。唯一比 babel-cli 复杂的是，它需要和 webpack 交互，因此需要在 webpack 这边进行配置。比较常见的如下： module: { rules: [ { test: /\\.js$/, exclude: /(node_modules|bower_components)/, loader: 'babel-loader' } ] } 如果想在这里传入 babel 的配置项，也可以把改成： // loader: 'babel-loader' 改成如下： use: { loader: 'babel-loader', options: { // 配置项在这里 } } 这里的配置项优先级是最高的。但我认为放到单独的配置文件中更加清晰合理，可读性强一些。 小结一下 Babel 7.x 最近 babel 发布了 7.0。因为上面部分都是针对 6.x 编写的，所以我们关注一下 7.0 带来的变化(核心机制方面没有变化，插件，preset，解析转译生成这些都没有变化) 我只挑选一些和开发者关系比较大的列在这里，省略的多数是针对某一个 plugin 的改动。完整的列表可以参考官网。 preset 的变更：淘汰 es201x，删除 stage-x，强推 env (重点) 淘汰 es201x 的目的是把选择环境的工作交给 env 自动进行，而不需要开发者投入精力。凡是使用 es201x 的开发者，都应当使用 env 进行替换。但这里的淘汰 (原文 deprecated) 并不是删除，只是不推荐使用了，不好说 babel 8 就真的删了。 与之相比，stage-x 就没那么好运了，它们直接被删了。这是因为 babel 团队认为为这些 “不稳定的草案” 花费精力去更新 preset 相当浪费。stage-x 虽然删除了，但它包含的插件并没有删除(只是被更名了，可以看下面一节)，我们依然可以显式地声明这些插件来获得等价的效果。完整列表 为了减少开发者替换配置文件的机械工作，babel 开发了一款 babel-upgrade 的工具，它会检测 babel 配置中的 stage-x 并且替换成对应的 plugins。除此之外它还有其他功能，我们一会儿再详细看。(总之目的就是让你更加平滑地迁移到 babel 7) npm package 名称的变化 (重点) 这是 babel 7 的一个重大变化，把所有 babel-* 重命名为 @babel/*，例如： babel-cli 变成了 @babel/cli。 babel-preset-env 变成了 @babel/preset-env。进一步，还可以省略 preset 而简写为 @babel/env。 babel-plugin-transform-arrow-functions 变成了 @babel/plugin-transform-arrow-functions。和 preset 一样，plugin 也可以省略，于是简写为 @babel/transform-arrow-functions。 这个变化不单单应用于 package.json 的依赖中，包括 .babelrc 的配置 (plugins, presets) 也要这么写，为了保持一致。例如 { \"presets\": [ - \"env\" + \"@babel/preset-env\" ] } 顺带提一句，上面提过的 babel 解析语法的内核 babylon 现在重命名为 @babel/parser，看起来是被收编了。 上文提过的 stage-x 被删除了，它包含的插件虽然保留，但也被重命名了。babel 团队希望更明显地区分已经位于规范中的插件 (如 es2015 的 babel-plugin-transform-arrow-functions) 和仅仅位于草案中的插件 (如 stage-0 的 @babel/plugin-proposal-function-bind)。方式就是在名字中增加 proposal，所有包含在 stage-x 的转译插件都使用了这个前缀，语法插件不在其列。 最后，如果插件名称中包含了规范名称 (-es2015-, -es3- 之类的)，一律删除。例如 babel-plugin-transform-es2015-classes 变成了 @babel/plugin-transform-classes。(这个插件我自己没有单独用过，惭愧) 不再支持低版本 node babel 7.0 开始不再支持 nodejs 0.10, 0.12, 4, 5 这四个版本，相当于要求 nodejs >= 6 (当前 nodejs LTS 是 8，要求也不算太过分吧)。 这里的不再支持，指的是在这些低版本 node 环境中不能使用 babel 转译代码，但 babel 转译后的代码依然能在这些环境上运行，这点不要混淆。 only 和 ignore 匹配规则的变化 在 babel 6 时，ignore 选项如果包含 *.foo.js，实际上的含义 (转化为 glob) 是 ./**/*.foo.js，也就是当前目录 包括子目录 的所有 foo.js 结尾的文件。这可能和开发者常规的认识有悖。 于是在 babel 7，相同的表达式 *.foo.js 只作用于当前目录，不作用于子目录。如果依然想作用于子目录的，就要按照 glob 的完整规范书写为 ./*/.foo.js 才可以。only 也是相同。 这个规则变化只作用于通配符，不作用于路径。所以 node_modules 依然包含所有它的子目录，而不单单只有一层。(否则全世界开发者都要爆炸) @babel/node 从 @babel/cli 中独立了 和 babel 6 不同，如果要使用 @babel/node，就必须单独安装，并添加到依赖中。 babel-upgrade 在提到删除 stage-x 时候提过这个工具，它的目的是帮助用户自动化地从 babel 6 升级到 7。 这款升级工具的功能包括：(这里并不列出完整列表，只列出比较重要和常用的内容) package.json 把依赖(和开发依赖)中所有的 babel- 替换为 @babel/ 把这些 @babel/* 依赖的版本更新为最新版 (例如 ^7.0.0) 如果 scripts 中有使用 babel-node，自动添加 @babel/node 为开发依赖 如果有 babel 配置项，检查其中的 plugins 和 presets，把短名 (env) 替换为完整的名字 (@babel/preset-env) .babelrc 检查其中的 plugins 和 presets，把短名 (env) 替换为完整的名字 (@babel/preset-env) 检查是否包含 preset-stage-x，如有替换为对应的插件并添加到 plugins 使用方式如下： # 不安装到本地而是直接运行命令，npm 的新功能 npx babel-upgrade --write # 或者常规方式 npm i babel-upgrade -g babel-upgrade --write babel-upgrade 工具本身也还在开发中，还列出了许多 TODO 没有完成，因此之后的功能可能会更加丰富，例如上面提过的 ignore 的通配符转化等等。 "},"Node/node基础/mongodb.html":{"url":"Node/node基础/mongodb.html","title":"mongodb","keywords":"","body":"mongodb mongodb 安装 创建数据文件 开机自启动 1. 设置plist文件 查找可执行文件mongod的位置 2. 查找plist配置启动项文件 3. 修改plist配置启动项文件 4. 拷贝plist配置启动项文件 5.启动服务 安装 $ brew update $ brew info mongodb $ brew install mongodb $ mongo --version 启动 mongod —config /usr/local/etc/mongod.conf 连接到MongoDb,可以用命令行工具mongo连接： $ mongo MongoDB shell version: 2.6.5 connecting to: test Welcome to the MongoDB shell. For interactive help, type “help”. For more comprehensive documentation, see http://docs.mongodb.org/ Questions? Try the support group http://groups.google.com/group/mongodb-user 创建数据文件 进入根目录 cd / 创建目录 mkdir -p /data/db 设置权限，并输入用户密码 sudo chmod -R 777 /data 提示：其中-p是创建多个文件目录使用的参数,-R表示对目录进行递归操作，就是data目录下的子文件也设置该权限。 开机自启动 1. 设置plist文件 查找可执行文件mongod的位置 查看安装位置 which mongod 右击Dock中的Finder选中前往文件夹...，输入/usr/local/bin找到这个mongod可执行文件 右击mongod可执行文件，选中显示简介...，可以看到路径例：/usr/local/Cellar/mongodb/3.2.6/bin/mongod 2. 查找plist配置启动项文件 使用homebrew安装mongodb会产生一个启动项配置文件，一般位于mongod可执行文件的上一级bin文件所在的目录文件中。 3. 修改plist配置启动项文件 使用vim或者xcode打开plist配置文件，该文件名可能类似于homebrew.mxcl.mongodb.plist 方便起见，修改文件名为mongodb.plist 修改其中的Label为mongodb,与文件名相同 修改ProgramArguments的可执行进程为可执行文件mongod的位置，例如以上/usr/local/Cellar/mongodb/3.2.6/bin/mongod，可删除ProgramArguments的其余项。 4. 拷贝plist配置启动项文件 cp mongodb.plist /Library/LaunchDaemons/ 提示：mongodb.plist如果不是在当前的文件夹路径下，先进入所在文件夹，注意该目录与~/Library/LaunchDaemons/和/System/Library/LaunchDaemons/的区别。 5.启动服务 使用root权限 sudo -s 启动服务 sudo launchctl load -w /Library/LaunchDaemons/mongodb.plist 关闭服务 sudo launchctl unload -w /Library/LaunchDaemons/mongodb.plist 若发现以下错误： Path had bad permissions 是因为文件的权限不够，将权限修改为root,执行以下命令，再执行启动服务 sudo chown root mongodb.plist 测试数据库是否可启动 使用CMD + N新建一个终端，输入mongo Last login: Tue Jun 7 21:50:28 on ttys001 victor:~ victor$ mongo MongoDB shell version: 3.2.6 connecting to: test > 表明连接成功！如果关机重新启动，仍然可以连接数据库。 提示：如果有RoboMongo等mongdodb可视化工具，在启动服务时可以尝试连接数据库，此时应该可以连接上数据库。 "},"Node/node基础/node-http-proxy解决本地开发ajax跨域问题.html":{"url":"Node/node基础/node-http-proxy解决本地开发ajax跨域问题.html","title":"node-http-proxy解决本地开发ajax跨域问题","keywords":"","body":"Node.js配合node-http-proxy解决本地开发ajax跨域问题 用到的技术： nodejs搭建本地http服务器 应用node-http-proxy，做接口url的转发 具体方法： node.js搭建本地http服务器参考了shawn.xie的《nodejs搭建本地http服务器》 node.js做转发使用node-http-proxy实现，官方文档 操作方法参考了：http://hao.jser.com/archive/10394/?utm_source=tuicool&utm_medium=referral 下面是我自己的实战操作 项目准备 npm初始化npm init 安装node-http-proxy模块npm install http-proxy --save-dev 项目结构 下面的例子中，我们把html文件直接放在根目录'./'，也可以指定一个网站目录，在proxy.js中可以自定义 配置HTTP服务器和PROXY转发 var PORT = 3000; var http = require('http'); var url=require('url'); var fs=require('fs'); var mine=require('./mine').types; var path=require('path'); var httpProxy = require('http-proxy'); var proxy = httpProxy.createProxyServer({ target: 'http://192.168.10.38:8180/', //接口地址 // 下面的设置用于https // ssl: { // key: fs.readFileSync('server_decrypt.key', 'utf8'), // cert: fs.readFileSync('server.crt', 'utf8') // }, // secure: false }); proxy.on('error', function(err, req, res){ res.writeHead(500, { 'content-type': 'text/plain' }); console.log(err); res.end('Something went wrong. And we are reporting a custom error message.'); }); var server = http.createServer(function (request, response) { var pathname = url.parse(request.url).pathname; //var realPath = path.join(\"main-pages\", pathname); // 指定根目录 var realPath = path.join(\"./\", pathname); console.log(pathname); console.log(realPath); var ext = path.extname(realPath); ext = ext ? ext.slice(1) : 'unknown'; //判断如果是接口访问，则通过proxy转发 if(pathname.indexOf(\"mspj-mall-admin\") > 0){ proxy.web(request, response); return; } fs.exists(realPath, function (exists) { if (!exists) { response.writeHead(404, { 'Content-Type': 'text/plain' }); response.write(\"This request URL \" + pathname + \" was not found on this server.\"); response.end(); } else { fs.readFile(realPath, \"binary\", function (err, file) { if (err) { response.writeHead(500, { 'Content-Type': 'text/plain' }); response.end(err); } else { var contentType = mine[ext] || \"text/plain\"; response.writeHead(200, { 'Content-Type': contentType }); response.write(file, \"binary\"); response.end(); } }); } }); }); server.listen(PORT); console.log(\"Server runing at port: \" + PORT + \".\"); MINE.JS 这里参考shawn.xie的源码，补充了几个字体文件的mime。 exports.types = { \"css\": \"text/css\", \"gif\": \"image/gif\", \"html\": \"text/html\", \"ico\": \"image/x-icon\", \"jpeg\": \"image/jpeg\", \"jpg\": \"image/jpeg\", \"js\": \"text/javascript\", \"json\": \"application/json\", \"pdf\": \"application/pdf\", \"png\": \"image/png\", \"svg\": \"image/svg+xml\", \"swf\": \"application/x-shockwave-flash\", \"tiff\": \"image/tiff\", \"txt\": \"text/plain\", \"wav\": \"audio/x-wav\", \"wma\": \"audio/x-ms-wma\", \"wmv\": \"video/x-ms-wmv\", \"xml\": \"text/xml\", \"woff\": \"application/x-woff\", \"woff2\": \"application/x-woff2\", \"tff\": \"application/x-font-truetype\", \"otf\": \"application/x-font-opentype\", \"eot\": \"application/vnd.ms-fontobject\" }; 以上就是全部源码 然后把项目中的接口地址改成http://localhost:3000/...... 启动nodejs服务 启动cmd，定位到项目目录，运行 node proxy.js 访问： http://localhost:3000/index.html 可以看到项目中调用的http://localhost:3000/..... 都会从http://192.168.10.38:8180/...... 获取数据，然后转发到本地。 这样就不存在跨域了。 "},"Js/TypeScript/Typescript.html":{"url":"Js/TypeScript/Typescript.html","title":"TypeScript","keywords":"","body":"react-typescript-cheatsheet react-typescript-cheatsheet 介绍 序 第一章：配置 准备工作 React + Typescript 脚手架 引入 React 第二章：开始 无状态组件 基于 Class 的有状态组件 定义 DefaultProps 提取 Prop Types types 还是 interfaces？ 基本的 Prop Types 例子 有用的 React Type 例子 表单与事件 第三章：高级用法 高阶组件 / render props Context Forwarding References/createRef Portals 错误边界 Timeout/Placeholder/createFetcher 第四章：其他注意事项 写 Typescript 库而不是应用 组件/设计 系统开发 从Flow迁移 Prettier + TSLint ESLint + TSLint 与非Typescript库配合使用 (编辑自己的 index.d.ts) 故障排除手册：Types 联合类型 可选类型 枚举类型 类型断言 交叉类型 忽略类型的属性 Type Zoo 故障排除手册：TSLint 故障排除手册：tsconfig.json 推荐的值得学习的 React+TypeScript 代码库 其他的 React + TypeScript 资源 我想问的问题在这里没有答案！ 介绍 原文地址：sw-yx / react-typescript-cheatsheet 译文地址：[译] react-typescript-备忘录 序 :wave: 本仓库由 @swyx 与 @IslamAttrash 共同维护，我们很高兴看到你想配合 React 来使用 TypeScript， 本文是提供给那些熟悉 TypeScript 概念的 React 开发者，帮助他们编写他们的第一个 React + TypeScript 应用的教程，如果你在阅读的过程中发现任何错误和疏漏， 请提出 issue! 👍 第一章：配置 准备工作 对 React 有一定的了解。 熟悉 Typescript Types。 阅读过 the Typescript section in the official React docs。 (可选) 阅读过微软的 TypeScript-React-Starter 文档。 React + Typescript 脚手架 https://github.com/wmonk/create-react-app-typescript 是官方推荐的 Typescript 的脚手架，fork 自create-react-app。 CodeSandbox 有一个基于 React TypeScript template 的模版项目。 Contributed by: @antmdvs https://github.com/sw-yx/create-react-app-parcel-typescript 使用 Parcel 来建立了一个 React + Typescript 应用 :) https://github.com/basarat/typescript-react/tree/master/01%20bootstrap，手动配置 React + Typescript + Webpack + Babel。 要注意的是，请确保你安装了 @types/react 和 @types/react-dom 。 如果你对有类型定义的项目不熟悉的话点击了解更多。 引入 React import * as React from 'react'; import * as ReactDOM from 'react-dom'; 在 TypeScript 2.7+ 中，你可以将 Typescript 配置 --allowSyntheticDefaultImports （或者在 tsconfig 中添加 \"allowSyntheticDefaultImports\": true ）来像普通的 jsx 一样来引入模块： import React from 'react'; import ReactDOM from 'react-dom'; 解释 为什么不是添加 `esModuleInterop`？ [Daniel Rosenwasser](https://twitter.com/drosenwasser/status/1003097042653073408) 解释说这是为了更好的配合 webpack/parcel. 更多讨论请参见 Please PR or [File an issue](https://github.com/sw-yx/react-typescript-cheatsheet/issues/new) with your suggestions! 第二章：开始 无状态组件 Contributed by: @jasanst and @tpetrina 你可以在将 props 解构的时候指定它们的类型： const App = ({ message }: { message: string }) => {message}; 或者你可以使用 @types/react 提供的无状态组件的通用类型： const App: React.SFC = ({ message }) => {message}; 讨论 前一种模式要简洁一点，那么为什么人们还会使用 `React.SFC` 呢？如果你想在函数体内正确的使用 `children` 的话，在第一种模式下你需要显示的声明它。`SFC` 已经正确的包含了 `children` 属性，所以不需要你再声明它的类型了。 ```tsx const Title: React.SFC = ({ children, title }) => ( {children} ); ``` [Something to add? File an issue](https://github.com/sw-yx/react-typescript-cheatsheet/issues/new). 基于 Class 的有状态组件 在使用 Typescript 时，React.Component 是一个通用类型 （也被写作 React.Component），所以你实际上需要给它提供 prop 和 state（可选）的类型： class App extends React.Component { render() { return ( {this.props.message} ); } } 如果组件有状态，我们如下来给状态添加类型： class App extends React.Component { state = { count: 0 } render() { return ( {this.props.message} {this.state.count} ); } } 如果你想定义一个 clickhandler，那么就像原来一样即可，不过记住函数的参数都需要被定义类型： class App extends React.Component { state = { count: 0 } render() { return ( this.increment(1)}>{this.props.message} {this.state.count} ); } increment = (amt: number) => { // like this this.setState(state => ({ count: state.count + amt })); } } 如果你想先声明一个之后用到的变量，那么声明它的类型即可： class App extends React.Component { pointer: number // like this componentDidMount() { this.pointer = 3; } render() { return ( {this.props.message} and {this.pointer} ); } } Something to add? File an issue. 定义 DefaultProps 定义一个 React 组件的 defaultProps 静态成员变量不难，有很多种方法可以实现，不过我们想展示一种我们最终选择的最优雅的代码方式来实现。 interface IMyComponentProps { firstProp: string; secondProp: IPerson[]; } export class MyComponent extends React.Component { static defaultProps: Partial = { firstProp: \"default\", }; } 解释 这种模式使用了TypeScript 的 `Partial type` 特性，这意味着当前的接口只会实现被包裹的接口的一部分，这样我们可以随意拓展 defaultProps 而不需要改其他任何地方。 另一种方案是定义一个全新的接口，如下： ```ts interface IMyComponentProps { firstProp: string; secondProp: IPerson[]; } interface IMyComponentDefaultProps { firstProp: string; } export class MyComponent extends React.Component { static defaultProps: IMyComponentDefaultProps = { firstProp: \"default\", }; } ``` 这种方式的问题是当我们需要给 defaultProps 添加新的属性的时候，需要给 `IMyComponentDefaultProps` 添加新的属性！ Something to add? File an issue. 提取 Prop Types 相对于内联式的定义 prop types，我们也可以分离的进行声明（这样有更好的可复用性及代码组织） type AppProps = { message: string } const App: React.SFC = ({ message }) => {message}; 你也可以在有状态组件中使用（真的，任何类型都可以）： type AppProps = { // like this message: string, } type AppState = { // and this count: number, } class App extends React.Component { state = { count: 0 } render() { return ( {this.props.message} {this.state.count} ); } } Something to add? File an issue. types 还是 interfaces？ interfaces 和 types 在 Typescript 中是不同的，不过就目前在 React 中使用到的方面来看，他们的作用用法和作用非常相似，这里提供一份何时使用它们的经验法则： 当允许库或第三方开发者定义类型时，要给这些公共的 API 定义使用 interface。 考虑为 React 组件的 Props 和 State 使用 type ，因为它有更多的限制。 你可以在这里阅读更多的使用 types 和 interfaces 的边界用例。注意 Typescript 2.1 之后已经有了很大的变化。 Something to add? File an issue. 基本的 Prop Types 例子 type AppProps = { message: string, count: number, disabled: boolean, names: string[], // array of a type! obj: object, // any object as long as you dont use it in your typescript code obj2: {}, // same object: { id: string, title: string }, // an object with defined properties objects: { id: string, title: string }[], // array of objects! onSomething: Function, // not recommended onClick: () => void, // function that doesn't return anything onChange: (id: number) => void, // function with named prop optional?: OptionalType, // an optional prop } 有用的 React Type 例子 export declare interface AppProps { children1: JSX.Element; // bad children2: JSX.Element | JSX.Element[]; // meh children3: React.ReactChild | React.ReactChildren; // better children: React.ReactNode; // best style?: React.CSSProperties; // for style onChange?: (e: React.FormEvent) => void; // form events! props: Props & React.HTMLProps // to impersonate all the props of a HTML element } Something to add? File an issue. 表单与事件 这里可以耍一下小聪明，因为有编辑器在这里帮了很大的忙，@type 给了我们很多预置的定义，在定义你想定义的类型时自动补全会帮助你完成，这里有一个表单的 onChange 类型定义： class App extends React.Component { state = { text: '' } render() { return ( ); } onChange = (e: React.FormEvent): void => { this.setState({text: e.currentTarget.value}) } } Something to add? File an issue. 第三章：高级用法 高阶组件 / render props 有时你想写一个接受 React 元素或者字符串或者其他的类型的 prop，这种情况下最好的 Type 方式是使用 React.ReactNode，React Node 可以匹配任何合适的类型： import * as React from 'react'; export interface Props { label?: React.ReactNode; children: React.ReactNode; } export const Card = (props: Props) => { return ( {props.label && {props.label}} {props.children} ); }; 如果你使用函数作为渲染的 prop export interface Props { children: (foo: string) => React.ReactNode; } Something to add? File an issue. Context Contributed by: @jpavon 使用新的 context API React.createContext： class Provider extends React.Component { public readonly state = { themeColor: 'red' } private update = ({ key, value }: UpdateStateArg) => { this.setState({ [key]: value }) } public render() { const store: ProviderStore = { state: this.state, update: this.update } return ( {this.props.children} ) } } const Consumer = Context.Consumer Something to add? File an issue. Forwarding References/createRef 使用 React.RefObject： class CssThemeProvider extends React.PureComponent { private rootRef: React.RefObject = React.createRef(); render() { return {this.props.children}; } } Something to add? File an issue. Portals Not written yet. Want to contribute this section? Respond in this issue. 错误边界 Not written yet. Something to add? File an issue. Timeout/Placeholder/createFetcher Not written yet. watch https://github.com/sw-yx/fresh-async-react for more on React Suspense and Time Slicing. Something to add? File an issue. 第四章：其他注意事项 在写 React 的时候我们并不只是在写 React，现在我们还没有关注其他的库，比如 Redux（下面有关于它的内容），这里有一些在写 React + Typescript 应用需要经常注意的事项。 写 Typescript 库而不是应用 看起来 propTypes 对于 Typescript 并不是必要的，尤其是当我们写 React + Typescript 应用时。可是它们在写提供给使用 Javascript 语言的开发者的库时还是有用的。 interface IMyComponentProps { autoHeight: boolean; secondProp: number; } export class MyComponent extends React.Component { static propTypes = { autoHeight: PropTypes.bool, secondProp: PropTypes.number.isRequired, }; } Something to add? File an issue. 组件/设计 系统开发 对于使用 Storybook 的开发者，请阅读我维护的文档：https://storybook.js.org/configurations/typescript-config/. 包括自动化的 proptype 文档生成，棒极了 :) Something to add? File an issue. 从Flow迁移 你也许想使用 https://github.com/piotrwitek/utility-types。如果你在这方面有好的建议，请提出 PR！ Something to add? File an issue. Prettier + TSLint Contributed by: @azdanov 要想配合 Prettier 使用 TSLint，你需要 tslint-config-prettier ，它禁止了所有冲突的规则，你也可以选择 tslint-plugin-prettier，它高亮了所有 TSLint 指出的不同之处。 配置样例： tslint.json .prettierrc { \"rulesDirectory\": [\"tslint-plugin-prettier\"], \"extends\": [ \"tslint:recommended\", \"tslint-config-prettier\" ], \"linterOptions\": { \"exclude\": [\"node_modules/**/*.ts\"] }, \"rules\": { \"prettier\": true } } { \"printWidth\": 89, \"tabWidth\": 2, \"useTabs\": false, \"semi\": true, \"singleQuote\": true, \"trailingComma\": \"all\", \"bracketSpacing\": true, \"jsxBracketSameLine\": false } 这是一个展示如何集成的项目的 github 仓库的地址： prettier + tslint + create-react-app-ts. ESLint + TSLint 为什么？ESLint 有着非常丰富的生态，各种插件还有配置文件，这些都是 TSLint 所欠缺的。 eslint-typescript-parser 可以补救这些缺陷，它试图连接 Javascript 和 Typescript 之前的不同，尽管它目前还有一些不完善的地方，但是在一些插件的帮配合下已经可以稳定地提供帮助了。 Usage .eslintrc // Install: npm i -D typescript-eslint-parser // And in your ESLint configuration file: \"parser\": \"typescript-eslint-parser\" { \"extends\": [ \"airbnb\", \"prettier\", \"prettier/react\", \"plugin:prettier/recommended\", \"plugin:jest/recommended\", \"plugin:unicorn/recommended\" ], \"plugins\": [\"prettier\", \"jest\", \"unicorn\"], \"parserOptions\": { \"sourceType\": \"module\", \"ecmaFeatures\": { \"jsx\": true } }, \"env\": { \"es6\": true, \"browser\": true, \"jest\": true }, \"settings\": { \"import/resolver\": { \"node\": { \"extensions\": [\".js\", \".jsx\", \".ts\", \".tsx\"] } } }, \"overrides\": [ { \"files\": [\"**/*.ts\", \"**/*.tsx\"], \"parser\": \"typescript-eslint-parser\", \"rules\": { \"no-undef\": \"off\" } } ] } 这是一个展示如何集成的项目的 github 仓库的地址：eslint + tslint + create-react-app-ts. 与非Typescript库配合使用 (编辑自己的 index.d.ts) Not written yet. Please contribute on this topic! We have an ongoing issue here with some references. 故障排除手册：Types 你是否还在面对奇奇怪怪的错误提示？你不是一个人遇到这种事。这是 Typescript 配合 React 使用时最糟糕的地方，尽量避免使用 any 来尽可能多的获得来自 Typescript 的帮助。在这里，我们试着熟悉一些经常使用到的策略来解决这些问题。 联合类型 联合类型在解决这些类型问题时非常好用： class App extends React.Component { state = { count: null } render() { return ( this.increment(1)}>{this.state.count} ); } increment = (amt: number) => { this.setState(state => ({ count: (state.count || 0) + amt })); } } 解释 This is not yet written. Please PR or [File an issue](https://github.com/sw-yx/react-typescript-cheatsheet/issues/new) with your suggestions! 可选类型 如果一个组件有可选 prop，增加一个问号标记然后在解构的时候赋值（或者使用 defaultProps）。 class MyComponent extends React.Component { render() { const {message = 'default'} = this.props; return ( {message} ); } } 你也可以使用 ! 来断言某些变量没有被定义，不过并不推荐这样做。 解释 This is not yet written. Please PR or [File an issue](https://github.com/sw-yx/react-typescript-cheatsheet/issues/new) with your suggestions! 枚举类型 Typescript 中的枚举默认是数字类型，不过你总会更倾向于使用字符串。 export enum ButtonSizes { default = 'default', small = 'small', large = 'large' } 用法： export const PrimaryButton = ( props: Props & React.HTMLProps ) => ( ); 还有一种更简单的方案来做到枚举 —— 联合声明一串字符串，不过这样做不会有自动补全和语法的好处： export declare type Position = 'left' | 'right' | 'top' | 'bottom'; 解释 枚举类型的好处是当你对 props 传入了错误的字符串那么 TypeScript 将会报错。 类型断言 有的时候 TypeScript 会判断错变量的类型，或者联合类型需要被断言为一个更加具体的类型才能配合其他 API 工作，这时候需要使用 as 进行类型断言。as 告诉编译器你比它更懂类型。 class MyComponent extends React.Component { render() { const {message} = this.props; return ( {message} ); } } 解释 注意这 [与 casting 是不一样的](https://www.reddit.com/r/reactjs/comments/8o5owb/react_typescript_cheatsheet_for_react_users_using/e01d2md/?context=3). Something to add? Please PR or [File an issue](https://github.com/sw-yx/react-typescript-cheatsheet/issues/new) with your suggestions! 交叉类型 将两种类型融合在一起 export interface Props { label: string; } export const PrimaryButton = ( props: Props & React.HTMLProps // adding my Props together with the @types/react button provided props ) => ( ); 忽略类型的属性 当交叉类型的时候，有时我们想定义我们自己的属性。举个例子，我想让我的组件有一个我们自定义的 label prop，可是交叉后的类型后已经有了一个 label 属性，接下来展示如何将交叉类型中的 label 抽离出来： export interface Props { label: React.ReactNode // this will conflict with the InputElement's label } // here is the magic - omitting an attribute type Diff = ({ [P in T]: P } & { [P in U]: never } & { [x: string]: never })[T]; type Omit = Pick>; // end of magic // usage export const Checkbox = ( props: Props & Omit, 'label'> ) => { const { label } = props; return ( {label} ); }; Explanation This is not yet written. Please PR or [File an issue](https://github.com/sw-yx/react-typescript-cheatsheet/issues/new) with your suggestions! Type Zoo 正如你上面看到的 Omit 的例子，你可以在你的代码中写出很炫酷的逻辑。 你也许想了解一下 type-zoo，它是一个很棒的操作工具包（包括 Omit），utility-types 也是（尤其是给那些从 Flow 迁移过来的开发者）。 故障排除手册：TSLint 有时候 TSLint 会产生阻碍，明智的选择是将它们关闭。接下来是一些你可能禁用的 TSLint 规则： /* tslint:disable */ 全部禁止 // tslint:disable-line 某一行代码禁止规则检查 /* tslint:disable:semicolon */ 有的时候 Prettier 会添加分号但是 TSLint 并不认可 /* tslint:disable:no-any */ 当你想使用 any 的时候，禁止掉 TSLint 限制使用 any 的规则 /* tslint:disable:max-line-length */ 禁止掉折行规则 诸如以上这些等等，你可以随意禁止掉任何规则，通常你会根据 VSCode 或其他编辑器提示的错误信息的对应规则来决定。 解释 This is not yet written. Please PR or [File an issue](https://github.com/sw-yx/react-typescript-cheatsheet/issues/new) with your suggestions! 故障排除手册：tsconfig.json 这是我的电脑上的配置： { \"compilerOptions\": { \"outDir\": \"build/lib\", \"module\": \"commonjs\", \"target\": \"es5\", \"lib\": [\"es5\", \"es6\", \"es7\", \"es2017\", \"dom\"], \"sourceMap\": true, \"allowJs\": false, \"jsx\": \"react\", \"moduleResolution\": \"node\", \"rootDir\": \"src\", \"baseUrl\": \"src\", \"forceConsistentCasingInFileNames\": true, \"noImplicitReturns\": true, \"noImplicitThis\": true, \"noImplicitAny\": true, \"strictNullChecks\": true, \"suppressImplicitAnyIndexErrors\": true, \"noUnusedLocals\": true, \"declaration\": true, \"allowSyntheticDefaultImports\": true, \"experimentalDecorators\": true }, \"include\": [\"src/**/*\"], \"exclude\": [\"node_modules\", \"build\", \"scripts\"] } 欢迎提出 issue 来和我讨论更好的配置选择，我喜欢使用 noImplicitAny 来强制我设定类型。 Explanation This is not yet written. Please PR or [File an issue](https://github.com/sw-yx/react-typescript-cheatsheet/issues/new) with your suggestions! 推荐的值得学习的 React+TypeScript 代码库 https://github.com/jaredpalmer/formik https://github.com/jaredpalmer/react-fns https://github.com/palantir/blueprint https://github.com/Shopify/polaris 解释 This is not yet written. Please PR or [File an issue](https://github.com/sw-yx/react-typescript-cheatsheet/issues/new) with your suggestions! 其他的 React + TypeScript 资源 我！ https://twitter.com/swyx https://github.com/piotrwitek/react-redux-typescript-guide - 强烈推荐，在我写这篇文章之前我还不知道这个仓库，这个仓库涵盖了很多本文没有讲到的东西，包括 Redux 和 Jest。 Ultimate React Component Patterns with Typescript 2.8 Basarat's Typescript gitbook has a React section 来自 Egghead.io 的教程。 Charles Bryant's gitbook 维护了两年的项目，更加偏基础但是有简要的代码和 IDE 的建议。 You?. 我想问的问题在这里没有答案！ File an issue. "},"Js/TypeScript/TypeScript2.8下的终极React组件模式.html":{"url":"Js/TypeScript/TypeScript2.8下的终极React组件模式.html","title":"TypeScript2.8下的终极React组件模式","keywords":"","body":"TypeScript 2.8下的终极React组件模式 TypeScript 2.8下的终极React组件模式 有状态组件、无状态组件、默认属性、Render回调、组件注入、泛型组件、高阶组件、受控组件 准备开始 无状态组件 有状态组件 例子：编译时的State类型安全 整个容器组件/有状态组件的实现： 默认属性 render回调/render属性模式 组件注入 泛型组件 高阶组件 受控组件 总结 有状态组件、无状态组件、默认属性、Render回调、组件注入、泛型组件、高阶组件、受控组件 如果你了解我，你就已经知道我不编写没有类型定义的javascript代码，所以我从0.9版本后，就非常喜欢TypeScript了。除了有类型的JS，我也非常喜欢React库，所以当把React和Typescript 结合在一起后，对我来说就像置身天堂一样:)。整个应用程序和虚拟DOM中的完整的类型安全，是非常奇妙和开心的。 所以这篇文章说是关于什么的呢？在互联网上有各种关于React组件模式的文章，但没有介绍如何将这些模式应用到Typescript中。此外，即将发布的TS 2.8版本带来了另人兴奋的新功能如、如有条件的类型(conditional types)、标准库中新预定义的条件类型、同态映射类型修饰符等等，这些新功能是我们能够以类型安全的方式轻松地创建常见的React组件模式。 这篇文章篇幅会比较长，所以请你坐下放轻松，与此同时你将掌握Typescript下的 终极React组件模式。 所有的模式/例子均使用typescript 2.8版本和strict mode 准备开始 首先，我们需要安装typescript和tslibs帮助程序库，以便我们生出的代码更小 yarn add -D typescript@next # tslib 将仅用与您的编译目标不支持的功能 yarn add tslib 有了这个，我们可以初始化我们的typescript配置： # 这条命令将在我们的工程中创建默认配置 tsconfig.json yarn tsc --init 现在我们来安装 react、react-dom 和它们的类型定义。 yarn add react react-dom yarn add -D @types/{react,react-dom} 棒极啦！现在我们可以开始进入我们的组件模式吧，不是吗？ 无状态组件 你猜到了，这些是没有state的组件(也被称为展示型组件)。在部分时候，它们也是纯函数组件。让我们用TypeScript创建人造的无状态Button组件。 同使用原生JS一样，我们需要引入React以便我们可以使用JSX import React from 'react' const Button = ({ onClick: handleClick, children }) => ( {children} ) 虽然 tsc 编译器现在还会跑出错误！我们需要显式的告诉我们的组件/函数我们的props是什么类型的。让我们定义我们的 props： import React, { MouseEvent, ReactNode } from 'react' type Props = { onClick(e: MouseEvent): void children?: ReactNode } const Button = ({ onClick: handleClick, children }: Props) => ( {children} ) 现在我们已经解决了所有的错误了！非常好！但我们还可以做的更好！ 在@types/react中已经预定义一个类型type SFC，它也是类型interface StatelessComponent的一个别名，此外，它已经有预定义的children和其他（defaultProps、displayName等等…），所以我们不用每次都自己编写！ 所以最后的无状态组件是这样的： import React, { MouseEvent, SFC } from 'react'; type Props = { onClick(e: MouseEvent): void }; const Button: SFC = ({ onClick: handleClick, children }) => ( {children} ); 有状态组件 让我们使用我们的Button组件来创建有状态的计数器组件。 首先我们需要定义initialState const initialState = { clicksCount: 0 } 现在我们将使用TypeScript来从我们的实现中推断出State的类型。 这样我们不需要分开维护我们的类型定义和实现，我们只有唯一的真相源，即我们的实现，太好了！ type State = Readonly 另外请注意，该类型被明确映射为使所有的属性均为只读的。我们需要再次使用State类型来显式地在我们的class上定义只读的state属性。 readonly state: State = initialState 这么做的作用是什么？ 我们知道我们在React中不能像下面这样直接更新state： this.state.clicksCount = 2; this.state = { clicksCount: 2 } 这将导致运行时错误，但在编译时不会报错。通过显式地使用Readonly映射我们的type State，和在我们的类定义中设置只读的state属性，TS将会让我们立刻知道我们做错了。 例子：编译时的State类型安全 整个容器组件/有状态组件的实现： 我们的容器组件还没有任何Props API，所以我们需要将Compoent组件的第一个泛型参数定义为Object（因为在React中props永远是对象{}），并使用State类型作为第二个泛型参数。 import React, { Component } from 'react'; import Button from './Button'; const initialState = { clicksCount: 0 }; type State = Readonly; class ButtonCounter extends Component { readonly state: State = initialState; render() { const { clicksCount } = this.state; return ( <> Increment Decrement You've clicked me {clicksCount} times! ); } private handleIncrement = () => this.setState(incrementClicksCount); private handleDecrement = () => this.setState(decrementClicksCount); } const incrementClicksCount = (prevState: State) => ({ clicksCount: prevState.clicksCount + 1, }); const decrementClicksCount = (prevState: State) => ({ clicksCount: prevState.clicksCount - 1, }); 你可能已经注意到了我们将状态更新函数提取到类的外部作为纯函数。这是一种常见的模式，这样我们不需要了解渲染逻辑就可以简单的测试这些状态更新函数。此外，因为我们使用了TypeScript并将State显式地映射为只读的，它将阻止我们在这些函数中做一些更改状态的操作： const decrementClicksCount = (prevState: State) => ({ clicksCount: prevState.clicksCount--, }); // 这样讲抛出编译错误： // // [ts] Cannot assign to 'clicksCount' because it is a constant or a read-only property. 非常酷是吧？：） 默认属性 让我们扩展我们的Button组件，新增一个string类型的颜色属性。 type Props = { onClick(e: MouseEvent): void; color: string; }; 如果我们想定义默认属性，我们可以在我们的组件中通过Button.defaultProps = {…}来定义。 通过这样做，我们需要改变我们的属性类型定义来标记属性是可选有默认值的。 所以定义是这样的（注意?操作符） type Props = { onClick(e: MouseEvent): void; color?: string; }; 此时我们的组件实现是这样的： const Button: SFC = ({ onClick: handleClick, color, children }) => ( {children} ); 尽管这样在我们简单的例子中可用的，这有一个问题。因为我们在strict mode模式洗啊，可选的属性color的类型是一个联合类型undefined | string。 比如我们想对color属性做一些操作，TS将会抛出一个错误，因为它并不知道它在React创建中通过Component.defaultProps中已经定义了: 为了满足TS编译器，我们可以使用下面3种技术： 使用!操作符在render函数显式地告诉编译器这个变量不会是undefined，尽管它是可选的，如：{children} 使用条件语句/三目运算符来让编译器明白一些属性是没有被定义的：{children} 创建可服用的withDefaultProps高阶函数，它将更新我们的props类型定义和设置默认属性。我认为这是最简洁干净的方案。 我们可以很简单的实现我们的高阶函数（感谢TS 2.8种的条件类型映射）： export const withDefaultProps = = Partial >( defaultProps: DP, Cmp: ComponentType, ) => { // 提取出必须的属性 type RequiredProps = Omit; // 重新创建我们的属性定义，通过一个相交类型，将所有的原始属性标记成可选的，必选的属性标记成可选的 type Props = Partial & Required; Cmp.defaultProps = defaultProps; // 返回重新的定义的属性类型组件，通过将原始组件的类型检查关闭，然后再设置正确的属性类型 return (Cmp as ComponentType) as ComponentType; }; 现在我们可以使用withDefaultProps高阶函数来定义我们的默认属性，同时也解决了之前的问题： const defaultProps = { color: 'red', }; type DefaultProps = typeof defaultProps; type Props = { onClick(e: MouseEvent): void } & DefaultProps; const Button: SFC = ({ onClick: handleClick, color, children }) => ( {children} ); const ButtonWithDefaultProps = withDefaultProps(defaultProps, Button); 或者直接使用内联（注意我们需要显式的提供原始Button组件的属性定义，TS不能从函数中推断出参数的类型）： const ButtonWithDefaultProps = withDefaultProps( defaultProps, ({ onClick: handleClick, color, children }) => ( {children} ), ); 现在Button组件的属性已经被正确的定义被使用的，默认属性被反应出来并且在类型定义中是可选的，但在实现中是必选的！ { onClick(e: MouseEvent): void color?: string } 组件使用方法仍然是一样的： render() { return ( Increment ) } 当然这也使用与通过class定义的组件（得益于TS中的类结构起源，我们不需要显式指定我们的Props泛型类型）。 它看起来像这样： const ButtonViaClass = withDefaultProps( defaultProps, class Button extends Component { render() { const { onClick: handleClick, color, children } = this.props; return ( {Children} ); } }, ); 再次，它的使用方式仍然是一样的： render() { return ( Increment ); } 比如说你需要构建一个可展开的菜单组件，它需要在用户点击它时显示子内容。我们就可以使用各种各样的组件模式来实现它。 render回调/render属性模式 实现组件的逻辑可复用的最好方式将组件的children放到函数中去，或者利用render属性API——这也是为什么Render回调也被称为函数子组件。 让我们用render属性方法实现一个Toggleable组件： import React, { Component, MouseEvent } from 'react'; import { isFunction } from '../utils'; const initialState = { show: false, }; type State = Readonly; type Props = Partial; type RenderCallback = (args: ToggleableComponentProps) => JSX.Element; type ToggleableComponentProps = { show: State['show']; toggle: Toggleable['toggle']; }; export class Toggleable extends Component { readonly state: State = initialState; render() { const { render, children } = this.props; const renderProps = { show: this.state.show, toggle: this.toggle, }; if (render) { return render(renderProps); } return isFunction(children) ? children(renderProps) : null; } private toggle = (event: MouseEvent) => this.setState(updateShowState); } const updateShowState = (prevState: State) => ({ show: !prevState.show }); 这里都发生了什么，让我们来分别看看重要的部分： const initialState = { show: false, }; type State = Readonly; 这里我们和前面的例子一样声明了我们的state 现在我们来定义组件的props（注意这里我们使用了Partitial映射类型，因为我们所有的属性都是可选的，不用分别对每个属性手动添加?标识符）： type Props = Partial; type RenderCallback = (args: ToggleableComponentProps) => JSX.Element; type ToggleableComponentProps = { show: State['show']; toggle: Toggleable['toggle']; }; 我们需要同时支持child作为函数，和render属性作为函数，它们两者都是可选的。为了避免重复代码，我们定义了RenderCallback作为我们的渲染函数定义： type RenderCallback = (args: ToggleableComponentProps) => JSX.Element 在读者眼中看起来比较奇怪的部分是我们最后的别名类型：type ToggleableComponentProps！ type ToggleableComponentProps = { show: State['show']; toggle: Toggleable['toggle']; }; 这里我们使用了TypeScript的查找类型（lookup types），所以我们又不需要重复地去定义类型了： show: State['show']我们利用已有的state类型定义了show属性 toggle: Toggleable['toggle']我们利用了TS从类实现推断类类型来定义toggle属性。很好用而且非常强大。 剩下的实现部分很简单，标准的render属性/children作为函数的模式： export class Toggleable extends Component { // ... render() { const { render, children } = this.props; const renderProps = { show: this.state.show, toggle: this.toggle, }; if (render) { return render(renderProps); } return isFunction(children) ? children(renderProps) : null; } // ... } 现在我们可以把函数作为children传给Toggleable组件了： {({ show, toggle }) => ( <> some title {show ? some content : null} )} 或者我们可以把函数作为render属性： ( <> some title {show ? some content : null} )} /> 感谢TypeScript，我们在render属性的参数有了智能提示和正确的类型检查： 如果我们想复用它（比如用在多个菜单组件中），我们只需要创建一个使用Toggleable逻辑的心组件： type Props = { title: string } const ToggleableMenu: SFC = ({ title, children }) => ( ( <> title {show ? children : null} )} /> ) 现在我们全新的ToggleableMenu组件已经可以在Menu组件中使用了： export class Menu extends Component { render() { return ( <> Some content Some content Some content ); } } 并且它也像我们期望的那样工作了： 这中模式在我们想更改渲染的内容，而不关心状态改变的情况下非常有用：可以看到，我们将渲染逻辑移到ToggleableMenu组件的额children函数中了，但把状态管理逻辑保留在我们的Toggleable组件中！ 组件注入 为了让我们的组件更灵活，我们可以引入组件注入模式。 什么是组件注入模式呢？如果你对React-Router比较熟悉，那你已经在下面这样路由定义的时候使用这种模式了： 这样我们不是把函数传递给render/children属性，而是通过component属性“注入”组件。为此，我们可以重构，把我们的内置render属性函数改成一个可复用的无状态组件： type MenuItemProps = { title: string }; const MenuItem: SFC = ({ title, toggle, show, children, }) => ( <> {title} {show ? children : null} ); 有了这个，我们可以使用render属性重构ToggleableMenu： type Props = { title: string }; const ToggleableMenu: SFC = ({ title, children }) => ( ( {children} )} /> ); 这个完成之后，让我们来开始定义我们新的API——compoent属性。 我们需要更新我们的属性API。 children现在可以是函数或者ReactNode（当component属性被使用时） component是我们新的API，它可以接受实现了ToggleableComponentProps属性的组件，并且它需要是设置为any的泛型，这样各种各样的实现组件可以添加其他属性到ToggleableComponentProps并通过TS的验证 props我们引入可以传入任意属性的定义。它被定义成any类型的可索引类型，这里我们放松了严格的类型安全检查... // 我们需要使用我们任意的props类型来创建 defaultProps，默认是一个空对象 const defaultProps = { props: {} as { [name: string]: any } }; type Props = Partial>; } & DefaultProps >; type DefaultProps = typeof defaultProps; 下一步，我们需要添加新的属性API到ToggleableComponentProps上，以便用户可以通过来使用我们的props属性： export type ToggleableComponentProps = { show: State['show']; toggle: Toggleable['toggle']; } & P; 然后我们需要更新我们的render函数： render() { const { component: InjectedComponent, props, render, children, } = this.props; const renderProps = { show: this.state.show, toggle: this.toggle, }; // 当 component 属性被使用时，children 是 ReactNode 而不是函数 if (InjectedComponent) { return ( {children} ); } if (render) { return render(renderProps); } return isFunction(children) ? children(renderProps) : null; } 完整的Toggleable组件实现如下，支持 render 属性、children作为函数、组件注入功能： import React, { Component, ReactNode, ComponentType, MouseEvent } from 'react'; import { isFunction, getHocComponentName } from '../utils'; const initialState = { show: false }; const defaultProps = { props: {} as { [name: string]: any } }; type State = Readonly; type Props = Partial>; } & DefaultProps >; type DefaultProps = typeof defaultProps; type RenderCallback = (args: ToggleableComponentProps) => JSX.Element; export type ToggleableComponentProps = { show: State['show']; toggle: Toggleable['toggle']; } & P; export class Toggleable extends Component { static readonly defaultProps: Props = defaultProps; readonly state: State = initialState; render() { const { component: InjectedComponent, props, render, children, } = this.props; const renderProps = { show: this.state.show, toggle: this.toggle, }; if (InjectedComponent) { return ( {children} ); } if (render) { return render(renderProps); } return isFunction(children) ? children(renderProps) : null; } private toggle = (event: MouseEvent) => this.setState(updateShowState); } const updateShowState = (prevState: State) => ({ show: !prevState.show }); 我们最终使用component属性的ToggleableMenuViaComponentInjection组件是这样的： const ToggleableMenuViaComponentInjection: SFC = ({ title, children, }) => ( {children} ); 请注意，这里我们的props属性没有严格的类型安全检查，因为它被定义成索引对象类型{ [name: string]: any }: 我们可以还是像之前一样使用ToggleableMenuViaComponentInjection组件来实现菜单渲染： export class Menu extends Component { render() { return ( <> Some content Another content More content ); } } 泛型组件 在我们视线“组件注入模式”的时候，我们失去了对props属性严格的类型安全检查。我们怎样修复这个问题呢？对，你猜到了！我们可以把我们的Toggleable组件实现为一个泛型组件！ 首先我们需要把我们的属性泛型化。我们使用默认的泛型参数，所以我们不需要在没必要的时候显式地提供类型（针对 render 属性和 children 作为函数）。 type Props = Partial>; } & DefaultProps >; 我们也需要把ToggleableComponnetProps更新成泛型的。不，等等，它已经是泛型啦！所以还不需要做任何更改。 需要更新的是type DefaultProps，因为不支持从声明实现推倒出泛型类型定义，所以需要把它重构成传统的类型定义->实现： type DefaultProps = { props: P }; const defaultProps: DefaultProps = { props: {} }; 就快好啦！ 现在让我们把组件类也泛型化。再次说明，我们使用了默认的属性，所以在没有使用组件注入的时候不需要去指定泛型参数！ export class Toggleable extends Component, State> {} 这样就完成了吗？嗯…，我们可以在JSX中使用泛型类型吗？ 坏消息是，不能... 但我们可以在泛型组件上引入ofType的工场模式： export class Toggleable extends Component, State> { static ofType() { return Toggleable as Constructor>; } } 完整的 Toggleable 组件实现，支持 Render 属性、Children 作为函数、带泛型 props 属性支持的组件注入： import React, { Component, ReactNode, ComponentType, MouseEvent, SFC, } from 'react'; import { isFunction, getHocComponentName } from '../utils'; const initialState = { show: false }; // const defaultProps = { props: {} as { [name: string]: any } }; type State = Readonly; type Props = Partial>; } & DefaultProps >; type DefaultProps = { props: P }; const defaultProps: DefaultProps = { props: {} }; type RenderCallback = (args: ToggleableComponentProps) => JSX.Element; export type ToggleableComponentProps = { show: State['show']; toggle: Toggleable['toggle']; } & P; export class Toggleable extends Component, State> { static ofType() { return Toggleable as Constructor>; } static readonly defaultProps: Props = defaultProps; readonly state: State = initialState; render() { const { component: InjectedComponent, props, render, children, } = this.props; const renderProps = { show: this.state.show, toggle: this.toggle, }; if (InjectedComponent) { return ( {children} ); } if (render) { return render(renderProps); } return isFunction(children) ? children(renderProps) : null; } private toggle = (event: MouseEvent) => this.setState(updateShowState); } const updateShowState = (prevState: State) => ({ show: !prevState.show }); 有了static ofType工厂函数后，我们可以创建正确类型的泛型组件了。 type MenuItemProps = { title: string }; // ofType 是一种标识函数，返回的是相同实现的 Toggleable 组件，但带有制定的 props 类型 const ToggleableWithTitle = Toggleable.ofType(); type ToggleableMenuProps = MenuItemProps; const ToggleableMenuViaComponentInjection: SFC = ({ title, children, }) => ( {children} ); 并且所有的东西都还像一起一样工作，但这次我有的 props={} 属性有了正确的类型检查。鼓掌吧！ 高阶组件 因为我们已经创建了带render回调功能的Toggleable组件，实现HOC也会很容易。（这也是 render 回调函数模式的一个大优势，因为我们可以使用HOC来实现） 让我们开始实现我们的HOC组件吧： 我们需要创建： displayName (以便我们在devtools可以很好地调试) WrappedComponent (以便我们能够获取原始的组件——对测试很有用) 使用hoist-non-react-staticsnpm包中的hoistNonReactStatics import React, { ComponentType, Component } from 'react'; import hoistNonReactStatics from 'hoist-non-react-statics'; import { getHocComponentName } from '../utils'; import { Toggleable, Props as ToggleableProps, ToggleableComponentProps, } from './RenderProps'; // OwnProps 是内部组件上任意公开的属性 type OwnProps = object; type InjectedProps = ToggleableComponentProps; export const withToggleable = ( UnwrappedComponent: ComponentType, ) => { // 我们使用 TS 2.8 中的条件映射类型来得到我们最终的属性类型 type Props = Omit & OwnProps; class WithToggleable extends Component { static readonly displayName = getHocComponentName( WithToggleable.displayName, UnwrappedComponent, ); static readonly UnwrappedComponent = UnwrappedComponent; render() { const { ...rest } = this.props; return ( ( )} /> ); } } return hoistNonReactStatics(WithToggleable, UnwrappedComponent); }; 现在我们可以使用HOC来创建我们的Toggleable菜单组件了，并有正确的类型安全检查！ const ToggleableMenuViaHOC = withToggleable(MenuItem) 一切正常，还有类型安全检查！好极了！ 受控组件 这是最后一个组件模式了！假设我们想从父组件中控制我们的Toggleable组件，我们需要Toggleable组件配置化。这是一种很强大的模式。让我们来实现它吧。 当我说受控组件时，我指的是什么？我想从Menu组件内控制所以的ToggleableManu组件的内容是否显示。 我们需要像这样更新我们的ToggleableMenu组件的实现： // 更新我们的属性类型，以便我们可以通过 show 属性来控制是否显示 type Props = MenuItemProps & { show?: boolean }; // 注意：这里我们使用了结构来创建变量别，为了不和 render 回调函数的 show 参数冲突 // -> { show: showContent } // Render 属性 export const ToggleMenu: SFC = ({ title, children, show: showContent, }) => ( {({ show, toggle }) => ( {children} )} ); // 组件注入 const ToggleableWithTitle = Toggleable.ofType(); export const ToggleableMenuViaComponentInjection: SFC = ({ title, children, show: showContent, }) => ( {children} ); // HOC不需要更改 export const ToggleMenuViaHOC = withToggleable(MenuItem); 有了这些更新后，我们可以在Menu中添加状态，并传递给ToggleableMenu const initialState = { showContents: false }; type State = Readonly; export class Menu extends Component { readonly state: State = initialState; render() { const { showContents } = this.state; return ( <> toggle showContent Some Content Another Content More Content ); } } 让我们为了最终的功能和灵活性最后一次更新Toggleable组件。为了让 Toggleable 变成受控组件我们需要： 添加show属性到PropsAPI上 更新默认的属性（因为show是可选的） 从Props.show更新组件的初始化state，因为现在我们状态中值可能取决于父组件传来的属性 在componentWillReceiveProps生命周期函数中从props更新state 1 & 2： const initialState = { show: false } const defaultProps: DefaultProps = { ...initialState, props: {} } type State = Readonly type DefaultProps = { props: P } & Pick 3 & 4： export class Toggleable extends Component, State> { static readonly defaultProps: Props = defaultProps // Bang operator used, I know I know ... state: State = { show: this.props.show! } componentWillReceiveProps(nextProps: Props) { const currentProps = this.props if (nextProps.show !== currentProps.show) { this.setState({ show: Boolean(nextProps.show) }) } } } 最终支持所有所有模式（Render属性/Children作为函数/组件注入/泛型组件/受控组件）的 Toggleable 组件： import React, { Component, MouseEvent, ComponentType, ReactNode } from 'react' import { isFunction, getHocComponentName } from '../utils' const initialState = { show: false } const defaultProps: DefaultProps = { ...initialState, props: {} } type State = Readonly export type Props = Partial> } & DefaultProps > type RenderCallback = (args: ToggleableComponentProps) => JSX.Element export type ToggleableComponentProps = { show: State['show'] toggle: Toggleable['toggle'] } & P type DefaultProps = { props: P } & Pick export class Toggleable extends Component, State> { static ofType() { return Toggleable as Constructor> } static readonly defaultProps: Props = defaultProps readonly state: State = { show: this.props.show! } componentWillReceiveProps(nextProps: Props, nextContext: any) { const currentProps = this.props if (nextProps.show !== currentProps.show) { this.setState({ show: Boolean(nextProps.show) }) } } render() { const { component: InjectedComponent, children, render, props } = this.props const renderProps = { show: this.state.show, toggle: this.toggle } if (InjectedComponent) { return ( {children} ) } if (render) { return render(renderProps) } return isFunction(children) ? children(renderProps) : new Error('asdsa()') } private toggle = (event: MouseEvent) => this.setState(updateShowState) } const updateShowState = (prevState: State) => ({ show: !prevState.show }) 最终的Toggleable HOC 组件 withToggleable 只需要稍作修改 -> 我们需要在HOC组件中传递 show 属性，并更新我们的OwnPropsAPI import React, { ComponentType, Component } from 'react' import hoistNonReactStatics from 'hoist-non-react-statics' import { getHocComponentName } from '../utils' import { Toggleable, Props as ToggleableProps, ToggleableComponentProps as InjectedProps, } from './toggleable' // OwnProps is for any public props that should be available on internal Component.props // and for WrappedComponent type OwnProps = Pick export const withToogleable = ( UnwrappedComponent: ComponentType ) => { // we are leveraging TS 2.8 conditional mapped types to get proper final prop types type Props = Omit & OwnProps class WithToggleable extends Component { static readonly displayName = getHocComponentName( WithToggleable.displayName, UnwrappedComponent ) static readonly WrappedComponent = UnwrappedComponent render() { // Generics and spread issue // https://github.com/Microsoft/TypeScript/issues/10727 const { show, ...rest } = this.props as Pick // we need to explicitly pick props we wanna destructure, rest is gonna be type `{}` return ( } /> ) } } return hoistNonReactStatics(WithToggleable, UnwrappedComponent as any) as ComponentType } 总结 使用 TypeScript 和 React 时，实现恰当的类型安全组件可能会很棘手。但随着 TypeScript 2.8中新加入的功能，我们几乎可以在所有的 React 组件模式中编写类型安全的组件。 在这遍非常长（对此十分抱歉）文章中，感谢TypeScript，我们已经学会了在各种各样的模式下怎么编写严格类型安全检查的组件。 在这些模式中最强的应该是Render属性模式，它让我们可以在此基础上不需要太多改动就可以实现其他常见的模式，如组件注入、高阶组件等。 文中所有的demo都可以在我的 Github 仓库中找到。 此外，需要明白的是，本文中演示的模版类型安全，只能在使用 VDOM/JSX 的库中实现。 Angular 模版有 Language service 提供类型安全，但像 ngFor 等简单的构造检查好像都不行... Vue 的模版不像 Angular，它们的模版和数据绑定只是神奇的字符串（但这有可能在未来会改变。尽管你可以在模版中使用VDOM，但因为各种类型的属性定义，它使用起来十分笨重（这怪 snabdom...）） "},"webpack/webpack相关.html":{"url":"webpack/webpack相关.html","title":"webpack相关","keywords":"","body":"webpack相关 webpack相关 打包体积 优化思路 打包效率 Loader 编写一个loader plugins 打包体积 优化思路 提取第三方库或通过引用外部文件的方式引入第三方库 代码压缩插件UglifyJsPlugin 服务器启用gzip压缩 按需加载资源文件 require.ensure 优化devtool中的source-map 剥离css文件，单独打包 去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致 打包效率 开发环境采用增量构建，启用热更新 开发环境不做无意义的工作如提取css计算文件hash等 配置devtool 选择合适的loader 个别loader开启cache 如babel-loader 第三方库采用引入方式 提取公共代码 优化构建时的搜索路径 指明需要构建目录及不需要构建目录 模块化引入需要的部分 Loader 编写一个loader loader就是一个node模块，它输出了一个函数。当某种资源需要用这个loader转换时，这个函数会被调用。并且，这个函数可以通过提供给它的this上下文访问Loader API。 reverse-txt-loader // reverse-txt-loader // 定义 module.exports = function(src) { //src是原文件内容（abcde），下面对内容进行处理，这里是反转 var result = src.split('').reverse().join(''); //返回JavaScript源码，必须是String或者Buffer return `module.exports = '${result}'`; } // 使用 { test: /\\.txt$/, use: [ { './path/reverse-txt-loader' } ] }, plugins 使用范围更广，通常只需要require()然后添加到plugins数组中，且需要new一个 "},"框架通识/MVVM.html":{"url":"框架通识/MVVM.html","title":"MVVM","keywords":"","body":"MVVM MVVM MVVM 脏数据检测 数据劫持 Proxy 与 Object.defineProperty 对比 MVVM MVVM 由以下三个内容组成 View：界面 Model：数据模型 ViewModel：作为桥梁负责沟通 View 和 Model 在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合。 在 MVVM 中，UI 是通过数据驱动的，数据一旦改变就会相应的刷新对应的 UI，UI 如果改变，也会改变对应的数据。这种方式就可以在业务处理中只关心数据的流转，而无需直接和页面打交道。ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，在这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。 在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。 脏数据检测 当触发了指定事件后会进入脏数据检测，这时会调用 $digest 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 $watch 函数，然后再次调用 $digest 循环直到发现没有变化。循环至少为二次 ，至多为十次。 脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数。所以低效也是相对的，这就仁者见仁智者见智了。 数据劫持 Vue 内部使用了 Object.defineProperty() 来实现双向绑定，通过这个函数可以监听到 set 和 get 的事件。 var data = { name: 'yck' } observe(data) let name = data.name // -> get value data.name = 'yyy' // -> change value function observe(obj) { // 判断类型 if (!obj || typeof obj !== 'object') { return } Object.keys(obj).forEach(key => { defineReactive(obj, key, obj[key]) }) } function defineReactive(obj, key, val) { // 递归子属性 observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter() { console.log('get value') return val }, set: function reactiveSetter(newVal) { console.log('change value') val = newVal } }) } 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅 {{name}} 在解析如上模板代码时，遇到 {{name}} 就会给属性 name 添加发布订阅。 // 通过 Dep 解耦 class Dep { constructor() { this.subs = [] } addSub(sub) { // sub 是 Watcher 实例 this.subs.push(sub) } notify() { this.subs.forEach(sub => { sub.update() }) } } // 全局属性，通过该属性配置 Watcher Dep.target = null function update(value) { document.querySelector('div').innerText = value } class Watcher { constructor(obj, key, cb) { // 将 Dep.target 指向自己 // 然后触发属性的 getter 添加监听 // 最后将 Dep.target 置空 Dep.target = this this.cb = cb this.obj = obj this.key = key this.value = obj[key] Dep.target = null } update() { // 获得新值 this.value = this.obj[this.key] // 调用 update 方法更新 Dom this.cb(this.value) } } var data = { name: 'yck' } observe(data) // 模拟解析到 `{{name}}` 触发的操作 new Watcher(data, 'name', update) // update Dom innerText data.name = 'yyy' 接下来,对 defineReactive 函数进行改造 function defineReactive(obj, key, val) { // 递归子属性 observe(val) let dp = new Dep() Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter() { console.log('get value') // 将 Watcher 添加到订阅 if (Dep.target) { dp.addSub(Dep.target) } return val }, set: function reactiveSetter(newVal) { console.log('change value') val = newVal // 执行 watcher 的 update 方法 dp.notify() } }) } 以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加。 Proxy 与 Object.defineProperty 对比 Object.defineProperty 虽然已经能够实现双向绑定了，但是他还是有缺陷的。 只能对属性进行数据劫持，所以需要深度遍历整个对象 对于数组不能监听到数据的变化 虽然 Vue 中确实能检测到数组数据的变化，但是其实是使用了 hack 的办法，并且也是有缺陷的。 const arrayProto = Array.prototype export const arrayMethods = Object.create(arrayProto) // hack 以下几个函数 const methodsToPatch = [ 'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse' ] methodsToPatch.forEach(function(method) { // 获得原生函数 const original = arrayProto[method] def(arrayMethods, method, function mutator(...args) { // 调用原生函数 const result = original.apply(this, args) const ob = this.__ob__ let inserted switch (method) { case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break } if (inserted) ob.observeArray(inserted) // 触发更新 ob.dep.notify() return result }) }) 反观 Proxy 就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 Vue 也将在下个大版本中使用 Proxy 替换 Object.defineProperty let onWatch = (obj, setBind, getLogger) => { let handler = { get(target, property, receiver) { getLogger(target, property) return Reflect.get(target, property, receiver) }, set(target, property, value, receiver) { setBind(value) return Reflect.set(target, property, value) } } return new Proxy(obj, handler) } let obj = { a: 1 } let value let p = onWatch( obj, v => { value = v }, (target, property) => { console.log(`Get '${property}' = ${target[property]}`) } ) p.a = 2 // bind `value` to `2` p.a // -> Get 'a' = 2 "},"框架通识/VirtualDom.html":{"url":"框架通识/VirtualDom.html","title":"Virtual Dom","keywords":"","body":"Virtual Dom Virtual Dom 为什么需要 Virtual Dom Virtual Dom 算法简述 Virtual Dom 算法实现 树的递归 判断属性的更改 判断列表差异算法实现 遍历子元素打标识 渲染差异 最后 为什么需要 Virtual Dom 众所周知，操作 DOM 是很耗费性能的一件事情，既然如此，我们可以考虑通过 JS 对象来模拟 DOM 对象，毕竟操作 JS 对象比操作 DOM 省时的多。 举个例子 // 假设这里模拟一个 ul，其中包含了 5 个 li ;[1, 2, 3, 4, 5][ // 这里替换上面的 li (1, 2, 5, 4) ] 从上述例子中，我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。 如果以上操作对应到 DOM 中，那么就是以下代码 // 删除第三个 li ul.childNodes[2].remove() // 将第四个 li 和第五个交换位置 let fromNode = ul.childNodes[4] let toNode = node.childNodes[3] let cloneFromNode = fromNode.cloneNode(true) let cloenToNode = toNode.cloneNode(true) ul.replaceChild(cloneFromNode, toNode) ul.replaceChild(cloenToNode, fromNode) 当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 Vue 和 React 中官方推荐列表里的节点使用唯一的 key 来保证性能。 那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM 以下是一个 JS 对象模拟 DOM 对象的简单实现 export default class Element { /** * @param {String} tag 'div' * @param {Object} props { class: 'item' } * @param {Array} children [ Element1, 'text'] * @param {String} key option */ constructor(tag, props, children, key) { this.tag = tag this.props = props if (Array.isArray(children)) { this.children = children } else if (isString(children)) { this.key = children this.children = null } if (key) this.key = key } // 渲染 render() { let root = this._createElement( this.tag, this.props, this.children, this.key ) document.body.appendChild(root) return root } create() { return this._createElement(this.tag, this.props, this.children, this.key) } // 创建节点 _createElement(tag, props, child, key) { // 通过 tag 创建节点 let el = document.createElement(tag) // 设置节点属性 for (const key in props) { if (props.hasOwnProperty(key)) { const value = props[key] el.setAttribute(key, value) } } if (key) { el.setAttribute('key', key) } // 递归添加子节点 if (child) { child.forEach(element => { let child if (element instanceof Element) { child = this._createElement( element.tag, element.props, element.children, element.key ) } else { child = document.createTextNode(element) } el.appendChild(child) }) } return el } } Virtual Dom 算法简述 既然我们已经通过 JS 来模拟实现了 DOM，那么接下来的难点就在于如何判断旧的对象和新的对象之间的差异。 DOM 是多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现 O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。 所以判断差异的算法就分为了两步 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异 一旦节点有子元素，就去判断子元素是否有不同 Virtual Dom 算法实现 树的递归 首先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对比会有几种情况 新的节点的 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了 新的节点的 tagName 和 key（可能都没有）和旧的相同，开始遍历子树 没有新的节点，那么什么都不用做 import { StateEnums, isString, move } from './util' import Element from './element' export default function diff(oldDomTree, newDomTree) { // 用于记录差异 let pathchs = {} // 一开始的索引为 0 dfs(oldDomTree, newDomTree, 0, pathchs) return pathchs } function dfs(oldNode, newNode, index, patches) { // 用于保存子树的更改 let curPatches = [] // 需要判断三种情况 // 1.没有新的节点，那么什么都不用做 // 2.新的节点的 tagName 和 `key` 和旧的不同，就替换 // 3.新的节点的 tagName 和 key（可能都没有） 和旧的相同，开始遍历子树 if (!newNode) { } else if (newNode.tag === oldNode.tag && newNode.key === oldNode.key) { // 判断属性是否变更 let props = diffProps(oldNode.props, newNode.props) if (props.length) curPatches.push({ type: StateEnums.ChangeProps, props }) // 遍历子树 diffChildren(oldNode.children, newNode.children, index, patches) } else { // 节点不同，需要替换 curPatches.push({ type: StateEnums.Replace, node: newNode }) } if (curPatches.length) { if (patches[index]) { patches[index] = patches[index].concat(curPatches) } else { patches[index] = curPatches } } } 判断属性的更改 判断属性的更改也分三个步骤 遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中 遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化 在第二步中同时查看是否有属性不存在与旧的属性列列表中 function diffProps(oldProps, newProps) { // 判断 Props 分以下三步骤 // 先遍历 oldProps 查看是否存在删除的属性 // 然后遍历 newProps 查看是否有属性值被修改 // 最后查看是否有属性新增 let change = [] for (const key in oldProps) { if (oldProps.hasOwnProperty(key) && !newProps[key]) { change.push({ prop: key }) } } for (const key in newProps) { if (newProps.hasOwnProperty(key)) { const prop = newProps[key] if (oldProps[key] && oldProps[key] !== newProps[key]) { change.push({ prop: key, value: newProps[key] }) } else if (!oldProps[key]) { change.push({ prop: key, value: newProps[key] }) } } } return change } 判断列表差异算法实现 这个算法是整个 Virtual Dom 中最核心的算法，且让我一一为你道来。 这里的主要步骤其实和判断属性差异是类似的，也是分为三步 遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中 遍历新的节点列表，判断是否有新的节点 在第二步中同时判断节点是否有移动 PS：该算法只对有 key 的节点做处理 function listDiff(oldList, newList, index, patches) { // 为了遍历方便，先取出两个 list 的所有 keys let oldKeys = getKeys(oldList) let newKeys = getKeys(newList) let changes = [] // 用于保存变更后的节点数据 // 使用该数组保存有以下好处 // 1.可以正确获得被删除节点索引 // 2.交换节点位置只需要操作一遍 DOM // 3.用于 `diffChildren` 函数中的判断，只需要遍历 // 两个树中都存在的节点，而对于新增或者删除的节点来说，完全没必要 // 再去判断一遍 let list = [] oldList && oldList.forEach(item => { let key = item.key if (isString(item)) { key = item } // 寻找新的 children 中是否含有当前节点 // 没有的话需要删除 let index = newKeys.indexOf(key) if (index === -1) { list.push(null) } else list.push(key) }) // 遍历变更后的数组 let length = list.length // 因为删除数组元素是会更改索引的 // 所有从后往前删可以保证索引不变 for (let i = length - 1; i >= 0; i--) { // 判断当前元素是否为空，为空表示需要删除 if (!list[i]) { list.splice(i, 1) changes.push({ type: StateEnums.Remove, index: i }) } } // 遍历新的 list，判断是否有节点新增或移动 // 同时也对 `list` 做节点新增和移动节点的操作 newList && newList.forEach((item, i) => { let key = item.key if (isString(item)) { key = item } // 寻找旧的 children 中是否含有当前节点 let index = list.indexOf(key) // 没找到代表新节点，需要插入 if (index === -1 || key == null) { changes.push({ type: StateEnums.Insert, node: item, index: i }) list.splice(i, 0, key) } else { // 找到了，需要判断是否需要移动 if (index !== i) { changes.push({ type: StateEnums.Move, from: index, to: i }) move(list, index, i) } } }) return { changes, list } } function getKeys(list) { let keys = [] let text list && list.forEach(item => { let key if (isString(item)) { key = [item] } else if (item instanceof Element) { key = item.key } keys.push(key) }) return keys } 遍历子元素打标识 对于这个函数来说，主要功能就两个 判断两个列表差异 给节点打上标记 总体来说，该函数实现的功能很简单 function diffChildren(oldChild, newChild, index, patches) { let { changes, list } = listDiff(oldChild, newChild, index, patches) if (changes.length) { if (patches[index]) { patches[index] = patches[index].concat(changes) } else { patches[index] = changes } } // 记录上一个遍历过的节点 let last = null oldChild && oldChild.forEach((item, i) => { let child = item && item.children if (child) { index = last && last.children ? index + last.children.length + 1 : index + 1 let keyIndex = list.indexOf(item.key) let node = newChild[keyIndex] // 只遍历新旧中都存在的节点，其他新增或者删除的没必要遍历 if (node) { dfs(item, node, index, patches) } } else index += 1 last = item }) } 渲染差异 通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 DOM 了，下面就让我们来看看 Virtual Dom 算法的最后一步骤 这个函数主要两个功能 深度遍历树，将需要做变更操作的取出来 局部更新 DOM 整体来说这部分代码还是很好理解的 let index = 0 export default function patch(node, patchs) { let changes = patchs[index] let childNodes = node && node.childNodes // 这里的深度遍历和 diff 中是一样的 if (!childNodes) index += 1 if (changes && changes.length && patchs[index]) { changeDom(node, changes) } let last = null if (childNodes && childNodes.length) { childNodes.forEach((item, i) => { index = last && last.children ? index + last.children.length + 1 : index + 1 patch(item, patchs) last = item }) } } function changeDom(node, changes, noChild) { changes && changes.forEach(change => { let { type } = change switch (type) { case StateEnums.ChangeProps: let { props } = change props.forEach(item => { if (item.value) { node.setAttribute(item.prop, item.value) } else { node.removeAttribute(item.prop) } }) break case StateEnums.Remove: node.childNodes[change.index].remove() break case StateEnums.Insert: let dom if (isString(change.node)) { dom = document.createTextNode(change.node) } else if (change.node instanceof Element) { dom = change.node.create() } node.insertBefore(dom, node.childNodes[change.index]) break case StateEnums.Replace: node.parentNode.replaceChild(change.node.create(), node) break case StateEnums.Move: let fromNode = node.childNodes[change.from] let toNode = node.childNodes[change.to] let cloneFromNode = fromNode.cloneNode(true) let cloenToNode = toNode.cloneNode(true) node.replaceChild(cloneFromNode, toNode) node.replaceChild(cloenToNode, fromNode) break default: break } }) } 最后 Virtual Dom 算法的实现也就是以下三步 通过 JS 来模拟创建 DOM 对象 判断两个对象的差异 渲染差异 let test4 = new Element('div', { class: 'my-div' }, ['test4']) let test5 = new Element('ul', { class: 'my-div' }, ['test5']) let test1 = new Element('div', { class: 'my-div' }, [test4]) let test2 = new Element('div', { id: '11' }, [test5, test4]) let root = test1.render() let pathchs = diff(test1, test2) console.log(pathchs) setTimeout(() => { console.log('开始更新') patch(root, pathchs) console.log('结束更新') }, 1000) "},"框架通识/VirtualDOM算法.html":{"url":"框架通识/VirtualDOM算法.html","title":"VirtualDOM算法","keywords":"","body":"深度剖析：如何实现一个 Virtual DOM 算法 深度剖析：如何实现一个 Virtual DOM 算法 1 前言 2 对前端应用状态管理的思考 3 Virtual DOM算法 4 算法实现 4.1 步骤一：用JS对象模拟DOM树 4.2 步骤二：比较两棵虚拟DOM树的差异 4.2.1 深度优先遍历，记录差异 4.2.2 差异类型 4.2.3 列表对比算法 4.3 步骤三：把差异应用到真正的DOM树上 5 结语 1 前言 本文会在教你怎么用 300~400 行代码实现一个基本的 Virtual DOM 算法，并且尝试尽量把 Virtual DOM 的算法思路阐述清楚。希望在阅读本文后，能让你深入理解 Virtual DOM 算法，给你现有前端的编程提供一些新的思考。 本文所实现的完整代码存放在 Github。 2 对前端应用状态管理的思考 假如现在你需要写一个像下面一样的表格的应用程序，这个表格可以根据不同的字段进行升序或者降序的展示。 这个应用程序看起来很简单，你可以想出好几种不同的方式来写。最容易想到的可能是，在你的 JavaScript 代码里面存储这样的数据： var sortKey = \"new\" // 排序的字段，新增（new）、取消（cancel）、净关注（gain）、累积（cumulate）人数 var sortType = 1 // 升序还是逆序 var data = [{...}, {...}, {..}, ..] // 表格数据 用三个字段分别存储当前排序的字段、排序方向、还有表格数据；然后给表格头部加点击事件：当用户点击特定的字段的时候，根据上面几个字段存储的内容来对内容进行排序，然后用 JS 或者 jQuery 操作 DOM，更新页面的排序状态（表头的那几个箭头表示当前排序状态，也需要更新）和表格内容。 这样做会导致的后果就是，随着应用程序越来越复杂，需要在JS里面维护的字段也越来越多，需要监听事件和在事件回调用更新页面的DOM操作也越来越多，应用程序会变得非常难维护。后来人们使用了 MVC、MVP 的架构模式，希望能从代码组织方式来降低维护这种复杂应用程序的难度。但是 MVC 架构没办法减少你所维护的状态，也没有降低状态更新你需要对页面的更新操作（前端来说就是DOM操作），你需要操作的DOM还是需要操作，只是换了个地方。 既然状态改变了要操作相应的DOM元素，为什么不做一个东西可以让视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。这就是后来人们想出了 MVVM 模式，只要在模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图（关于MV*模式的内容，可以看这篇介绍）。 MVVM 可以很好的降低我们维护状态 -> 视图的复杂程度（大大减少代码中的视图更新逻辑）。但是这不是唯一的办法，还有一个非常直观的方法，可以大大降低视图更新的操作：一旦状态发生了变化，就用模版引擎重新渲染整个视图，然后用新的视图更换掉旧的视图。就像上面的表格，当用户点击的时候，还是在JS里面更新状态，但是页面更新就不用手动操作 DOM 了，直接把整个表格用模版引擎重新渲染一遍，然后设置一下innerHTML就完事了。 听到这样的做法，经验丰富的你一定第一时间意识这样的做法会导致很多的问题。最大的问题就是这样做会很慢，因为即使一个小小的状态变更都要重新构造整棵 DOM，性价比太低；而且这样做的话，input和textarea的会失去原有的焦点。最后的结论会是：对于局部的小视图的更新，没有问题（Backbone就是这么干的）；但是对于大型视图，如全局应用状态变更的时候，需要更新页面较多局部视图的时候，这样的做法不可取。 但是这里要明白和记住这种做法，因为后面你会发现，其实 Virtual DOM 就是这么做的，只是加了一些特别的步骤来避免了整棵 DOM 树变更。 另外一点需要注意的就是，上面提供的几种方法，其实都在解决同一个问题：维护状态，更新视图。在一般的应用当中，如果能够很好方案来应对这个问题，那么就几乎降低了大部分复杂性。 3 Virtual DOM算法 DOM是很慢的。如果我们把一个简单的div元素的属性都打印出来，你会看到： 而这仅仅是第一层。真正的 DOM 元素非常庞大，这是因为标准就是这么设计的。而且操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。 相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来： var element = { tagName: 'ul', // 节点标签名 props: { // DOM的属性，用一个对象存储键值对 id: 'list' }, children: [ // 该节点的子节点 {tagName: 'li', props: {class: 'item'}, children: [\"Item 1\"]}, {tagName: 'li', props: {class: 'item'}, children: [\"Item 2\"]}, {tagName: 'li', props: {class: 'item'}, children: [\"Item 3\"]}, ] } 上面对应的HTML写法是： Item 1 Item 2 Item 3 既然原来 DOM 树的信息都可以用 JavaScript 对象来表示，反过来，你就可以根据这个用 JavaScript 对象表示的树结构来构建一棵真正的DOM树。 之前的章节所说的，状态变更->重新渲染整个视图的方式可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。 但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。 这就是所谓的 Virtual DOM 算法。包括几个步骤： 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了 Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。 4 算法实现 4.1 步骤一：用JS对象模拟DOM树 用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点： element.js function Element (tagName, props, children) { this.tagName = tagName this.props = props this.children = children } module.exports = function (tagName, props, children) { return new Element(tagName, props, children) } 例如上面的 DOM 结构就可以简单的表示： var el = require('./element') var ul = el('ul', {id: 'list'}, [ el('li', {class: 'item'}, ['Item 1']), el('li', {class: 'item'}, ['Item 2']), el('li', {class: 'item'}, ['Item 3']) ]) 现在ul只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个ul构建真正的： Element.prototype.render = function () { var el = document.createElement(this.tagName) // 根据tagName构建 var props = this.props for (var propName in props) { // 设置节点的DOM属性 var propValue = props[propName] el.setAttribute(propName, propValue) } var children = this.children || [] children.forEach(function (child) { var childEl = (child instanceof Element) ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点 : document.createTextNode(child) // 如果字符串，只构建文本节点 el.appendChild(childEl) }) return el } render方法会根据tagName构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要： var ulRoot = ul.render() document.body.appendChild(ulRoot) 上面的ulRoot是真正的DOM节点，把它塞入文档中，这样body里面就有了真正的的DOM结构： Item 1 Item 2 Item 3 完整代码可见 element.js。 4.2 步骤二：比较两棵虚拟DOM树的差异 正如你所预料的，比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比： 上面的div只会和同一层级的div对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。 4.2.1 深度优先遍历，记录差异 在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记： 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。 // diff 函数，对比两棵树 function diff (oldTree, newTree) { var index = 0 // 当前节点的标志 var patches = {} // 用来记录每个节点差异的对象 dfsWalk(oldTree, newTree, index, patches) return patches } // 对两棵树进行深度优先遍历 function dfsWalk (oldNode, newNode, index, patches) { // 对比oldNode和newNode的不同，记录下来 patches[index] = [...] diffChildren(oldNode.children, newNode.children, index, patches) } // 遍历子节点 function diffChildren (oldChildren, newChildren, index, patches) { var leftNode = null var currentNodeIndex = index oldChildren.forEach(function (child, i) { var newChild = newChildren[i] currentNodeIndex = (leftNode && leftNode.count) // 计算节点的标识 ? currentNodeIndex + leftNode.count + 1 : currentNodeIndex + 1 dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点 leftNode = child }) } 例如，上面的div和新的div有差异，当前的标记是0，那么： patches[0] = [{difference}, {difference}, ...] // 用数组存储新旧节点的不同 同理p是patches[1]，ul是patches[3]，类推。 4.2.2 差异类型 上面说的节点的差异指的是什么呢？对 DOM 操作可能会： 替换掉原来的节点，例如把上面的div换成了section 移动、删除、新增子节点，例如上面div的子节点，把p和ul顺序互换 修改了节点的属性 对于文本节点，文本内容可能会改变。例如修改上面的文本节点2内容为Virtual DOM 2。 所以我们定义了几种差异类型： var REPLACE = 0 var REORDER = 1 var PROPS = 2 var TEXT = 3 对于节点替换，很简单。判断新旧节点的tagName和是不是一样的，如果不一样的说明需要替换掉。如div换成section，就记录下： patches[0] = [{ type: REPALCE, node: newNode // el('section', props, children) }] 如果给div新增了属性id为container，就记录下： patches[0] = [{ type: REPALCE, node: newNode // el('section', props, children) }, { type: PROPS, props: { id: \"container\" } }] 如果是文本节点，如上面的文本节点2，就记录下： patches[2] = [{ type: TEXT, content: \"Virtual DOM2\" }] 那如果把我div的子节点重新排序呢？例如p, ul, div的顺序换成了div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如p和div的tagName不同，p会被div所替代。最终，三个节点都会被替换，这样DOM开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。 这牵涉到两个列表的对比算法，需要另外起一个小节来讨论。 4.2.3 列表对比算法 假设现在可以英文字母唯一地标识每一个子节点： 旧的节点顺序： a b c d e f g h i 现在对节点进行了删除、插入、移动的操作。新增j节点，删除e节点，移动h节点： 新的节点顺序： a b c h d f g i j 现在知道了新旧的顺序，求最小的插入、删除操作（移动可以看成是删除和插入操作的结合）。这个问题抽象出来其实是字符串的最小编辑距离问题（Edition Distance），最常见的解决算法是 Levenshtein Distance，通过动态规划求解，时间复杂度为 O(M * N)。但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，牺牲一定DOM操作，让算法时间复杂度达到线性的（O(max(M, N))。具体算法细节比较多，这里不累述，有兴趣可以参考代码。 我们能够获取到某个父节点的子节点的操作，就可以记录下来： patches[0] = [{ type: REORDER, moves: [{remove or insert}, {remove or insert}, ...] }] 但是要注意的是，因为tagName是可重复的，不能用这个来进行对比。所以需要给子节点加上唯一标识key，列表对比的时候，使用key进行对比，这样才能复用老的 DOM 树上的节点。 这样，我们就可以通过深度优先遍历两棵树，每层的节点进行对比，记录下每个节点的差异了。完整 diff 算法代码可见 diff.js。 4.3 步骤三：把差异应用到真正的DOM树上 因为步骤一所构建的 JavaScript 对象树和render出来真正的DOM树的信息、结构是一样的。所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候从步骤二生成的patches对象中找出当前遍历的节点差异，然后进行 DOM 操作。 function patch (node, patches) { var walker = {index: 0} dfsWalk(node, walker, patches) } function dfsWalk (node, walker, patches) { var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异 var len = node.childNodes ? node.childNodes.length : 0 for (var i = 0; i applyPatches，根据不同类型的差异对当前节点进行 DOM 操作： function applyPatches (node, currentPatches) { currentPatches.forEach(function (currentPatch) { switch (currentPatch.type) { case REPLACE: node.parentNode.replaceChild(currentPatch.node.render(), node) break case REORDER: reorderChildren(node, currentPatch.moves) break case PROPS: setProps(node, currentPatch.props) break case TEXT: node.textContent = currentPatch.content break default: throw new Error('Unknown patch type ' + currentPatch.type) } }) } 完整代码可见 patch.js。 5 结语 Virtual DOM 算法主要是实现上面步骤的三个函数：element，diff，patch。然后就可以实际的进行使用： // 1. 构建虚拟DOM var tree = el('div', {'id': 'container'}, [ el('h1', {style: 'color: blue'}, ['simple virtal dom']), el('p', ['Hello, virtual-dom']), el('ul', [el('li')]) ]) // 2. 通过虚拟DOM构建真正的DOM var root = tree.render() document.body.appendChild(root) // 3. 生成新的虚拟DOM var newTree = el('div', {'id': 'container'}, [ el('h1', {style: 'color: red'}, ['simple virtal dom']), el('p', ['Hello, virtual-dom']), el('ul', [el('li'), el('li')]) ]) // 4. 比较两棵虚拟DOM树的不同 var patches = diff(tree, newTree) // 5. 在真正的DOM元素上应用变更 patch(root, patches) 当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的ReactJS了。 本文所实现的完整代码存放在 Github，仅供学习。 "},"框架通识/构建一个使用Virtual-DOM的前端模版引擎.html":{"url":"框架通识/构建一个使用Virtual-DOM的前端模版引擎.html","title":"构建一个使用Virtual-DOM的前端模版引擎","keywords":"","body":"深度剖析：如何实现一个 Virtual DOM 算法 深度剖析：如何实现一个 Virtual DOM 算法 1 前言 2 对前端应用状态管理的思考 3 Virtual DOM算法 4 算法实现 4.1 步骤一：用JS对象模拟DOM树 4.2 步骤二：比较两棵虚拟DOM树的差异 4.2.1 深度优先遍历，记录差异 4.2.2 差异类型 4.2.3 列表对比算法 4.3 步骤三：把差异应用到真正的DOM树上 5 结语 1 前言 本文会在教你怎么用 300~400 行代码实现一个基本的 Virtual DOM 算法，并且尝试尽量把 Virtual DOM 的算法思路阐述清楚。希望在阅读本文后，能让你深入理解 Virtual DOM 算法，给你现有前端的编程提供一些新的思考。 本文所实现的完整代码存放在 Github。 2 对前端应用状态管理的思考 假如现在你需要写一个像下面一样的表格的应用程序，这个表格可以根据不同的字段进行升序或者降序的展示。 这个应用程序看起来很简单，你可以想出好几种不同的方式来写。最容易想到的可能是，在你的 JavaScript 代码里面存储这样的数据： var sortKey = \"new\" // 排序的字段，新增（new）、取消（cancel）、净关注（gain）、累积（cumulate）人数 var sortType = 1 // 升序还是逆序 var data = [{...}, {...}, {..}, ..] // 表格数据 用三个字段分别存储当前排序的字段、排序方向、还有表格数据；然后给表格头部加点击事件：当用户点击特定的字段的时候，根据上面几个字段存储的内容来对内容进行排序，然后用 JS 或者 jQuery 操作 DOM，更新页面的排序状态（表头的那几个箭头表示当前排序状态，也需要更新）和表格内容。 这样做会导致的后果就是，随着应用程序越来越复杂，需要在JS里面维护的字段也越来越多，需要监听事件和在事件回调用更新页面的DOM操作也越来越多，应用程序会变得非常难维护。后来人们使用了 MVC、MVP 的架构模式，希望能从代码组织方式来降低维护这种复杂应用程序的难度。但是 MVC 架构没办法减少你所维护的状态，也没有降低状态更新你需要对页面的更新操作（前端来说就是DOM操作），你需要操作的DOM还是需要操作，只是换了个地方。 既然状态改变了要操作相应的DOM元素，为什么不做一个东西可以让视图和状态进行绑定，状态变更了视图自动变更，就不用手动更新页面了。这就是后来人们想出了 MVVM 模式，只要在模版中声明视图组件是和什么状态进行绑定的，双向绑定引擎就会在状态更新的时候自动更新视图（关于MV*模式的内容，可以看这篇介绍）。 MVVM 可以很好的降低我们维护状态 -> 视图的复杂程度（大大减少代码中的视图更新逻辑）。但是这不是唯一的办法，还有一个非常直观的方法，可以大大降低视图更新的操作：一旦状态发生了变化，就用模版引擎重新渲染整个视图，然后用新的视图更换掉旧的视图。就像上面的表格，当用户点击的时候，还是在JS里面更新状态，但是页面更新就不用手动操作 DOM 了，直接把整个表格用模版引擎重新渲染一遍，然后设置一下innerHTML就完事了。 听到这样的做法，经验丰富的你一定第一时间意识这样的做法会导致很多的问题。最大的问题就是这样做会很慢，因为即使一个小小的状态变更都要重新构造整棵 DOM，性价比太低；而且这样做的话，input和textarea的会失去原有的焦点。最后的结论会是：对于局部的小视图的更新，没有问题（Backbone就是这么干的）；但是对于大型视图，如全局应用状态变更的时候，需要更新页面较多局部视图的时候，这样的做法不可取。 但是这里要明白和记住这种做法，因为后面你会发现，其实 Virtual DOM 就是这么做的，只是加了一些特别的步骤来避免了整棵 DOM 树变更。 另外一点需要注意的就是，上面提供的几种方法，其实都在解决同一个问题：维护状态，更新视图。在一般的应用当中，如果能够很好方案来应对这个问题，那么就几乎降低了大部分复杂性。 3 Virtual DOM算法 DOM是很慢的。如果我们把一个简单的div元素的属性都打印出来，你会看到： 而这仅仅是第一层。真正的 DOM 元素非常庞大，这是因为标准就是这么设计的。而且操作它们的时候你要小心翼翼，轻微的触碰可能就会导致页面重排，这可是杀死性能的罪魁祸首。 相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单。DOM 树上的结构、属性信息我们都可以很容易地用 JavaScript 对象表示出来： var element = { tagName: 'ul', // 节点标签名 props: { // DOM的属性，用一个对象存储键值对 id: 'list' }, children: [ // 该节点的子节点 {tagName: 'li', props: {class: 'item'}, children: [\"Item 1\"]}, {tagName: 'li', props: {class: 'item'}, children: [\"Item 2\"]}, {tagName: 'li', props: {class: 'item'}, children: [\"Item 3\"]}, ] } 上面对应的HTML写法是： Item 1 Item 2 Item 3 既然原来 DOM 树的信息都可以用 JavaScript 对象来表示，反过来，你就可以根据这个用 JavaScript 对象表示的树结构来构建一棵真正的DOM树。 之前的章节所说的，状态变更->重新渲染整个视图的方式可以稍微修改一下：用 JavaScript 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 JavaScript 的对象结构。当然这样做其实没什么卵用，因为真正的页面其实没有改变。 但是可以用新渲染的对象树去和旧的树进行对比，记录这两棵树差异。记录下来的不同就是我们需要对页面真正的 DOM 操作，然后把它们应用在真正的 DOM 树上，页面就变更了。这样就可以做到：视图的结构确实是整个全新渲染了，但是最后操作DOM的时候确实只变更有不同的地方。 这就是所谓的 Virtual DOM 算法。包括几个步骤： 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了 Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）。 4 算法实现 4.1 步骤一：用JS对象模拟DOM树 用 JavaScript 来表示一个 DOM 节点是很简单的事情，你只需要记录它的节点类型、属性，还有子节点： element.js function Element (tagName, props, children) { this.tagName = tagName this.props = props this.children = children } module.exports = function (tagName, props, children) { return new Element(tagName, props, children) } 例如上面的 DOM 结构就可以简单的表示： var el = require('./element') var ul = el('ul', {id: 'list'}, [ el('li', {class: 'item'}, ['Item 1']), el('li', {class: 'item'}, ['Item 2']), el('li', {class: 'item'}, ['Item 3']) ]) 现在ul只是一个 JavaScript 对象表示的 DOM 结构，页面上并没有这个结构。我们可以根据这个ul构建真正的： Element.prototype.render = function () { var el = document.createElement(this.tagName) // 根据tagName构建 var props = this.props for (var propName in props) { // 设置节点的DOM属性 var propValue = props[propName] el.setAttribute(propName, propValue) } var children = this.children || [] children.forEach(function (child) { var childEl = (child instanceof Element) ? child.render() // 如果子节点也是虚拟DOM，递归构建DOM节点 : document.createTextNode(child) // 如果字符串，只构建文本节点 el.appendChild(childEl) }) return el } render方法会根据tagName构建一个真正的DOM节点，然后设置这个节点的属性，最后递归地把自己的子节点也构建起来。所以只需要： var ulRoot = ul.render() document.body.appendChild(ulRoot) 上面的ulRoot是真正的DOM节点，把它塞入文档中，这样body里面就有了真正的的DOM结构： Item 1 Item 2 Item 3 完整代码可见 element.js。 4.2 步骤二：比较两棵虚拟DOM树的差异 正如你所预料的，比较两棵DOM树的差异是 Virtual DOM 算法最核心的部分，这也是所谓的 Virtual DOM 的 diff 算法。两个树的完全的 diff 算法是一个时间复杂度为 O(n^3) 的问题。但是在前端当中，你很少会跨越层级地移动DOM元素。所以 Virtual DOM 只会对同一个层级的元素进行对比： 上面的div只会和同一层级的div对比，第二层级的只会跟第二层级对比。这样算法复杂度就可以达到 O(n)。 4.2.1 深度优先遍历，记录差异 在实际的代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个唯一的标记： 在深度优先遍历的时候，每遍历到一个节点就把该节点和新的的树进行对比。如果有差异的话就记录到一个对象里面。 // diff 函数，对比两棵树 function diff (oldTree, newTree) { var index = 0 // 当前节点的标志 var patches = {} // 用来记录每个节点差异的对象 dfsWalk(oldTree, newTree, index, patches) return patches } // 对两棵树进行深度优先遍历 function dfsWalk (oldNode, newNode, index, patches) { // 对比oldNode和newNode的不同，记录下来 patches[index] = [...] diffChildren(oldNode.children, newNode.children, index, patches) } // 遍历子节点 function diffChildren (oldChildren, newChildren, index, patches) { var leftNode = null var currentNodeIndex = index oldChildren.forEach(function (child, i) { var newChild = newChildren[i] currentNodeIndex = (leftNode && leftNode.count) // 计算节点的标识 ? currentNodeIndex + leftNode.count + 1 : currentNodeIndex + 1 dfsWalk(child, newChild, currentNodeIndex, patches) // 深度遍历子节点 leftNode = child }) } 例如，上面的div和新的div有差异，当前的标记是0，那么： patches[0] = [{difference}, {difference}, ...] // 用数组存储新旧节点的不同 同理p是patches[1]，ul是patches[3]，类推。 4.2.2 差异类型 上面说的节点的差异指的是什么呢？对 DOM 操作可能会： 替换掉原来的节点，例如把上面的div换成了section 移动、删除、新增子节点，例如上面div的子节点，把p和ul顺序互换 修改了节点的属性 对于文本节点，文本内容可能会改变。例如修改上面的文本节点2内容为Virtual DOM 2。 所以我们定义了几种差异类型： var REPLACE = 0 var REORDER = 1 var PROPS = 2 var TEXT = 3 对于节点替换，很简单。判断新旧节点的tagName和是不是一样的，如果不一样的说明需要替换掉。如div换成section，就记录下： patches[0] = [{ type: REPALCE, node: newNode // el('section', props, children) }] 如果给div新增了属性id为container，就记录下： patches[0] = [{ type: REPALCE, node: newNode // el('section', props, children) }, { type: PROPS, props: { id: \"container\" } }] 如果是文本节点，如上面的文本节点2，就记录下： patches[2] = [{ type: TEXT, content: \"Virtual DOM2\" }] 那如果把我div的子节点重新排序呢？例如p, ul, div的顺序换成了div, p, ul。这个该怎么对比？如果按照同层级进行顺序对比的话，它们都会被替换掉。如p和div的tagName不同，p会被div所替代。最终，三个节点都会被替换，这样DOM开销就非常大。而实际上是不需要替换节点，而只需要经过节点移动就可以达到，我们只需知道怎么进行移动。 这牵涉到两个列表的对比算法，需要另外起一个小节来讨论。 4.2.3 列表对比算法 假设现在可以英文字母唯一地标识每一个子节点： 旧的节点顺序： a b c d e f g h i 现在对节点进行了删除、插入、移动的操作。新增j节点，删除e节点，移动h节点： 新的节点顺序： a b c h d f g i j 现在知道了新旧的顺序，求最小的插入、删除操作（移动可以看成是删除和插入操作的结合）。这个问题抽象出来其实是字符串的最小编辑距离问题（Edition Distance），最常见的解决算法是 Levenshtein Distance，通过动态规划求解，时间复杂度为 O(M * N)。但是我们并不需要真的达到最小的操作，我们只需要优化一些比较常见的移动情况，牺牲一定DOM操作，让算法时间复杂度达到线性的（O(max(M, N))。具体算法细节比较多，这里不累述，有兴趣可以参考代码。 我们能够获取到某个父节点的子节点的操作，就可以记录下来： patches[0] = [{ type: REORDER, moves: [{remove or insert}, {remove or insert}, ...] }] 但是要注意的是，因为tagName是可重复的，不能用这个来进行对比。所以需要给子节点加上唯一标识key，列表对比的时候，使用key进行对比，这样才能复用老的 DOM 树上的节点。 这样，我们就可以通过深度优先遍历两棵树，每层的节点进行对比，记录下每个节点的差异了。完整 diff 算法代码可见 diff.js。 4.3 步骤三：把差异应用到真正的DOM树上 因为步骤一所构建的 JavaScript 对象树和render出来真正的DOM树的信息、结构是一样的。所以我们可以对那棵DOM树也进行深度优先的遍历，遍历的时候从步骤二生成的patches对象中找出当前遍历的节点差异，然后进行 DOM 操作。 function patch (node, patches) { var walker = {index: 0} dfsWalk(node, walker, patches) } function dfsWalk (node, walker, patches) { var currentPatches = patches[walker.index] // 从patches拿出当前节点的差异 var len = node.childNodes ? node.childNodes.length : 0 for (var i = 0; i applyPatches，根据不同类型的差异对当前节点进行 DOM 操作： function applyPatches (node, currentPatches) { currentPatches.forEach(function (currentPatch) { switch (currentPatch.type) { case REPLACE: node.parentNode.replaceChild(currentPatch.node.render(), node) break case REORDER: reorderChildren(node, currentPatch.moves) break case PROPS: setProps(node, currentPatch.props) break case TEXT: node.textContent = currentPatch.content break default: throw new Error('Unknown patch type ' + currentPatch.type) } }) } 完整代码可见 patch.js。 5 结语 Virtual DOM 算法主要是实现上面步骤的三个函数：element，diff，patch。然后就可以实际的进行使用： // 1. 构建虚拟DOM var tree = el('div', {'id': 'container'}, [ el('h1', {style: 'color: blue'}, ['simple virtal dom']), el('p', ['Hello, virtual-dom']), el('ul', [el('li')]) ]) // 2. 通过虚拟DOM构建真正的DOM var root = tree.render() document.body.appendChild(root) // 3. 生成新的虚拟DOM var newTree = el('div', {'id': 'container'}, [ el('h1', {style: 'color: red'}, ['simple virtal dom']), el('p', ['Hello, virtual-dom']), el('ul', [el('li'), el('li')]) ]) // 4. 比较两棵虚拟DOM树的不同 var patches = diff(tree, newTree) // 5. 在真正的DOM元素上应用变更 patch(root, patches) 当然这是非常粗糙的实践，实际中还需要处理事件监听等；生成虚拟 DOM 的时候也可以加入 JSX 语法。这些事情都做了的话，就可以构造一个简单的ReactJS了。 本文所实现的完整代码存放在 Github，仅供学习。 "},"框架通识/Object.defineProperty方法.html":{"url":"框架通识/Object.defineProperty方法.html","title":"Object.defineProperty方法","keywords":"","body":"Object.defineProperty方法 对象是由多个名/值对组成的无序的集合。对象中每个属性对应任意类型的值。 定义对象可以使用构造函数或字面量的形式： var obj = new Object; //obj = {} obj.name = \"张三\"; //添加描述 obj.say = function(){}; //添加行为 除了以上添加属性的方式，还可以使用Object.defineProperty定义新属性或修改原有的属性。 Object.defineProperty() 语法： Object.defineProperty(obj, prop, descriptor) 参数说明： obj：必需。 目标对象 prop：必需。 需定义或修改的属性的名字 descriptor：必需。 目标属性所拥有的特性 返回值： 传入函数的对象。即第一个参数obj 针对属性，我们可以给这个属性设置一些特性，比如是否只读不可以写；是否可以被for..in或Object.keys()遍历。 给对象的属性添加特性描述，目前提供两种形式：数据描述和存取器描述。 configurable enumerable value writable get set 数据描述符 Yes Yes Yes Yes No No 存取描述符 Yes Yes No No Yes Yes 数据描述 当修改或定义对象的某个属性的时候，给这个属性添加一些特性： var obj = { test:\"hello\" } //对象已有的属性添加特性描述 Object.defineProperty(obj,\"test\",{ configurable:true | false, enumerable:true | false, value:任意类型的值, writable:true | false }); //对象新添加的属性的特性描述 Object.defineProperty(obj,\"newKey\",{ configurable:true | false, enumerable:true | false, value:任意类型的值, writable:true | false }); 数据描述中的属性都是可选的，来看一下设置每一个属性的作用。 value 属性对应的值,可以使任意类型的值，默认为undefined var obj = {} //第一种情况：不设置value属性 Object.defineProperty(obj,\"newKey\",{ }); console.log( obj.newKey ); //undefined ------------------------------ //第二种情况：设置value属性 Object.defineProperty(obj,\"newKey\",{ value:\"hello\" }); console.log( obj.newKey ); //hello writable 属性的值是否可以被重写。设置为true可以被重写；设置为false，不能被重写。默认为false。 var obj = {} //第一种情况：writable设置为false，不能重写。 Object.defineProperty(obj,\"newKey\",{ value:\"hello\", writable:false }); //更改newKey的值 obj.newKey = \"change value\"; console.log( obj.newKey ); //hello //第二种情况：writable设置为true，可以重写 Object.defineProperty(obj,\"newKey\",{ value:\"hello\", writable:true }); //更改newKey的值 obj.newKey = \"change value\"; console.log( obj.newKey ); //change value enumerable 此属性是否可以被枚举（使用for...in或Object.keys()）。设置为true可以被枚举；设置为false，不能被枚举。默认为false。 var obj = {} //第一种情况：enumerable设置为false，不能被枚举。 Object.defineProperty(obj,\"newKey\",{ value:\"hello\", writable:false, enumerable:false }); //枚举对象的属性 for( var attr in obj ){ console.log( attr ); } //第二种情况：enumerable设置为true，可以被枚举。 Object.defineProperty(obj,\"newKey\",{ value:\"hello\", writable:false, enumerable:true }); //枚举对象的属性 for( var attr in obj ){ console.log( attr ); //newKey } configurable 是否可以删除目标属性或是否可以再次修改属性的特性（writable, configurable, enumerable）。 设置为true可以被删除或可以重新设置特性；设置为false，不能被可以被删除或不可以重新设置特性。默认为false。 configurable特性表示对象的属性是否可以被删除，以及除writable特性外的其他特性是否可以被修改。 这个属性起到两个作用： 1. 目标属性是否可以使用delete删除 2. 目标属性是否可以再次设置特性 //-----------------测试目标属性是否能被删除------------------------ var obj = {} //第一种情况：configurable设置为false，不能被删除。 Object.defineProperty(obj,\"newKey\",{ value:\"hello\", writable:false, enumerable:false, configurable:false }); //删除属性 delete obj.newKey; console.log( obj.newKey ); //hello //第二种情况：configurable设置为true，可以被删除。 Object.defineProperty(obj,\"newKey\",{ value:\"hello\", writable:false, enumerable:false, configurable:true }); //删除属性 delete obj.newKey; console.log( obj.newKey ); //undefined //-----------------测试是否可以再次修改特性------------------------ var obj = {} //第一种情况：configurable设置为false，不能再次修改特性。 Object.defineProperty(obj,\"newKey\",{ value:\"hello\", writable:false, enumerable:false, configurable:false }); //重新修改特性 Object.defineProperty(obj,\"newKey\",{ value:\"hello\", writable:true, enumerable:true, configurable:true }); console.log( obj.newKey ); //报错：Uncaught TypeError: Cannot redefine property: newKey //第二种情况：configurable设置为true，可以再次修改特性。 Object.defineProperty(obj,\"newKey\",{ value:\"hello\", writable:false, enumerable:false, configurable:true }); //重新修改特性 Object.defineProperty(obj,\"newKey\",{ value:\"hello\", writable:true, enumerable:true, configurable:true }); console.log( obj.newKey ); //hello 除了可以给新定义的属性设置特性，也可以给已有的属性设置特性 //定义对象的时候添加的属性，是可删除、可重写、可枚举的。 var obj = { test:\"hello\" } //改写值 obj.test = 'change value'; console.log( obj.test ); //'change value' Object.defineProperty(obj,\"test\",{ writable:false }) //再次改写值 obj.test = 'change value again'; console.log( obj.test ); //依然是：'change value' 提示：一旦使用Object.defineProperty给对象添加属性，那么如果不设置属性的特性，那么configurable、enumerable、writable这些值都为默认的false var obj = {}; //定义的新属性后，这个属性的特性中configurable，enumerable，writable都为默认的值false //这就导致了neykey这个是不能重写、不能枚举、不能再次设置特性 // Object.defineProperty(obj,'newKey',{ }); //设置值 obj.newKey = 'hello'; console.log(obj.newKey); //undefined //枚举 for( var attr in obj ){ console.log(attr); } configurable和writable 当configurable为false时，我们唯一仍能改变的属性就是将设置为true的writable设置为false。对此译者进行了以下测试（以下代码在Chrome和IE下运行论证，输出结果相同）： var a={}; Object.defineProperty(a,\"o\",{ configurable:false, value:10, writable:true }); console.log(a.o);//10 a.o=12;//不报错 console.log(a.o);//12 Object.defineProperty(a,\"o\",{ configurable:false, value:14, writable:true }); console.log(a.o);//14 Object.defineProperty(a,\"o\",{ configurable:false, value:14, writable:false }); a.o=16;//不报错 console.log(a.o);//14 //报错 Object.defineProperty(a,\"o\",{ configurable:false, value:16, writable:false }); 设置的特性总结： value: 设置属性的值 writable: 值是否可以重写。true | false enumerable: 目标属性是否可以被枚举。true | false configurable: 目标属性是否可以被删除或是否可以再次修改特性 true | false 存取器描述 当使用存取器描述属性的特性的时候，允许设置以下特性属性： var obj = {}; Object.defineProperty(obj,\"newKey\",{ get:function (){} | undefined, set:function (value){} | undefined configurable: true | false enumerable: true | false }); 注意：当使用了getter或setter方法，不允许使用writable和value这两个属性 getter/setter 当设置或获取对象的某个属性的值的时候，可以提供getter/setter方法。 getter 是一种获得属性值的方法 setter是一种设置属性值的方法。 在特性中使用get/set属性来定义对应的方法。 var obj = {}; var initValue = 'hello'; Object.defineProperty(obj,\"newKey\",{ get:function (){ //当获取值的时候触发的函数 return initValue; }, set:function (value){ //当设置值的时候触发的函数,设置的新值通过参数value拿到 initValue = value; } }); //获取值 console.log( obj.newKey ); //hello //设置值 obj.newKey = 'change value'; console.log( obj.newKey ); //change value 注意：get或set不是必须成对出现，任写其一就可以。如果不设置方法，则get和set的默认值为undefined configurable和enumerable同上面的用法。 一般的 Setters 和 Getters 为了保证这些描述符属性被填充为默认值，你可能会使用形如预先冻结Object.prototype、明确设置每个描述符属性的值、使用Object.create(null)来获取空对象等方式。 // using __proto__ var obj = {}; var descriptor = Object.create(null); // no inherited properties //所有描述符的属性被设置为默认值 descriptor.value = 'static'; Object.defineProperty(obj, 'key', descriptor); //明确设置每个描述符的属性 Object.defineProperty(obj, 'key', { enumerable: false, configurable: false, writable: false, value: 'static' }); //重用同一个对象作为描述符 function withValue(value) { var d = withValue.d || ( withValue.d = { enumerable: false, writable: false, configurable: false, value: null } ); d.value = value; return d; } Object.defineProperty(obj, 'key', withValue('static')); //如果Object.freeze方法可用，则使用它来防止对对象属性的修改 (Object.freeze || Object)(Object.prototype); 下面的例子展示了如何实现一个自存档对象。 当设置temperature 属性时，archive 数组会获取日志条目。 function Archiver() { var temperature = null; var archive = []; Object.defineProperty(this, 'temperature', { get: function() { console.log('get!'); return temperature; }, set: function(value) { temperature = value; archive.push({ val: temperature }); } }); this.getArchive = function() { return archive; }; } var arc = new Archiver(); arc.temperature; // 'get!' arc.temperature = 11; arc.temperature = 13; arc.getArchive(); // [{ val: 11 }, { val: 13 }] 或 var pattern = { get: function () { return 'I alway return this string,whatever you have assigned'; }, set: function () { this.myname = 'this is my name string'; } }; function TestDefineSetAndGet() { Object.defineProperty(this, 'myproperty', pattern); } var instance = new TestDefineSetAndGet(); instance.myproperty = 'test'; // 'I alway return this string,whatever you have assigned' console.log(instance.myproperty); // 'this is my name string' console.log(instance.myname); // 继承属性 继承属性 如果访问者的属性是被继承的，它的 get 和set 方法会在子对象的属性被访问或者修改时被调用。 如果这些方法用一个变量存值，该值会被所有对象共享。 function myclass() { } var value; Object.defineProperty(myclass.prototype, \"x\", { get() { return value; }, set(x) { value = x; } }); var a = new myclass(); var b = new myclass(); a.x = 1; console.log(b.x); // 1 这可以通过将值存储在另一个属性中固定。在 get 和 set 方法中，this 指向某个被访问和修改属性的对象。 function myclass() { } Object.defineProperty(myclass.prototype, \"x\", { get() { return this.stored_x; }, set(x) { this.stored_x = x; } }); var a = new myclass(); var b = new myclass(); a.x = 1; console.log(b.x); // undefined 不像访问者属性，值属性始终在对象自身上设置，而不是一个原型。 然而，如果一个不可写的属性被继承，它仍然可以防止修改对象的属性。 function myclass() { } myclass.prototype.x = 1; Object.defineProperty(myclass.prototype, \"y\", { writable: false, value: 1 }); var a = new myclass(); a.x = 2; console.log(a.x); // 2 console.log(myclass.prototype.x); // 1 a.y = 2; // Ignored, throws in strict mode console.log(a.y); // 1 console.log(myclass.prototype.y); // 1 "},"框架通识/Proxy.html":{"url":"框架通识/Proxy.html","title":"Proxy","keywords":"","body":"Proxy Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作 let p = new Proxy(target, handler); // `target` 代表需要添加代理的对象 // `handler` 用来自定义对象中的操作 可以很方便的使用 Proxy 来实现一个数据绑定和监听 let onWatch = (obj, setBind, getLogger) => { let handler = { get(target, property, receiver) { getLogger(target, property) return Reflect.get(target, property, receiver); }, set(target, property, value, receiver) { setBind(value); return Reflect.set(target, property, value); } }; return new Proxy(obj, handler); }; let obj = { a: 1 } let value let p = onWatch(obj, (v) => { value = v }, (target, property) => { console.log(`Get '${property}' = ${target[property]}`); }) p.a = 2 // bind `value` to `2` p.a // -> Get 'a' = 2 "},"框架通识/10分钟快速入门rollupJs1.html":{"url":"框架通识/10分钟快速入门rollupJs1.html","title":"10分钟快速入门rollup(1)","keywords":"","body":"10分钟快速入门rollup.js 10分钟快速入门rollup.js 为什么要学习rollup.js rollup.js的工作原理 安装rollup.js 全局安装rollup.js rollup.js打包实例 验证rollup.js打包结果 rollup.js配置文件 rollup.js api打包 编写rollup.js配置 编写rollup.js build代码 总结 为什么要学习rollup.js rollup.js是Javascript的ES模块打包器，我们熟知的Vue、React等诸多知名框架或类库都通过rollup.js进行打包。与Webpack偏向于应用打包的定位不同，rollup.js更专注于Javascript类库打包（虽然rollup.js也可以提供资源打包，但显然这不是它的强项）。在我们学习Vue和React等框架源码或者自己编写Javascript类库时，rollup.js是一条必经之路。 rollup.js的工作原理 rollup.js可以将我们自己编写的Javascript代码（通过插件可以支持更多语言，如Tyepscript）与第三方模块打包在一起，形成一个文件，该文件可以是一个库（Library）或者一个应用（App），在打包过程中可以应用各类插件实现特定功能。下图揭示了rollup.js的运行机制： rollup.js默认采用ES模块标准，我们可以通过rollup-plugin-commonjs插件使之支持CommonJS标准。 安装rollup.js 全局安装rollup.js 首先全局安装rollup： npm i rollup -g rollup.js打包实例 安装成功后，我们尝试使用rollup做一个简单的案例，创建src目录： mkdir src 在src目录下创建a.js： vim src/a.js 写入如下代码，这个模块非常简单，仅仅对外暴露一个变量a： const a = 1 export default a 在src目录下再创建main.js： vim src/main.js 写入如下代码，这个模块会引入模块a，并对外暴露一个function： import a from './a.js' export default function() { console.log(a) } 通过rollup指令，我们可以快速地预览打包后的源码，这点和babel非常类似： $ rollup src/main.js -f es src/main.js stdout... const a = 1; function main() { console.log(a); } export default main; created stdout in 26ms 需要注意的是rollup必须带有-f参数，否则会报错： $ rollup src/main.js src/main.js stdout... [!] Error: You must specify output.format, which can be one of 'amd', 'cjs', 'system', 'esm', 'iife' or 'umd' https://rollupjs.org/guide/en#output-format-f-format rollup的报错提示非常棒，非常有利于我们定位错误和修复问题。通过上面的错误提示，我们了解到-f的值可以为’amd’、‘cjs’、‘system’、‘esm’（'es’也可以）、'iife’或’umd’中的任何一个。-f参数是--format的缩写，它表示生成代码的格式，amd表示采用AMD标准，cjs为CommonJS标准，esm（或es）为ES模块标准。接着我们把这段代码输出到一个文件中： $ rollup src/main.js -f es -o dist/bundle.js src/main.js dist/bundle.js... created dist/bundle.js in 29ms 参数-o指定了输出的路径，这里我们将打包后的文件输出到dist目录下的bundle.js，这个文件内容与我们之前预览的内容是完全一致的。我们再输出一份CommonJS格式的代码： $ rollup src/main.js --format cjs --output.file dist/bundle-cjs.js src/main.js dist/bundle-cjs.js... created dist/bundle-cjs.js in 27ms 参数--output.file是-o的全称，它们是等价的，输出后我们在dist目录下会多一个bundle-cjs.js文件，查看这个文件的内容： 'use strict'; const a = 1; function main() { console.log(a); } module.exports = main; 可以看到代码采用CommonJS标准编写，并且将a.js和main.js两个文件进行了融合。 验证rollup.js打包结果 在打包成功后，我们尝试运行dist/bundle-cjs.js代码： $ node > const m = require('./dist/bundle-cjs.js') > m() 1 我们接着尝试运行之前输出的ES标准代码dist/bundle.js，由于nodejs并不支持ES标准，直接运行会报错： $ node > require('./dist/bundle.js')() /Users/sam/Desktop/rollup-test/dist/bundle.js:7 export default main; ^^^^^^ SyntaxError: Unexpected token export babel为我们提供了一个工具：babel-node，它可以在运行时将ES标准的代码转换为CommonJS格式，从而使得运行ES标准的代码成为可能，首先全局安装babel-node及相关工具，@babel/node包含babel-node，@babel/cli包含babel，而这两个工具都依赖@babel/core，所以建议都安装： npm i @babel/core @babel/node @babel/cli -g 这里要注意的是babel 7改变了npm包的名称，之前的babel-core和babel-cli已经被弃用，所以安装老版本babel的同学建议先卸载： npm uninstall babel-cli babel-core -g 然后到代码的根目录下，初始化项目： npm init 一路回车后，在代码根目录下创建babel的配置文件.babelrc，写入如下配置 { \"presets\": [\"@babel/preset-env\"] } 完成babel配置后安装babel的依赖： npm i -D @babel/core @babel/preset-env 尝试通过babel编译代码： $ babel dist/bundle.js \"use strict\"; Object.defineProperty(exports, \"__esModule\", { value: true }); exports.default = void 0; var a = 1; function main() { console.log(a); } var _default = main; exports.default = _default; 可以看到ES模块代码被编译成了CommonJS格式，下面通过babel-node运行代码： $ babel-node > require('./dist/bundle.js') { default: [Function: main] } > require('./dist/bundle.js').default() 1 注意babel会认为export default function()是一个名称为default的函数，如果想更改这个函数名称，可以修改main.js： import a from './a.js' export function test() { console.log(a) } 重写打包后通过babel-node运行： $ rollup -f es --file dist/bundle.js src/main.js src/main.js dist/bundle.js... created dist/bundle.js in 26ms $ babel-node > require('./dist/bundle.js').test() 1 注意这里的--file定价于-o和--output.file，通过上述案例，我们完成了rollup打包的基本操作，并验证了打包结果。但很多时候我们不会这样操作，因为直接使用命令行功能单一，而且无法使用插件，所以我们需要借助配置文件来操作。 rollup.js配置文件 首先在代码根目录下创建rollup.config.js文件： touch rollup.config.js 写入如下配置： export default { input: './src/main.js', output: [{ file: './dist/index-cjs.js', format: 'cjs', banner: '// welcome to imooc.com', footer: '// powered by sam' }, { file: './dist/index-es.js', format: 'es', banner: '// welcome to imooc.com', footer: '// powered by sam' }] } rollup的配置文件非常容易理解，这里有几点需要说明： rollup的配置文件需要采用ES模块标准编写 input表示入口文件的路径（老版本为entry，已经废弃） output表示输出文件的内容，它允许传入一个对象或一个数组，当为数组时，依次输出多个文件，它包含以下内容： output.file：输出文件的路径（老版本为dest，已经废弃） output.format：输出文件的格式 output.banner：文件头部添加的内容 output.footer：文件末尾添加的内容 通过rollup -c指令进行打包，rollup.js会自动寻找名称为rollup.config.js的配置文件： $ rollup -c ./src/main.js ./dist/index-cjs.js, ./dist/index-es.js... created ./dist/index-cjs.js, ./dist/index-es.js in 13ms 查看dist/index-es.js文件： // welcome to imooc.com const a = 1; function test() { console.log(a); } export { test }; // powered by sam 代码的内容与命令行生成的无异，但头部和末尾添加了自定义的注释信息。接着我们修改配置文件的名称，并通过-c参数指定配置文件进行打包： $ mv rollup.config.js rollup.config.dev.js $ rollup -c rollup.config.dev.js ./src/main.js ./dist/index-cjs.js, ./dist/index-es.js... created ./dist/index-cjs.js, ./dist/index-es.js in 13ms rollup.js api打包 编写rollup.js配置 很多时候命令行和配置文件的打包方式无法满足需求，我们需要更加个性化的打包方式，这时我们可以考虑通过rollup.js的api进行打包，创建rollup-input-options.js，这是输入配置，我们单独封装一个模块，提高复用性和可扩展性： touch rollup-input-options.js 在输入配置文件中加入以下内容，需要注意的是这个文件必须为CommonJS格式，因为需要使用nodejs来执行： module.exports = { input: './src/main.js' } 再添加一个输出配置文件： touch rollup-output-options.js 在输出配置文件我们仍然使用一个数组，实现多种文件格式的输出，需要注意的是umd格式必须指定模块的名称，通过name属性来实现： module.exports = [{ file: './dist/index-cjs.js', format: 'cjs', banner: '// welcome to imooc.com', footer: '// powered by sam' }, { file: './dist/index-es.js', format: 'es', banner: '// welcome to imooc.com', footer: '// powered by sam', }, { file: './dist/index-amd.js', format: 'amd', banner: '// welcome to imooc.com', footer: '// powered by sam', }, { file: './dist/index-umd.js', format: 'umd', name: 'sam-umd', // 指定文件名称 banner: '// welcome to imooc.com', footer: '// powered by sam', }] 编写rollup.js build代码 接下来我们要在当前项目中安装rollup库： i -D rollup 创建一个rollup-build文件，通过这个文件来调用rollup的api： touch rollup-build.js rollup-build的源码如下： const rollup = require('rollup') const inputOptions = require('./rollup-input-options') const outputOptions = require('./rollup-output-options') async function rollupBuild(input, output) { const bundle = await rollup.rollup(input) // 根据input配置进行打包 console.log(`正在生成：${output.file}`) await bundle.write(output) // 根据output配置输出文件 console.log(`${output.file}生成成功！`) } (async function () { for (let i = 0; i 代码的核心有两点： 通过rollup.rollup(input)得到打包对象 通过bundle.write(output)输出打包文件 这里我们还可以通过async和await实现同步操作，因为bundle.write(output)是异步的，会返回Promise对象，我们可以借助async机制实现按配置顺序依次打包。执行rollup-build文件： $ node rollup-build.js 正在生成：./dist/index-cjs.js ./dist/index-cjs.js生成成功！ 正在生成：./dist/index-es.js ./dist/index-es.js生成成功！ 正在生成：./dist/index-amd.js ./dist/index-amd.js生成成功！ 正在生成：./dist/index-umd.js ./dist/index-umd.js生成成功！ 查看dist/index-umd.js文件： (function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (factory((global['sam-umd'] = {}))); }(this, (function (exports) { // ... } 可以看到index-umd.js文件中在global全局变量中添加了sam-umd属性，这就是我们之前需要在umd配置中添加name属性的原因。 总结 本文向大家介绍了rollup.js的三种打包方式：命令行、配置文件和API，在下一篇教程中我将继续为大家介绍更多rollup.js的特性，如Tree-shaking、watch等，还会详细演示各种插件的用途及用法，敬请关注。 "},"框架通识/谈谈JavaScript中的双向数据绑定.html":{"url":"框架通识/谈谈JavaScript中的双向数据绑定.html","title":"谈谈JavaScript中的双向数据绑定","keywords":"","body":"谈谈JavaScript中的双向数据绑定 谈谈JavaScript中的双向数据绑定 原理 使用jQuery的简单实现 不使用jQuery来创建数据双向绑定 原理 双向数据绑定指的是将对象属性变化绑定到UI，或者反之。换句话说，如果我们有一个拥有name属性的user对象，当我们给user.name赋予一个新值是UI也会相应的显示新的名字。同样的，如果UI包括了一个输入字段用来输入用户名，输入一个新的值会导致user对象中的那么属性发生变化。 双向数据绑定底层的思想非常的基本，它可以被压缩成为三个步骤： 我们需要一个方法来识别哪个UI元素被绑定了相应的属性 我们需要监视属性和UI元素的变化 我们需要将所有变化传播到绑定的对象和元素 虽然实现的方法有很多，但是最简单也是最有效的途径是使用发布者-订阅者模式。 思想很简单：我们可以使用自定义的data属性在HTML代码中指明绑定。所有绑定起来的JavaScript对象以及DOM元素都将“订阅”一个发布者对象。任何时候如果JavaScript对象或者一个HTML输入字段被侦测到发生了变化，我们将代理事件到发布者-订阅者模式，这会反过来将变化广播并传播到所有绑定的对象和元素。 使用jQuery的简单实现 使用jQuery来实现双向数据绑定非常的直接且简单，因为这个流行的库能够是我们轻松的订阅和发布DOM事件，以及我们自定义的事件： function DataBinder(object_id){ //使用一个jQuery对象作为简单的订阅者发布者 var pubSub = jQuery({}); //我们希望一个data元素可以在表单中指明绑定：data-bind-=\"\" var data_attr = \"bind-\" + object_id, message = object_id + \":change\"; //使用data-binding属性和代理来监听那个元素上的变化事件 // 以便变化能够“广播”到所有的关联对象 jQuery(document).on(\"change\",\"[data-\" + data_attr + \"]\",function(evt){ var input = jQuery(this); pubSub.trigger(message, [ $input.data(data_attr),$input.val()]); }); //PubSub将变化传播到所有的绑定元素，设置input标签的值或者其他标签的HTML内容 pubSub.on(message,function(evt,prop_name,new_val){ jQuery(\"[data-\" + data_attr + \"=\" + prop_name + \"]\").each(function(){ var $bound = jQuery(this); if($bound.is(\"input,text area,select\")){ $bound.val(new_val); }else{ $bound.html(new_val); } }); }); return pubSub; } 在这个实验中可以按照以下代码简单的实现一个User模型： function User(uid){ var binder = new DataBinder(uid), user = { atttibutes: {}, //属性设置器使用数据绑定器PubSub来发布变化 set: function(attr_name,val){ this.attriures[attr_name] = val; binder.trigger(uid + \":change\", [attr_name, val, this]); }, get: function(attr_name){ return this.attributes[attr_name]; }, _binder: binder }; binder.on(uid +\":change\",function(vet,attr_name,new_val,initiator){ if(initiator !== user){ user.set(attr_name,new_val); } }) } 现在，无论我们什么时候想把模型的属性绑定到UI的一部分上，我们只需要在相应的HTML元素上设置一个合适的data属性即可。 //JavaScript var user = new User(123); user.set(\"name\",\"Wolfgang\"); //html input字段的值会自动反映出user对象的name属性，反之亦然。任务完成了！ 不使用jQuery来创建数据双向绑定 使用原生的JavaScript来实现一个自定义的PubSub以及观察DOM事件。 function DataBinder(object_id){ //创建一个简单地PubSub对象 var pubSub = { callbacks: {}. on: function(msg,calssback){ this.callbacks[msg] = this.callbacks[msg] || []; this.callbacks[msg].push(callback); }, publish: function(msg){ this.callbacks[msg] = this.callbacks[msg] || []; for(var i = 0, len = this.callbacks[msg].length; i 模型可以和勤勉你的例子保持一直，除了在设置器中调用那个jQuery的trigger方法之外，它需要通过调用一个自定义的PubSub的publish方法来实现： //在model的设置器中 function User(uid){ //... user = { //... set: function(attr_name,val){ this.attribute[attr_name] = val; //使用“publish”方法 binder.publish(uid+ \":change\", attr_name, val,this); } } //... } "},"框架通识/MVC-VS-Flux.html":{"url":"框架通识/MVC-VS-Flux.html","title":"MVC VS Flux","keywords":"","body":"MVC VS Flux MVC VS Flux MVC简介 MVC的局限 Flux Flux代码 View Actions Store MVC简介 MVC架构讲程序划分为三个角色，从上到下依次为： View: 视图，用户数据展示，同时接受用户输入 Contorller：响应用户的输入，对数据进行操作， Model：负责管理程序需要的数据，并且定义了操作数据的行为。 对于一个简单的MVC架构程序来说，其工作流程如下： 从最右边的View开始，当用户在UI上进行操作之后，用户的操作被转发到了Controller上，Controller根据用户的操作对数据进行更新(准确来说是调用Model层的API)，数据更新之后自然视图View展现的内容也需要进行更新。Model层此时可以向所有关联的视图发出通知，收到通知的视图重新获取最新的数据。注意这最后一步Model与View的交互，大部分现有的MVC框架将其进行了封装，开发人员只要使用数据绑定即可。 如果上面的流程图还过于抽象的话，我们可以看一段MVC项目的代码，比如基于Nodejs的Kraken框架的Shopping_Cart示例项目中的controller controllers/index.js： var Product = require('../models/productModel'); module.exports = function (server) { server.get('/', function (req, res) { Product.find(function (err, prods) { if (err) { console.log(err); } var model = { products: prods }; res.render('index', model); }); }); }; 由于这是一个后端框架，用户的操作只能通过url路径体现。当用户访问/路径时，首页index.html对应的controller，也就是该controllers/index.js收到请求，它调用Model层的Product模块的find方法请求数据，并将或得到的数据交给index模板进行重新渲染，产生的页面返回给用户。 为了和flux做比较，在这里我们要强调几点： 通常View和Controller的关系是一一对应的，比如首页index.html有自己的controllercontrollers/index.js，查询页面search.html有自己的controllercontrollers/search.js。从下面这段angular的路由代码就是很典型的示例： phonecatApp.config(['$routeProvider', function($routeProvider) { $routeProvider. when('/phones', { templateUrl: 'partials/phone-list.html', controller: 'PhoneListCtrl' }). when('/phones/:phoneId', { templateUrl: 'partials/phone-detail.html', controller: 'PhoneDetailCtrl' }). otherwise({ redirectTo: '/phones' }); }]); controller是有业务逻辑的。虽然在MVC中我们强调\"fat model, skinny controller\"(业务逻辑应尽量放在Model层，Controller只应该作为View与Model的接口)，但skinny并不代表none，controller中还是有与业务相关的逻辑来决定将如何转发用户的请求，最典型的决定是转发到哪个Model层。 Model应该被更准确的称为Domain Model(领域模型)，它不代表具体的Class或者Object，也不是单纯的databse。而是一个“层”的概念：数据在Model里得到存储，Model提供方法操作数据(Model的行为)。所以Model代码可以有业务逻辑，甚至可以有数据的存储操作的底层服务代码。 MVC中的数据流是双向的，模型通知视图数据已经更新，视图直接查询模型中的数据。 MVC的局限 上小节单组MVC(View、Model、Controller是1:1:1的关系)只是一种理想状态。现实中的程序往往是多视图，多模型。更严重的是视图与模型之间还可以是多对多的关系。也就是说，单个视图的数据可以来自多个模型，单个模型更新是需要通知多个视图，用户在视图上的操作可以对多个模型造成影响。可以想象最致命的后果是，视图与模型之间相互更新的死循环。 Flux 一个简单的flux流程图如下所示： 参照上面的图示，我们首先总结一下，flux架构下一共有四类模块角色，按照交互顺序依次是： Component/View: 你可以把组件(Component)理解为View与Controller的结合，它既展现数据，同时也处理用户的交互请求。不同于MVC的Controller直接调用模型层业务逻辑处理接口，flux上来自用户的操作或者请求最终会映射为对应的Action，交由Action进行下一步处理。另一点需要注意的是View同时也监听着Store中数据的更改事件，一旦发生更改则重新请求数据。 Action：描述组件触发的操作，包括名称和数据，比如{ 'actionType': 'delete', 'data': item} Dispatcher: flux的中央枢纽(central hub)，所有的Action都会交由Dispatcher进行处理。Dispatcher在接收到Action之后，调用Store注册在Action上的回调函数。需要注意与MVC中Controller不同的是，Dispatcher是不包含业务逻辑的，它机械的像一座桥，一个路由器，所以它能被别的程序复用当然也能被别的Dispatcher替换。 Store：包含程序的数据与业务逻辑。和MVC的Model比较，Store有一些不易被察觉但又非常重要的差异：MVC中的每一个model即对应着一个领域模型；而flux中的一个Store自己并不是一个领域模型，而是可能包含多个模型。最重要的是，只有store自己知道如何修改数据，它并不对外直接提供操作数据的接口(但是提供查询数据的接口)，action和dispatcher没法操作store. 一个简单的flux流程我们可以这么描述：用户在View上的操作最终会映射为一类Action，Action传递给Dispatcher，再由Dispatcher执行注册在指定Action上的回调函数。最终完成对Store的操作。如果Store中的数据发生了更改，则触发数据更改的事件，View监听着这些时间，并对这些事件做出反应（比如重新查询数据）。 当有多个Store和View被添加后，复杂的flux流程图如下图所示 如果上图还是让你感觉到复杂的话，我们继续抽象flux流程如下： 由此可见即使是复杂的flux应用，它的数据流和程序的运作过程仍然是清晰可辨的。 Flux代码 View 我们从最简单的场景出发，假设页面上只有一个按钮，我们通过这个按钮向store里添加一条数据。这里视图我们通过Reactjs实现： var View = React.createClass({ addNewItem: function (event) { Dispatcher.dispatch({ action: 'add_item', data: {date: +new Date} }); }, render: function(){ return ( Add Item ) } }); 在按钮的点击事件中我们触发了add_item事件。只不过触发事件是直接通过调用Dispatcher来实现。 Actions 在上面的视图代码中，我们直接调用了Dispatcher的方法。但这样的代码耦合太强了。View其实无需感知Dispatcher，这里我们更是直接把Dispatcher的细节暴露给了View，同时action也没有被抽象出来。 接下来我们把Action抽象出来 var Actions = { add: function (item) { Dispatcher.dispatch({ action: 'add_item', data: item }); } } 此时的View也要修改为： var View = React.createClass({ addNewItem: function (event) { Actions.add({ date: +new Date }); }, render: function(){ return ( Add Item ) } }); Store Store负责存储并更新数据，它需要监听Dispatcher上触发的action并做出响应： var Store = { items: [] } Dispatcher.register(function(payload) { switch(payload.action) { case 'add_item': // 当事件名为“添加”时，向仓库里添加数据 Store.items.push(payload.data); // 同时触发“数据已更改”的事件 Store.triggerEvent('change'); break; } }); 当Store更新完数据之后，它还需要触发一个数据更新的事件，以告知那些关注这些数据的人。如果我们的视图需要在数据更改后时时更新数据，则还需要在Store注册数据更改事件的回调函数 var View = React.createClass({ update: function () { // TODO }, componentDidMount: function() { Store.bind('change', this.update); }, addNewItem: function (event) { Actions.add({ date: +new Date }); }, render: function(){ return ( Add Item ) } }); "},"框架通识/路由实现.html":{"url":"框架通识/路由实现.html","title":"路由实现","keywords":"","body":"前端路由的实现 前端路由的实现 前言 1.hash路由 1.1 初始化class 1.2 实现路由hash储存与执行 1.3 监听对应事件 2.增加回退功能 2.1 实现后退功能 2.2 完整实现hash Router 2.3完整示例 3. HTML5新路由方案 3.1 History API 3.2 新标准下路由的实现 3.3完整代码 小结 基于hash的前端路由实现 基于hash的前端路由升级 基于H5 History的前端路由实现 前言 前端路由是现代SPA应用必备的功能,每个现代前端框架都有对应的实现,例如vue-router、react-router。 我们不想探究vue-router或者react-router们的实现，因为不管是哪种路由无外乎用兼容性更好的hash实现或者是H5 History实现，与框架几个只需要做相应的封装即可。 提前声明: 我们没有对传入的参数进行及时判断而规避错误,也没有考虑兼容性问题,仅仅对核心方法进行了实现. 1.hash路由 hash路由一个明显的标志是带有#,我们主要是通过监听url中的hash变化来进行路由跳转。 hash的优势就是兼容性更好,在老版IE中都有运行,问题在于url中一直存在#不够美观,而且hash路由更像是Hack而非标准,相信随着发展更加标准化的History API会逐步蚕食掉hash路由的市场。 1.1 初始化class 我们用Class关键字初始化一个路由. class Routers { constructor() { // 以键值对的形式储存路由 this.routes = {}; // 当前路由的URL this.currentUrl = ''; } } 1.2 实现路由hash储存与执行 在初始化完毕后我们需要思考两个问题: 将路由的hash以及对应的callback函数储存 触发路由hash变化后,执行对应的callback函数 class Routers { constructor() { this.routes = {}; this.currentUrl = ''; } // 将path路径与对应的callback函数储存 route(path, callback) { this.routes[path] = callback || function() {}; } // 刷新 refresh() { // 获取当前URL中的hash路径 this.currentUrl = location.hash.slice(1) || '/'; // 执行当前hash路径的callback函数 this.routes[this.currentUrl](); } } 1.3 监听对应事件 那么我们只需要在实例化Class的时候监听上面的事件即可. class Routers { constructor() { this.routes = {}; this.currentUrl = ''; this.refresh = this.refresh.bind(this); window.addEventListener('load', this.refresh, false); window.addEventListener('hashchange', this.refresh, false); } route(path, callback) { this.routes[path] = callback || function() {}; } refresh() { this.currentUrl = location.hash.slice(1) || '/'; this.routes[this.currentUrl](); } } 对应效果如下: 2.增加回退功能 上一节我们只实现了简单的路由功能,没有我们常用的回退与前进功能,所以我们需要进行改造。 2.1 实现后退功能 我们在需要创建一个数组history来储存过往的hash路由例如/blue,并且创建一个指针currentIndex来随着后退和前进功能移动来指向不同的hash路由。 class Routers { constructor() { // 储存hash与callback键值对 this.routes = {}; // 当前hash this.currentUrl = ''; // 记录出现过的hash this.history = []; // 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash this.currentIndex = this.history.length - 1; this.refresh = this.refresh.bind(this); this.backOff = this.backOff.bind(this); window.addEventListener('load', this.refresh, false); window.addEventListener('hashchange', this.refresh, false); } route(path, callback) { this.routes[path] = callback || function() {}; } refresh() { this.currentUrl = location.hash.slice(1) || '/'; // 将当前hash路由推入数组储存 this.history.push(this.currentUrl); // 指针向前移动 this.currentIndex++; this.routes[this.currentUrl](); } // 后退功能 backOff() { // 如果指针小于0的话就不存在对应hash路由了,因此锁定指针为0即可 this.currentIndex 问题在于,我们每次在后退都会执行相应的callback,这会触发refresh()执行,因此每次我们后退,history中都会被push新的路由hash,currentIndex也会向前移动,这显然不是我们想要的。 refresh() { this.currentUrl = location.hash.slice(1) || '/'; // 将当前hash路由推入数组储存 this.history.push(this.currentUrl); // 指针向前移动 this.currentIndex++; this.routes[this.currentUrl](); } 如图所示,我们每次点击后退,对应的指针位置和数组被打印出来 2.2 完整实现hash Router 我们必须做一个判断,如果是后退的话,我们只需要执行回调函数,不需要添加数组和移动指针。 class Routers { constructor() { // 储存hash与callback键值对 this.routes = {}; // 当前hash this.currentUrl = ''; // 记录出现过的hash this.history = []; // 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash this.currentIndex = this.history.length - 1; this.refresh = this.refresh.bind(this); this.backOff = this.backOff.bind(this); // 默认不是后退操作 this.isBack = false; window.addEventListener('load', this.refresh, false); window.addEventListener('hashchange', this.refresh, false); } route(path, callback) { this.routes[path] = callback || function() {}; } refresh() { this.currentUrl = location.hash.slice(1) || '/'; if (!this.isBack) { // 如果不是后退操作,且当前指针小于数组总长度,直接截取指针之前的部分储存下来 // 此操作来避免当点击后退按钮之后,再进行正常跳转,指针会停留在原地,而数组添加新hash路由 // 避免再次造成指针的不匹配,我们直接截取指针之前的数组 // 此操作同时与浏览器自带后退功能的行为保持一致 if (this.currentIndex 前进的部分就不实现了,思路我们已经讲得比较清楚了,可以看出来,hash路由这种方式确实有点繁琐,所以HTML5标准提供了History API供我们使用。 2.3完整示例 class Routers { constructor() { // 储存hash与callback键值对 this.routes = {}; // 当前hash this.currentUrl = ''; // 记录出现过的hash this.history = []; // 作为指针,默认指向this.history的末尾,根据后退前进指向history中不同的hash this.currentIndex = this.history.length - 1; this.refresh = this.refresh.bind(this); this.backOff = this.backOff.bind(this); // 默认不是后退操作 this.isBack = false; window.addEventListener('load', this.refresh, false); window.addEventListener('hashchange', this.refresh, false); } route(path, callback) { this.routes[path] = callback || function() {}; } refresh() { this.currentUrl = location.hash.slice(1) || '/'; if (!this.isBack) { // 如果不是后退操作,且当前指针小于数组总长度,直接截取指针之前的部分储存下来 // 此操作来避免当点击后退按钮之后,再进行正常跳转,指针会停留在原地,而数组添加新hash路由 // 避免再次造成指针的不匹配,我们直接截取指针之前的数组 // 此操作同时与浏览器自带后退功能的行为保持一致 if (this.currentIndex 3. HTML5新路由方案 3.1 History API 我们可以直接在浏览器中查询出History API的方法和属性。 当然,我们常用的方法其实是有限的,如果想全面了解可以去MDN查询History API的资料。 我们只简单看一下常用的API window.history.back(); // 后退 window.history.forward(); // 前进 window.history.go(-3); // 后退三个页面 history.pushState用于在浏览历史中添加历史记录,但是并不触发跳转,此方法接受三个参数，依次为： state:一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。 title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。 url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。 history.replaceState方法的参数与pushState方法一模一样，区别是它修改浏览历史中当前纪录,而非添加记录,同样不触发跳转。 popstate事件,每当同一个文档的浏览历史（即history对象）出现变化时，就会触发popstate事件。 需要注意的是，仅仅调用pushState方法或replaceState方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用back、forward、go方法时才会触发。 另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。 以上API介绍选自history对象,可以点击查看完整版,我们不想占用过多篇幅来介绍API。 3.2 新标准下路由的实现 上一节我们介绍了新标准的History API,相比于我们在Hash 路由实现的那些操作,很显然新标准让我们的实现更加方便和可读。 所以一个mini路由实现起来其实很简单 class Routers { constructor() { this.routes = {}; // 在初始化时监听popstate事件 this._bindPopState(); } // 初始化路由 init(path) { history.replaceState({path: path}, null, path); this.routes[path] && this.routes[path](); } // 将路径和对应回调函数加入hashMap储存 route(path, callback) { this.routes[path] = callback || function() {}; } // 触发路由对应回调 go(path) { history.pushState({path: path}, null, path); this.routes[path] && this.routes[path](); } // 监听popstate事件 _bindPopState() { window.addEventListener('popstate', e => { const path = e.state && e.state.path; this.routes[path] && this.routes[path](); }); } } 3.3完整代码 class Routers { constructor() { this.routes = {}; this._bindPopState(); } init(path) { history.replaceState({path: path}, null, path); this.routes[path] && this.routes[path](); } route(path, callback) { this.routes[path] = callback || function() {}; } go(path) { history.pushState({path: path}, null, path); this.routes[path] && this.routes[path](); } _bindPopState() { window.addEventListener('popstate', e => { const path = e.state && e.state.path; this.routes[path] && this.routes[path](); }); } } window.Router = new Routers(); Router.init(location.pathname); const content = document.querySelector('body'); const ul = document.querySelector('ul'); function changeBgColor(color) { content.style.backgroundColor = color; } Router.route('/', function() { changeBgColor('yellow'); }); Router.route('/blue', function() { changeBgColor('blue'); }); Router.route('/green', function() { changeBgColor('green'); }); ul.addEventListener('click', e => { if (e.target.tagName === 'A') { e.preventDefault(); Router.go(e.target.getAttribute('href')); } }); 小结 我们大致探究了前端路由的两种实现方法,在没有兼容性要求的情况下显然符合标准的History API实现的路由是更好的选择。 想更深入了解前端路由实现可以阅读vue-router代码，除去开发模式代码、注释和类型检测代码，核心代码并不多，适合阅读。 "},"框架通识/使用EventEmitter2[观察者模式]构建前端应用.html":{"url":"框架通识/使用EventEmitter2[观察者模式]构建前端应用.html","title":"使用EventEmitter2(观察者模式)构建前端应用","keywords":"","body":"使用EventEmitter2（观察者模式）构建前端应用 观察者模式在前端中的表现形式——事件机制 这里的“事件”，实际上是指“观察者模式（Observer Pattern）”在前端的一种呈现方式。所谓观察者模式可以类比博客“订阅/推送”，你通过RSS订阅了某个博客，那么这个博客有新的博文就会自动推送给你；当你退订阅这个博客，那么就不会再推送给你。 用JavaScript代码可以怎么表示这么一个场景？ var blog = new Blog; // 假设已有一个Blog类实现subscribe、publish、unsubscribe方法 var readerFunc1 = function(blogContent) { console.log(blogContent + \" will be shown here.\"); } var readerFunc2 = function(blogContent) { console.log(blogContent + \" will be shown here, too.\"); } blog.subscribe(readerFunc1); // 读者1订阅博客 blog.subscribe(readerFunc2); // 读者2订阅博客 blog.publish(\"This is blog content.\"); // 发布博客内容，上面的两个读者的函数都会被调用 blog.unsubscribe(readerFunc1); // 读者1取消订阅 blog.publish(\"This is another blog content.\"); // readerFunc1函数不再调用，readerFunc2继续调用 可以把上面的“新文章”看成是一个事件，“订阅文章”则是“监听”这个事件，“发布新文章”则是“触发”这个事件，“取消订阅文章”就是“取消监听”“新文章”这个事件。假如“监听”用on来表示，“触发”用emit来表示，“取消监听”用off来表示，那么上面的代码可以重新表示为： var blog = new Blog; // 假设已有一个Blog类实现on、emit、off方法 var readerFunc1 = function(blogContent) { console.log(blogContent + \" will be shown here.\"); } var readerFunc2 = function(blogContent) { console.log(blogContent + \" will be shown here, too.\"); } blog.on(\"new post\", readerFunc1); // 读者1监听事件 blog.on(\"new post\", readerFunc2); // 读者2监听事件 blog.emit(\"new post\", \"This is blog content.\"); // 发布博客内容，触发事件，上面的两个读者的函数都会被调用 blog.off(\"new post\", readerFunc1); // 读者1取消监听事件 blog.emit(\"new post\", \"This is another blog content.\"); // readerFunc1函数不再调用，readerFunc2继续调用 这就是前端中观察者模式的一种具体的表现，使用on来监听特定的事件，emit触发特定的事件，off取消监听特定的事件。再举一个场景“小猫听到小狗叫就会跑”： var dog = new Dog; var cat = new Cat; dog.on(\"park\", function() { cat.run(); }); dog.emit(\"park\"); 巧妙利用观察者模式可以让前端应用开发耦合性变得更加低，开发效率更高。可能说“变得更有趣”会显得有点不专业，但确实会变得有趣。 EventEmitter2 如果要自己实现一遍也不很复杂：每个“事件名”对应的就是一个函数数组，每次on某个事件的时候就是把函数压到对应的函数数组当中；每次emit的时候相当于把事件名对应的函数数组遍历一遍进行调用；每次off的时候把目标函数从数组当中剔除。 简单实现 function events (obj) { if(!isEventObj(obj)) { obj.events = {} extend(obj, eventsObj) } return obj } var eventsObj = {} eventsObj.on = function(eventName, handler) { var events = this.events || (this.events = {}) if (events[eventName]) { events[eventName].push(handler) } else { events[eventName] = [handler] } } eventsObj.off = function(eventName, handler) { var events = this.events || (this.events = {}) if (events[eventName] && handler) { var handlers = events[eventName] if (handlers) { for(var i = 0, len = handlers.length; i EventEmitter2可以供浏览器、或者Node.js使用。安装过程和API就不在这里累述，参照官方文档即可。使用Browserify或者Node.js可以非常方便地引用EvenEmitter2，只需要require即可。示例： var EventEmitter2 = require('eventemitter2').EventEmitter2; var emitter = new EventEmitter2; emitter.on(\"Hello World\", function() { console.log(\"Somebody said: Hello world.\"); }); emitter.emit(\"Hello World\"); // 输出 Somebody said: Hello world. EventEmitter2作为父类给给子类提供事件机制 但在实际应用当中，很少单纯EventEmitter直接实例化来使用。比较多的应用场景是，为某些已有的类添加事件的功能。如上面的第一章中的“小猫听到小狗叫就会跑”的例子，Cat和Dog类本身就有自己的类属性、方法，需要的是为已有的Cat、Dog添加事件功能。这里就需要让EventEmitter作为其他类的父类进行继承。 var EventEmitter2 = require('eventemitter2').EventEmitter2; // Cat子类继承父类构造字 function Cat() { EventEmitter2.apply(this); // Cat 构造子，属性初始化等 } // 原型继承 Cat.prototype = Object.create(EventEmitter2.prototype); Cat.prototype.constructor = Cat; // Cat类方法 Cat.prototype.run = function () { console.log(\"This cat is running...\"); } var cat = new Cat; console.assert(typeof cat.on == \"function\"); // => true console.assert(typeof cat.run == \"function\"); // => true 很棒是吧，这样就可以即有EventEmitter2的原型方法，也可以定义Cat自身的方法。 这一点都不棒！每次定义一个类都要重新写一堆啰嗦的东西，下面做个继承的改进：构建一个函数，只需要传入已经定义好的类就可以在不影响类原有功能的情况下，让其拥有EventEmitter2的功能： // Function `eventify`: Making a class get power of EventEmitter2! // @copyright: Livoras // @date: 2015/3/27 // All rights reserve! function eventify(klass) { if (klass.prototype instanceof EventEmitter2) { console.warn(\"Class has been eventified!\"); return klass; } function Tempt() { klass.apply(this, arguments); EventEmitter2.call(this); }; function Tempt2() {}; Tempt2.prototype = Object.create(EventEmitter2.prototype) Tempt2.prototype.constructor = EventEmitter2; var temptProp = Object.create(Tempt2.prototype); var klassProp = klass.prototype; for (var attr in klassProp) { temptProp[attr] = klassProp[attr]; } Tempt.prototype = temptProp; Tempt.prototype.constructor = klass; return Tempt; } 上面的代码可以的实现原理在这里并不重要的，有兴趣的可以接下来的博客，会继续讨论eventify的实现原理。在这里只需要知道，有了eventify就可以很方便的给类添加EventEmitter2的功能，使用方法如下： // Dog类的构造函数和原型方法定义 function Dog(name) { this.name = name; } Dog.prototype.park = function() { console.log(this.name + \" parking....\"); } // 使Dog具有EventEmitter2功能 Dog = eventify(Dog); var dog = new Dog(\"Jerry\"); dog.on(\"somebody is coming\", function() { dog.park(); }) dog.emit(\"somebody is coming\") // 输出 Jerry is parking.... 如上面的代码，现在没有必要为Dog类重新书写类继承代码，只需要按正常的方式定义好Dog类，然后传入eventify函数即可使Dog获取EventEmitter2的功能。本文接下来的讨论会持续使用eventify函数。 注意：如果你正在使用CoffeeScript，直接使用CoffeeScript自带的extends进行类继承即可，无需上面复杂的代码： class Dog extends EventEmitter2 constructor: -> super.apply @, arguments park: -> // ... EventEmitter2 在组件化的前端架构中的应用 组件化的前端架构 当一个前端应用足够复杂的时候，往往需要对应用进行“组件化”。所谓组件化，就是把一个大的应用拆分成多个小的应用。每个“应用”具有自己独特的结构和内容、样式和业务逻辑，这些小的应用称为“组件”（Component）。组件的复用性一般很强，是DRY原则的应用典范，多个组件的嵌套、组合，构建成了一个完成而复杂的应用。 举我在《一种SPA（单页面应用）架构》举过的例子，博客的评论功能组件： 这个评论组件的功能大概如此：可显示多条评论（comment）；每条评论多条有自己的回复（reply）；评论或者回复都会显示有用户头像，鼠标放到用户头像上会显示该用户的信息（类似微博的功能）。 这里可以把这个功能分好几个组件： 整体评论功能作为一个组件：commentsBox commentsBox有子组件（child component）comment负责显示用户的评论 每个comment组件有子组件replay负责显示用户对评论的回复 commentsBox有子组件user-info-card负责显示用户的信息 组件这样的关系可以用树的结构来表示： 这里要注意的是组件之间的关系一般有两种：嵌套和组合。嵌套，如，每个commentBox有comment和user-info-card，comment和user-info-card是嵌套在commentBox当中的，所以这两个组件和commentBox之间都是嵌套的关系；组合，comment和user-info-card都是作为commentBox的子组件存在，他们两个互为兄弟，是组合的关系。处理组件之间的嵌套和组合关系是架构层面需要解决的最重要的问题之一，不在本文讨论范围内，故不累述。但接下来我们讨论的“组件之间以事件的形式进行消息传递”和这些组件之间的关系密切相关。 当开始按照上面的设计进行组件化的时候，我们首先要做的是为每个组件构建一个超类，所有的组件都应该继承这个超类： component.js: eventify = require(\"./eventify.js\"); // Component构造函数 function Component(parent) { this.$el = $(\"...\") this.parent = parent; } // Component原型方法 Component.prototype.init = function () {/* ... */}; module.exports = eventify(Component); 这里为了方便起见，Component基本什么内容都没有，几乎只是一个“空”的类，而它通过eventify函数获得了“超能力”，所以继承Component的类同样具有事件的功能。 注意Component构造函数，每个Component在示例化的时候应该传入一个它所属的父组件的实例parent，接下来会看到，组件之间的消息通信可以通过这个实例来完成。而$el可以看作是该组件所负责的HTML元素。 父子、兄弟组件之间的消息传递 现在把注意力放在commentsBox、comment、user-info-card三个组件上，暂且忽略reply。 目前要实现的功能是：鼠标放到comment组件的用户头像上，就会显示用户信息。要把这个功能完成大概是这么一个事件流程：comment组件监听用户鼠标放在头像上的交互事件，然后通过this.parent向父组件（commentsBox）传递该事件（this.parent就是commentsBox），commentsBox获取到该事件以后触发一个事件给user-info-card，user-info-card可以通过this.parent监听到该事件，显示用户信息。 // comment-component.js // 从Component类中继承获得Comment类 // ... // 原型方法 Comment.prototype.init = function () { var that = this; this.$el.find(\"div.avatar\").on(\"mouseover\", function () { // 这里的that.parent相当于父组件CommentsBox，在Comment组件被示例化的时候传入 that.parent.emit(\"comment:user-mouse-on-avatar\", this.userId); }) } 上述代码为当用户把鼠标放到用户头像的时候触发一个事件comment:user-mouse-on-avatar，这里需要注意的是，通过组件名:事件名给这样的事件命名方式可以区分事件的来源组件或目标组件，是一种比较好的编程习惯。 // comments-box-component.js // 从Component类中继承获得CommentsBox类 // ... // 原型方法 CommentsBox.prototype.init = function() { var that = this; this.on(\"comment:user-mouse-on-avatar\", function (userId) { // 这里接受到来自Comment组件的事件 that.emit(\"user-info-card:show-user-info\", userId); // 把这个事件传递给user-info-card组件 }); } 上述代码中commentsBox获取到来自comment组件的comment:user-mouse-on-avatar事件，由于user-info-card组件也同时拥有commentsBox的实例，所以commentsBox可以通过触发自身的事件user-info-card:show-user-info来给user-info-card组件传递事件。再一次注意这里到事件名，user-info-card:前缀说明这个事件是由user-info-card组件所接收的。 // user-info-card-component.js // 从Component类中继承获得UserInfoCard类 // ... // 原型方法 UserInfoCard.prototype.init = function () { var that = this; this.parent.on(\"user-info-card:show-user-info\", function (userId) { $.ajax({ // 通过ajax获取用户数据 url: \"/users/\" + userId, method: \"GET\" }).success(function(data) { that.render(data); // 渲染用户信息 that.show(); // 显示信息 }) }); } 上述代码中，user-info-card组件通过this.parent获取到来自其父组件（也就是commentsBox）的事件user-info-card:show-user-info，并且得到所传入的用户id；然后通过ajax向服务器发送用户id，请求用户数据渲染页面数据然后显示。 这样，消息就通过事件机制从comment到达了它的父组件commentsBox，然后通过commentsBox到达它的兄弟组件user-info-card。完成了一个父子组件之间、兄弟之间的消息传递过程： 按照这种消息传递方式的事件有四种类型： this.parent.emit，触发父组件的事件，由父组件监听，相当于告知父组件自己所发生的事情。 this.parent.on，监听父组件的事件，由父组件触发，相当于接收处理来自父组件的指令。 this.emit，触发自己的事件，由子组件监听，相当于向某个子组件发送命令。 this.on，监听自己的事件，由子组件触发，相当于接受处理来自子组件的事件。 每个组件只要hold住一个其父组件实例，就可以完成： 和父组件直接进行消息通信 通过父组件和自己的兄弟组件间接进行消息通信 两个功能。 使用事件总线（eventbus）进行跨组件消息传递 现在可以把注意力放到reply组件上，reply作为comment的子组件，负责显示这条评论下的回复。类似地，它有回复者的用户头像，鼠标放上去以后也可以显示用户的信息。 user-info-card是commentsBox的子组件，reply是comment的子组件；user－info-card和reply既不是父子也不是兄弟节点关系，reply无法按照上面的方式比较直接地把事件传递给它；reply的鼠标放到头像上的事件需要先传递给其父组件comment，然后经过comment传递给commentsBox，最后通过commentsBox传递给user-info-card组件。如下： 看起来好像比较麻烦，reply离它根组件commentsBox高度为二，嵌套了两层。假设reply嵌套了很多层，那么事件的传递就类似浏览器的事件冒泡一样，需要先冒泡到根节点commentsBox，再由跟节点把事件发送给user-info-card。 如果要真的这样写会带来相当大的维护成本，当组件之间的交互方式更改了甚至只是单单修改了事件名，中间层的负责事件转发的都需要把代码重新修改。而且，这些负责转发的组件需要维护和自己业务逻辑并不相关的逻辑，违反单一职责原则。 解决这个问题的方式就是：提供一个组件之间共享的事件对象eventbus，可以负责跨组件之间的事件传递。所有的组件都可以从这个这个总线上触发事件，也可以从这个总线上监听事件。 commom/eventbus.js var EventEmitter2 = require('eventemitter2').EventEmitter2; module.exports = new EventEmitter2; // eventbus是一个简单的EventEmitter2对象 那么reply组件和user-info-card就可以通过eventbus进行之间的信息交换，在reply组件中： // reply.js // 从Component类中继承获得Reply类 // ... eventbus = require(\"../common/eventbus.js\"); // 原型方法 Reply.prototype.init = function () { var that = this; this.$el.find(\"div.avatar\").on(\"mouseover\", function () { // 触发eventbus上的事件user-info-card:show-user-info eventbus.emit(\"user-info-card:show-user-info\", that.userId); }) } 在user-info-card组件当中： // user-info-card-component.js // 从Component类中继承获得UserInfoCard类 // ... eventbus = require(\"../common/eventbus.js\"); // 原型方法 UserInfoCard.prototype.init = function () { var that = this; // 原来的逻辑不变 this.parent.on(\"user-info-card:show-user-info\", getUserInfoAndShow); // 新增获取eventbus的事件 eventbus.on(\"user-info-card:show-user-info\", getUserInfoAndShow); function getUserInfoAndShow (userId) { $.ajax({ // 通过ajax获取用户数据 url: \"/users/\" + userId, method: \"GET\" }).success(function(data) { that.render(data); // 渲染用户信息 that.show(); // 显示信息 }); }; }; 这样user-info-card和就跨越了组件嵌套组合的关系，直接进行组件之间的信息事件的交互。 问题就来了 那么问题就来了： 既然eventbus这么方便，为什么不所有组件都往eventbus上发送事件，这样不就不需要组件的事件转发，方便多了吗？ 什么时候使用eventbus进行事件传递，什么时候通过组件转发事件？ 如果所有的组件都往eventbus上post事件，那么就会带来eventbus上事件的维护的困难；我们可以类比一下JavaScript里面的全局变量，假如所有函数都不自己维护局部变量，而都使用全局变量会带来什么问题？想想都觉得可怕。既然这个事件交互只是在局部组件之间交互的，那么就尽量不要把它post到eventbus，eventbus上的事件应该尽量少，越少越好。 那什么时候使用eventbus上的事件？这里给出一个原则：当组件嵌套了三层以上的时候，带来局部事件转发维护困难的时候，就可以考虑祭出eventbus。而在实际当中很少会出现三层事件传播这种情况，也可保持eventbus事件的简洁。（按照这个原则上面的reply是不需要使用eventbus的，但是为了阐述eventbus而使用，这点要注意。） "},"安全/安全.html":{"url":"安全/安全.html","title":"安全XSS-CSRF","keywords":"","body":" XSS 如何攻击 如何防御 CSP CSRF 如何攻击 如何防御 密码安全 加盐 XSS 跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。 XSS 分为三种：反射型，存储型和 DOM-based 如何攻击 XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站。 例如通过 URL 获取某些参数 alert(1) --> {{name}} 上述 URL 输入可能会将 HTML 改为 alert(1) ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击。 也有另一种场景，比如写了一篇包含攻击代码 alert(1) 的文章，那么可能浏览文章的用户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based 攻击，并且这种攻击打击面更广。 如何防御 最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义 function escape(str) { str = str.replace(/&/g, '&amp;') str = str.replace(//g, '&gt;') str = str.replace(/\"/g, '&quto;') str = str.replace(/'/g, '&#39;') str = str.replace(/`/g, '&#96;') str = str.replace(/\\//g, '&#x2F;') return str } 通过转义可以将攻击代码 alert(1) 变成 // -> &lt;script&gt;alert(1)&lt;&#x2F;script&gt; escape('alert(1)') 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。 var xss = require('xss') var html = xss('XSS Demoalert(\"xss\");') // -> XSS Demo&lt;script&gt;alert(\"xss\");&lt;/script&gt; console.log(html) 以上示例使用了 js-xss 来实现。可以看到在输出中保留了 h1 标签且过滤了 script 标签 CSP 内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。 我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。 通常可以通过 HTTP Header 中的 Content-Security-Policy 来开启 CSP 只允许加载本站资源 Content-Security-Policy: default-src ‘self’ 只允许加载 HTTPS 协议图片 Content-Security-Policy: img-src https://* 允许加载任何来源框架 Content-Security-Policy: child-src 'none' CSRF 跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。[1] 跟跨網站指令碼（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 简单点说，CSRF 就是利用用户的登录态发起恶意请求。 如何攻击 假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口 如果接口是 Post 提交的，就相对麻烦点，需要用表单来提交接口 如何防御 防范 CSRF 可以遵循以下几种规则： Get 请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 token SameSite可以对 Cookie 设置 SameSite 属性。该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。 验证 Referer对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。 Token服务器下发一个随机 Token（算法不能复杂），每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。 密码安全 密码安全虽然大多是后端的事情，但是作为一名优秀的前端程序员也需要熟悉这方面的知识。 加盐 对于密码存储来说，必然是不能明文存储在数据库中的，否则一旦数据库泄露，会对用户造成很大的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系。 通常需要对密码加盐，然后进行几次不同加密算法的加密。 // 加盐也就是给原密码添加字符串，增加原密码长度 sha256(sha1(md5(salt + password + salt))) 但是加盐并不能阻止别人盗取账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而应该提示账号或密码错误。 "},"安全/性能.html":{"url":"安全/性能.html","title":"性能","keywords":"","body":"性能 性能 网络相关 DNS 预解析 缓存 强缓存 协商缓存 选择合适的缓存策略 使用 HTTP / 2.0 预加载 预渲染 优化渲染过程 懒执行 懒加载 文件优化 图片优化 计算图片大小 图片加载优化 其他文件优化 CDN 其他 使用 Webpack 优化项目 监控 网络相关 DNS 预解析 DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。 缓存 缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。 通常浏览器缓存策略分为两种：强缓存和协商缓存。 强缓存 实现强缓存可以通过两种响应头实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200 Expires: Wed, 22 Oct 2018 08:41:00 GMT Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。 Cache-control: max-age=30 Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求。 协商缓存 如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。 Last-Modified 和 If-Modified-Since Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。 ETag 和 If-None-Match ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。 选择合适的缓存策略 对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。 使用 HTTP / 2.0 因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。 在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。 预加载 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。 预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。 预渲染 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染 优化渲染过程 代码层面的优化 懒执行 懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。 懒加载 懒加载就是将不关键的资源延后加载。 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。 文件优化 图片优化 计算图片大小 对于一张 100 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1 个字节），所以该图片大小大概为 39KB（10000 1 * 4 / 1024）。 但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。 了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了： 减少像素点 减少每个像素点能够显示的颜色 图片加载优化 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。 小图使用 base64 格式 将多个图标文件整合到一张图片中（雪碧图） 选择正确的图片格式： 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替 照片使用 JPEG 其他文件优化 CSS 文件放在 head 中 服务端开启文件压缩功能 将 script 标签放在 body 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 script 标签放在任意位置然后加上 defer ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 async ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。 执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 Webworker。Webworker 可以让我们另开一个线程执行脚本而不影响渲染。 CDN 静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。 其他 使用 Webpack 优化项目 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码 优化图片，对于小图可以使用 base64 的方式写入文件中 按照路由拆分代码，实现按需加载 给打包出来的文件名添加哈希，实现浏览器缓存文件 监控 对于代码运行错误，通常的办法是使用 window.onerror 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外 对于跨域的代码运行错误会显示 Script error. 对于这种情况我们需要给 script 标签添加 crossorigin 属性 对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 arguments.callee.caller 来做栈递归 对于异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch 但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。 对于捕获的错误需要上传给服务器，通常可以通过 img 标签的 src 发起一个请求。 "},"安全/网站性能优化.html":{"url":"安全/网站性能优化.html","title":"网站性能优化","keywords":"","body":"网站性能优化 网站性能优化 引言 1.网络传输性能优化 1.1.浏览器缓存 1.2.资源打包压缩 在对webpack进行上线配置时，我们要特别注意以下几点： 1.3.图片资源优化 1.3.1.不要在HTML里缩放图像 1.3.2.使用雪碧图（CSS Sprite） 1.3.3.使用字体图标（iconfont） 1.3.4.使用WebP 1.4.网络传输性能检测工具——Page Speed 1.5.使用CDN 2.页面渲染性能优化 2.1.浏览器渲染过程（Webkit） 2.2.DOM渲染层与GPU硬件加速 2.3.重排与重绘 2.4.优化策略 3.JS阻塞性能 4.【拓展】负载均衡 4.1.Node.js处理IO密集型请求 4.2.pm2实现Node.js“多进程” 4.3.nginx搭建反向代理 4.3.1.upstream配置信息 4.3.2.server配置信息 5. React性能优化军规 5.1 渲染相关 5.2 tap事件 5.3 Debug相关 5.4 其它 引言 对于网站的性能，在行业内有很多既定的指标，但就以我们Front-Enders而言，应该更加关注以下指标：白屏时间、首屏时间、整页时间、DNS时间、CPU占用率。 从性能优化的三大方面 网络传输性能、 页面渲染性能 JS阻塞性能 1.网络传输性能优化 在开始介绍网络传输性能优化这项工作之前，我们需要了解浏览器处理用户请求的过程，那么就必须奉上这幅神图 这是navigation timing监测指标图，从图中我们可以看出，浏览器在得到用户请求之后，经历了下面这些阶段：重定向→拉取缓存→DNS查询→建立TCP链接→发起请求→接收响应→处理HTML元素→元素加载完成。不着急，我们将对其中的细节一步步展开讨论： 1.1.浏览器缓存 我们都知道，浏览器在向服务器发起请求前，会先查询本地是否有相同的文件，如果有，就会直接拉取本地缓存，这和我们在后台部属的Redis、Memcache类似，都是起到了中间缓冲的作用，我们先看看浏览器处理缓存的策略： 因为网上的图片太笼统了，而且我翻过很多讲缓存的文章，很少有将状态码还有什么时候将缓存存放在内存（memory）中什么时候将缓存在硬盘中（disk）系统地整理出来，所以我自己绘制了一张浏览器缓存机制流程图，结合这张图再更深入地说明浏览器的缓存机制。 这里我们可以使用chrome devtools里的network面板查看网络传输的相关信息： （这里需要特别注意，在我们进行缓存调试时，需要去除network面板顶部的Disable cache 勾选项，否则浏览器将始终不会从缓存中拉取数据） 浏览器默认的缓存是放在内存内的，但我们知道，内存里的缓存会因为进程的结束或者说浏览器的关闭而被清除，而存在硬盘里的缓存才能够被长期保留下去。很多时候，我们在network面板中各请求的size项里，会看到两种不同的状态：from memory cache 和 from disk cache，前者指缓存来自内存，后者指缓存来自硬盘。而控制缓存存放位置的，不是别人，就是我们在服务器上设置的Etag字段。在浏览器接收到服务器响应后，会检测响应头部（Header），如果有Etag字段，那么浏览器就会将本次缓存写入硬盘中。 之所以拉取缓存会出现200、304两种不同的状态码，取决于浏览器是否有向服务器发起验证请求。 只有向服务器发起验证请求并确认缓存未被更新，才会返回304状态码。 这里我以nginx为例，谈谈如何配置缓存: 首先，我们先进入nginx的配置文档 $ vim nginxPath/conf/nginx.conf 在配置文档内插入如下两项： etag on; //开启etag验证expires 7d; //设置缓存过期时间为7天 打开我们的网站，在chrome devtools的network面板中观察我们的请求资源，如果在响应头部看见Etag和Expires字段，就说明我们的缓存配置成功了。 【！！！特别注意！！！】在我们配置缓存时一定要切记，浏览器在处理用户请求时，如果命中强缓存，浏览器会直接拉取本地缓存，不会与服务器发生任何通信，也就是说，如果我们在服务器端更新了文件，并不会被浏览器得知，就无法替换失效的缓存。所以我们在构建阶段，需要为我们的静态资源添加md5 hash后缀，避免资源更新而引起的前后端文件无法同步的问题。 1.2.资源打包压缩 我们之前所作的浏览器缓存工作，只有在用户第二次访问我们的页面才能起到效果，如果要在用户首次打开页面就实现优良的性能，必须对资源进行优化。我们常将网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率。现在，让我们逐个击破： 结合前端工程化思想，我们在对上线文件进行自动化打包编译时，通常都需要打包工具的协助，这里我推荐webpack，我通常都使用Gulp和Grunt来编译node，Parcel太新，而且webpack也一直在自身的特性上向Parcel靠拢。 在对webpack进行上线配置时，我们要特别注意以下几点： JS压缩：（这点应该算是耳熟能详了，就不多介绍了） new webpack.optimize.UglifyJsPlugin() HTML压缩： new HtmlWebpackPlugin({ template: __dirname + '/views/index.html', // new 一个这个插件的实例，并传入相关的参数 filename: '../index.html', minify: { removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true, }, chunksSortMode: 'dependency' }) 我们在使用html-webpack-plugin 自动化注入JS、CSS打包HTML文件时，很少会为其添加配置项，这里我给出样例，大家直接复制就行。 PS：这里有一个技巧，在我们书写HTML元素的src 或 href 属性时，可以省略协议部分，这样也能简单起到节省资源的目的。 提取公共资源： new webpack.optimize.CommonsChunkPlugin({ name: 'vendor', filename: 'scripts/common/vendor-[hash:5].js' }) PS:这里是webpack3的语法，在webpack4中已作更改，希望大家注意 提取css并压缩： 在使用webpack的过程中，我们通常会以模块的形式引入css文件（webpack的思想不就是万物皆模块嘛），但是在上线的时候，我们还需要将这些css提取出来，并且压缩，这些看似复杂的过程只需要简单的几行配置就行： （PS:我们需要用到extract-text-webpack-plugin ，所以还得大家自行npm install） const ExtractTextPlugin = require('extract-text-webpack-plugin') module: { rules: [ ..., { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: 'style-loader', use: { loader: 'css-loader', options: { minimize: true } } }) } ] } 使用webpack3的新特性：ModuleConcatenationPlugin new webpack.optimize.ModuleConcatenationPlugin() 如果你能按照上述五点将webpack上线配置完整配置出来，基本能将文件资源体积压缩到极致了，如有疏漏，还希望大家能加以补充。 给大家上一份我的webpack上线配置文档，欢迎参考： //webpack.pro.js const webpack = require('webpack') const HtmlWebpackPlugin = require('html-webpack-plugin') const ExtractTextPlugin = require('extract-text-webpack-plugin') const CleanWebpackPlugin = require('clean-webpack-plugin') const CopyWebpackPlugin = require('copy-webpack-plugin') module.exports = { entry: __dirname + '/public/scripts/index.js', output: { path: __dirname + '/build/static', // 打包后的文件存放的地方 filename: 'scripts/[name]-[hash:5].js' // 打包后输出文件的文件名,带有md5 hash戳 }, resolve: { extensions: ['.jsx', '.js'] }, module: { rules: [{ test: /(\\.jsx|\\.js)$/, use: { loader: 'babel-loader' }, exclude: /node_modules/ // 不进行编译的目录 }, { test: /\\.css$/, use: ExtractTextPlugin.extract({ fallback: 'style-loader', use: { loader: 'css-loader', options: { minimize: true } } }) }] }, plugins: [ new HtmlWebpackPlugin({ template: __dirname + '/views/index.html', filename: '../index.html', minify: { removeComments: true, collapseWhitespace: true, removeRedundantAttributes: true, useShortDoctype: true, removeEmptyAttributes: true, removeStyleLinkTypeAttributes: true, keepClosingSlash: true, minifyJS: true, minifyCSS: true, minifyURLs: true, }, chunksSortMode: 'dependency' }), new ExtractTextPlugin('styles/style-[hash:5].css'), new CleanWebpackPlugin('build/*', { root: __dirname, verbose: true, dry: false }), new webpack.optimize.UglifyJsPlugin(), new CopyWebpackPlugin([{ from: __dirname + '/public/images', to: __dirname + '/build/static/images' }, { from: __dirname + '/public/scripts/vector.js', to: __dirname + '/build/static/scripts/vector.js' }]), new webpack.optimize.ModuleConcatenationPlugin(), new webpack.optimize.CommonsChunkPlugin({ name: 'vendor', filename: 'scripts/common/vendor-[hash:5].js' }) ] } 最后，我们还应该在服务器上开启Gzip传输压缩，它能将我们的文本类文件体积压缩至原先的四分之一，效果立竿见影，还是切换到我们的nginx配置文档，添加如下两项配置项目： gzip on; gzip_types text/plain application/javascriptapplication/x-javascripttext/css application/xml text/javascriptapplication/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml; 如果你在网站请求的响应头里看到这样的字段，那么就说明咱们的Gzip压缩配置成功啦： ！！！特别注意！！！】不要对图片文件进行Gzip压缩！不要对图片文件进行Gzip压缩！不要对图片文件进行Gzip压缩！我只会告诉你效果适得其反，至于具体原因，还得考虑服务器压缩过程中的CPU占用还有压缩率等指标，对图片进行压缩不但会占用后台大量资源，压缩效果其实并不可观，可以说是“弊大于利”，所以请在gzip_types 把图片的相关项去掉。针对图片的相关处理，我们接下来会更加具体地介绍。 1.3.图片资源优化 刚刚我们介绍了资源打包压缩，只是停留在了代码层面，而在我们实际开发中，真正占用了大量网络传输资源的，并不是这些文件，而是图片，如果你对图片进行了优化工作，你能立刻看见明显的效果。 1.3.1.不要在HTML里缩放图像 很多开发者可能会有这样的错觉（其实我曾经也是这样），比如我们会为了方便在一个200✖200的图片容器内直接使用一张400✖400的图片，我们甚至认为这样能让用户觉得图片更加清晰，其实不然，在普通的显示器上，用户并不会感到缩放后的大图更加清晰，但这一切却导致网页加速速度下降，同时照成带宽浪费，你可能不知道，一张200KB的图片和2M的图片的传输时间会是200ms和12s的差距（亲身经历，深受其害(┬＿┬)）。所以，当你需要用多大的图片时，就在服务器上准备好多大的图片，尽量固定图片尺寸。 1.3.2.使用雪碧图（CSS Sprite） 雪碧图的概念大家一定在开发中经常听见，其实雪碧图是减小请求数的示范性代表。而且很奇妙的是，多张图片拼在一块后，总体积会比之前所有图片的体积之和小（你可以亲自试试）。这里给大家推荐一个自动化生成雪碧图的工具：https://www.toptal.com/developers/css/sprite-generator （图片来自官网首页） 只要你添加相关资源文件，他就会自动帮你生成雪碧图以及对应的CSS样式，你要做的，只是download和copy。 1.3.3.使用字体图标（iconfont） 不论是压缩后的图片，还是雪碧图，终归还是图片，只要是图片，就还是会占用大量网络传输资源。但是字体图标的出现，却让前端开发者看到了另外一个神奇的世界。 我最喜欢用的是阿里矢量图标库（网址：http://www.iconfont.cn/ ） ，里面有大量的矢量图资源，而且你只需要像在淘宝采购一样把他们添加至购物车就能把它们带回家，整理完资源后还能自动生成CDN链接，可以说是完美的一条龙服务了。（图片来自官网首页） 图片能做的很多事情，矢量图都能作，而且它只是往HTML里插入字符和CSS样式而已，和图片请求比起来，在网络传输资源的占用上它们完全不在一个数量级，如果你的项目里有大量的小图标，就用矢量图吧。 1.3.4.使用WebP WebP格式，是谷歌公司开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook、Ebay等知名网站已经开始测试并使用WebP格式。 我们可以使用官网提供的Linux命令行工具对项目中的图片进行WebP编码，也可以使用我们的线上服务，这里我推荐叉拍云（网址：https://www.upyun.com/webp ）。但是在实际的上线工作中，我们还是得编写Shell脚本使用命令行工具进行批量编码，不过测试阶段我们用线上服务就足够了，方便快捷。（图片来自叉拍云官网） 1.4.网络传输性能检测工具——Page Speed 除了network版块，其实chrome还为我们准备好了一款监测网络传输性能的插件——Page Speed，咱们的文章封面，就是用的Page Speed的官方宣传图（因为我觉得这张图再合适不过了）。我们只需要通过下面步骤安装，就可以在chrome devtools里找到它了：chrome菜单→更多工具→拓展程序→chrome网上应用商店→搜索pagespeed后安转即可。 （PS：使用chrome应用商店需要翻墙，怎么翻墙我就不便多说了） 这就是Page Speed的功能界面： 我们只需要打开待测试的网页，然后点击Page Speed里的 Start analyzing按钮，它就会自动帮我们测试网络传输性能了，这是我的网站测试结果： Page Speed最人性化的地方，便是它会对测试网站的性能瓶颈提出完整的建议，我们可以根据它的提示进行优化工作。这里我的网站已经优化到最好指标了(•́⌄•́๑)૭✧，Page Speed Score表示你的性能测试得分，100/100表示已经没有需要优化的地方。 优化完毕后再使用chorme devtools的network版块测量一下我们网页的白屏时间还有首屏时间，是不是得到了很大的提升？ 1.5.使用CDN Last but not least， 再好的性能优化实例，也必须在CDN的支撑下才能到达极致。 如果我们在Linux下使用命令$ traceroute targetIp 或者在Windows下使用批处理 > tracert targetIp，都可以定位用户与目标计算机之间经过的所有路由器，不言而喻，用户和服务器之间距离越远，经过的路由器越多，延迟也就越高。使用CDN的目的之一便是解决这一问题，当然不仅仅如此，CDN还可以分担IDC压力。 当然，凭着我们单个人的资金实力（除非你是王思聪）是必定搭建不起来CDN的，不过我们可以使用各大企业提供的服务，诸如腾讯云等，配置也十分简单，这里就请大家自行去推敲啦。 其实我们的CDN域名一般是和我们的网站主域名不同的，大家可以看看淘宝、腾讯的官方网站，看看他们存放静态资源的CDN域名，都是和主域名不一样的。为什么要这么做？主要有两个原因：内容摘选自：https://bbs.aliyun.com/simple/t116453.html 便于CDN业务独立，能够独立配置缓存。为了降低web压力，CDN系统会遵循Cache-Control和Expires HTTP头标准 对改请求返回的内容进行缓存，便于后面的请求不在回源，起到加速功能。而传统CDN（Web与CDN共用域名）的方式，需要对不同类型的文件设置相应的Cache规则或者遵循后端的HTTP头，但这样难以发挥CDN的最大优势，因为动态请求回源的概率非常之大，如果访客与源站的线路并不慢，通过CDN的请求未必快于直接请求源站的。 大型网站为了提升web性能到极致，通常缓存头设置比较大，像谷歌JS设置一年缓存，百度首页logo设置十年缓存，如果将静态元素抽取出来，就可以很方便的对所有静态元素部署规则，而不用考虑动态请求。减少规则的条数可以提升CDN的效率。 抛开无用cookie，减小带宽占用。我们都知道HTTP协议每次发送请求都会自动带上该域名及父级域名下的cookie，但对于CSS，JS还有图片资源，这些cookie是没用的，反而会浪费访客带宽和服务器入带宽。而我们的主站，为了保持会话或者做其他缓存，都会存放着大量的cookie，所以如果将CDN与主站域名分离，就能解决这一问题。 不过这样一来，新的问题就出现了：CDN域名与主站域名不同，DNS解析CDN域名还需要花费额外的时间，增加网络延迟。不过这难不住我们伟大的程序员前辈，DNS Prefetch闪亮登场。 如果大家翻看大型网站的HTML源代码，都会在头部发现这样的link链接：（这里以淘宝首页为例） 这就是DNS Prefetch。DNS Prefetch是一种DNS预解析技术，当我们浏览网页时，浏览器会在加载网页时对网页中的域名进行预解析并缓存，这样在浏览器加载网页中的链接时，就无需进行DNS解析，减少用户的等待时间，提高用户体验。DNS Prefetch现已被主流浏览器支持，大多数浏览器针对DNS解析都进行了优化，典型的一次DNS解析会耗费20~120ms，减少DNS解析时间和次数是个很好的优化措施。这里附上一张Can I use it官网上的DNS Prefetch支持情况图： 所以，放心大胆地去使用它吧。 2.页面渲染性能优化 2.1.浏览器渲染过程（Webkit） 其实大家应该对浏览器的HTML渲染机制比较熟悉了，基本流程同上图所述，大家在入门的时候，你的导师或者前辈可能会告诉你，在渲染方面我们要减少重排和重绘，因为他们会影响浏览器性能。不过你一定不知道其中原理是什么，对吧。今天我们就结合《Webkit技术内幕》（这本书我还是很推荐大家买来看看，好歹作为一名前端工程师，你得知道我们天天接触的浏览器内核是怎样工作的）的相关知识，给大家普及普及那些深层次的概念。 PS：这里提到了Webkit内核，我顺带提一下浏览器内部的渲染引擎、解释器等组件的关系，因为经常有师弟或者一些前端爱好者向我问这方面的知识，分不清他们的关系，我就拿一张图来说明：（这部分内容与本文无关，如果你对此不感兴趣，可以直接跳过） 浏览器的解释器，是包括在渲染引擎内的，我们常说的Chrome（现在使用的是Blink引擎）和Safari使用的Webkit引擎，Firefox使用的Gecko引擎，指的就是渲染引擎。而在渲染引擎内，还包括着我们的HTML解释器（渲染时用于构造DOM树）、CSS解释器（渲染时用于合成CSS规则）还有我们的JS解释器。不过后来，由于JS的使用越来越重要，工作越来越繁杂，所以JS解释器也渐渐独立出来，成为了单独的JS引擎，就像众所周知的V8引擎，我们经常接触的Node.js也是用的它。 2.2.DOM渲染层与GPU硬件加速 如果我告诉你，一个页面是由许多许多层级组成的，他们就像千层面那样，你能想象出这个页面实际的样子吗？这里为了便于大家想象，我附上一张之前Firefox提供的3D View插件的页面Layers层级图： 对，你没看错，页面的真实样子就是这样，是由多个DOM元素渲染层（Layers）组成的，实际上一个页面在构建完Render Tree之后，是经历了这样的流程才最终呈现在我们面前的： 浏览器会先获取DOM树并依据样式将其分割成多个独立的渲染层 CPU将每个层绘制进绘图中 将位图作为纹理上传至GPU（显卡）绘制 GPU将所有的渲染层缓存（如果下次上传的渲染层没有发生变化，GPU就不需要对其进行重绘）并复合多个渲染层最终形成我们的图像 从上面的步骤我们可以知道，布局是由CPU处理的，而绘制则是由GPU完成的。 其实在chrome中，也为我们提供了相关插件供我们查看页面渲染层的分布情况以及GPU的占用率：（所以说，平时我们得多去尝试尝试chrome的那些莫名其妙的插件，真的会发现好多东西都是神器） chrome开发者工具菜单→more tools→Layers（开启渲染层功能模块） chrome开发者工具菜单→more tools→rendering（开启渲染性能监测工具） 执行上面的操作后，你会在浏览器里看到这样的效果： 太多东西了，分模块讲吧： 最先是页面右上方的小黑窗：其实提示已经说的很清楚了，它显示的就是我们的GPU占用率，能够让我们清楚地知道页面是否发生了大量的重绘。 Layers版块：这就是用于显示我们刚提到的DOM渲染层的工具了，左侧的列表里将会列出页面里存在哪些渲染层，还有这些渲染层的详细信息。 Rendering版块：这个版块和我们的控制台在同一个地方，大家可别找不到它。前三个勾选项是我们最常使用的，让我来给大家解释一下他们的功能（充当一次免费翻译） Paint flashing：勾选之后会对页面中发生重绘的元素高亮显示 Layer borders：和我们的Layer版块功能类似，它会用高亮边界突出我们页面中的各个渲染层 FPS meter：就是开启我们在（一）中提到的小黑窗，用于观察我们的GPU占用率 可能大家会问我，提到DOM渲染层这么深的概念有什么用啊，好像跟性能优化没一点关系啊？大家应该还记得我刚说到GPU会对我们的渲染层作缓存对吧，那么大家试想一下，如果我们把那些一直发生大量重排重绘的元素提取出来，单独触发一个渲染层，那样这个元素不就不会“连累”其他元素一块重绘了对吧。 那么问题来了，什么情况下会触发渲染层呢？大家只要记住： Video元素、WebGL、Canvas、CSS3 3D、CSS滤镜、z-index大于某个相邻节点的元素都会触发新的Layer，其实我们最常用的方法，就是给某个元素加上下面的样式： transform: translateZ(0); backface-visibility: hidden; 这样就可以触发渲染层啦 。 我们把容易触发重排重绘的元素单独触发渲染层，让它与那些“静态”元素隔离，让GPU分担更多的渲染工作，我们通常把这样的措施成为硬件加速，或者是GPU加速。大家之前肯定听过这个说法，现在完全清楚它的原理了吧。 2.3.重排与重绘 现在到我们的重头戏了，重排和重绘。先抛出概念： 重排（reflow）：渲染层内的元素布局发生修改，都会导致页面重新排列，比如窗口的尺寸发生变化、删除或添加DOM元素，修改了影响元素盒子大小的CSS属性（诸如：width、height、padding）。 重绘（repaint）：绘制，即渲染上色，所有对元素的视觉表现属性的修改，都会引发重绘。 我们习惯使用chrome devtools中的performance版块来测量页面重排重绘所占据的时间： 蓝色部分：HTML解析和网络通信占用的时间 黄色部分：JavaScript语句执行所占用时间 紫色部分：重排占用时间 绿色部分：重绘占用时间 不论是重排还是重绘，都会阻塞浏览器。要提高网页性能，就要降低重排和重绘的频率和成本，近可能少地触发重新渲染。正如我们在2.3中提到的，重排是由CPU处理的，而重绘是由GPU处理的，CPU的处理效率远不及GPU，并且重排一定会引发重绘，而重绘不一定会引发重排。所以在性能优化工作中，我们更应当着重减少重排的发生。 这里给大家推荐一个网站，里面详细列出了哪些CSS属性在不同的渲染引擎中是否会触发重排或重绘： https://csstriggers.com/ （图片来自官网） 2.4.优化策略 谈了那么多理论，最实际不过的，就是解决方案，大家一定都等着急了吧，做好准备，一大波干货来袭： CSS属性读写分离：浏览器每次对元素样式进行读操作时，都必须进行一次重新渲染（重排 + 重绘），所以我们在使用JS对元素样式进行读写操作时，最好将两者分离开，先读后写，避免出现两者交叉使用的情况。最最最客观的解决方案，就是不用JS去操作元素样式，这也是我最推荐的。 通过切换class或者使用元素的style.csstext属性去批量操作元素样式。 DOM元素离线更新：当对DOM进行相关操作时，例、appendChild等都可以使用Document Fragment对象进行离线操作，带元素“组装”完成后再一次插入页面，或者使用display:none 对元素隐藏，在元素“消失”后进行相关操作。 将没用的元素设为不可见：visibility: hidden，这样可以减小重绘的压力，必要的时候再将元素显示。 压缩DOM的深度，一个渲染层内不要有过深的子元素，少用DOM完成页面样式，多使用伪元素或者box-shadow取代。 图片在渲染前指定大小：因为img元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流。 对页面中可能发生大量重排重绘的元素单独触发渲染层，使用GPU分担CPU压力。（这项策略需要慎用，得着重考量以牺牲GPU占用率为代价能否换来可期的性能优化，毕竟页面中存在太多的渲染层对于GPU而言也是一种不必要的压力，通常情况下，我们会对动画元素采取硬件加速。） 请慎用setState，因其容易导致重新渲染 既然将数据主要交给了Redux来管理，那就尽量使用Redux管理你的数据和状态state，除了少数情况外，别忘了shouldComponentUpdate也需要比较state。 请将方法的bind一律置于constructor Component的render里不动态bind方法，方法都在constructor里bind好，如果要动态传参，方法可使用闭包返回一个最终可执行函数。如：showDelBtn(item) { return (e) => {}; }。如果每次都在render里面的jsx去bind这个方法，每次都要绑定会消耗性能。 请只传递component需要的props传得太多，或者层次传得太深，都会加重shouldComponentUpdate里面的数据比较负担，因此，也请慎用spread attributes（）。 请尽量使用const element可以将不怎么变动，或者不需要传入状态的component写成const element的形式，这样能加快这个element的初始渲染速度。 3.JS阻塞性能 JavaScript在网站开发中几乎已经确定了垄断地位，哪怕是一个再简单不过的静态页面，你都可能看到JS的存在，可以说，没有JS，网站就基本告别用户交互了。然而，脚本带来的问题就是他会阻塞页面的平行下载，还会提高进程的CPU占用率。更有甚者，现在node.js已经在前端开发中普及，稍有不慎，我们引发了内存泄漏，或者在代码中误写了死循环，会直接造成我们的服务器崩溃。在如今这个JS已经遍布前后端的时代，性能的瓶颈不单单只是停留在影响用户体验上，还会有更多更为严重的问题，对JS的性能优化工作不可小觑。 在编程的过程中，如果我们使用了闭包后未将相关资源加以释放，或者引用了外链后未将其置空（比如给某DOM元素绑定了事件回调，后来却remove了该元素），都会造成内存泄漏的情况发生，进而大量占用用户的CPU，造成卡顿或死机。我们可以使用chrome提供的JavaScript Profile版块，开启方式同Layers等版块，这里我就不再多说了，直接上效果图： 我们可以清楚看见JS执行时各函数的执行时间以及CPU占用情况，如果我在代码里增加一行while(true){}, 那么它的占用率一定会飙升到一个异常的指标（亲测93.26%）。 其实浏览器强大的内存回收机制在大多数时候避免了这一情况的发生，即便用户发生了死机，他只要结束相关进程（或关闭浏览器）就可以解决这一问题，但我们要知道，同样的情况还会发生在我们的服务器端，也就是我们的node中，严重的情况，会直接造成我们的服务器宕机，网站崩溃。所以更多时候，我们都使用JavaScript Profile版块来对我们的node服务进行压力测试，搭配node-inspector 插件，我们能更有效地检测JS执行时各函数的CPU占用率，针对性地进行优化。 （PS：所以没修炼到一定水平，千万别在服务端使用闭包，一个是真没啥用，我们会有更多优良的解决办法，二是真的很容易内存泄漏，造成的后果是你无法预期的） 4.【拓展】负载均衡 之所以将负载均衡作为拓展内容，是因为如果是你自己搭建的个人网站，或者中小型网站，其实并不需要考虑多大的并发量，但是如果你搭建的是大型网站，负载均衡便是开发过程不可或缺的步骤。 4.1.Node.js处理IO密集型请求 现在的开发流程都注重前后端分离，也就是软件工程中常提到的“高内聚低耦合”的思想，你也可以用模块化的思想去理解，前后解耦就相当与把一个项目分成了前端和后端两个大模块，中间通过接口联系起来，分别进行开发。这样做有什么好处？我就举最有实际效果的一点：“异步编程”。这是我自己想的名字，因为我觉得前后解耦的形式很像我们JS中的异步队列，传统的开发模式是“同步”的，前端需要等后端封装好接口，知道了能拿什么数据，再去开发，时间短，工程大。而解耦之后，我们只需要提前约定好接口，前后两端就可以同时开发，不仅高效而且省时。 我们都知道node的核心是事件驱动，通过Event Loop去异步处理用户请求，相比于传统的后端服务，它们都是将用户的每个请求分配一个进程进行处理，推荐大家去看这样一篇博文 。特别生动地讲解了事件驱动的运行机制，通俗易懂。事件驱动的最大优势是什么？就是在高并发IO时，不会造成堵塞，对于直播类网站，这点是至关重要的，我们有成功的先例——快手，快手强大的IO高并发究其本质一定能追溯到node。 其实现在的企业级网站，都会搭建一层node作为中间层。大概的网站框架如图所示： 4.2.pm2实现Node.js“多进程” 我们都知道node的优劣，这里分享一份链接，找了挺久写的还算详细。其实很多都是老套路，那些说node不行的都是指着node是单进程这一个软肋开撕，告诉你，我们有解决方案了——pm2。这是它的官网。它是一款node.js进程管理器，具体的功能，就是能在你的计算机里的每一个内核都启动一个node.js服务，也就是说如果你的电脑或者服务器是多核处理器（现在也少见单核了吧），它就能启动多个node.js服务，并且它能够自动控制负载均衡，会自动将用户的请求分发至压力小的服务进程上处理。听起来这东西简直就是神器啊！而且它的功能远远不止这些，这里我就不作过多介绍了，大家知道我们在上线的时候需要用到它就行了，安装的方法也很简单，直接用npm下到全局就可以了$ npm i pm2 -g具体的使用方法还有相关特性可以参照官网。 下面是pm2启动后的效果图： 4.3.nginx搭建反向代理 在开始搭建工作之前，首先得知道什么是反向代理。可能大家对这个名词比较陌生，先上一张图： 所谓代理就是我们通常所说的中介，网站的反向代理就是指那台介于用户和我们真实服务器之间的服务器（说的我都拗口了），它的作用便是能够将用户的请求分配到压力较小的服务器上，其机制是轮询。听完这句话是不是感觉很耳熟，没错，在我介绍pm2的时候也说过同样的话，反向代理起到的作用同pm2一样也是实现负载均衡，你现在应该也明白了两者之间的差异，反向代理是对服务器实现负载均衡，而pm2是对进程实现负载均衡。大家如果想深入了解反向代理的相关知识，我推荐知乎的一个贴子 。但是大家会想到，配服务器是运维的事情啊，和我们前端有什么关系呢？的确，在这部分，我们的工作只有一些，只需要向运维提供一份配置文档即可。 http { upstream video { ip_hash; server localhost:3000; } server { listen: 8080; location / { proxy_pass: http://video } } } 也就是说，在和运维对接的时候，我们只需要将上面这几行代码改为我们配置好的文档发送给他就行了，其他的事情，运维小哥会明白的，不用多说，都在酒里。 但是，这几行代码该怎么去改呢？首先我们得知道，在nginx中，模块被分为三大类：handler、filter和upstream。而其中的upstream模块，负责完成完成网络数据的接收、处理和转发，也是我们需要在反向代理中用到的模块。接下来我们将介绍配置代码里的内容所表示的含义： 4.3.1.upstream配置信息 upstream关键字后紧跟的标识符是我们自定义的项目名称，通过一对花括号在其中增添我们的配置信息。 ip_hash 关键字：控制用户再次访问时是否连接到前一次连接的服务器 server关键字：我们真实服务器的地址，这里的内容肯定是需要我们去填写的，不然运维怎么知道你把项目放在那个服务器上了，也不知道你封装了一层node而得去监听3000端口。 4.3.2.server配置信息 server是nginx的基本配置，我们需要通过server将我们定义的upstream应用到服务器上。 listen关键字：服务器监听的端口 location关键字：和我们之前在node层说到的路由是起同样的功能，这里是把用户的请求分配到对应的upstream上 5. React性能优化军规 5.1 渲染相关 提升级项目性能，请使用immutable(props、state、store) 请pure-render-decorator与immutablejs搭配使用 请慎用setState，因其容易导致重新渲染 谨慎将component当作props传入 请将方法的bind一律置于constructor 请只传递component需要的props，避免其它props变化导致重新渲染（慎用spread attributes） 请在你希望发生重新渲染的dom上设置可被react识别的同级唯一key，否则react在某些情况可能不会重新渲染。 请尽量使用const element 5.2 tap事件 简单的tap事件，请使用react-tap-event-plugin 开发环境时，最好引入webpack的环境变量（仅在开发环境中初始化），在container中初始化。生产环境的时候，请将plugin跟react打包到一起（需要打包在一起才能正常使用，因为plugin对react有好多依赖），外链引入。 目前参考了这个项目的打包方案： https://github.com/hartmamt/react-with-tap-events Facebook官方issue: https://github.com/facebook/react/blob/bef45b0b1a98ea9b472ba664d955a039cf2f8068/src/renderers/dom/client/eventPlugins/TapEventPlugin.js React-tap-event-plugin github: https://github.com/zilverline/react-tap-event-plugin 复杂的tap事件，建议使用tap component 5.3 Debug相关 移动端请慎用redux-devtools，易造成卡顿 Webpack慎用devtools的inline-source-map模式 使用此模式会内联一大段便于定位bug的字符串，查错时可以开启，不是查错时建议关闭，否则开发时加载的包会非常大。 5.4 其它 慎用太新的es6语法。Object.assign等较新的类库避免在移动端上使用，会报错。 Object.assign目前使用object-assign包。或者使用babel-plugin-transform-object-assign插件。会转换成一个extends的函数： var _extends = ...; _extends(a, b); 注意Object.assign是浅拷贝Object.assign是浅拷贝，若数据结构层次较深的时候会拷贝失败，直接回传原本的object reference，此处推荐lodash.merge。 "},"面试/如何渲染几万条数据并不卡住界面.html":{"url":"面试/如何渲染几万条数据并不卡住界面.html","title":"如何渲染几万条数据并不卡住界面","keywords":"","body":"如何渲染几万条数据并不卡住界面 这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 requestAnimationFrame 来每 16 ms 刷新一次。 Document 控件 setTimeout(() => { // 插入十万条数据 const total = 100000 // 一次插入 20 条，如果觉得性能不好就减少 const once = 20 // 渲染数据总共需要几次 const loopCount = total / once let countOfRender = 0 let ul = document.querySelector('ul') function add() { // 优化性能，插入不会造成回流 const fragment = document.createDocumentFragment() for (let i = 0; i "},"面试/综合1.html":{"url":"面试/综合1.html","title":"综合1","keywords":"","body":"js面试题(一) js面试题(一) 1. 循环闭包、IIFE、 ES6、 Promise、 ES7 await async 1.1 不起眼的开始 1.2 期望代码的输出变成 0 -> 1 -> 2 -> 3 -> 4 -> 5，并且要求原有的代码块中的循环和两处 console.log 不变 1.3 ES7 2. 闭包的作用，缺点 2.1 定义 2.2 闭包的特点： 2.3 优缺点 3. 深浅拷贝的区别和用途 3.1 理解 3.2 JavaScript的数据类型分为基本数据类型和引用数据类型 3.3 几种深拷贝的实现 4. CSS有哪些实现布局的方式 5. CSS命名冲突如何解决 6. 介绍下 ES 里的 Generator 是怎么运行的？ 和 async + await 有何区别？ 7. React 里的 key 有什么作用？ 8. React 里什么时候用 Context? 9. render props是什么？什么时候用？ 9.1 render props 9.2 传递 props 9.3 不局限于 children 9.4 依赖注入 9.5 render props 和高阶组件的比较 10. 路由如何做权限校验？ 10.1 实现 10.2 vue 路由权限限制 10.3 vue 路由验证 10.4 如何用 Vue 实现前端权限控制(CSDN) 11. SSR 的原理是什么？ 11.1 使用 SSR 技术的主要因素 11.2 SSR 中客户端渲染与服务器端渲染路由代码的差异 11.3 服务器端代码和客户端代码的打包差异 11.4 SSR 中异步数据的获取 + Redux 的使用 11.5 Node 只是一个中间层 12. React中调用setState之后发生了什么事情? 13. React中Element与Component的区别? 14. 在什么情况下会优先选择使用ClassComponent而不是FunctionalComponent? 15. React中的refs属性的作用是什么? 16. React中keys的作用是什么? 17. 回调渲染模式( Render Callback Pattern) 18. 组件的生命周期有哪三个状态, 有哪几个钩子函数？ 19. 在生命周期中的哪一步你应该发起 AJAX 请求？ 20. shouldComponentUpdate作用,为何重要？ 21. React 的工作原理 22. 使用 React 有何优点 23. 展示组件(Presentational component)和容器组件(Container component)之间有何不同 24. 类组件(Class component)和函数式组件(Functional component)之间有何不同 25. (组件的)状态(state)和属性(props)之间有何不同 26. 何为受控组件(controlled component) 27. 何为高阶组件(higher order component) 28. 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象 29. 除了在构造函数中绑定 this，还有其它方式吗 30. 怎么阻止组件的渲染 31. (在构造函数中)调用 super(props) 的目的是什么 32. 何为 JSX 33. 何为 Children 34. 何为 redux 35. 在 Redux 中，何为 store 36. 何为 action 37. 何为 reducer 38. Redux Thunk 的作用是什么 39. 何为纯函数(pure function) 40. react中的回调渲染模式 41. React 中的事件处理逻辑 42. React解决了什么问题 43. React的协议问题你了解吗 44. 你在过去的项目里遇到的最大问题是什么？你最大的成就？ 45. 传入 setState 函数的第二个参数的作用是什么？ 46. 封装ajax 47. Bind实现 48. 快速排序 49. 正则匹配结巴程序 50. ['1', '2', '3'].map(parseInt) 解析 51. 防抖和节流 防抖 debounce 节流 throttle 52. Set、Map、WeakSet 和 WeakMap 的区别？ 53. ES5/ES6 的继承除了写法以外还有什么区别 54. 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组 55. JS 异步解决方案的发展历程以及优缺点。 1. 回调函数（callback） 2. Promise 3. Generator 4. Async/await 56. 10 个 Ajax 同时发起请求，全部返回展示结果，并且至多允许三次失败，说出设计思路 57. 基于 Localstorage 设计一个 1M 的缓存系统，需要实现缓存淘汰机制 1. 循环闭包、IIFE、 ES6、 Promise、 ES7 await async 1.1 不起眼的开始 for (var i = 0; i 1.2 期望代码的输出变成 0 -> 1 -> 2 -> 3 -> 4 -> 5，并且要求原有的代码块中的循环和两处 console.log 不变 代码执行时，立即输出 0，之后每隔 1 秒依次输出 1,2,3,4，循环结束后在大概第 5 秒的时候输出 5 ```js for (var i = 0; i setTimeout(function() { // 这里增加定时器，超时设置为 5 秒 console.log(new Date, i); }, 1000 * i); 如果把这次的需求抽象为：在系列异步操作完成（每次循环都产生了 1 个异步操作）之后，再做其他的事情 ```js const tasks = []; for (var i = 0; i { tasks.push(new Promise((resolve) => { setTimeout(() => { console.log(new Date, j); resolve(); // 这里一定要 resolve，否则代码不会按预期 work }, 1000 * j); // 定时器的超时时间逐步增加 })); })(i); } Promise.all(tasks).then(() => { setTimeout(() => { console.log(new Date, i); }, 1000); // 注意这里只需要把超时设置为 1 秒 }); 相比而言，笔者更倾向于下面这样看起来更简洁的代码，要知道编程风格也是很多面试官重点考察的点，代码阅读时的颗粒度更小，模块化更好，无疑会是加分点。 const tasks = []; // 这里存放异步操作的 Promise const output = (i) => new Promise((resolve) => { setTimeout(() => { console.log(new Date, i); resolve(); }, 1000 * i); }); // 生成全部的异步操作 for (var i = 0; i { setTimeout(() => { console.log(new Date, i); }, 1000); }); 1.3 ES7 既然 Promise 已经被拿下，如何使用 ES7 中的 async await 特性来让这段代码变的更简洁？ // 模拟其他语言中的 sleep，实际上可以是任何异步操作 const sleep = (timeountMS) => new Promise((resolve) => { setTimeout(resolve, timeountMS); }); (async () => { // 声明即执行的 async 函数表达式 for (var i = 0; i 2. 闭包的作用，缺点 2.1 定义 闭包 当一个函数的返回值是另外一个函数,而返回的那个函数如果调用了其父函数内部的变量,且返回的这个函数在外部被执行就产生了闭包.闭包是一个环境，具体指的就是外部函数--高阶函数。 一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数） 能够读取其他函数内部变量的函数 2.2 闭包的特点： 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。 简单的闭包如下： function f1(){ var n = 100; return function f2(){ alert(++n); } } 函数执行时创建了一个内部函数，这个内部函数作为返回值，或以某种方式保留下来（属性），之后才会调用，这就会形成了闭包。通俗来讲，JS所有的function都是一个闭包。 2.3 优缺点 优点 可以读取函数内部的变量 可以让这些局部变量保存在内存中，实现变量数据共享。 避免全局变量的污染 私有成员的存在 缺点 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。 3. 深浅拷贝的区别和用途 3.1 理解 简单的来说就是，在有指针的情况下，浅拷贝只是增加了一个指针指向已经存在的内存，而深拷贝就是增加一个指针并且申请一个新的内存，使这个增加的指针指向这个新的内存，采用深拷贝的情况下，释放内存的时候就不会出现在浅拷贝时重复释放同一内存的错误！ 假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，拿人手短，如果B没变，那就是深拷贝，自食其力。 浅拷贝例子 let a=[0,1,2,3,4], b=a; console.log(a===b); // true a[0]=1; console.log(a,b); // (5) [1, 1, 2, 3, 4] (5) [1, 1, 2, 3, 4] 3.2 JavaScript的数据类型分为基本数据类型和引用数据类型 基本数据类型: number，string，boolean，null，undefined，symbol以及未来ES10新增的BigInt(任意精度整数)七类 引用数据类型(Object类)有常规名值对的无序对象{a:1}，数组[1,2,3]，以及函数等 而这两类数据存储分别是这样的 基本类型--名值存储在栈内存中，例如let a=1; 当你b=a复制时，栈内存会新开辟一个内存，例如这样： 所以当你此时修改a=2，对b并不会造成影响，因为此时的b已自食其力，翅膀硬了，不受a的影响了。 当然，let a=1,b=a;虽然b不受a影响，但这也算不上深拷贝，因为深拷贝本身只针对较为复杂的object类型数据。 引用数据类型--名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值 我们以上面浅拷贝的例子画个图： 当b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里面的值。 而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝了。 那，要是在堆内存中也开辟一个新的内存专门为b存放值，就像基本类型那样，岂不就达到深拷贝的效果了 3.3 几种深拷贝的实现 // 法1 // 递归去复制所有层级属性 function deepClone(obj){ let objClone = Array.isArray(obj)?[]:{}; if(obj && typeof obj===\"object\"){ for(key in obj){ if(obj.hasOwnProperty(key)){ //判断ojb子元素是否为对象，如果是，递归复制 if(obj[key]&&typeof obj[key] ===\"object\"){ objClone[key] = deepClone(obj[key]); }else{ //如果不是，简单复制 objClone[key] = obj[key]; } } } } return objClone; } let a=[1,2,3,4], b=deepClone(a); a[0]=2; console.log(a,b); // 法2 // 除了递归，我们还可以借用JSON对象的parse和stringify function deepClone(obj){ let _obj = JSON.stringify(obj), objClone = JSON.parse(_obj); return objClone } let a=[0,1,[2,3],4], b=deepClone(a); a[0]=1; a[2][0]=1; console.log(a,b); // 法3 function copy(obj){ //浅拷贝 var newObj = {}; for(var attr in obj){ newObj[attr] = obj[attr] } return newObj; } function deepCopy(obj){ //深拷贝 if(typeof obj != 'object'){ console.trace(); return obj; } var newObj = {}; for(var attr in obj){ newObj[attr] = deepCopy(obj[attr]); } return newObj; } // 法4 function extendCopy(p){ var c = {}; for(var i in p){ c[i] = p[i]; } c.uber = p; return c; } function deepCopy(p,c){ var c = c || {}; for(var i in p){ if(typeof p[i] === 'object'){ c[i] = (p[i].constructor === Array) ? [] : {}; deepCopy(p[i],c[i]); }else{ c[i] = p[i] } } return c; } 4. CSS有哪些实现布局的方式 table 布局 flex 布局 float 布局 响应式布局 meta 标签 使用 rem media query 5. CSS命名冲突如何解决 css-modules 细化选择符 假如全局是这样来定义一个元素的样式的：.abc {background:#000}，同时这个class为abc的元素是隶属于某个元素的，比如下面这样的html代码结构 那么在细化css里面，只需要在.abc前面加多一个父元素的选择符就行了： .container .abc {background:#fff} 这样.container .abc的优先级就大于了.abc，自然细化css里面的background设置也就不会被全局CSS覆盖了~~ 提升样式的优先级 这种方法个人不太推荐，相对而言会简单粗暴一些。同样是上面的例子，在细化CSS里面，只要在样式后面加一个!important，例如这样： .abc {background:#fff !improtant;} 这个样式的优先级就会默认提升到顶级，全局样式就无法影响到它了。 改变两个样式的加载顺序 这种方法比较简单，就是只要把细化css加载在全局css之后就行了，这样后面的样式就会自动覆盖前面的样式。不过如果你的html里面这两个样式表的加载顺序是先细化后全局的话，就要稍微调整一下代码才行。 6. 介绍下 ES 里的 Generator 是怎么运行的？ 和 async + await 有何区别？ Promise的写法只是回调函数的改进，使用then方法，只是让异步任务的两段执行更清楚而已。Promise的最大问题是代码冗余，请求任务多时，一堆的then，也使得原来的语义变得很不清楚 Generator 函数是一个普通函数，但是有两个特征。 一是，function关键字与函数名之间有一个星号； 二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。虽然Generator将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段） async函数，自动执行Generator函数的方法。使得异步操作变得更加方便。简单说来，它就是Generator函数的语法糖。 简单的说async函数就相当于自执行的Generator函数，相当于自带一个状态机，在await的部分等待返回， 返回后自动执行下一步。而且相较于Promise,async的优越性就是把每次异步返回的结果从then中拿到最外层的方法中，不需要链式调用，只要用同步的写法就可以了。更加直观而且，更适合处理并发调用的问题。但是async必须以一个Promise对象开始 ，所以async通常是和Promise结合使用的 7. React 里的 key 有什么作用？ Keys 是React在操作列表中元素被修改,添加,或者删除的辅助标识. 在开发过程中,我们需要保证某个元素的key 在其同级元素中具有唯一性,在ReactDiff算法中React会借助元素的Key值来判断该元素是新创建的还是被移动而来的元素,React会保存这个辅助状态,从而减少不必要的元素渲染.此外,React还需要借助Key值来判断元素与本地状态的关联干洗,因此我们在开发中不可忽视Key值的使用. Keys 会有助于 React 识别哪些 items 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key 的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 items 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果 items 可以重新排序，就会导致 re-render 变慢。 8. React 里什么时候用 Context? 当我们使用React时，很容易的通过观察组件的props来跟踪组件间的数据流流向，这种跟踪观察方式也让我们很容易的去理解组件。 而有的时候，我们不想让一个props从最外层，通过组件一层一层的传递到目标组件上，这时就可以通过context来直接实现我们希望的操作。 context最好的使用场景是隐式的传入登录的用户，当前的语言，或者主题信息。要不然所有这些可能就是全局变量，但是context让你限定他们到一个单独的React树里。 9. render props是什么？什么时候用？ 9.1 render props 所谓 render props，指的是让 React 组件的 props 支持函数这种模式。因为作为 props 传入的函数往往被用来渲染一部分界面，所以这种模式被称为 render props。 Render Props 的核心思想是，通过一个函数将class组件的state作为props传递给纯函数组件 一个最简单的 render props 组件 RenderAll，代码如下： const RenderAll = (props) => { return( {props.children(props)} ); }; 这个 RenderAll 预期子组件是一个函数，它所做的事情就是把子组件当做函数调用，调用参数就是传入的 props，然后把返回结果渲染出来，除此之外什么事情都没有做。 使用 RenderAll 的代码如下： {() => hello world} 可以看到，RenderAll 的子组件，也就是夹在 RenderAll 标签之间的部分，其实是一个函数。这个函数渲染出 hello world，这就是上面使用 RenderAll 渲染出来的结果。 当然，这个 RenderAll 没做任何实际工作，接下来我们看 render props 真正强悍的使用方法。 9.2 传递 props 和高阶组件一样，render props 可以做很多的定制功能，我们还是以根据是否登录状态来显示一些界面元素为例，来实现一个 render props。 下面是实现 render props 的 Login 组件，可以看到，render props 和高阶组件的第一个区别，就是 render props 是真正的 React 组件，而不是一个返回 React 组件的函数。 const Login = (props) => { const userName = getUserName(); if (userName) { const allProps = {userName, ...props}; return ( {props.children(allProps)} ); } else { return null; } }; 当用户处于登录状态，getUserName 返回当前用户名，否则返回空，然后我们根据这个结果决定是否渲染 props.children 返回的结果。 当然，render props 完全可以决定哪些 props 可以传递给 props.children，在 Login 中，我们把 userName 作为增加的 props 传递给下去，这样就是 Login 的增强功能。 一个使用上面 Login 的 JSX 代码示例如下： {({userName}) => Hello {userName}} 对于名为“程墨Morgan”的用户登录，上面的 JSX 会产生 Hello 程墨Morgan。 9.3 不局限于 children 在上面的例子中，作为 render 方法的 props 就是 children，在我写的《深入浅出React和Redux》中，将这种模式称为“以函数为子组件（function as child）”的模式，这可以算是 render props 的一种具体形式，也就利用 children 这个 props 来作为函数传递。 实际上，render props 这个模式不必局限于 children 这一个 props，任何一个 props 都可以作为函数，也可以利用多个 props 来作为函数。 我们来扩展 Login，不光在用户登录时显示一些东西，也可以定制用户没有登录时显示的东西，我们把这个组件叫做 Auth，对应代码如下： const Auth = (props) => { const userName = getUserName(); if (userName) { const allProps = {userName, ...props}; return ( {props.login(allProps)} ); } else { {props.nologin(props)} } }; 使用 Auth 的话，可以分别通过 login 和 nologin 两个 props 来指定用户登录或者没登录时显示什么，用法如下： Hello {userName}} nologin={() => Please login} /> 9.4 依赖注入 render props 其实就是 React 世界中的 “依赖注入”（Dependency Injection)。 所谓依赖注入，指的是解决这样一个问题：逻辑 A 依赖于逻辑 B，如果让 A 直接依赖于 B，当然可行，但是 A 就没法做得通用了。依赖注入就是把 B 的逻辑以函数形式传递给 A，A 和 B 之间只需要对这个函数接口达成一致就行，如此一来，再来一个逻辑 C，也可以用一样的方法重用逻辑 A。 在上面的代码示例中，Login 和 Auth 组件就是上面所说的逻辑 A，而传递给组件的函数类型 props，就是逻辑 B 和 C。 9.5 render props 和高阶组件的比较 我们来比对一下这两种重用 React 组件逻辑的模式。 首先，render props 模式的应用，就是做一个 React 组件，而高阶组件，虽然名为“组件”，其实只是一个产生 React 组件的函数。 render props 不像上一小节中介绍的高阶组件有那么多毛病，如果说 render props 有什么缺点，那就是 render props 不能像高阶组件那样链式调用，当然，这并不是一个致命缺点。 render props 相对于高阶组件还有一个显著优势，就是对于新增的 props 更加灵活。还是以登录状态为例，假如我们扩展 withLogin 的功能，让它给被包裹的组件传递用户名这个 props，代码如下： const withLogin = (Component) => { const NewComponent = (props) => { const userName= getUserName(); if (userName) { return ; } else { return null; } } return NewComponent; }; 这就要求被 withLogin 包住的组件要接受 userName 这个props。可是，假如有一个现成的 React 组件不接受 userName，却接受名为 name 的 props 作为用户名，这就麻烦了。我们就不能直接用 withLogin 包住这个 React 组件，还要再造一个组件来做 userName 到 name 的映射，十分费事。 对于应用 render props 的 Login，就不存在这个问题，接受 name 不接受 userName 是吗？这样写就好了： { (props) => { const {userName} = props; return } } 所以，当需要重用 React 组件的逻辑时，建议首先看这个功能是否可以抽象为一个简单的组件；如果行不通的话，考虑是否可以应用 render props 模式；再不行的话，才考虑应用高阶组件模式。 这并不表示高阶组件无用武之地，在后续章节，我们会对 render props 和高阶组件分别讲解具体的实例。 10. 路由如何做权限校验？ 10.1 实现 登陆权限，一般来说这个是独立出来，不用 spa 做，就一个表单的事情，后面也容易做扩展，包括单点登录什么的； 登陆集成到 spa 里面，这个一般在请求加拦截，vuex 可以存 token，每次请求头带 token，后端校验 token 是否有效，如果修改了或者过期了，返回约定的字段标识，异步请求 axios 在返回 response 的时候优先拦截 token 校验，如果失效直接 vue-router 路由到登录页； 内部权限，子页面什么的，前端一般是打包好了文件，页面是全部的，但是有的页面需要权限控制是否能访问，这时候只能做 2 次校验，后端返回当前权限能访问的路由 or 页面，存 vuex，前端路由加 watch，每次切换跳转都要遍历一次； 接口权限，有的接口是不能提供给无权限的人使用的，比如抓包出来的；这时候后端做鉴权，返回约定的字段就行 后台接口加一层 api gateway 做权限控制，防止越权调用 请求后台接口获取当前登录用户所有的 [可用菜单（路由）] 及 [权限信息（权限 key ）] 根据 [可用菜单] 动态生成 router 页面子控件，如按钮（对应权限 key ）通过 v-if 实现显示与隐藏， 如新增用户 hasPermission 做成一个 mixin 混入所有组件 10.2 vue 路由权限限制 function routerXmlFlag (menu, to) { for (let i = 0; i { if (to.meta.requireAuth) { // 判断该路由是否需要登录权限 let token = sessionStorage.getItem('X-CSRF-TOKEN') if (token) { // 通过vuex state获取当前的token是否存在 let menu = store.state.common.menu // 为了菜单的链接，直接跳转404 if (menu && menu.length > 0) { let flag = routerXmlFlag(menu, to) if (flag) { next() } else { next('/404') } } else { next() } } else { next({ path: '/login', query: {redirect: to.fullPath} // 将跳转的路由path作为参数，登录成功后跳转到该路由 }) } } else { next() } }) // 前提，每个用户进来分配的菜单权限不一样， 但是手动输入菜单以外的url 可以进行访问 // bug 修改，手动输入菜单以外的链接，返回404 10.3 vue 路由验证 在没有登录的情况下开发者有可能会不让用户看到某些或者进入某些页面，vue 跳转使用的是vue-roter跳转。 使用vue-router的beforeEach函数接受三个参数to, from, next分别是to：去的页面、from：来自那个页面、next：定向到哪里 beforeEach需要写到vue实例前。 //首先登录成功之后需要存一个状态到本地 这个状态可以是自己设置也可以配合后台来操作 router.beforeEach((to, from, next) => { //获取到登录状态 const loginStuts = sessionStorage.getItem('loginStuts') //如果登录状态不存在或者去的页面是某个用户没登录不能去的页面 //（to.path的意思为去往的 路径是/myinformation也可不写） //就跳转到login页面也就是登录界面 //next函数不传参数即是验证通过去往该页面 传入参数即是调往参数页面 if (!loginStuts && to.path == '/myinformation') { next('/login') } else { next() } }) /* eslint-disable no-new */ new Vue({ el: '#app', router, components: { App }, template: '', store }) 10.4 如何用 Vue 实现前端权限控制(CSDN) 如何用 Vue 实现前端权限控制https://blog.csdn.net/gitchat/article/details/78849246 项目本身也是一个可运行的 DEMO，演示地址和测试账号同样见下方。 仓库地址：https://github.com/tower1229/Vue-Access-Control 项目主页：http://refined-x.com/Vue-Access-Control/ root 任意 client 任意 11. SSR 的原理是什么？ SSR，很多人的第一反应是“服务器端渲染”，但我更倾向于称之为“同构”，所以首先我们来对“客户端渲染”，“服务器端渲染”，“同构”这三个概念简单的做一个分析： 客户端渲染：客户端渲染，页面初始加载的 HTML 页面中无网页展示内容，需要加载执行JavaScript 文件中的 React 代码，通过 JavaScript 渲染生成页面，同时，JavaScript 代码会完成页面交互事件的绑定，详细流程可参考下图（图片取材自 fullstackacademy.com）： 服务器端渲染：用户请求服务器，服务器上直接生成 HTML 内容并返回给浏览器。服务器端渲染来，页面的内容是由 Server 端生成的。一般来说，服务器端渲染的页面交互能力有限，如果要实现复杂交互，还是要通过引入 JavaScript 文件来辅助实现。服务器端渲染这个概念，适用于任何后端语言。 同构：同构这个概念存在于 Vue，React 这些新型的前端框架中，同构实际上是客户端渲染和服务器端渲染的一个整合。我们把页面的展示内容和交互写在一起，让代码执行两次。在服务器端执行一次，用于实现服务器端渲染，在客户端再执行一次，用于接管页面交互，详细流程可参考下图（图片取材自 fullstackacademy.com）: 一般情况下，当我们使用 React 编写代码时，页面都是由客户端执行 JavaScript 逻辑动态挂 DOM 生成的，也就是说这种普通的单页面应用实际上采用的是客户端渲染模式。在大多数情况下，客户端渲染完全能够满足我们的业务需求，那为什么我们还需要 SSR 这种同构技术呢？ 11.1 使用 SSR 技术的主要因素 CSR 项目的 TTFP（Time To First Page）时间比较长，参考之前的图例，在 CSR 的页面渲染流程中，首先要加载 HTML 文件，之后要下载页面所需的 JavaScript 文件，然后 JavaScript 文件渲染生成页面。在这个渲染过程中至少涉及到两个 HTTP 请求周期，所以会有一定的耗时，这也是为什么大家在低网速下访问普通的 React 或者 Vue 应用时，初始页面会有出现白屏的原因。 CSR 项目的 SEO 能力极弱，在搜索引擎中基本上不可能有好的排名。因为目前大多数搜索引擎主要识别的内容还是 HTML，对 JavaScript 文件内容的识别都还比较弱。如果一个项目的流量入口来自于搜索引擎，这个时候你使用 CSR 进行开发，就非常不合适了。 SSR 的产生，主要就是为了解决上面所说的两个问题。在 React 中使用 SSR 技术，我们让 React 代码在服务器端先执行一次，使得用户下载的 HTML 已经包含了所有的页面展示内容，这样，页面展示的过程只需要经历一个 HTTP 请求周期，TTFP 时间得到一倍以上的缩减。 同时，由于 HTML 中已经包含了网页的所有内容，所以网页的 SEO 效果也会变的非常好。之后，我们让 React 代码在客户端再次执行，为 HTML 网页中的内容添加数据及事件的绑定，页面就具备了 React 的各种交互能力。 但是，SSR 这种理念的实现，并非易事。我们来看一下在 React 中实现 SSR 技术的架构图： SSR 之所以能够实现，本质上是因为虚拟 DOM 的存在 SSR 的工程中，React 代码会在客户端和服务器端各执行一次。你可能会想，这没什么问题，都是 JavaScript 代码，既可以在浏览器上运行，又可以在 Node 环境下运行。但事实并非如此，如果你的 React 代码里，存在直接操作 DOM 的代码，那么就无法实现 SSR 这种技术了，因为在 Node 环境下，是没有 DOM 这个概念存在的，所以这些代码在 Node 环境下是会报错的。 好在 React 框架中引入了一个概念叫做虚拟 DOM，虚拟 DOM 是真实 DOM 的一个 JavaScript 对象映射，React 在做页面操作时，实际上不是直接操作 DOM，而是操作虚拟 DOM，也就是操作普通的 JavaScript 对象，这就使得 SSR 成为了可能。在服务器，我可以操作 JavaScript 对象，判断环境是服务器环境，我们把虚拟 DOM 映射成字符串输出；在客户端，我也可以操作 JavaScript 对象，判断环境是客户端环境，我就直接将虚拟 DOM 映射成真实 DOM，完成页面挂载。 其他的一些框架，比如 Vue，它能够实现 SSR 也是因为引入了和 React 中一样的虚拟 DOM 技术。 好，接下来我们回过头看流程图，前两步不说了，服务器端渲染肯定要先向 Node 服务器发送请求。重点是第 3 步，大家可以看到，服务器端要根据请求的地址，判断要展示什么样的页面了，这一步叫做服务器端路由。 我们再看第 10 步，当客户端接收到 JavaScript 文件后，要根据当前的路径，在浏览器上再判断当前要展示的组件，重新进行一次客户端渲染，这个时候，还要经历一次客户端路由（前端路由）。 那么，我们下面要说的就是服务器端路由和客户端路由的区别。 11.2 SSR 中客户端渲染与服务器端渲染路由代码的差异 实现 React 的 SSR 架构，我们需要让相同的 React 代码在客户端和服务器端各执行一次。大家注意，这里说的相同的 React 代码，指的是我们写的各种组件代码，所以在同构中，只有组件的代码是可以公用的，而路由这样的代码是没有办法公用的，大家思考下这是为什么呢？其实原因很简单，在服务器端需要通过请求路径，找到路由组件，而在客户端需通过浏览器中的网址，找到路由组件，是完全不同的两套机制，所以这部分代码是肯定无法公用。我们来看看在 SSR 中，前后端路由的实现代码： 客户端路由： const App = () => { return ( ) } ReactDom.render(, document.querySelector('#root')) 服务器端路由代码： const App = () => { return } Return ReactDom.renderToString() 服务器端路由代码相对要复杂一点，需要你把 location（当前请求路径）传递给 StaticRouter 组件，这样 StaticRouter 才能根据路径分析出当前所需要的组件是谁。（PS：StaticRouter 是 React-Router 针对服务器端渲染专门提供的一个路由组件。） 通过 BrowserRouter 我们能够匹配到浏览器即将显示的路由组件，对浏览器来说，我们需要把组件转化成 DOM，所以需要我们使用 ReactDom.render 方法来进行 DOM 的挂载。而 StaticRouter 能够在服务器端匹配到将要显示的组件，对服务器端来说，我们要把组件转化成字符串，这时我们只需要调用 ReactDom 提供的 renderToString 方法，就可以得到 App 组件对应的 HTML 字符串。 对于一个 React 应用来说，路由一般是整个程序的执行入口。在 SSR 中，服务器端的路由和客户端的路由不一样，也就意味着服务器端的入口代码和客户端的入口代码是不同的。远程控制电脑 我们知道， React 代码是要通过 Webpack 打包之后才能运行的，也就是第 3 步和第10 步运行的代码，实际上是源代码打包过后生成的代码。上面也说到，服务器端和客户端渲染中的代码，只有一部分一致，其余是有区别的。所以，针对代码运行环境的不同，要进行有区别的 Webpack 打包。 11.3 服务器端代码和客户端代码的打包差异 简单写两个 Webpack 配置文件作为 DEMO： 客户端 Webpack 配置： { entry: './src/client/index.js', output: { filename: 'index.js', path: path.resolve(__dirname, 'public') }, module: { rules: [{ test: /\\.js?$/, loader: 'babel-loader' },{ test: /\\.css?$/, use: ['style-loader', { loader: 'css-loader', options: {modules: true} }] },{ test: /\\.(png|jpeg|jpg|gif|svg)?$/, loader: 'url-loader', options: { limit: 8000, publicPath: '/' } }] } } 服务器端 Webpack 配置: { target: 'node', entry: './src/server/index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'build') }, externals: [nodeExternals()], module: { rules: [{ test: /\\.js?$/, loader: 'babel-loader' },{ test: /\\.css?$/, use: ['isomorphic-style-loader', { loader: 'css-loader', options: {modules: true} }] },{ test: /\\.(png|jpeg|jpg|gif|svg)?$/, loader: 'url-loader', options: { limit: 8000, outputPath: '../public/', publicPath: '/' } }] } }; 11.4 SSR 中异步数据的获取 + Redux 的使用 客户端渲染中，异步数据结合 Redux 的使用方式遵循下面的流程（对应图中第 12 步）： 创建 Store 根据路由显示组件 派发 Action 获取数据 更新 Store 中的数据 组件 Rerender 而在服务器端，页面一旦确定内容，就没有办法 Rerender 了，这就要求组件显示的时候，就要把 Store 的数据都准备好，所以服务器端异步数据结合 Redux 的使用方式，流程是下面的样子（对应图中第 4 步）： 创建 Store 根据路由分析 Store 中需要的数据 派发 Action 获取数据 更新Store 中的数据 结合数据和组件生成 HTML，一次性返回 下面，我们分析下服务器端渲染这部分的流程： 创建 Store：这一部分有坑，要注意避免，大家知道，客户端渲染中，用户的浏览器中永远只存在一个 Store，所以代码上你可以这么写： const store = createStore(reducer, defaultState) export default store; 然而在服务器端，这么写就有问题了，因为服务器端的 Store 是所有用户都要用的，如果像上面这样构建 Store，Store 变成了一个单例，所有用户共享 Store，显然就有问题了。所以在服务器端渲染中，Store 的创建应该像下面这样，返回一个函数，每个用户访问的时候，这个函数重新执行，为每个用户提供一个独立的 Store： const getStore = (req) => { return createStore(reducer, defaultState); } export default getStore; 根据路由分析 Store 中需要的数据： 要想实现这个步骤，在服务器端，首先我们要分析当前出路由要加载的所有组件，这个时候我们可以借助一些第三方的包，比如说 react-router-config, 具体这个包怎么使用，不做过多说明，大家可以查看文档，使用这个包，传入服务器请求路径，它就会帮助你分析出这个路径下要展示的所有组件。 派发 Action 获取数据: 接下来，我们在每个组件上增加一个获取数据的方法： Home.loadData = (store) => { return store.dispatch(getHomeList()) } 这个方法需要你把服务器端渲染的 Store 传递进来，它的作用就是帮助服务器端的 Store 获取到这个组件所需的数据。 所以，组件上有了这样的方法，同时我们也有当前路由所需要的所有组件，依次调用各个组件上的 loadData 方法，就能够获取到路由所需的所有数据内容了。 更新 Store 中的数据: 其实，当我们执行第三步的时候，已经在更新 Store 中的数据了，但是，我们要在生成 HTML 之前，保证所有的数据都获取完毕，这怎么处理呢？ // matchedRoutes 是当前路由对应的所有需要显示的组件集合 matchedRoutes.forEach(item => { if (item.route.loadData) { const promise = new Promise((resolve, reject) => { item.route.loadData(store).then(resolve).catch(resolve); }) promises.push(promise); } }) Promise.all(promises).then(() => { // 生成 HTML 逻辑 }) 这里，我们使用 Promise 来解决这个问题，我们构建一个 Promise 队列，等待所有的 Promise 都执行结束后，也就是所有 store.dispatch 都执行完毕后，再去生成 HTML。这样的话，我们就实现了结合 Redux 的 SSR 流程。 在上面，我们说到，服务器端渲染时，页面的数据是通过 loadData 函数来获取的。而在客户端，数据获取依然要做，因为如果这个页面是你访问的第一个页面，那么你看到的内容是服务器端渲染出来的，但是如果经过 react-router 路由跳转道第二个页面，那么这个页面就完全是客户端渲染出来的了，所以客户端也要去拿数据。 在客户端获取数据，使用的是我们最习惯的方式，通过 componentDidMount 进行数据的获取。这里要注意的是，componentDidMount 只在客户端才会执行，在服务器端这个生命周期函数是不会执行的。所以我们不必担心 componentDidMount 和 loadData 会有冲突，放心使用即可。这也是为什么数据的获取应该放到 componentDidMount 这个生命周期函数中而不是 componentWillMount 中的原因，可以避免服务器端获取数据和客户端获取数据的冲突。 11.5 Node 只是一个中间层 上一部分我们说到了获取数据的问题，在 SSR 架构中，一般 Node 只是一个中间层，用来做 React 代码的服务器端渲染，而 Node 需要的数据通常由 API 服务器单独提供。 这样做一是为了工程解耦，二也是为了规避 Node 服务器的一些计算性能问题。 请大家关注图中的第 4 步和第 12，13 步，我们接下来分析这几个步骤。 服务器端渲染时，直接请求 API 服务器的接口获取数据没有任何问题。但是在客户端，就有可能存在跨域的问题了，所以，这个时候，我们需要在服务器端搭建 Proxy 代理功能，客户端不直接请求 API 服务器，而是请求 Node 服务器，经过代理转发，拿到 API 服务器的数据。 这里你可以通过 express-http-proxy 这样的工具帮助你快速搭建 Proxy 代理功能，但是记得配置的时候，要让代理服务器不仅仅帮你转发请求，还要把 cookie 携带上，这样才不会有权限校验上的一些问题。 // Node 代理功能实现代码 app.use('/api', proxy('http://apiServer.com', { proxyReqPathResolver: function (req) { return '/ssr' + req.url; } })); 12. React中调用setState之后发生了什么事情? React会将当前传入的参数对象与组件当前的状态合并,然后触发调和过程,在调和的过程中,React会以相对高效的方式根据新的状态构建React元素树并且重新渲染整个UI界面. React得到的元素树之后,React会自动计算出新的树与老的树的节点的差异,然后根据差异对界面进行最小化的渲染,在React的差异算法中,React能够精确的知道在哪些位置发生看改变以及应该如何去改变,这样就保证了UI是按需更新的而不是重新渲染整个界面. 调用setState >> 将传入参数与组件当前状态合并 >> 触发Reconciliation调和过程(生成最终状态) >> 高效构建虚拟DOM,并准备renderUI界面 >> 计算新旧DOM异同 >> 根据异同进行render不同点 >> 完成按需更新 在代码中调用setState函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个UI界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。 13. React中Element与Component的区别? ReactElement是描述屏幕上所见的内容的数据结构,是对于UI的对象的表述.典型的ReactElement就是利用JSX构建的声明式代码片段,然后被转化为createElement的调用组合. ReactComponent则是可以接收参数输入并且返回某个ReactElement的函数或者类. 14. 在什么情况下会优先选择使用ClassComponent而不是FunctionalComponent? 组件需要包含内部状态或者使用到生命周期函数的时候使用ClassComponent,否则使用函数式组件 15. React中的refs属性的作用是什么? Refs是React提供给我们安全的访问DOM元素或者某个组件实例的句柄,我们可以为元素添加ref属性然后在回调函数中接收该元素在DOM树中的句柄,该值会作为回调函数的第一个参数的返回. 16. React中keys的作用是什么? Keys 是React在操作列表中元素被修改,添加,或者删除的辅助标识. 在开发过程中,我们需要保证某个元素的key 在其同级元素中具有唯一性,在ReactDiff算法中React会借助元素的Key值来判断该元素是新创建的还是被移动而来的元素,React会保存这个辅助状态,从而减少不必要的元素渲染.此外,React还需要借助Key值来判断元素与本地状态的关联干洗,因此我们在开发中不可忽视Key值的使用. Keys 会有助于 React 识别哪些 items 改变了，被添加了或者被移除了。Keys 应该被赋予数组内的元素以赋予(DOM)元素一个稳定的标识，选择一个 key 的最佳方法是使用一个字符串，该字符串能惟一地标识一个列表项。很多时候你会使用数据中的 IDs 作为 keys，当你没有稳定的 IDs 用于被渲染的 items 时，可以使用项目索引作为渲染项的 key，但这种方式并不推荐，如果 items 可以重新排序，就会导致 re-render 变慢。 key是给每一个vnode的唯一id,可以依靠key,更准确, 更快的拿到oldVnode中对应的vnode节点。 主要是为了提升diff【同级比较】的效率。自己想一下自己要实现前后列表的diff，如果对列表的每一项增加一个key，即唯一索引，那就可以很清楚的知道两个列表谁少了谁没变。而如果不加key的话，就只能一个个对比了。 17. 回调渲染模式( Render Callback Pattern) 在这种模式中,组件会接收某个函数作为子组件,然后在渲染函数中以props.children进行调用. import React ,{ Component, PropTypes } from 'react'; import fetchUser from 'Twitter'; class Twitter extends Component{ state = { user : null } satic propTypes = { userName.propTypes.String.isRequied } componentDidMount(){ fetchUser(this.props.userName) .then((user)=>{ this.setState({user}) }) } render(){ return this.props.children(this.state.user) } } 此模式的优势在于将父组件与子组件解耦,父组件可以直接访问子组件的内部状态而不需要再通过Props传递,这样父组件能够更为方便地控制子组件展示的UI界面.如果将原本展示的Badge替换为Profile,可以方便的修改回调函数来实现 { (user) => user === null } 18. 组件的生命周期有哪三个状态, 有哪几个钩子函数？ 有三个状态: 已经插入到DOM中 正在更新 已经卸载完毕 8个生命周期: construtor()　　 　　　　　　 创建组件 componentWillMount 　　 组件加载前 componentDidMount 　　　　 组件加载完成 componentWillRecevieProps() 　　父组件发生了 render 的时候, 子组件就调用这个钩子函数, 进行更新当前组件中, 传参相关的状态 shouldComponentUpdate() 　　　 组件挂载完成后, 如果调用setState就会调用shouldComponentUpdate()函数, 来确定是否有必要更新渲染此组件, 默认返回true componentDidUpdate() 　　　 必要的状态更新完成 render()　　　　　　　　　　　　开始渲染, react核心函数 componentWillUnMount　　　　 组件卸载 / 销毁时调用, 一般都是: componentDidMount() 函数中定义注册的事件, 在这里删除 19. 在生命周期中的哪一步你应该发起 AJAX 请求？ 我们应当将AJAX 请求放到 componentDidMount 函数中执行，主要原因有下： 放到componentWillMount不好. React 下一代调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。对于 componentWillMount 这个生命周期函数的调用次数会变得不确定，React 可能会多次频繁调用 componentWillMount。如果我们将 AJAX 请求放到 componentWillMount 函数中，那么显而易见其会被触发多次，自然也就不是好的选择。 如果我们将 AJAX 请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在 componentDidMount 函数中进行 AJAX 请求则能有效避免这个问题 在 componentDidMount 函数中发起ajax请求 保证请求仅在组件挂载完毕后才会要求响应 调和算法 Fiber 会通过开始或停止渲染的方式优化应用性能，其会影响到 componentWillMount 的触发次数。React 可能会多次频繁调用componentWillMount。 20. shouldComponentUpdate作用,为何重要？ shouldComponentUpdate 是 允许 我们手动进行组件更新, 可以根据组件的实际应用场景, 设置合理的函数返回值 , 决定是否要更新, 能够避免不必要的更新. 21. React 的工作原理 React 会创建一个虚拟 DOM(virtual DOM)。当一个组件中的状态改变时，React 首先会通过 \"diffing\" 算法来标记虚拟 DOM 中的改变，第二步是调节(reconciliation)，会用 diff 的结果来更新 DOM。 22. 使用 React 有何优点 只需查看 render 函数就会很容易知道一个组件是如何被渲染的 JSX 的引入，使得组件的代码更加可读，也更容易看懂组件的布局，或者组件之间是如何互相引用的 支持服务端渲染，这可以改进 SEO 和性能 易于测试 React 只关注 View 层，所以可以和其它任何框架(如Backbone.js, Angular.js)一起使用 23. 展示组件(Presentational component)和容器组件(Container component)之间有何不同 展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。 容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。 24. 类组件(Class component)和函数式组件(Functional component)之间有何不同 类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态 当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 '无状态组件(stateless component)'，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件 在组件需要包含内部状态或者使用到生命周期函数的时候使用 Class Component ，否则使用函数式组件。 25. (组件的)状态(state)和属性(props)之间有何不同 State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。 Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据--回调函数也可以通过 props 传递。 26. 何为受控组件(controlled component) 在 HTML 中，类似 , 和 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为\"受控元素\"。 27. 何为高阶组件(higher order component) 高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。 28. 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象 因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。 29. 除了在构造函数中绑定 this，还有其它方式吗 你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。 30. 怎么阻止组件的渲染 在组件的 render 方法中返回 null 并不会影响触发组件的生命周期方法 31. (在构造函数中)调用 super(props) 的目的是什么 在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。 32. 何为 JSX JSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React \"元素\"，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 if 语句和 for 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它。 33. 何为 Children 在JSX表达式中，一个开始标签(比如)和一个关闭标签(比如)之间的内容会作为一个特殊的属性props.children被自动传递给包含着它的组件。 这个属性有许多可用的方法，包括 React.Children.map，React.Children.forEach， React.Children.count， React.Children.only，React.Children.toArray。 34. 何为 redux Redux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该有任何副作用。 35. 在 Redux 中，何为 store Store 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责： 允许通过 getState() 访问 state 运行通过 dispatch(action) 改变 state 通过 subscribe(listener) 注册 listeners 通过 subscribe(listener) 返回的函数处理 listeners 的注销 36. 何为 action Actions 是一个纯 javascript 对象，它们必须有一个 type 属性表明正在执行的 action 的类型。实质上，action 是将数据从应用程序发送到 store 的有效载荷。 37. 何为 reducer 一个 reducer 是一个纯函数，该函数以先前的 state 和一个 action 作为参数，并返回下一个 state。 38. Redux Thunk 的作用是什么 Redux thunk 是一个允许你编写返回一个函数而不是一个 action 的 actions creators 的中间件。如果满足某个条件，thunk 则可以用来延迟 action 的派发(dispatch)，这可以处理异步 action 的派发(dispatch) 39. 何为纯函数(pure function) 一个纯函数是一个不依赖于且不改变其作用域之外的变量状态的函数，这也意味着一个纯函数对于同样的参数总是返回同样的结果。 40. react中的回调渲染模式 这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以 props.children进行调用： 这种模式的优势在于将父组件与子组件解耦和， 父组件可以直接访问子组件的内部状态而不需要再通过Props传递，这样父组件能够更为方便地控制子组件展示的UI界面 41. React 中的事件处理逻辑 为了解决跨浏览器兼容性问题，React 会将浏览器原生事件（Browser Native Event）封装为合成事件（SyntheticEvent）传入设置的事件处理器中。这里的合成事件提供了与原生事件相同的接口，不过它们屏蔽了底层浏览器的细节差异，保证了行为的一致性。 另外有意思的是，React 并没有直接将事件附着到子元素上，而是以单一事件监听器的方式将所有的事件发送到顶层进行处理。这样 React 在更新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的目的。 42. React解决了什么问题 一个是组件复用问题，一个是性能问题，还有一个，如果也算的话，就是兼容性问题 43. React的协议问题你了解吗 React遵循的协议是“BSD许可证 + 专利开源协议”，这个协议比较奇葩，如果你的产品跟facebook没有竞争关系，你可以自由的使用react，但是如果有竞争关系，你的react的使用许可将会被取消。 44. 你在过去的项目里遇到的最大问题是什么？你最大的成就？ 寻找更高级职位的人将解释他如何优化应用程序性能，而带领团队的人会解释他如何通过结对编程提高速度。 45. 传入 setState 函数的第二个参数的作用是什么？ 该函数会在setState函数调用完成并且组件开始重渲染的时候被调用，我们可以用该函数来监听渲染是否完成： this.setState( { username: 'tylermcginnis33' }, () => console.log('setState has finished and the component has re-rendered.') ) 46. 封装ajax var jsGetAjaxPromise = function(param){ return new Promise(function(resolve, reject){ var xhr = new XMLHttpRequest(); xhr.open(‘get’, param.url, true); xhr.onload = resolve; xhr.onerror = reject; xhr.send(); }) } 47. Bind实现 // 将bind方法的参数提取出来拼接返回的闭包函数中 Function.prototype.bind = function(context) { var that = this; var args = Array.prototype.slice.call(arguments, 1); return function() { // 预设参数一定是args在前拼接 return that.apply(context, args.concat(Array.prototype.slice.call(arguments))); } }; 48. 快速排序 function quickSort(arr) { //如果数组 49. 正则匹配结巴程序 var str = '我...我是是.......一个......个.....帅帅帅帅........哥!'; var reg = /\\./gi; var str = str.replace(reg, ''); document.write(str + ''); //我是是个个帅帅帅帅哥! reg = /(.)\\1+/gi; str = str.replace(reg, '$1'); document.write(str); //我是个帅哥！ 50. ['1', '2', '3'].map(parseInt) 解析 第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是真正的答案是[1, NaN, NaN]。 首先让我们回顾一下，map函数的第一个参数callback：var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg]) 这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。 而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。 parseInt(string, radix)接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。 了解这两个函数后，我们可以模拟一下运行情况 parseInt('1', 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1 parseInt('2', 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN parseInt('3', 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaN map函数返回的是一个数组，所以最后结果为[1, NaN, NaN] 早在 2013年, 加里·伯恩哈德就在微博上发布了以下代码段: ['10','10','10','10','10'].map(parseInt); // [10, NaN, 2, 3, 4] parseInt parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。 const intValue = parseInt(string[, radix]); string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。 radix 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。 返回值 返回一个整数或NaN parseInt(100); // 100 parseInt(100, 10); // 100 parseInt(100, 2); // 4 -> converts 100 in base 2 to base 10 注意： 在radix为 undefined，或者radix为 0 或者没有指定的情况下，JavaScript 作如下处理： 如果字符串 string 以\"0x\"或者\"0X\"开头, 则基数是16 (16进制). 如果字符串 string 以\"0\"开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。 如果字符串 string 以其它任何值开头，则基数是10 (十进制)。 map map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 var new_array = arr.map(function callback(currentValue[,index[, array]]) { // Return element for new_array }[, thisArg]) 可以看到callback回调函数需要三个参数, 我们通常只使用第一个参数 (其他两个参数是可选的)。 currentValue 是callback 数组中正在处理的当前元素。 index可选, 是callback 数组中正在处理的当前元素的索引。 array可选, 是callback map 方法被调用的数组。 另外还有thisArg可选, 执行 callback 函数时使用的this 值。 const arr = [1, 2, 3]; arr.map((num) => num + 1); // [2, 3, 4] 回到真实的事例上 回到我们真实的事例上 ['1', '2', '3'].map(parseInt) 对于每个迭代map, parseInt()传递两个参数: 字符串和基数。 所以实际执行的的代码是： ['1', '2', '3'].map((item, index) => { return parseInt(item, index) }) // 即返回的值分别为： parseInt('1', 0) // 1 parseInt('2', 1) // NaN parseInt('3', 2) // NaN, 3 不是二进制 所以： ['1', '2', '3'].map(parseInt) // 1, NaN, NaN 由此，加里·伯恩哈德例子也就很好解释了，这里不再赘述 ['10','10','10','10','10'].map(parseInt); // [10, NaN, 2, 3, 4] 51. 防抖和节流 防抖 debounce 典型例子：限制 鼠标连击 触发。 一个比较好的解释是： 当一次事件发生后，事件处理器要等一定阈值的时间，如果这段时间过去后 再也没有 事件发生，就处理最后一次发生的事件。假设还差 0.01 秒就到达指定时间，这时又来了一个事件，那么之前的等待作废，需要重新再等待指定时间。 思路: 每次触发事件时都取消之前的延时调用方法 function debounce(fn, wait = 50, immediate) { let timer; return function() { if (immediate) { fn.apply(this, arguments) } if (timer) clearTimeout(timer) timer = setTimeout(() => { fn.apply(this, arguments) }, wait) } } function sayHi() { console.log('防抖成功'); } var inp = document.getElementById('inp'); inp.addEventListener('input', debounce(sayHi)); // 防抖 节流 throttle 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率 可以理解为事件在一个管道中传输，加上这个节流阀以后，事件的流速就会减慢。实际上这个函数的作用就是如此，它可以将一个函数的调用频率限制在一定阈值内，例如 1s，那么 1s 内这个函数一定不会被调用两次 简单的节流函数: function throttle(fn, wait) { let prev = new Date(); return function() { const args = arguments; const now = new Date(); if (now - prev > wait) { fn.apply(this, args); prev = new Date(); } } } 思路： 每次触发事件时都判断当前是否有等待执行的延时函数 function throttle(fn) { let canRun = true; // 通过闭包保存一个标记 return function() { if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return canRun = false; // 立即设置为false setTimeout(() => { // 将外部传入的函数的执行放在setTimeout中 fn.apply(this, arguments); // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。 // 当定时器没有执行的时候标记永远是false，在开头被return掉 canRun = true; }, 500); }; } function sayHi(e) { console.log(e.target.innerWidth, e.target.innerHeight); } window.addEventListener('resize', throttle(sayHi)); 52. Set、Map、WeakSet 和 WeakMap 的区别？ Set 成员唯一、无序且不重复； [value, value]，键值与键名是一致的（或者说只有键值，没有键名）； 可以遍历，方法有：add、delete、has。 WeakSet 成员都是对象； 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存 DOM 节点，不容易造成内存泄漏； 不能遍历，方法有 add、delete、has。 Map 本质上是键值对的集合，类似集合； 可以遍历，方法很多，可以跟各种数据格式转换。 WeakMap 只接受对象最为键名（null 除外），不接受其他类型的值作为键名； 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的； 不能遍历，方法有 get、set、has、delete。 53. ES5/ES6 的继承除了写法以外还有什么区别 class 声明会提升，但不会初始化赋值。Foo 进入暂时性死区，类似于 let、const 声明变量。 const bar = new Bar(); // it's ok function Bar() { this.bar = 42; } const foo = new Foo(); // ReferenceError: Foo is not defined class Foo { constructor() { this.foo = 42; } } class 声明内部会启用严格模式。 // 引用一个未声明的变量 function Bar() { baz = 42; // it's ok } const bar = new Bar(); class Foo { constructor() { fol = 42; // ReferenceError: fol is not defined } } const foo = new Foo(); class 的所有方法（包括静态方法和实例方法）都是不可枚举的。 // 引用一个未声明的变量 function Bar() { this.bar = 42; } Bar.answer = function() { return 42; }; Bar.prototype.print = function() { console.log(this.bar); }; const barKeys = Object.keys(Bar); // ['answer'] const barProtoKeys = Object.keys(Bar.prototype); // ['print'] class Foo { constructor() { this.foo = 42; } static answer() { return 42; } print() { console.log(this.foo); } } const fooKeys = Object.keys(Foo); // [] const fooProtoKeys = Object.keys(Foo.prototype); // [] class 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有[[construct]]，不能使用 new 来调用。 function Bar() { this.bar = 42; } Bar.prototype.print = function() { console.log(this.bar); }; const bar = new Bar(); const barPrint = new bar.print(); // it's ok class Foo { constructor() { this.foo = 42; } print() { console.log(this.foo); } } const foo = new Foo(); const fooPrint = new foo.print(); // TypeError: foo.print is not a constructor 必须使用 new 调用 class。 function Bar() { this.bar = 42; } const bar = Bar(); // it's ok class Foo { constructor() { this.foo = 42; } } const foo = Foo(); // TypeError: Class constructor Foo cannot be invoked without 'new' class 内部无法重写类名。 function Bar() { Bar = 'Baz'; // it's ok this.bar = 42; } const bar = new Bar(); // Bar: 'Baz' // bar: Bar {bar: 42} class Foo { constructor() { this.foo = 42; Foo = 'Fol'; // TypeError: Assignment to constant variable } } const foo = new Foo(); Foo = 'Fol'; // it's ok 54. 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组 Array.from(new Set(arr.flat(Infinity))).sort((a,b)=>{ return a-b}) 55. JS 异步解决方案的发展历程以及优缺点。 1. 回调函数（callback） setTimeout(() => { // callback 函数体 }, 1000) 缺点：回调地狱，不能用 try catch 捕获错误，不能 return 回调地狱的根本问题在于： 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符； 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）； 嵌套函数过多的多话，很难处理错误。 ajax('XXX1', () => { // callback 函数体 ajax('XXX2', () => { // callback 函数体 ajax('XXX3', () => { // callback 函数体 }) }) }) 优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行）。 2. Promise Promise 就是为了解决 callback 的问题而产生的。 Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装。 优点：解决了回调地狱的问题。 ajax('XXX1') .then(res => { // 操作逻辑 return ajax('XXX2') }).then(res => { // 操作逻辑 return ajax('XXX3') }).then(res => { // 操作逻辑 }) 缺点：无法取消 Promise ，错误需要通过回调函数来捕获。 3. Generator 特点：可以控制函数的执行，可以配合 co 函数库使用。 function *fetch() { yield ajax('XXX1', () => {}) yield ajax('XXX2', () => {}) yield ajax('XXX3', () => {}) } let it = fetch() let result1 = it.next() let result2 = it.next() let result3 = it.next() 4. Async/await async、await 是异步的终极解决方案。 优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题； 缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。 async function test() { // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式 // 如果有依赖性的话，其实就是解决回调地狱的例子了 await fetch('XXX1') await fetch('XXX2') await fetch('XXX3') } 下面来看一个使用 await 的例子： let a = 0 let b = async () => { a = a + await 10 console.log('2', a) // -> '2' 10 } b() a++ console.log('1', a) // -> '1' 1 // 1 1 // 2 10 对于以上代码你可能会有疑惑，让我来解释下原因： 首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来； 因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码； 同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10 上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。 56. 10 个 Ajax 同时发起请求，全部返回展示结果，并且至多允许三次失败，说出设计思路 这个问题相信很多人会第一时间想到 Promise.all ，但是这个函数有一个局限在于如果失败一次就返回了，直接这样实现会有点问题，需要变通下。以下是两种实现思路 // 以下是不完整代码，着重于思路 非 Promise 写法 let successCount = 0 let errorCount = 0 let datas = [] ajax(url, (res) => { if (success) { success++ if (success + errorCount === 10) { console.log(datas) } else { datas.push(res.data) } } else { errorCount++ if (errorCount > 3) { // 失败次数大于3次就应该报错了 throw Error('失败三次') } } }) // Promise 写法 let errorCount = 0 let p = new Promise((resolve, reject) => { if (success) { resolve(res.data) } else { errorCount++ if (errorCount > 3) { // 失败次数大于3次就应该报错了 reject(error) } else { resolve(error) } } }) Promise.all([p]).then(v => { console.log(v); }); 57. 基于 Localstorage 设计一个 1M 的缓存系统，需要实现缓存淘汰机制 设计思路如下： 存储的每个对象需要添加两个属性：分别是过期时间和存储时间。 利用一个属性保存系统中目前所占空间大小，每次存储都增加该属性。当该属性值大于 1M 时，需要按照时间排序系统中的数据，删除一定量的数据保证能够存储下目前需要存储的数据。 每次取数据时，需要判断该缓存数据是否过期，如果过期就删除。 以下是代码实现，实现了思路，但是可能会存在 Bug，但是这种设计题一般是给出设计思路和部分代码，不会需要写出一个无问题的代码 class Store { constructor() { let store = localStorage.getItem('cache') if (!store) { store = { maxSize: 1024 * 1024, size: 0 } this.store = store } else { this.store = JSON.parse(store) } } set(key, value, expire) { this.store[key] = { date: Date.now(), expire, value } let size = this.sizeOf(JSON.stringify(this.store[key])) if (this.store.maxSize { let item1 = this.store[a], item2 = this.store[b]; return item2.date - item1.date; }); while (size + this.store.size > this.store.maxSize) { let index = keys[keys.length - 1] this.store.size -= this.sizeOf(JSON.stringify(this.store[index])) delete this.store[index] } } this.store.size += size localStorage.setItem('cache', JSON.stringify(this.store)) } get(key) { let d = this.store[key] if (!d) { console.log('找不到该属性'); return } if (d.expire > Date.now) { console.log('过期删除'); delete this.store[key] localStorage.setItem('cache', JSON.stringify(this.store)) } else { return d.value } } sizeOf(str, charset) { var total = 0, charCode, i, len; charset = charset ? charset.toLowerCase() : ''; if (charset === 'utf-16' || charset === 'utf16') { for (i = 0, len = str.length; i "},"面试/综合2.html":{"url":"面试/综合2.html","title":"综合2","keywords":"","body":"js面试题（二） js面试题（二） 1. 如何创建一个ajax请求 2. javascript 连等赋值问题 3. 使用正则实现trim函数删除字符串前后空格 4. 找出数组中的最大值 4.1 reduce 4.2 apply 4.3 ES6 5. 打乱数组的方法 6. 数组扁平化 7. 简单的字符串模板 8. js实现循环 setTimeout输出 0, 1, 2, 3, 4 8.1 解决办法 8.2 如果要让0-4一秒一秒地输出来呢？ 9. 谈谈对this的理解 10. eval是做什么的？ 11. ['1', '2', '3'].map(parseInt)答案是多少？ 12. 什么是闭包(closure)，为什么要用它？ 13. JS延迟加载的方式有哪些？ 14. 页面编码和被请求的资源编码不一致如何处理？ 15. 渐进增强与优雅降级 16. 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？ 17. 事件的代理/委托 18. 说说循环数组和对象，你用过哪些方法？ 19. 哪些操作会引起浏览器重绘(repaint)和重排(reflow), 延伸：重绘和重排谁更消耗性能？ 20. 如何进行网站性能优化 21. 如何提高webpack的编译速度？ 22. 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例) 23. 冒泡排序 24. 快速排序 25. 查找字符串中出现次数最多的字符和次数 26. 计算数组中每个元素出现的次数 27. for(var i=0,j=0;i 28. 前后端路由差别 1. 如何创建一个ajax请求 创建Ajax的过程： 创建XMLHttpRequest对象（异步调用对象） var xhr = new XMLHttpRequest(); 创建新的Http请求（方法、URL、是否异步） xhr.open('get', 'example.php', false); 设置响应HTTP请求状态变化的函数 onreadystatechange事件中readyState属性等于4。响应的HTTP状态为 200(OK)或者304(Not Modified)。 发送http请求 xhr.send(data); 获取异步调用返回的数据 详细过程： const xhr = new XMLHttpRequest(); xhr.open(method, url, async); // send 方法发送请求，并接受一个可选参数 // 当请求方式为 post 时，可以将请求体的参数传入 // 当请求方式为 get 时，可以不传或传入 null // 不管是 get 还是 post，参数都需要通过 encodeURIComponent 编码后拼接 xhr.send(data); xhr.onreadystatechange = () => { if (xhr.readyState === 4) { // HTTP 状态在 200 -300 之间表示请求成功 // HTTP 状态为 304 表示内容未发生改变，可直接从缓存中获取 if (xhr.status >= 200 && xhr.status console.log('请求超时') // other var xhr = new XMLHttpRequest(); xhr.open('GET', url); xhr.responseType = 'json'; xhr.onload = function() { console.log(xhr.response); }; xhr.onerror = function() { console.log(\"Oops, error\"); }; 2. javascript 连等赋值问题 var a = { n: 1 }; var b = a; a.x = a = { n: 2 } console.log(a.x); // undefined console.log(b.x); // {n:2} 解析： 解析器在接收到 a = a.x = { n: 2 } 这个语句后，会这样子做： 在找到 a 和 a.x 的指针。如果已有指针,那么不改变它。如果没有指针, 即那个变量还没被申明，那么就创建它，指向 null。 a 是有指针的，指向 {n: 1}; a.x 是没有指针的，所以创建它，指向 null。 然后把上面找到的指针，都指向最右赋值的那个指，即是 {n: 2}。 3. 使用正则实现trim函数删除字符串前后空格 function trim(str) { return str.replace(/(^\\s*)|(\\s*$)/g, ''); } if (!String.prototype.trim) { String.prototype.trim = function () { return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''); }; } 4. 找出数组中的最大值 4.1 reduce var arr = [6, 4, 1, 8, 2, 11, 3]; function max (prev, next) { return Math.max(prev, next) } console.log(arr.reduce(max)); 4.2 apply var arr = [6, 4, 1, 8, 2, 11, 3]; console.log(Math.max.apply(null, arr)); // 11 4.3 ES6 var arr = [6, 4, 1, 8, 2, 11, 3]; function max (arr) { return Math.max(...arr); } console.log(max(arr)); 5. 打乱数组的方法 var arr = []; for(var i = 0; i 6. 数组扁平化 var arr = [1, [2, [3, 4]]] function flatten(arr) { while(arr.some(item => Array.isArray(item))) { arr = [].concat(...arr); } return arr; } console.log(flatten(arr)); // [1, 2, 3, 4] 7. 简单的字符串模板 var TemplateEngine = function(tpl, data) { var re = /]+)?%>/g, match; while(match = re.exec(tpl)) { console.log('match0: ', match[0]); console.log('match1: ', match[1]); tpl = tpl.replace(match[0], data[match[1]]) } return tpl; } var template = 'Hello, my name is . I\\'m years old.'; console.log(TemplateEngine(template, { name: 'ly2011', age: 16 })) 8. js实现循环 setTimeout输出 0, 1, 2, 3, 4 for(var i = 0; i 结果为： 5,5,5,5,5 8.1 解决办法 第一种：闭包 for(var i = 0; i 第二种：值类型传递 var output = function(i) { setTimeout(function() { console.log(i) }, 1000) } for(var i = 0; i 第三种：es6 let for(let i = 0; i 8.2 如果要让0-4一秒一秒地输出来呢？ 第一种： for(var i = 0; i 第二种： const tasks= [] const output = (i) => new Promise((resolve) => { setTimeout(() => { console.log(i) resolve() // 这里一定要 resolve, 否则代码不会按预期 work }, 1000 * i) }) // 生成全部的异步操作 for(var i = 0; i { setTimeout(() => { console.log(i) }, 1000) }) 第三种 模拟其他语言中的 sleep，实际上可以是任何异步操作 // 模拟其他语言中的 sleep，实际上可以是任何异步操作 const sleep = (timeountMS) => new Promise((resolve) => { setTimeout(resolve, timeountMS); }); (async () => { // 声明即执行的 async 函数表达式 for (var i = 0; i 9. 谈谈对this的理解 this总是指向函数的直接调用者（而非间接调用者） 如果有new关键字，this指向new出来的那个对象 在事件中，this指向目标元素，特殊的是IE的attachEvent中的this总是指向全局对象window。 10. eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行；应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 11. ['1', '2', '3'].map(parseInt)答案是多少？ [1, NaN, NaN] 解析： Array.prototype.map() array.map(callback[, thisArg]) callback函数的执行规则 参数：自动传入三个参数 currentValue(当前被传递的元素) index(当前被传递的元素的索引) array(调用map方法的数组) parseInt parseInt方法接收两个参数 第三个参数['1', '2', '3']将被忽略。parseInt方法将会通过以下方式被调用 parseInt('1', 0) parseInt('2', 1) parseInt('3', 2) parseInt的第二个参数radix为0时，ECMAScript5将string作为十进制数字的字符串解析。 parseInt的第二个参数radix为1时，解析结果为NaN; parseInt的第二个参数radix在2-36之间时，如果string参数的第一个字符（除空白以外），不属于radix指定进制下的字符，解析结果为NaN。 parseInt('3', 2)执行时，由于 '3' 不属于二进制字符，解析结果为 NaN。 12. 什么是闭包(closure)，为什么要用它？ 闭包指的是一个函数可以访问另一个函数作用域中变量。常见的构造方法，是在一个函数内部定义另外一个函数。内部函数可以引用外层的变量；外层变量不会被垃圾回收机制回收。 注意：闭包的原理是作用域链，所以闭包访问的上级作用域中的变量是个对象，其值为其运算结束后的左后一个值。 优点：避免全局变量污染。 缺点：容易造成内存泄漏。 例子： function makeFunc() { var name = 'Mozilla' function displayName() { console.log(name) } return displayName } var myFunc = makeFunc() myFunc() // 输出Mozilla myFunc变成一个闭包。闭包是一种特殊的对象。它由两部分构成： 函数，以及创建该函数的环境。环境由闭包创建时在作用域中的任何局部变量组成。在我们的例子中，myFunc是一个闭包，由displayName函数和闭包创建时存在的 'Mozilla' 字符串组成。 13. JS延迟加载的方式有哪些？ defer async 动态创建DOM方式 按需异步载入JS defer和async、动态创建DOM方式、按需异步载入JS defer: 延迟脚本。立即下载，但延迟执行（延迟到整个页面都解析完毕后再运行），按照脚本出现的先后顺序执行。 async: 异步脚本。下载完立即执行，但不保证按照脚本出现的先后顺序执行。 14. 页面编码和被请求的资源编码不一致如何处理？ 若请求的资源编码，如外引js文件编码与页面编码不同。可根据外引资源编码方式定义为 charset=\"utf-8\"或\"gbk\"。 比如：http://www.yyy.com/a.html 中嵌入了一个http://www.xxx.com/test.js a.html 的编码是gbk或gb2312的。 而引入的js编码为utf-8的 ，那就需要在引入的时候 15. 渐进增强与优雅降级 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进，达到更好的用户体验。 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 16. 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？ 该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数） 如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获 如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡 17. 事件的代理/委托 事件委托是指将事件绑定目标元素到父元素上，利用冒泡机制触发该事件 优点： 可以减少事件注册，节省大量内存占用 可以将事件应用于动态添加的子元素上 缺点： 使用不当会造成事件在不应该触发时触发 18. 说说循环数组和对象，你用过哪些方法？ for forEach map filter some every 对象循环: for ... in 19. 哪些操作会引起浏览器重绘(repaint)和重排(reflow), 延伸：重绘和重排谁更消耗性能？ postion:absolute; left:100px;会不会引起？ translateX:100px;会不会引起？ getBoundingClientRect会不会引起？ getClientWidth、getClientHeight会不会引起？ 原理： 触发重排: 页面布局和元素几何属性的改变就会导致重排 下列情况会发生重排: 页面初始渲染 添加/删除可见DOM元素 改变元素位置 改变元素尺寸（宽、高、内外边距、边框等） 改变元素内容（文本或图片等） 改变窗口尺寸 以下属性或方法会刷新渲染队列: offsetTop、offsetLeft、offsetWidth、offsetHeight clientTop、clientLeft、clientWidth、clientHeight scrollTop、scrollLeft、scrollWidth、scrollHeight getComputedStyle()（IE中currentStyle） 减少重绘和重排的原理很简单: 元素脱离文档 改变样式 元素回归文档 20. 如何进行网站性能优化 content 方面 减少 HTTP 请求：合并文件、CSS 精灵、inline Image 减少 DNS 查询： DNS 缓存、将资源分布到恰当数量的主机名 减少 DOM 元素数量 server 方面 使用 CDN 配置 ETag 对组件使用 Gzip 压缩 cookie 方面 减少 Cookie 大小 css 方面 将样式表放到页面顶部 不使用 CSS 表达式 使用 不使用 @import javascript 方面 将脚本放到页面底部 将 javascript 和 css 从外部引入 压缩 javascript和css 删除不需要的脚本 减少 DOM 访问 图片方面 优化图片：根据实际颜色需要选择色深、压缩 优化 css 精灵 不要在 HTML 中拉伸图片 21. 如何提高webpack的编译速度？ 版本升级 利用多核(happypack) 利用缓存(dll) 开发环境去掉组件懒加载、不压缩图片、不分离css文件 22. 从浏览器地址栏输入url到显示页面的步骤(以HTTP为例) 主要过程是：浏览器解析 -> 查询缓存 -> dns查询 -> 建立链接 -> 服务器处理请求 -> 服务器发送响应 -> 客户端收到页面 -> 解析HTML -> 构建渲染树 -> 开始显示内容(白屏时间) -> 首屏内容加载完成(首屏时间) -> 用户可交户(DOMContentLoaded) -> 加载完成(load) 在浏览器地址栏输入URL 浏览器查看 缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 如果资源未缓存，发起新请求 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。 检验新鲜通常有两个HTTP头进行控制 Expires 和 Cache-Control： HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间 浏览器解析URL获取协议，主机，端口，path 浏览器组装一个HTTP（GET）请求报文 浏览器获取主机ip地址，过程如下： 浏览器缓存 本机缓存 hosts文件 路由器缓存 ISP DNS缓存 DNS递归查询（可能存在负载均衡导致每次IP不一样） 打开一个socket与目标IP地址，端口建立TCP链接，三次握手如下： 客户端发送一个TCP的SYN=1，Seq=X的包到服务器端口 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 客户端发送ACK=Y+1， Seq=Z TCP链接建立后发送HTTP请求 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 服务器将响应报文通过TCP连接发送回浏览器 浏览器接收HTTP响应，然后根据情况选择 关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下： 主动方发送Fin=1， Ack=Z， Seq= X报文 被动方发送ACK=X+1， Seq=Z报文 被动方发送Fin=1， ACK=X， Seq=Y报文 主动方发送ACK=Y， Seq=X报文 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 如果资源可缓存，进行缓存 对响应进行解码（例如gzip压缩） 根据资源类型决定如何处理（假设资源为HTML文档） 解析HTML文档，构建DOM树，下载资源，构造CSSOM树，执行js脚本，这些操作没有严格的先后顺序，以下分别解释 构建DOM树： Tokenizing：根据HTML规范将字符流解析为标记 Lexing：词法分析将标记转换为对象并定义属性和规则 DOM construction：根据HTML标记关系将对象组成DOM树 解析过程中遇到图片、样式表、js文件，启动下载 构建CSSOM树： Tokenizing：字符流转换为标记流 Node：根据标记创建节点 CSSOM：节点创建CSSOM树 根据DOM树和CSSOM树构建渲染树: 从DOM树的根节点遍历所有可见节点，不可见节点包括：1）script,meta这样本身不可见的标签。2)被css隐藏的节点，如display: none 对每一个可见节点，找到恰当的CSSOM规则并应用 发布可视节点的内容和计算样式 js解析如下： 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时document.readystate为loading HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容 当解析器遇到设置了async属性的script时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用document.write()，它们可以访问自己script和之前的文档元素 当文档完成解析，document.readState变成interactive 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用document.write() 浏览器在Document对象上触发DOMContentLoaded事件 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState变为complete,window触发load事件 显示页面（HTML解析过程中会逐步显示页面） 23. 冒泡排序 解析： 比较相邻的两个元素，如果前一个比后一个大，则交换位置。 第一轮的时候最后一个元素应该是最大的一个。 按照步骤一的方法进行相邻两个元素的比较，这个时候由于最后一个元素已经是最大的了，所以最后一个元素不用比较。 function sort(elements) { for(var i = 0; i elements[j + 1]) { var swap = elements[j]; elements[j] = elements[j + 1]; elements[j + 1] = swap; } } } } var elements = [3, 1, 5, 7, 2, 4, 9, 6, 10, 8]; console.log('before: ', elements) sort(elements) console.log('after: ', elements) 24. 快速排序 解析：快速排序是对冒泡排序的一种改进，第一趟排序时将数据分成两部分，一部分比另一部分的所有数据都要小。然后递归调用，在两边都实行快速排序。 function quickSort(elements) { if (elements.length 25. 查找字符串中出现次数最多的字符和次数 例如：sdddrtkjsfkasjdddj中出现最多的字符是d,出现了6次 var str = \"sdddrtkjsfkkkasjdddj\"; var max = 0; var char; function Search(str) { var json = {}; for (var i = 0; i max) { max = json[str[i]].length; char = str[i]; } } console.log('json: ', json) console.log(\"出现次数最多的字符是\" + char + \",出现了\" + max + \"次\") } Search(str); 26. 计算数组中每个元素出现的次数 // 计算数组中每个元素出现的次数 var names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'] var countedNames = names.reduce(function(allNames, name) { if(name in allNames) { allNames[name]++ } else { allNames[name] = 1 } return allNames; }, {}) console.log(countedNames) 27. for(var i=0,j=0;i var sum = 0; for(var i=0,j=0;i 解析：答案是: 10, 首先每次for循环的i和j值是相等的：第一次：i=0, j =0; 符合条件, sum = i + j = 0;第二次：i=1,j=1;符合条件, sum = i + j = 2;第三次：i=2,j=2;符合条件, sum = i + j = 4;第四次：i=3,j=3;符合条件，sum = i + j = 6;第五次：i=4,j=4;符合条件, sum = i + j = 8;第六次：i=5,j=5;符合条件,sum = i + j =10;第七次：i=6,j=6;不符合条件（这里需要注意，循环继续的判断依据以分号前的最后一项为准，即判断j）,循环结束。 注意：这里值得一提的是 如果把条件i结果将完全不同，此时循环执行到j 28. 前后端路由差别 后端每次路由请求都是重新访问服务器 前端路由实际上只是JS根据URL来操作DOM元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合。 "},"面试/综合3.html":{"url":"面试/综合3.html","title":"综合3","keywords":"","body":"js面试题（三） js面试题（三） 1. JavaScript中的数据类型都有哪些? 2. 如何判断一个变量是否为数组？ 3. undefined 和 null 的相同与不同？ 4. 隐式类型转换的时候，JavaScript底层都做了哪些处理？ 5. 有哪些值转化为布尔值后为false？ 6. 讲讲ES6中的Symbol？ 7. 如何把字符串转换为数组？ 8. 如何把类数组变量转换为数组，如函数内部的 arguments 对象，selector 返回的 DOM 列表。 9. 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组 10. 简单讲解一下http2的多路复用 11. 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？ 1. npm 模块安装机制： 2. npm 实现原理 12. 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣Object.prototype.toString.call() 、 instanceof 以及 Array.isArray() 1. Object.prototype.toString.call() 2. instanceof 3. Array.isArray() 13. 如何判断一个变量是否为数组？ 14. 数组的原生方法有哪些？ 会改变自身的方法： 不会改变自身的方法： 遍历方法： 15. 如何将一个类数组变量转为数组？ 16. 说一说ES6中对于数组有哪些扩展？ 17. 数组去重，你能说出多少种方法？ 实现一 补充 3.1 普通版 复杂度 O(n^2) 3.2 进阶版 3.3 时间复杂度为O(n) 3.4 终极版 18. 你知道Array.prototype的类型是什么吗？ [19. 如何\"打平\"一个嵌套数组,如[1, [2, [3]], 4, [5]] => [1, 2, 3, 4, 5]？你能说出多少种方法？](#19-如何打平一个嵌套数组如1-2-3-4-5--1-2-3-4-5你能说出多少种方法) 1. 利用 Array.prototype.toString()方法（元素为数字） 2. 利用Array.prototype.join()方法（元素为数字） 3. 利用JSON.parse()方法（元素为数字） 20. 如何克隆一个数组？你能说出多少种？ 21. 说一说Array.prototype.sort()方法的原理？（追问：不传递参数会如何？） 22. 找出Array中的最大元素，你能说出几种方法？ 23. mouseover 和 mouseenter 两个事件有何区别？ 24. 移动端的click时间行为与PC端有什么不同？如何屏蔽这个不同？ 25. Event对象中, target和currentTarget的区别？ 26. 说一说什么是事件冒泡，如何阻止事件冒泡？如何阻止默认事件？ 27. 是否了解移动端的点击穿透，原理及解决方法？ 28. 是否了解事件委托？ 29. 什么是事件循环？ 30. css3中有哪些属性可以直接影响JS中的事件？（可以讲一下pointer-events和touch-action属性吗？） 31. 怎么去设计一个组件封装 32. js 异步加载的方式 33. css 动画和 js 动画的差异 34. XSS 与 CSRF 两种跨站攻击 35. 事件委托，目的，功能，写法 36. 线程，进程 37. 负载均衡 38. 什么是CDN缓存 39. javascript 中常见的内存泄露陷阱 40. babel把ES6转成ES5或者ES3之类的原理是什么 41. Promise 模拟终止 42. promise 放在try catch里面有什么结果 43. get与post 通讯的区别 44. 有没有去研究webpack的一些原理和机制，怎么实现的 45. ES6模块与CommonJS模块的差异 46. 模块加载AMD，CMD，CommonJS Modules/2.0 规范 47. Node 事件循环，js 事件循环差异 1. JavaScript中的数据类型都有哪些? 数据类型有两种：原始数据类型（又称基础数据类型、可变数据类型）和复杂数据类型（又称对象、不可变数据类型）。原始数据类型包括：undefined,null,数字,字符串,布尔类型,Symbol(ES6 新加入的类型)复杂数据类型包括：对象其中对象包括：内部对象（Array、String等），宿主对象(window)和自定义对象。 2. 如何判断一个变量是否为数组？ Object.prototype.toString.call() Array.isArray() 3. undefined 和 null 的相同与不同？ 相同点： 这两个数据类型都只有一个值 都没有方法 都表示\"无\" 转化为布尔值时，都是false 不同点： null 是一个关键字，而 undefined 不是一个关键字。所以 var undefined = 1; 这是可以的，虽然这里 undefined 的值是不会改变的。 var null = 1; // 这样是报错的。 null的实质是一个空的对象，而undefined是window的一个属性。 进行数字类型转换时，null 返回 0, undefined 返回 NaN。 4. 隐式类型转换的时候，JavaScript底层都做了哪些处理？ 对象转成原始数据类型时，先调用对象的 valueOf 方法，如果返回结果不是原始数据类型的值，再调用 toString 方法。 原始类型转原始类型时，直接调用对应的构造函数进行转换。 5. 有哪些值转化为布尔值后为false？ 包括下面这六种：0, -0, undefined, null, 空字符串, NaN 6. 讲讲ES6中的Symbol？ Symbol 是 ES6 新加的一个原始类型，它的每个值都是唯一的，即使是用两个完全一样的变量构建出来的Symbol也不相等。 原始类型传入 Symbol 方法时，会进行转换成 字符串 再转成 Symbol 类型值; 如果是对象的话，会先调用对象的 toString 方法再转成 Symbol 类型的值。 Symbol最大的用处是用来消除 \"魔术字符串\" 的。 7. 如何把字符串转换为数组？ split() Array.from() 8. 如何把类数组变量转换为数组，如函数内部的 arguments 对象，selector 返回的 DOM 列表。 Array.prototype.slice.call() Array.from() Array.from()的详解： Set类型的转换 let s = new Set(['foo', window]) Array.from(s); // [\"foo\", window] Map类型的转换 let m = new Map([[1, 2], [2, 4], [4, 8]]) Array.from(m) // [[1, 2], [2, 4], [4, 8]] 类数组的值 function f() { console.log(arguments) return Array.from(arguments) } f(1, 2, 3) Array.from() 的第二个参数 mapFn 也很有用处，可以对传入的类数组值进行定定制化修改 Array.from([1, 2, 3], x => x + x); // [2, 4, 6] Array.from({length: 5}, (v, i) => i) // [0, 1, 2, 3, 4, 5] 9. 将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组 var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10]; Array.from(new Set(arr.toString().split(\",\").sort((a,b)=>{ return a-b}))) // [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 10, 11, 12, 12, 13, 14] 10. 简单讲解一下http2的多路复用 HTTP2采用二进制格式传输，取代了HTTP1.x的文本格式，二进制格式解析更高效。 多路复用代替了HTTP1.x的序列和阻塞机制，所有的相同域名请求都通过同一个TCP连接并发完成。在HTTP1.x中，并发多个请求需要多个TCP连接，浏览器为了控制资源会有6-8个TCP连接都限制。 HTTP2中 同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。 单个连接上可以并行交错的请求和响应，之间互不干扰 在 HTTP/1 中，每次请求都会建立一次HTTP连接，也就是我们常说的3次握手4次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 Keep-Alive ，解决了多次连接的问题，但是依然有两个效率上的问题： 第一个：串行的文件传输。当请求a文件时，b文件只能等待，等待a连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是1秒，那么a文件用时为3秒，b文件传输完成用时为6秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输） 第二个：连接数过多。我们假设Apache设置了最大并发数为300，因为浏览器限制，浏览器发起的最大请求数为6，也就是服务器能承载的最高并发为50，当第51个人访问时，就需要等待前面某个请求处理完成。 HTTP/2的多路复用就是为了解决上述的两个性能问题。在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。 简单来说， 就是在同一个TCP连接，同一时刻可以传输多个HTTP请求之前是同一个连接只能用一次， 如果开启了keep-alive，虽然可以用多次，但是同一时刻只能有一个HTTP请求 11. 介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？ 1. npm 模块安装机制： 发出npm install命令 查询node_modules目录之中是否已经存在指定模块 若存在，不再重新安装 若不存在 npm 向 registry 查询模块压缩包的网址 下载压缩包，存放在根目录下的.npm目录里 解压压缩包到当前项目的node_modules目录 2. npm 实现原理 输入 npm install 命令并敲下回车后，会经历如下几个阶段（以 npm 5.5.1 为例）： 执行工程自身 preinstall当前 npm 工程如果定义了 preinstall 钩子此时会被执行。 确定首层依赖模块 首先需要做的是确定工程中的首层依赖，也就是 dependencies 和 devDependencies 属性中直接指定的模块（假设此时没有添加 npm install 参数）。工程本身是整棵依赖树的根节点，每个首层依赖模块都是根节点下面的一棵子树，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。 获取模块 获取模块是一个递归的过程，分为以下几步： 获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 packaeg.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。 获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。 查找该模块依赖，如果有依赖则回到第1步，如果没有则停止。 模块扁平化（dedupe） 上一步获取到的是一棵完整的依赖树，其中可能包含大量重复模块。比如 A 模块依赖于 loadsh，B 模块同样依赖于 lodash。在 npm3 以前会严格按照依赖树的结构进行安装，因此会造成模块冗余。 从 npm3 开始默认加入了一个 dedupe 的过程。它会遍历所有节点，逐个将模块放在根节点下面，也就是 node-modules 的第一层。当发现有重复模块时，则将其丢弃。 这里需要对重复模块进行一个定义，它指的是模块名相同且 semver 兼容。每个 semver 都对应一段版本允许范围，如果两个模块的版本允许范围存在交集，那么就可以得到一个兼容版本，而不必版本号完全一致，这可以使更多冗余模块在 dedupe 过程中被去掉。 比如 node-modules 下 foo 模块依赖 lodash@^1.0.0，bar 模块依赖 lodash@^1.1.0，则 ^1.1.0 为兼容版本。 而当 foo 依赖 lodash@^2.0.0，bar 依赖 lodash@^1.1.0，则依据 semver 的规则，二者不存在兼容版本。会将一个版本放在 node_modules 中，另一个仍保留在依赖树里。 举个例子，假设一个依赖树原本是这样： node_modules -- foo ---- lodash@version1 -- bar ---- lodash@version2 假设 version1 和 version2 是兼容版本，则经过 dedupe 会成为下面的形式： node_modules -- foo -- bar -- lodash（保留的版本为兼容版本） 假设 version1 和 version2 为非兼容版本，则后面的版本保留在依赖树中： node_modules -- foo -- lodash@version1 -- bar ---- lodash@version2 安装模块 这一步将会更新工程中的 node_modules，并执行模块中的生命周期函数（按照 preinstall、install、postinstall 的顺序）。 执行工程自身生命周期 当前 npm 工程如果定义了钩子此时会被执行（按照 install、postinstall、prepublish、prepare 的顺序）。 最后一步是生成或更新版本描述文件，npm install 过程完成。 12. 有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣Object.prototype.toString.call() 、 instanceof 以及 Array.isArray() 1. Object.prototype.toString.call() 每一个继承 Object 的对象都有 toString 方法，如果 toString 方法没有重写的话，会返回 [Object type]，其中 type 为对象的类型。但当除了 Object 类型的对象外，其他类型直接使用 toString 方法时，会直接返回都是内容的字符串，所以我们需要使用call或者apply方法来改变toString方法的执行上下文。 const an = ['Hello','An']; an.toString(); // \"Hello,An\" Object.prototype.toString.call(an); // \"[object Array]\" 这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。 Object.prototype.toString.call('An') // \"[object String]\" Object.prototype.toString.call(1) // \"[object Number]\" Object.prototype.toString.call(Symbol(1)) // \"[object Symbol]\" Object.prototype.toString.call(null) // \"[object Null]\" Object.prototype.toString.call(undefined) // \"[object Undefined]\" Object.prototype.toString.call(function(){}) // \"[object Function]\" Object.prototype.toString.call({name: 'An'}) // \"[object Object]\" Object.prototype.toString.call() 常用于判断浏览器内置对象时。 2. instanceof instanceof 的内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 使用 instanceof判断一个对象是否为数组，instanceof 会判断这个对象的原型链上是否会找到对应的 Array 的原型，找到返回 true，否则返回 false。 [] instanceof Array; // true 但 instanceof 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。 [] instanceof Object; // true 3. Array.isArray() 功能：用来判断对象是否为数组 instanceof 与 isArray 当检测Array实例时，Array.isArray 优于 instanceof ，因为 Array.isArray 可以检测出 iframes var iframe = document.createElement('iframe'); document.body.appendChild(iframe); xArray = window.frames[window.frames.length-1].Array; var arr = new xArray(1,2,3); // [1,2,3] // Correctly checking for Array Array.isArray(arr); // true Object.prototype.toString.call(arr); // true // Considered harmful, because doesn't work though iframes arr instanceof Array; // false Array.isArray() 与 Object.prototype.toString.call() Array.isArray()是ES5新增的方法，当不存在 Array.isArray() ，可以用 Object.prototype.toString.call() 实现。 if (!Array.isArray) { Array.isArray = function(arg) { return Object.prototype.toString.call(arg) === '[object Array]'; }; } 13. 如何判断一个变量是否为数组？ 不可靠的检测数组方式： 为什么不用 typeof ? var list = [1, 2, 3] typeof list // 'object' Array继承于Object, 所以 typeof 会直接返回 object, 所以不可以用 typeof 来检测 为什么不用 instanceof ? var list = [1, 2, 3] list instanceof Array // true instanceof 表面上看确实是返回了true,但其实并不可靠。原因是Array实质是一个引用，用instanceof方法（包括下面的constructor）都是利用引用地址进行比较的方法来确定的，但是在iframe嵌套的情况下，每一个Array的引用地址都是不同的，比较起来结果也是不确定的，所以这种方法有其局限性。 为什么不同 constructor 方法？ var list = [1, 2, 3] list.constructor === Array // true 原因同上 可靠的检测数组方式: 利用Object的toString方法 var list = [1, 2, 3] Object.prototype.toString.call(list) // [object Array] 利用ES6的Array.isArray()方法 var list = [1, 2, 3] Array.isArray(list) // true 14. 数组的原生方法有哪些？ 会改变自身的方法： Array.prototype.copyWithin()：在数组内部，将一段元素序列拷贝到另外一段元素序列上，覆盖原有的值。 Array.prototype.fill()：将数组中指定区间的所有元素的值，都替换成某个固定的值。 Array.prototype.pop()：删除数组最后一个元素，并返回这个元素。 Array.prototype.push()：在数组的尾部增加一个或多个元素，并返回数组的新长度。 Array.prototype.reverse()：颠倒数组中元素的排列顺序，即原先的第一个变为最后一个，最后一个变为第一个。 Array.prototype.shift()：删除数组的第一个元素，返回这个元素。 Array.prototype.sort()：对数组元素进行排序，并返回当前数组。 Array.prototype.splice()：在任意的位置给数组添加或删除任意个元素。 Array.prototype.unshift()：在数组的开头增加一个或多个元素，并返回数组的新长度。 不会改变自身的方法： Array.prototype.concat()：返回一个由当前数组和其他若干个数组或若干个非数组值组合而成的新数组。 Array.prototype.includes()：判断当前数组是否包含某指定的值，如果是返回true,否则返回false。 Array.prototype.join()：连接所有数组元素组成一个字符串。 Array.prototype.slice()：抽取当前数组中的一段元素组合成一个新的数组。 Array.prototype.toSource()：返回一个表示当前数组字面了的字符串。 Array.prototype.toString()：返回一个由所有数组元素组合而成的字符串。 Array.prototype.toLocaleString()：返回一个由数组元素组合而成的本地化后的字符串。 Array.prototype.indexOf()：返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 Array.prototype.lastIndexOf()：返回数组中最后一个（从右边第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。 遍历方法： Array.prototype.forEach()：为数组中的每个元素执行一次回调函数。 Array.prototype.entries()：返回一个对象迭代器对象，该迭代器会包含所有数组元素的键值对。 Array.prototype.every()：如果数组中的每个元素都满足测试函数，则返回true,否则返回 false。 Array.prototype.some()：如果数组中至少有一个元素满足测试函数，则返回true，否则返回false。 Array.prototype.filter()：将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。 Array.prototype.find()：找到第一个满足测试函数的元素并返回那个元素的值。如果找不到，则返回undefined。 Array.prototype.findIndex()：找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。 Array.prototype.keys()：返回数组迭代器对象，该迭代器会包含所有数组元素的健。 Array.prototype.map()：返回一个由回调函数的返回值组成的新数组。 Array.prototype.reduce()：从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 Array.prototype.reduceRight()：从右到左为每个元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 Array.prototype.values()：返回数组迭代器，该迭代器会包含所有数组元素的值。 Array.prototype[@@iterator]()： 和上面的 values() 方法是同一个函数。 15. 如何将一个类数组变量转为数组？ Array.prototype.slice.call() Array.from() 16. 说一说ES6中对于数组有哪些扩展？ 增加了扩展运算符(spread) ... 增加了两个方法，Array.from() 和 Array.of() 方法 增加了一些实例方法，如 copyWithin()、fill()、entries()、keys()、values()、includes() 等。 17. 数组去重，你能说出多少种方法？ 实现一 // A.方法1：使用Set + Array function uniqueArray(arr){ return Array.from(new Set(arr)); } // B.方法2：使用splice function uniqueArray(arr){ for(var i = 0; i 补充 注：暂不考虑对象字面量，函数等引用类型的去重，也不考虑 NaN, undefined, null等特殊类型情况。 数组样本：[1, 1, '1', '2', 1] 3.1 普通版 复杂度 O(n^2) 无需思考，我们可以得到 O(n^2) 复杂度的解法。定义一个变量数组 res 保存结果，遍历需要去重的数组，如果该元素已经存在在 res 中了，则说明是重复的元素，如果没有，则放入 res 中。 var a = [1, 1, '1', '2', 1] function unique(arr) { var res = [] for (var i = 0, len = arr.length; i 优点： 没有任何兼容性问题，通俗易懂，没有任何理解成本 缺点： 看起来比较臃肿比较繁琐，时间复杂度比较高O(n^2) 3.2 进阶版 var a = [1, 1, '1', '2', 1] function unique(arr) { return arr.filter(function(ele,index,array){ return array.indexOf(ele) === index//很巧妙,这样筛选一对一的,过滤掉重复的 }) } console.log(unique(a)) // [1, 2, \"1\"] 优点：很简洁，思维也比较巧妙，直观易懂。 缺点：不支持 IE9 以下的浏览器，时间复杂度还是O(n^2) 3.3 时间复杂度为O(n) var a = [1, 1, '1', '2', 1] function unique(arr) { var obj = {} return arr.filter(function(item, index, array){ return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) }) } console.log(unique(a)) // [1, 2, \"1\"] 优点：hasOwnProperty 是对象的属性(名称)存在性检查方法。对象的属性可以基于 Hash 表实现，因此对属性进行访问的时间复杂度可以达到O(1); filter 是数组迭代的方法，内部还是一个 for 循环，所以时间复杂度是 O(n)。 缺点：不兼容 IE9 以下浏览器，其实也好解决，把 filter 方法用 for 循环代替或者自己模拟一个 filter 方法。 3.4 终极版 以 Set 为例，ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 const unique = a => [...new Set(a)] 优点：ES6 语法，简洁高效，我们可以看到，去重方法从原始的 14 行代码到 ES6 的 1 行代码，其实也说明了 JavaScript 这门语言在不停的进步，相信以后的开发也会越来越高效。 缺点：兼容性问题，现代浏览器才支持，有 babel 这些都不是问题。 18. 你知道Array.prototype的类型是什么吗？ Array.prototype 是一个数组，不过 length 为 0 19. 如何\"打平\"一个嵌套数组,如[1, [2, [3]], 4, [5]] => [1, 2, 3, 4, 5]？你能说出多少种方法？ 1. 利用 Array.prototype.toString()方法（元素为数字） var list = [1, [2, [3]], 4, [5]] console.log(list.toString()) // 1, 2, 3, 4, 5 原理：toString 方法返回一个字符串，该字符串由数组中的每个元素的 toString() 返回值经调用 join() 方法连接（由逗号隔开）组成。 2. 利用Array.prototype.join()方法（元素为数字） var list = [1, [2, [3]], 4, [5]] console.log(list.join()) // 1, 2, 3, 4, 5 原理：join 方法会让所有的数组元素转换成字符串，再用一个分隔符将这些字符串连接起来。如果元素是undefined或null，则会转化成空字符串。 3. 利用JSON.parse()方法（元素为数字） var list = [1, [2, [3]], 4, [5]] JSON.parse(`[${arr}]`) // [1, 2, 3, 4, 5] PS: 如果觉得上面输出的不是一个数组，可以稍微加工一下。 var list = [1, [2, [3]], 4, [5]] JSON.parse(`[${list.toString()}]`) JSON.parse(`[${list.join()}]`) JSON.parse(`[${arr}]`) 20. 如何克隆一个数组？你能说出多少种？ concat() var arr1 = [1, 2, 3] var arr2 = arr1.concat(); slice var arr1 = [1, 2, 3] var arr2 = arr1.join(); 原理：数组本质上也是Object，直接赋值的话，只是将引用赋值给另一个变量，最终会导致被复制的变量也会随着原来的数组变化而变化。 21. 说一说Array.prototype.sort()方法的原理？（追问：不传递参数会如何？） 语法：sort方法接收一个 \"比较参数\" 作为参数。 如果调用该参数时没有使用参数, 将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），再以便进行比较。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这个两个值得相对顺序的数字。比较函数应该具有两个参数 a 和 b,其返回值如下： 若 a 小于 b,在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。 若 a 等于 b, 则返回 0。 若 a 大于 b, 则返回一个大于 0 的值。 22. 找出Array中的最大元素，你能说出几种方法？ 实现一个冒泡算法 循环遍历一遍 var list = [1, 100, 23, 65, 43, 2, 9] var max = list[0] for(var i = 1; i reduce var list = [1, 100, 23, 65, 43, 2, 9] function Max(prev, next) { return Math.max(prev, next) } console.log(list.reduce(Max)) // 100 apply var list = [1, 100, 23, 65, 43, 2, 9] Math.max.apply(null, list) // 100 ES6 ... 使用ES6的扩展运算符 var list = [1, 100, 23, 65, 43, 2, 9] Math.max(...list) // 100 利用Array的sort方法先排序再取值 var list = [1, 100, 23, 65, 43, 2, 9] list.sort((a, b) => {return a - b}) list[list.length - 1] // 100 evalMath.max 支持传多个参数来进行比较，那么我们如何将一个数组转换成参数传进 Math.max 函数呢？ eval 便是一种： var list = [1, 100, 23, 65, 43, 2, 9] var max = eval(\"Math.max(\" + list+ \")\") console.log(max) // 100 解析：因为 发生了隐式类型转换例如： var list = [1, 100, 23, 65, 43, 2, 9] console.log(list+'') // 1,100,23,65,43,2,9 其实 var max = eval(\"Math.max(\"+ list+\")\") 就相当于 var max = eval(\"Math.max(1,100,23,65,43,2,9)\") 23. mouseover 和 mouseenter 两个事件有何区别？ 二者的区别是 mouseenter 不会冒泡(bubble)。 详细解析一下： 当两者绑定的元素都没有子元素时，两者的行为是一直的。但是当两者内部都包含子元素时，行为就不一样了。 在 mouseover 绑定的元素中，鼠标每次进入一个子元素就会触发一次 mouseover 事件，而 mouseenter 只会触发一次。 mouseover 事件对应 mouseout事件mouseenter 事件对应 mouseleave 事件 demo: * { margin: 0; padding: 0; } .container { overflow: hidden; } .over { background-color: lightgray; padding: 20px; width: 40%; float: left; } .enter { background-color: lightgray; padding: 20px; width: 40%; float: right; } .over h2, .enter h2 { background-color: #fff; } --> --> function $(ele) { return document.querySelector(ele) } var x = 0, y = 0; var $over = $('.over'); var $enter = $('.enter'); $over.addEventListener('mouseover', function(e) { $over.innerText = ++x; // $('.over-counter').innerText = ++x; }); $enter.addEventListener('mouseenter', function(e) { $enter.innerText = ++y; // $('.enter-counter').innerText = ++y; }); 24. 移动端的click时间行为与PC端有什么不同？如何屏蔽这个不同？ 移动端的click事件会延迟300ms触发事件回调(只在部分手机浏览器上出现)。 解决办法：引入 fastclick.js 来解决。它的原理是 fastlick 在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即触发一个模拟 click 事件，并把浏览器在 300 毫秒之后真正触发的click事件阻止掉。 25. Event对象中, target和currentTarget的区别？ currentTarget是当前事件遍历DOM时，标识事件的当前目标。它总是引用事件处理程序附加到的元素（事件代理对象上），而不是 event.target, event.target标识事件发生的元素。 有个简单的验证方法，你会在下面的例子中看到 e.currentTarget 一直返回的是 body元素，而e.target则随着你点击的位置的不同而变化。 item 1-1 item 1-2 item 2-1 item 2-2 document.body.addEventListener('click', function (e) { console.log(e.target, e.currentTarget) }) 26. 说一说什么是事件冒泡，如何阻止事件冒泡？如何阻止默认事件？ 事件冒泡是指事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接受，然后逐级向上传播到较为不具体的节点（文档）。 阻止事件冒泡的方法： 调用当前时间对象的 stopPropagation() 方法 IE10及其以下 cancelBubble = true function cancelBubble(e) { var evt = e ? e : window.event; if (evt.stopPropagation) { // W3C evt.stopPropagation(); }else { // IE evt.cancelBubble = true; } } 阻止默认事件： 调用当前事件对象的 preventDefault() 方法 IE下：returnValue = false function preventDefaultAction(event){ var event = window.event || event; if(document.all){ // 支持IE event.returnValue = false; }else{ // IE不支持 event.preventDefault(); } } 27. 是否了解移动端的点击穿透，原理及解决方法？ 点击穿透是指在移动端，由于click事件延迟300ms触发，那么如果300ms内，页面显示变化（主要是指DOM的隐藏和显示）的话，会出现实际点击元素触发了touch事件，而300ms后该位置的实际元素又被再次触发了click事件的情况。 避免方法： 引入 fastclick.js 28. 是否了解事件委托？ 事件委托是指利用 \"事件冒泡\"，指定一个事件处理程序，来管理某一类型的所有事件。 29. 什么是事件循环？ 为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。 事件循环的职责，就是不断得等待事件的发生，然后将这个事件的所有处理器，以它们订阅这个事件的时间顺序，依次执行。当这个事件的所有处理器都被执行完毕之后，事件循环就会开始继续等待下一个事件的触发，不断往复。 事件循环的机制： 一个事件循环有一个或者多个任务队列（task queues）。任务队列是task的有序列表，这些task是以下工作的对应算法：Events，Parsing，Callbacks，Using a resource，Reacting to DOM manipulation。 每一个任务都来自一个特定的任务源（task source）。所有来自一个特定任务源并且属于特定事件循环的任务，通常必须被加入到同一个任务队列中，但是来自不同任务源的任务可能会放在不同的任务队列中。 举个例子，用户代理有一个处理鼠标和键盘事件的任务队列。用户代理可以给这个队列比其他队列多3/4的执行时间，以确保交互的响应而不让其他任务队列饿死（starving），并且不会乱序处理任何一个任务队列的事件。 每个事件循环都有一个进入microtask检查点（performing a microtask checkpoint）的flag标志，这个标志初始为false。它被用来组织反复调用‘进入microtask检查点’的算法。 一个事件循环里有很多个任务队列（task queues）来自不同任务源，每一个任务队列里的任务是严格按照先进先出的顺序执行的，但是不同任务队列的任务的执行顺序是不确定的。按我的理解就是，浏览器会自己调度不同任务队列。 在事件循环中，用户代理会不断从task队列中按顺序取task执行，每执行完一个task都会检查microtask队列是否为空（执行完一个task的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后再进入下一个循环去task队列中取下一个task执行... 30. css3中有哪些属性可以直接影响JS中的事件？（可以讲一下pointer-events和touch-action属性吗？） css3中有两个属性是可以直接影响到JS中的事件的，他们是pointer-events和touch-action。 pointer-events CSS 属性指定在什么情况下 (如果有) 某个特定的图形元素可以成为鼠标事件的 target。当该属性值设定为none时 表示鼠标事件“穿透”该元素并且指定该元素“下面”的任何东西。 需要注意的是，如果当前元素的pointer-events属性指定位none，但是当其后代元素的pointer-events属性指定其他值时，鼠标事件可以指向后代元素，在这种情况下，鼠标事件将在捕获或冒泡阶段触发父元素的事件侦听器。 touch-action 用于指定某个给定的区域是否允许用户操作，以及如何响应用户操作（比如浏览器自带的划动、缩放等）。 最常见的用法是禁用元素（及其不可滚动的后代）上的所有手势，以使用自己提供的拖放和缩放行为（如地图或游戏表面）。 #map { touch-action: none; } 31. 怎么去设计一个组件封装 组件封装的目的是为了重用，提高开发效率和代码质量 低耦合，单一职责，可复用性，可维护性 32. js 异步加载的方式 渲染引擎遇到 script 标签会停下来，等到执行完脚本，继续向下渲染 defer 是“渲染完再执行”，async 是“下载完就执行”，defer 如果有多个脚本，会按照在页面中出现的顺序加载，多个async 脚本不能保证加载顺序 加载 es6模块的时候设置 type=module，异步加载不会造成阻塞浏览器，页面渲染完再执行，可以同时加上async属性，异步执行脚本（利用顶层的this等于undefined这个语法点，可以侦测当前代码是否在 ES6 模块之中） 33. css 动画和 js 动画的差异 代码复杂度，js 动画代码相对复杂一些 动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css动画不能添加事件 动画性能看，js 动画多了一个js 解析的过程，性能不如 css 动画好 34. XSS 与 CSRF 两种跨站攻击 xss 跨站脚本攻击，主要是前端层面的，用户在输入层面插入攻击脚本，改变页面的显示，或则窃取网站 cookie，预防方法：不相信用户的所有操作，对用户输入进行一个转义，不允许 js 对 cookie 的读写 csrf 跨站请求伪造，以你的名义，发送恶意请求，通过 cookie 加参数等形式过滤 我们没法彻底杜绝攻击，只能提高攻击门槛 35. 事件委托，目的，功能，写法 把一个或者一组元素的事件委托到它的父层或者更外层元素上 优点，减少内存消耗，动态绑定事件 target 是触发事件的最具体的元素，currenttarget是绑定事件的元素(在函数中一般等于this) 36. 线程，进程 线程是最小的执行单元，进程是最小的资源管理单元 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程 37. 负载均衡 当系统面临大量用户访问，负载过高的时候，通常会使用增加服务器数量来进行横向扩展，使用集群和负载均衡提高整个系统的处理能力 38. 什么是CDN缓存 CDN 是一种部署策略，根据不同的地区部署类似nginx 这种服务服务，会缓存静态资源。前端在项目优化的时候，习惯在讲台资源上加上一个 hash 值，每次更新的时候去改变这个 hash，hash 值变化的时候，服务会去重新取资源 (CDN)是一个经策略性部署的整体系统，包括分布式存储、负载均衡、网络请求的重定向和内容管理4个要件 39. javascript 中常见的内存泄露陷阱 内存泄露会导致一系列问题，比如：运行缓慢，崩溃，高延迟 内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来 意外的全局变量，这些都是不会被回收的变量（除非设置 null 或者被重新赋值），特别是那些用来临时存储大量信息的变量 周期函数一直在运行，处理函数并不会被回收，jq 在移除节点前都会，将事件监听移除 js 代码中有对 DOM 节点的引用，dom 节点被移除的时候，引用还维持 JavaScript 中 4 种常见的内存泄露陷阱 意外的全局变量 被遗漏的定时器和回调函数 DOM 之外的引用 闭包 40. babel把ES6转成ES5或者ES3之类的原理是什么 它就是个编译器，输入语言是ES6+，编译目标语言是ES5 babel 官方工作原理 解析：将代码字符串解析成抽象语法树 变换：对抽象语法树进行变换操作 再建：根据变换后的抽象语法树再生成代码字符串 41. Promise 模拟终止 当新对象保持“pending”状态时，原Promise链将会中止执行。 return new Promise(()=>{}); // 返回“pending”状态的Promise对象 42. promise 放在try catch里面有什么结果 Promise 对象的错误具有冒泡性质，会一直向后传递，直到被捕获为止，也即是说，错误总会被下一个catch语句捕获 当Promise链中抛出一个错误时，错误信息沿着链路向后传递，直至被捕获 43. get与post 通讯的区别 Get 请求能缓存，Post 不能 Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。 Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术 URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的 Post 支持更多的编码类型且不对数据类型限制 44. 有没有去研究webpack的一些原理和机制，怎么实现的 解析webpack配置参数，合并从shell传入和webpack.config.js文件里配置的参数，生产最后的配置结果。 注册所有配置的插件，好让插件监听webpack构建生命周期的事件节点，以做出对应的反应。 从配置的entry入口文件开始解析文件构建AST语法树，找出每个文件所依赖的文件，递归下去。 在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换。 递归完后得到每个文件的最终结果，根据entry配置生成代码块chunk。 输出所有chunk到文件系统。 45. ES6模块与CommonJS模块的差异 CommonJs 模块输出的是一个值的拷贝，ES6模块输出的是一个值的引用 CommonJS 模块是运行时加载，ES6模块是编译时输出接口 ES6输入的模块变量，只是一个符号链接，所以这个变量是只读的，对它进行重新赋值就会报错 46. 模块加载AMD，CMD，CommonJS Modules/2.0 规范 这些规范的目的都是为了 JavaScript 的模块化开发，特别是在浏览器端的 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行 CMD 推崇依赖就近，AMD 推崇依赖前置 47. Node 事件循环，js 事件循环差异 Node.js 的事件循环分为6个阶段 浏览器和Node 环境下，microtask 任务队列的执行时机不同 Node.js中，microtask 在事件循环的各个阶段之间执行 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行 递归的调用process.nextTick()会导致I/O starving，官方推荐使用setImmediate() "},"面试/综合4-vue.html":{"url":"面试/综合4-vue.html","title":"综合4-vue","keywords":"","body":"js面试题（vue） js面试题（vue） 1. 请详细说下你对vue生命周期的理解 2. vue 生命周期图 3. 谈谈你对vue的双向数据绑定的原理的理解 4. 谈谈你对vue组件间数据传递 5. vue里面父组件如何修改子组件样式 1. 请详细说下你对vue生命周期的理解 vue的生命周期总共分为8个阶段：创建前/后，载入前/后，更新前/后，销毁前/后。 创建前/后：在beforeCreate阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段,vue实例的数据对象data有了，$el还没有。 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法。 销毁前/后：在执行destoryed方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。 2. vue 生命周期图 实例代码： 3. 谈谈你对vue的双向数据绑定的原理的理解 vue是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter,getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体步骤： 第一步：通过Observer提供的接口，对需要observe的数据对象进行递归遍历，给对象的每个属性、子属性对象的属性，都加上setter和getter（都绑定了一个专用的 Dep对象，这里的状态对象主要指组件当中的data属性）。 这样的话，给这个对象的某个值赋值，就会触发setter,那么就能监听到了数据变化。 第二步：compile解析模版指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图。 第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是： 在自身实例化时往属性订阅器(dep)里面添加自己 自身必须有一个update()方法 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模版指令，最终利用Watcher搭起Observer和Compiler之间的通信桥梁，达到数据变化->视图更新；视图交互变化(input)->数据model变更的双向绑定效果。 4. 谈谈你对vue组件间数据传递 通过 props 的方式向子组件传递（父子组件） vuex进行状态管理（父子组件和非父子组件） 非父子组件的通信传递 Vue Event Bus($emit)，使用Vue的实例，实现事件的监听和发布，实现组件之间数据的传递。 inheritAttrs + $attrs + $listeners 5. vue里面父组件如何修改子组件样式 在使用 vue 的开发中，我们有时会引用外部组件，包括UI组件。当 标签有 scoped 属性时，它的css只作用于当前组件中的元素。但是在父组件中添加了 scoped 之后，父组件的样式将不会渗透到子组件中，所以在父组件中书写子组件的样式是无效的。 解决方案: 去掉scoped 在父组件的 中去掉 scoped 后，父组件中可以书写子组件的样式，但是需要注意避免污染了全局样式。 混用本地和全局样式 可以在同一个组件中同时使用有作用域和无作用域的样式： /* ...全局样式...*/ /* ...本地样式... */ 使用深度作用选择器 如果你希望 scoped 样式中的一个选择器能够作用得 “更深“，例如影响子组件，你可以使用 >>> 操作符： .parent >>> .child { /* ... */ } 有些像SASS之类的预处理器无法正确解析 >>> 。这种情况下你可以用 /deep/ 操作符取而代之，deep 是 >>> 的别名，同样可以正常工作。 需要额外补充的是： 通过 v-html 创建的 DOM 内容不受作用域内的样式影响，但是你仍然可以通过深度作用选择器来为他们设置样式 CSS 作用域不能代替 class 在递归组件中小心使用后代选择器 "},"面试/综合5.html":{"url":"面试/综合5.html","title":"综合5","keywords":"","body":"js (五) 1. 为什么form表单提交没有跨域问题，但ajax提交有跨域问题？ 2. 移动端适配1px问题 3. 居中为什么要使用transform(为什么不使用marginLeft/Top) 4. JavaScript (a ==1 && a== 2 && a==3) 可能为 true 吗？ 5. 何为受控组件(controlled component) 6. 在 React 中，refs 的作用是什么 7. 何为高阶组件(higher order component) 8. 使用箭头函数(arrow functions)的优点是什么 9. 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象 10. 何为 JSX 11. 怎么用 React.createElement 重写下面的代码 12. 何为 Children 13. 何为 redux 14. 在 Redux 中，何为 store 15. redux中间件 16. redux有什么缺点 17. react组件的划分业务组件技术组件？ 18. 为什么虚拟dom会提高性能? 19. react性能优化方案 20. 简述flux 思想 21. React项目用过什么脚手架？Mern? Yeoman? 22. JSX引入React 23. prop 和 state 的对比 1. 为什么form表单提交没有跨域问题，但ajax提交有跨域问题？ ajax跨域是因为浏览器需要保护用户的安全和隐私而给js设定的限制。如果你自己写个浏览器去掉这个限制那js就可以任意跨域访问了 form表单可以跨域一个是历史原因要保持兼容性，一个是form表单会刷新页面不会把结果返回给js，所以相对安全 用jsonp跨域其实也是利用了浏览器的历史兼容性，而最新的font资源就不允许直接跨域引用 2. 移动端适配1px问题 构建1个伪元素，将它的长宽放大到2倍，边框宽度设置为1px,再以transform缩放到50% .radius-border { position: relative; } @media screen and (-webkit-min-device-pixel-ratio: 2) { .radius-border:before { content: \"\"; pointer-events: none; /* 防止点击触发 */ box-sizing: border-box; position: absolute; width: 200%; height: 200%; left: 0; top: 0; border-radius: 8px; border: 1px solid #999; -webkit-transform(scale(0.5)); -webkit-transform-origin: 0 0; transform(scale(0.5)); transform-origin: 0 0; } } 3. 居中为什么要使用transform(为什么不使用marginLeft/Top) top/left花了大量的时间去绘制每一帧。所有的css包括box-shadow都是在CPU上计算的。在translate版本中，却让这个 macbook 在自己新的图层在GPU中得到提升。此时此元素的macbook是在自己单独的一层上，任何2D transform, 3D transform或者opacity的变化都可以完全的使用GPU，GPU可以保持非常快并且可以给我们提供非常快的帧速率。 4. JavaScript (a ==1 && a== 2 && a==3) 可能为 true 吗？ 自定义 toString（或者 valueOf）方法，每次调用改变一次返回值，从而满足判断条件。 const a = { i: 1, toString: function () { return a.i++; } } if(a == 1 && a == 2 && a == 3) { console.log('Hello World!'); } 当使用 == 时，如果两个参数的类型不一样，那么 JS 会尝试将其中一个的类型转换为和另一个相同。在这里左边对象，右边数字的情况下，会首先尝试调用 valueOf（如果可以调用的话）来将对象转换为数字，如果失败，再调用 toString。 比如，我比较喜欢这个： with({ get a() { return Math.floor(Math.random()*4); } }){ for(var i=0;i stackoverflow var aﾠ = 1; var a = 2; var ﾠa = 3; if(aﾠ==1 && a== 2 &&ﾠa==3) { console.log(\"Why hello there!\") } a = [1,2,3]; a.join = a.shift; console.log(a == 1 && a == 2 && a == 3); // true let i = 0; let a = { [Symbol.toPrimitive]: () => ++i }; console.log(a == 1 && a == 2 && a == 3); // true var a = { r: /\\d/g, valueOf: function(){ return this.r.exec(123)[0] } } if (a == 1 && a == 2 && a == 3) { console.log(\"!\") } 5. 何为受控组件(controlled component) 在 HTML 中，类似 , 和 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为\"受控元素\"。 6. 在 React 中，refs 的作用是什么 Refs 可以用于获取一个 DOM 节点或者 React 组件的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用 String 类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的。 7. 何为高阶组件(higher order component) 高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。 8. 使用箭头函数(arrow functions)的优点是什么 作用域安全：在箭头函数之前，每一个新创建的函数都有定义自身的 this 值(在构造函数中是新对象；在严格模式下，函数调用中的 this 是未定义的；如果函数被称为“对象方法”，则为基础对象等)，但箭头函数不会，它会使用封闭执行上下文的 this 值。 简单：箭头函数易于阅读和书写 清晰：当一切都是一个箭头函数，任何常规函数都可以立即用于定义作用域。开发者总是可以查找 next-higher 函数语句，以查看 this 的值 9. 为什么建议传递给 setState 的参数是一个 callback 而不是一个对象 因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。 10. 何为 JSX JSX 是 JavaScript 语法的一种语法扩展，并拥有 JavaScript 的全部功能。JSX 生产 React \"元素\"，你可以将任何的 JavaScript 表达式封装在花括号里，然后将其嵌入到 JSX 中。在编译完成之后，JSX 表达式就变成了常规的 JavaScript 对象，这意味着你可以在 if 语句和 for 循环内部使用 JSX，将它赋值给变量，接受它作为参数，并从函数中返回它 11. 怎么用 React.createElement 重写下面的代码 Question： const element = ( Hello, rdhub.cn! ); Answer： const element = React.createElement( 'h1', {className: 'greeting'}, 'Hello, rdhub.cn!' ); 12. 何为 Children 在JSX表达式中，一个开始标签(比如)和一个关闭标签(比如)之间的内容会作为一个特殊的属性props.children被自动传递给包含着它的组件。 这个属性有许多可用的方法，包括 React.Children.map，React.Children.forEach， React.Children.count， React.Children.only，React.Children.toArray。 13. 何为 redux Redux 的基本思想是整个应用的 state 保持在一个单一的 store 中。store 就是一个简单的 javascript 对象，而改变应用 state 的唯一方式是在应用中触发 actions，然后为这些 actions 编写 reducers 来修改 state。整个 state 转化是在 reducers 中完成，并且不应该有任何副作用。 14. 在 Redux 中，何为 store Store 是一个 javascript 对象，它保存了整个应用的 state。与此同时，Store 也承担以下职责： 允许通过 getState() 访问 state 运行通过 dispatch(action) 改变 state 通过 subscribe(listener) 注册 listeners 通过 subscribe(listener) 返回的函数处理 listeners 的注销 15. redux中间件 中间件提供第三方插件的模式，自定义拦截 action -> reducer 的过程。变为 action -> middlewares -> reducer 。这种机制可以让我们改变数据流，实现如异步 action ，action 过滤，日志输出，异常报告等功能。 常见的中间件： redux-logger：提供日志输出 redux-thunk：处理异步操作 redux-promise：处理异步操作，actionCreator的返回值是promise 16. redux有什么缺点 一个组件所需要的数据，必须由父组件传过来，而不能像flux中直接从store取。 当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新render，可能会有效率影响，或者需要写复杂的shouldComponentUpdate进行判断。 17. react组件的划分业务组件技术组件？ 根据组件的职责通常把组件分为UI组件和容器组件。 UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。 两者通过React-Redux 提供connect方法联系起来。 18. 为什么虚拟dom会提高性能? 虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能。具体实现步骤如下：用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把2所记录的差异应用到步骤1所构建的真正的DOM树上，视图就更新了。 19. react性能优化方案 重写shouldComponentUpdate来避免不必要的dom操作。 使用 production 版本的react.js。 使用key来帮助React识别列表中所有子组件的最小变化。 20. 简述flux 思想 Flux 的最大特点，就是数据的\"单向流动\"。 用户访问 View View 发出用户的 Action Dispatcher 收到 Action，要求 Store 进行相应的更新 Store 更新后，发出一个\"change\"事件 View 收到\"change\"事件后，更新页面 21. React项目用过什么脚手架？Mern? Yeoman? Mern：MERN是脚手架的工具，它可以很容易地使用Mongo, Express, React and NodeJS生成同构JS应用。它最大限度地减少安装时间，并得到您使用的成熟技术来加速开发。 22. JSX引入React 在使用JSX的范围内必须要有React, 在使用JSX的代码文件中，即使代码中并没有直接使用React，也一定要导入这个React，这是因为JSX最终会被转义成依赖于React的表达式 23. prop 和 state 的对比 prop 用于定义外部接口， state 用于记录内部状态 prop 的赋值在外部世界使用组件时， state 的赋值在组件内部 组件不应该改变prop的值，而 state存在的目的就是让组件来改变的 "},"面试/综合6.html":{"url":"面试/综合6.html","title":"综合6","keywords":"","body":"js (六) 1. new 2. instanceof 3. 对于 CommonJS 和 ES6 中的模块化的两者区别是 4. 防抖 5. 节流 6. call, apply, bind 区别 7. 模拟实现 call 和 apply 和 bind 8. Promise 实现 9. Generator 实现 10. Map、FlatMap 和 Reduce 11. Proxy 1. new 新生成了一个对象 链接到原型 绑定 this 返回新对象 在调用 new 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 new function create() { // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === 'object' ? result : obj } 2. instanceof instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 我们也可以试着实现一下 instanceof function instanceof(left, right) { // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) { if (left === null) return false if (prototype === left) return true left = left.__proto__ } } 3. 对于 CommonJS 和 ES6 中的模块化的两者区别是 前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案 前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响 前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化 后者会编译成 require/exports 来执行的 4. 防抖 你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。 这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。 PS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。 我们先来看一个袖珍版的防抖理解一下防抖的实现： // func是用户传入需要防抖的函数 // wait是等待时间 const debounce = (func, wait = 50) => { // 缓存一个定时器id let timer = 0 // 这里返回的函数是每次用户实际调用的防抖函数 // 如果已经设定过定时器了就清空上一次的定时器 // 开始一个新的定时器，延迟执行用户传入的方法 return function(...args) { if (timer) clearTimeout(timer) timer = setTimeout(() => { func.apply(this, args) }, wait) } } // 不难看出如果用户调用该函数的间隔小于wait的情况下，上一次的时间还未到就被清除了，并不会执行函数 这是一个简单版的防抖，但是有缺陷，这个防抖只能在最后调用。一般的防抖会有immediate选项，表示是否立即调用。这两者的区别，举个栗子来说： 例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用延迟执行的防抖函数，它总是在一连串（间隔小于wait的）函数触发之后调用。 例如用户给interviewMap点star的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变star按钮的样子，用户就可以立马得到反馈是否star成功了，这个情况适用立即执行的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于wait才会触发。 下面我们来实现一个带有立即执行选项的防抖函数 // 这个是用来获取当前时间戳的 function now() { return +new Date() } /** * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param {function} func 回调函数 * @param {number} wait 表示时间窗口的间隔 * @param {boolean} immediate 设置为ture时，是否立即调用函数 * @return {function} 返回客户调用函数 */ function debounce (func, wait = 50, immediate = true) { let timer, context, args // 延迟执行函数 const later = () => setTimeout(() => { // 延迟函数执行完毕，清空缓存的定时器序号 timer = null // 延迟执行的情况下，函数会在延迟函数中执行 // 使用到之前缓存的参数和上下文 if (!immediate) { func.apply(context, args) context = args = null } }, wait) // 这里返回的函数是每次实际调用的函数 return function(...params) { // 如果没有创建延迟执行函数（later），就创建一个 if (!timer) { timer = later() // 如果是立即执行，调用函数 // 否则缓存参数和调用上下文 if (immediate) { func.apply(this, params) } else { context = this args = params } // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个 // 这样做延迟函数会重新计时 } else { clearTimeout(timer) timer = later() } } } 整体函数实现的不难，总结一下。 对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 null，就可以再次点击了。 对于延时执行函数来说的实现：清除定时器ID，如果是延迟调用就调用函数 5. 节流 防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。 /** * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait * * @param {function} func 回调函数 * @param {number} wait 表示时间窗口的间隔 * @param {object} options 如果想忽略开始函数的的调用，传入{leading: false}。 * 如果想忽略结尾函数的调用，传入{trailing: false} * 两者不能共存，否则函数不能执行 * @return {function} 返回客户调用函数 */ _.throttle = function(func, wait, options) { var context, args, result; var timeout = null; // 之前的时间戳 var previous = 0; // 如果 options 没传则设为空对象 if (!options) options = {}; // 定时器回调函数 var later = function() { // 如果设置了 leading，就将 previous 设为 0 // 用于下面函数的第一个 if 判断 previous = options.leading === false ? 0 : _.now(); // 置空一是为了防止内存泄漏，二是为了下面的定时器判断 timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; }; return function() { // 获得当前时间戳 var now = _.now(); // 首次进入前者肯定为 true // 如果需要第一次不执行函数 // 就将上次时间戳设为当前的 // 这样在接下来计算 remaining 的值时会大于0 if (!previous && options.leading === false) previous = now; // 计算剩余时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果当前调用已经大于上次调用时间 + wait // 或者用户手动调了时间 // 如果设置了 trailing，只会进入这个条件 // 如果没有设置 leading，那么第一次会进入这个条件 // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了 // 其实还是会进入的，因为定时器的延时 // 并不是准确的时间，很可能你设置了2秒 // 但是他需要2.2秒才触发，这时候就会进入这个条件 if (remaining wait) { // 如果存在定时器就清理掉否则会调用二次回调 if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; result = func.apply(context, args); if (!timeout) context = args = null; } else if (!timeout && options.trailing !== false) { // 判断是否设置了定时器和 trailing // 没有的话就开启一个定时器 // 并且不能不能同时设置 leading 和 trailing timeout = setTimeout(later, remaining); } return result; }; }; 6. call, apply, bind 区别 首先说下前两者的区别。 call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。 除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。 bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。 7. 模拟实现 call 和 apply 和 bind 可以从以下几点来考虑如何实现 不传入第一个参数，那么默认为 window 改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？ Function.prototype.myCall = function (context) { var context = context || window // 给 context 添加一个属性 // getValue.call(a, 'yck', '24') => a.fn = getValue context.fn = this // 将 context 后面的参数取出来 var args = [...arguments].slice(1) // getValue.call(a, 'yck', '24') => a.fn('yck', '24') var result = context.fn(...args) // 删除 fn delete context.fn return result } 以上就是 call 的思路，apply 的实现也类似 Function.prototype.myApply = function (context) { var context = context || window context.fn = this var result // 需要判断是否存储第二个参数 // 如果存在，就将第二个参数展开 if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。 Function.prototype.myBind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } var _this = this var args = [...arguments].slice(1) // 返回一个函数 return function F() { // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) { return new _this(...args, ...arguments) } return _this.apply(context, args.concat(...arguments)) } } 8. Promise 实现 Promise 是 ES6 新增的语法，解决了回调地狱的问题。 可以把 Promise 看成一个状态机。初始是 pending 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化。 then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 then 调用就失去意义了。 对于 then 来说，本质上可以把它看成是 flatMap // 三种状态 const PENDING = \"pending\"; const RESOLVED = \"resolved\"; const REJECTED = \"rejected\"; // promise 接收一个函数参数，该函数会立即执行 function MyPromise(fn) { let _this = this; _this.currentState = PENDING; _this.value = undefined; // 用于保存 then 中的回调，只有当 promise // 状态为 pending 时才会缓存，并且每个实例至多缓存一个 _this.resolvedCallbacks = []; _this.rejectedCallbacks = []; _this.resolve = function (value) { if (value instanceof MyPromise) { // 如果 value 是个 Promise，递归执行 return value.then(_this.resolve, _this.reject) } setTimeout(() => { // 异步执行，保证执行顺序 if (_this.currentState === PENDING) { _this.currentState = RESOLVED; _this.value = value; _this.resolvedCallbacks.forEach(cb => cb()); } }) }; _this.reject = function (reason) { setTimeout(() => { // 异步执行，保证执行顺序 if (_this.currentState === PENDING) { _this.currentState = REJECTED; _this.value = reason; _this.rejectedCallbacks.forEach(cb => cb()); } }) } // 用于解决以下问题 // new Promise(() => throw Error('error)) try { fn(_this.resolve, _this.reject); } catch (e) { _this.reject(e); } } MyPromise.prototype.then = function (onResolved, onRejected) { var self = this; // 规范 2.2.7，then 必须返回一个新的 promise var promise2; // 规范 2.2.onResolved 和 onRejected 都为可选参数 // 如果类型不是函数需要忽略，同时也实现了透传 // Promise.resolve(4).then().then((value) => console.log(value)) onResolved = typeof onResolved === 'function' ? onResolved : v => v; onRejected = typeof onRejected === 'function' ? onRejected : r => throw r; if (self.currentState === RESOLVED) { return (promise2 = new MyPromise(function (resolve, reject) { // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行 // 所以用了 setTimeout 包裹下 setTimeout(function () { try { var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (reason) { reject(reason); } }); })); } if (self.currentState === REJECTED) { return (promise2 = new MyPromise(function (resolve, reject) { setTimeout(function () { // 异步执行onRejected try { var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (reason) { reject(reason); } }); })); } if (self.currentState === PENDING) { return (promise2 = new MyPromise(function (resolve, reject) { self.resolvedCallbacks.push(function () { // 考虑到可能会有报错，所以使用 try/catch 包裹 try { var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (r) { reject(r); } }); self.rejectedCallbacks.push(function () { try { var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (r) { reject(r); } }); })); } }; // 规范 2.3 function resolutionProcedure(promise2, x, resolve, reject) { // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用 if (promise2 === x) { return reject(new TypeError(\"Error\")); } // 规范 2.3.2 // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行 if (x instanceof MyPromise) { if (x.currentState === PENDING) { x.then(function (value) { // 再次调用该函数是为了确认 x resolve 的 // 参数是什么类型，如果是基本类型就再次 resolve // 把值传给下个 then resolutionProcedure(promise2, value, resolve, reject); }, reject); } else { x.then(resolve, reject); } return; } // 规范 2.3.3.3.3 // reject 或者 resolve 其中一个执行过得话，忽略其他的 let called = false; // 规范 2.3.3，判断 x 是否为对象或者函数 if (x !== null && (typeof x === \"object\" || typeof x === \"function\")) { // 规范 2.3.3.2，如果不能取出 then，就 reject try { // 规范 2.3.3.1 let then = x.then; // 如果 then 是函数，调用 x.then if (typeof then === \"function\") { // 规范 2.3.3.3 then.call( x, y => { if (called) return; called = true; // 规范 2.3.3.3.1 resolutionProcedure(promise2, y, resolve, reject); }, e => { if (called) return; called = true; reject(e); } ); } else { // 规范 2.3.3.4 resolve(x); } } catch (e) { if (called) return; called = true; reject(e); } } else { // 规范 2.3.4，x 为基本类型 resolve(x); } } 9. Generator 实现 Generator 是 ES6 中新增的语法，和 Promise 一样，都可以用来异步编程 // 使用 * 表示这是一个 Generator 函数 // 内部可以通过 yield 暂停代码 // 通过调用 next 恢复执行 function* test() { let a = 1 + 2; yield 2; yield 3; } let b = test(); console.log(b.next()); // > { value: 2, done: false } console.log(b.next()); // > { value: 3, done: false } console.log(b.next()); // > { value: undefined, done: true } 从以上代码可以发现，加上 * 的函数执行后拥有了 next 函数，也就是说函数执行后返回了一个对象。每次调用 next 函数可以继续执行被暂停的代码。以下是 Generator 函数的简单实现 // cb 也就是编译过的 test 函数 function generator(cb) { return (function() { var object = { next: 0, stop: function() {} }; return { next: function() { var ret = cb(object); if (ret === undefined) return { value: undefined, done: true }; return { value: ret, done: false }; } }; })(); } // 如果你使用 babel 编译后可以发现 test 函数变成了这样 function test() { var a; return generator(function(_context) { while (1) { switch ((_context.prev = _context.next)) { // 可以发现通过 yield 将代码分割成几块 // 每次执行 next 函数就执行一块代码 // 并且表明下次需要执行哪块代码 case 0: a = 1 + 2; _context.next = 4; return 2; case 4: _context.next = 6; return 3; // 执行完毕 case 6: case \"end\": return _context.stop(); } } }); } 10. Map、FlatMap 和 Reduce Map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后 append 到新的数组中。 [1, 2, 3].map((v) => v + 1) // -> [2, 3, 4] Map 有三个参数，分别是当前索引元素，索引，原数组 ['1','2','3'].map(parseInt) // parseInt('1', 0) -> 1 // parseInt('2', 1) -> NaN // parseInt('3', 2) -> NaN FlatMap 和 map 的作用几乎是相同的，但是对于多维数组来说，会将原数组降维。可以将 FlatMap 看成是 map + flatten ，目前该函数在浏览器中还不支持。 [1, [2], 3].flatMap((v) => v + 1) // -> [2, 3, 4] 如果想将一个多维数组彻底的降维，可以这样实现 const flattenDeep = (arr) => Array.isArray(arr) ? arr.reduce( (a, b) => [...a, ...flattenDeep(b)] , []) : [arr] flattenDeep([1, [[2], [3, [4]], 5]]) Reduce 作用是数组中的值组合起来，最终得到一个值 function a() { console.log(1); } function b() { console.log(2); } [a, b].reduce((a, b) => a(b())) // -> 2 1 11. Proxy Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作 let p = new Proxy(target, handler); // `target` 代表需要添加代理的对象 // `handler` 用来自定义对象中的操作 可以很方便的使用 Proxy 来实现一个数据绑定和监听 let onWatch = (obj, setBind, getLogger) => { let handler = { get(target, property, receiver) { getLogger(target, property) return Reflect.get(target, property, receiver); }, set(target, property, value, receiver) { setBind(value); return Reflect.set(target, property, value); } }; return new Proxy(obj, handler); }; let obj = { a: 1 } let value let p = onWatch(obj, (v) => { value = v }, (target, property) => { console.log(`Get '${property}' = ${target[property]}`); }) p.a = 2 // bind `value` to `2` p.a // -> Get 'a' = 2 "},"面试/vue.html":{"url":"面试/vue.html","title":"Vue","keywords":"","body":"Vue框架 Vue框架 1. 对于MVVM的理解 2. 开发中常用的指令有哪些 3. 请详细说下你对vue生命周期的理解 4. Vue的双向数据绑定原理是什么 5. Proxy 相比于 defineProperty 的优势 6. vue-router 有哪几种导航守卫? 6.1. 全局守卫 6.2. 路由独享守卫 6.3. 路由组件内的守卫 7. Vue的路由实现：hash模式 和 history模式 7.1. hash模式 7.2. history模式 8. 组件之间的传值通信 9. Vue与Angular以及React的区别？ 9.1 Vue与AngularJS的区别 9.2 Vue与React的区别 10. vuex是什么？怎么使用？哪种功能场景使用它？ 1. 对于MVVM的理解 MVVM 是 Model-View-ViewModel 的缩写 Model: 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为 View: 用户操作界面。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View ViewModel： 业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说它是Model for View. 总结： MVVM模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。 2. 开发中常用的指令有哪些 v-model :一般用在表达输入，很轻松的实现表单控件和数据的双向绑定 v-html: 更新元素的 innerHTML v-show 与 v-if: 条件渲染, 注意二者区别 使用了v-if的时候，如果值为false，那么页面将不会有这个html标签生成。v-show则是不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏 v-on : click: 可以简写为@click,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数 v-for: 基于源数据多次渲染元素或模板块 v-bind: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM 语法：v-bind:title=\"msg\"简写：:title=\"msg\" 3. 请详细说下你对vue生命周期的理解 vue生命周期总共分为8个阶段: 创建前/后，载入前/后，更新前/后， 销毁前/后。 beforeCreate （创建前）vue实例的挂载元素$el和数据对象 data都是undefined, 还未初始化 created (创建后) 完成了 data数据初始化, el还未初始化 beforeMount (载入前) vue实例的$el和data都初始化了, 相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。 mounted (载入后) 在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互 beforeUpdate (更新前) 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 updated （更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy (销毁前） 在实例销毁之前调用。实例仍然完全可用。 destroyed (销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 4. Vue的双向数据绑定原理是什么 vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体实现步骤，感兴趣的可以看看: 当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: 在自身实例化时往属性订阅器(dep)里面添加自己 自身必须有一个update()方法 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果 //vue实现数据双向绑定的原理就是用Object.defineproperty()重新定义（set方法）对象设置属性值和（get方法）获取属性值的操纵来实现的。 //Object.property()方法的解释：Object.property(参数1，参数2，参数3) 返回值为该对象obj //其中参数1为该对象（obj），参数2为要定义或修改的对象的属性名，参数3为属性描述符，属性描述符是一个对象，主要有两种形式：数据描述符和存取描述符。这两种对象只能选择一种使用，不能混合使用。而get和set属于存取描述符对象的属性。 //这个方法会直接在一个对象上定义一个新属性或者修改对象上的现有属性，并返回该对象。 var model = { message: \"\" }; var models = myapp.querySelectorAll(\"[v-model=message]\"); for (var i = 0; i 5. Proxy 相比于 defineProperty 的优势 Object.defineProperty() 的问题主要有三个： 不能监听数组的变化 必须遍历对象的每个属性 必须深层遍历嵌套的对象 Proxy 在 ES2015 规范中被正式加入，它有以下几个特点： 针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题 支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。 除了上述两点之外，Proxy 还拥有以下优势: Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富 Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。 6. vue-router 有哪几种导航守卫? 全局守卫 路由独享守卫 路由组件内的守卫 6.1. 全局守卫 vue-router全局有三个守卫： router.beforeEach 全局前置守卫 进入路由之前 router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用 router.afterEach 全局后置钩子 进入路由之后 使用方法: // main.js 入口文件 import router from './router'; // 引入路由 router.beforeEach((to, from, next) => { next(); }); router.beforeResolve((to, from, next) => { next(); }); router.afterEach((to, from) => { console.log('afterEach 全局后置钩子'); }); 6.2. 路由独享守卫 如果你不想全局配置守卫的话，你可以为某些路由单独配置守卫 const router = new VueRouter({ routes: [ { path: '/foo', component: Foo, beforeEnter: (to, from, next) => { // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖 // ... } } ] }) 6.3. 路由组件内的守卫 beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建 beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this 7. Vue的路由实现：hash模式 和 history模式 7.1. hash模式 在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取； 特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。 hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 http://www.baidu.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。 7.2. history模式 history采用HTML5的新特性；且提供了两个新方法：pushState()，replaceState() 可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。 history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。Vue-Router 官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。” 8. 组件之间的传值通信 组件之间通讯分为三种: 父传子、子传父、兄弟组件之间的通讯 父组件给子组件传值 使用props，父组件可以使用props向子组件传递数据。 父组件vue模板father.vue: import child from './child.vue'; export default { components: { child }, data () { return { message: 'father message'; } } } 子组件vue模板child.vue: export default { props: { msg: { type: String, required: true } } } 子组件向父组件通信 父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件。 父组件vue模板father.vue: import child from './child.vue'; export default { components: { child }, methods: { func (msg) { console.log(msg); } } } 子组件vue模板child.vue: 点我 export default { props: { msg: { type: String, required: true } }, methods () { handleClick () { //........ this.$emit('msgFunc'); } } } 非父子, 兄弟组件之间通信 vue2中废弃了$dispatch和$broadcast广播和分发事件的方法。父子组件中可以用props和$emit()。如何实现非父子组件间的通信，可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递。 Bus.js可以是这样: import Vue from 'vue' export default new Vue() 在需要通信的组件都引入Bus.js: 子组件传给兄弟组件 import Bus from '../common/js/bus.js' export default{ methods: { toBus () { Bus.$emit('on', '来自兄弟组件') } } } 另一个组件也import Bus.js 在钩子函数中监听on事件 import Bus from '../common/js/bus.js' export default { data() { return { message: '' } }, mounted() { Bus.$on('on', (msg) => { this.message = msg }) } } 9. Vue与Angular以及React的区别？ 9.1 Vue与AngularJS的区别 Angular采用TypeScript开发, 而Vue可以使用javascript也可以使用TypeScript AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。 AngularJS社区完善, Vue的学习成本较小 9.2 Vue与React的区别 vue组件分为全局注册和局部注册，在react中都是通过import相应组件，然后模版中引用； props是可以动态变化的，子组件也实时更新，在react中官方建议props要像纯函数那样，输入输出一致对应，而且不太建议通过props来更改视图； 子组件一般要显示地调用props选项来声明它期待获得的数据。而在react中不必需，另两者都有props校验机制； 每个Vue实例都实现了事件接口，方便父子组件通信，小型项目中不需要引入状态管理机制，而react必需自己实现； 使用插槽分发内容，使得可以混合父组件的内容与子组件自己的模板； 多了指令系统，让模版可以实现更丰富的功能，而React只能使用JSX语法； Vue增加的语法糖computed和watch，而在React中需要自己写一套逻辑来实现； react的思路是all in js，通过js来生成html，所以设计了jsx，还有通过js来操作css，社区的styled-component、jss等；而 vue是把html，css，js组合到一起，用各自的处理方式，vue有单文件组件，可以把html、css、js写到一个文件中，html提供了模板引擎来处理。 react做的事情很少，很多都交给社区去做，vue很多东西都是内置的，写起来确实方便一些， 比如 redux的combineReducer就对应vuex的modules， 比如reselect就对应vuex的getter和vue组件的computed， vuex的mutation是直接改变的原始数据，而redux的reducer是返回一个全新的state，所以redux结合immutable来优化性能，vue不需要。 react是整体的思路的就是函数式，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以做到，比如结合redux-form，组件的横向拆分一般是通过高阶组件。而vue是数据可变的，双向绑定，声明式的写法，vue组件的横向拆分很多情况下用mixin。 10. vuex是什么？怎么使用？哪种功能场景使用它？ vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新 它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性 Vuex有5种属性: 分别是 state、getter、mutation、action、module; state Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 mutations mutations定义的方法动态修改Vuex 的 store 中的状态或数据。 getters 类似vue的计算属性，主要用来过滤一些数据。 action actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop 属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据。 使用Vuex解决非父子组件之间通信问题 vuex 是通过将 state 作为数据中心、各个组件共享 state 实现跨组件通信的，此时的数据完全独立于组件，因此将组件间共享的数据置于 State 中能有效解决多层级组件嵌套的跨组件通信问题。 vuex 作为数据存储中心 vuex 的 State 在单页应用的开发中本身具有一个“数据库”的作用，可以将组件中用到的数据存储在 State 中，并在 Action 中封装数据读写的逻辑。这时候存在一个问题，一般什么样的数据会放在 State 中呢？ 目前主要有两种数据会使用 vuex 进行管理： 组件之间全局共享的数据 通过后端异步请求的数据 比如做加入购物车、登录状态等都可以使用Vuex来管理数据状态。 一般面试官问到这里vue基本知识就差不多了， 如果更深入的研究就是和你探讨关于vue的底层源码；或者是具体在项目中遇到的问题，下面列举几个项目中可能遇到的问题： 开发时，改变数组或者对象的数据，但是页面没有更新如何解决？ vue弹窗后如何禁止滚动条滚动？ 如何在 vue 项目里正确地引用 jquery 和 jquery-ui的插件 "},"面试/20道JS原理题.html":{"url":"面试/20道JS原理题.html","title":"20道JS原理题","keywords":"","body":"20道JS原理题 20道JS原理题 1. 实现一个call函数 2. 实现一个apply函数 3. 实现一个bind函数 4. instanceof的原理 5. Object.create的基本实现原理 6. new本质 7. 实现一个基本的Promise 8. 实现浅拷贝 9. 实现一个基本的深拷贝 10. 使用setTimeout模拟setInterval 11. js实现一个继承方法 12. 实现一个基本的Event Bus 13. 实现一个双向数据绑定 14. 实现一个简单路由 15. 实现懒加载 16. rem实现原理 17. 手写实现AJAX 18. 实现拖拽 19. 实现一个节流函数 20. 实现一个防抖函数 1. 实现一个call函数 // 将要改变this指向的方法挂到目标this上执行并返回 Function.prototype.mycall = function (context) { if (typeof this !== 'function') { throw new TypeError('not funciton') } context = context || window context.fn = this let arg = [...arguments].slice(1) let result = context.fn(...arg) delete context.fn return result } 2. 实现一个apply函数 Function.prototype.myapply = function (context) { if (typeof this !== 'function') { throw new TypeError('not funciton') } context = context || window context.fn = this let result if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } 3. 实现一个bind函数 Function.prototype.mybind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } let _this = this let arg = [...arguments].slice(1) return function F() { // 处理函数使用new的情况 if (this instanceof F) { return new _this(...arg, ...arguments) } else { return _this.apply(context, arg.concat(...arguments)) } } } 4. instanceof的原理 // 右边变量的原型存在于左边变量的原型链上 function instanceOf(left, right) { let leftValue = left.__proto__ let rightValue = right.prototype while (true) { if (leftValue === null) { return false } if (leftValue === right) { return true } leftValue = rightValue.__proto__ } } 5. Object.create的基本实现原理 function create(obj) { function F() {} F.prototype = obj return new F() } 6. new本质 function myNew (fun) { return function () { // 创建一个新对象且将其隐式原型指向构造函数原型 let obj = { __proto__ : fun.prototype } // 执行构造函数 fun.call(obj, ...arguments) // 返回该对象 return obj } } function person(name, age) { this.name = name this.age = age } let obj = myNew(person)('chen', 18) // {name: \"chen\", age: 18} 7. 实现一个基本的Promise // ①自动执行函数，②三个状态，③then class Promise { constructor (fn) { // 三个状态 this.state = 'pending' this.value = undefined this.reason = undefined let resolve = value => { if (this.state === 'pending') { this.state = 'fulfilled' this.value = value } } let reject = value => { if (this.state === 'pending') { this.state = 'rejected' this.reason = value } } // 自动执行函数 try { fn(resolve, reject) } catch (e) { reject(e) } } // then then(onFulfilled, onRejected) { switch (this.state) { case 'fulfilled': onFulfilled() break case 'rejected': onRejected() break default: } } } 8. 实现浅拷贝 // 1. ...实现 let copy1 = {...{x:1}} // 2. Object.assign实现 let copy2 = Object.assign({}, {x:1}) 9. 实现一个基本的深拷贝 // 1. JOSN.stringify()/JSON.parse() let obj = {a: 1, b: {x: 3}} JSON.parse(JSON.stringify(obj)) // 2. 递归拷贝 function deepClone(obj) { let copy = obj instanceof Array ? [] : {} for (let i in obj) { if (obj.hasOwnProperty(i)) { copy[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i] } } return copy } 10. 使用setTimeout模拟setInterval // 可避免setInterval因执行时间导致的间隔执行时间不一致 setTimeout (function () { // do something setTimeout (arguments.callee, 500) }, 500) 11. js实现一个继承方法 // 借用构造函数继承实例属性 function Child () { Parent.call(this) } // 寄生继承原型属性 (function () { let Super = function () {} Super.prototype = Parent.prototype Child.prototype = new Super() })() 12. 实现一个基本的Event Bus // 组件通信，一个触发与监听的过程 class EventEmitter { constructor () { // 存储事件 this.events = this.events || new Map() } // 监听事件 addListener (type, fn) { if (!this.events.get(type)) { this.events.set(type, fn) } } // 触发事件 emit (type) { let handle = this.events.get(type) handle.apply(this, [...arguments].slice(1)) } } // 测试 let emitter = new EventEmitter() // 监听事件 emitter.addListener('ages', age => { console.log(age) }) // 触发事件 emitter.emit('ages', 18) // 18 13. 实现一个双向数据绑定 let obj = {} let input = document.getElementById('input') let span = document.getElementById('span') Object.defineProperty(obj, 'text', { configurable: true, enumerable: true, get() { console.log('获取数据了') return obj.text }, set(newVal) { console.log('数据更新了') input.value = newVal span.innerHTML = newVal } }) input.addEventListener('keyup', function(e) { obj.text = e.target.value }) 14. 实现一个简单路由 class Route{ constructor(){ // 路由存储对象 this.routes = {} // 当前hash this.currentHash = '' // 绑定this，避免监听时this指向改变 this.freshRoute = this.freshRoute.bind(this) // 监听 window.addEventListener('load', this.freshRoute, false) window.addEventListener('hashchange', this.freshRoute, false) } // 存储 storeRoute (path, cb) { this.routes[path] = cb || function () {} } // 更新 freshRoute () { this.currentHash = location.hash.slice(1) || '/' this.routes[this.currentHash]() } } 15. 实现懒加载 let imgs = document.querySelectorAll('img') // 可视区高度 let clientHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight function lazyLoad () { // 滚动卷去的高度 let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop for (let i = 0; i 0 && x 16. rem实现原理 function setRem () { let doc = document.documentElement let width = doc.getBoundingClientRect().width // 假设设计稿为宽750，则rem为10px let rem = width / 75 doc.style.fontSize = rem + 'px' } 17. 手写实现AJAX // 1. 简单实现 // 实例化 let xhr = new XMLHttpRequest() // 初始化 xhr.open(method, url, async) // 发送请求 xhr.send(data) // 设置状态变化回调处理请求结果 xhr.onreadystatechange = () => { if (xhr.readyStatus === 4 && xhr.status === 200) { console.log(xhr.responseText) } } // 2. 基于promise实现 function ajax (options) { // 请求地址 const url = options.url // 请求方法 const method = options.method.toLocaleLowerCase() || 'get' // 默认为异步true const async = options.async // 请求参数 const data = options.data // 实例化 const xhr = new XMLHttpRequest() // 请求超时 if (options.timeout && options.timeout > 0) { xhr.timeout = options.timeout } // 返回一个Promise实例 return new Promise ((resolve, reject) => { xhr.ontimeout = () => reject && reject('请求超时') // 监听状态变化回调 xhr.onreadystatechange = () => { if (xhr.readyState == 4) { // 200-300 之间表示请求成功，304资源未变，取缓存 if (xhr.status >= 200 && xhr.status reject && reject(err) let paramArr = [] let encodeData // 处理请求参数 if (data instanceof Object) { for (let key in data) { // 参数拼接需要通过 encodeURIComponent 进行编码 paramArr.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key])) } encodeData = paramArr.join('&') } // get请求拼接参数 if (method === 'get') { // 检测url中是否已存在 ? 及其位置 const index = url.indexOf('?') if (index === -1) url += '?' else if (index !== url.length -1) url += '&' // 拼接url url += encodeData } // 初始化 xhr.open(method, url, async) // 发送请求 if (method === 'get') xhr.send(null) else { // post 方式需要设置请求头 xhr.setRequestHeader('Content-Type','application/x-www-form-urlencoded;charset=UTF-8') xhr.send(encodeData) } }) } 18. 实现拖拽 window.onload = function () { // drag处于绝对定位状态 let drag = document.getElementById('box') drag.onmousedown = function(e) { var e = e || window.event // 鼠标与拖拽元素边界的距离 = 鼠标与可视区边界的距离 - 拖拽元素与边界的距离 let diffX = e.clientX - drag.offsetLeft let diffY = e.clientY - drag.offsetTop drag.onmousemove = function (e) { // 拖拽元素移动的距离 = 鼠标与可视区边界的距离 - 鼠标与拖拽元素边界的距离 let left = e.clientX - diffX let top = e.clientY - diffY // 避免拖拽出可视区 if (left window.innerWidth - drag.offsetWidth) { left = window.innerWidth - drag.offsetWidth } if (top window.innerHeight - drag.offsetHeight) { top = window.innerHeight - drag.offsetHeight } drag.style.left = left + 'px' drag.style.top = top + 'px' } drag.onmouseup = function (e) { this.onmousemove = null this.onmouseup = null } } } 19. 实现一个节流函数 function throttle (fn, delay) { // 利用闭包保存时间 let prev = Date.now() return function () { let context = this let arg = arguments let now = Date.now() if (now - prev >= delay) { fn.apply(context, arg) prev = Date.now() } } } function fn () { console.log('节流') } addEventListener('scroll', throttle(fn, 1000)) 20. 实现一个防抖函数 function debounce (fn, delay) { // 利用闭包保存定时器 let timer = null return function () { let context = this let arg = arguments // 在规定时间内再次触发会先清除定时器后再重设定时器 clearTimeout(timer) timer = setTimeout(function () { fn.apply(context, arg) }, delay) } } function fn () { console.log('防抖') } addEventListener('scroll', debounce(fn, 1000)) "},"面试/奇舞团面试秘籍.html":{"url":"面试/奇舞团面试秘籍.html","title":"奇舞团面试秘籍","keywords":"","body":"奇舞团面试秘籍 奇舞团面试秘籍 位运算相关 计算汉明重量 判断奇偶 二分查找 非递归方法 递归方法 常见排序 快速排序 冒泡排序 二叉树遍历相关 先序遍历（中->左->右） 中序遍历（左->中->右） 后序遍历（左->右->中） 层次遍历 位运算相关 计算汉明重量 function hammingWeight(n) { let num = 0; while(n !== 0) { n &= (n - 1); num++; } return num; } 判断奇偶 funciton isOdd(n) { return n & 1 === 1; } 二分查找 非递归方法 function binarySearch(nums, target) { let low = 0; let high = nums.length - 1; while (low target) { high = mid - 1; } if (nums[mid] 递归方法 function binarySearch(nums, target) { let low = 0; let high = nums.length - 1; const binaryWalker = (nums, low, high, target) => { if (low > high) return -1; const mid = parseInt((low + high) / 2); if (nums[mid] === target) return mid; if (nums[mid] > target) return binaryWalker(nums, low, mid - 1, target); if (nums[mid] 常见排序 快速排序 function quickSort(arr) { if (arr.length = pivot) { right.push(arr[i]); } else { left.push(arr[i]); } } return [...quickSort(left), pivot, ...quickSort(right)]; } 冒泡排序 function bubbleSort(arr) { let i = arr.length - 1; while (i >= 0) { for (let j = 0; j arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } i--; } return arr; } 二叉树遍历相关 先序遍历（中->左->右） 递归实现 function preOrderTraverse(root) { if (root) { console.log(root); preOrderTraverse(root.left); preOrderTraverse(root.right); } } 非递归实现 function preOrderTraverse(root) { let stack = []; if (root) { stack.push(root); } while (stack.length) { let temp = stack.pop(); console.log(temp); if (temp.right) stack.push(temp.right); if (temp.left) stack.pus(temp.left); } } 中序遍历（左->中->右） 递归实现 function midOrderTraverse(root) { if (root) { midOrderTraverse(root.left); console.log(root); midOrderTraverse(root.right); } } 非递归实现 function midOrderTraverse(root) { let stack = []; while (true) { while (root) { stack.push(root); root = root.left; } if (!stack.length) break; let temp = stack.pop(); console.log(temp); root = temp.right; } } 后序遍历（左->右->中） 递归实现 function postOrderTraverse(root) { if (root) { postOrderTraverse(root.left); postOrderTraverse(root.right); console.log(root); } } 非递归实现 function postOrderTraverse(root) { let stack = []; let rest = []; if (root) stack.push(root); while (stack.length) { let temp = stack.pop(); rest.push(temp); if (temp.left) stack.push(temp.left); if (temp.right) stack.push(temp.right); } return rest.reverse(); } 层次遍历 function levelTraverse(root) { if (!root) return; let stack = []; stack.push(root); while (stack.length) { let temp = stack.shift(); console.log(temp); if (temp.left) stack.push(temp.left); if (temp.right) stack.push(temp.right); } } "},"面试/一道思考题.html":{"url":"面试/一道思考题.html","title":"一道思考题","keywords":"","body":"一道思考题 将如下扁平对象，转为树形对象。parent字段为空字符串的节点为根节点： var input = { h3: { parent: 'h2', name: '副总经理(市场)' }, h1: { parent: 'h0', name: '公司机构' }, h7: { parent: 'h6', name: '副总经理(总务)' }, h4: { parent: 'h3', name: '销售经理' }, h2: { parent: 'h1', name: '总经理' }, h8: { parent: 'h0', name: '财务总监' }, h6: { parent: 'h4', name: '仓管总监' }, h5: { parent: 'h4', name: '销售代表' }, h0: { parent: '', name: 'root' } }; var plain2Tree = function (obj) { var key, res for(key in obj) { var parent = obj[key].parent if(parent === '') { res = obj[key] } else { obj[parent][key] = obj[key] } } return res } 这段代码，就是利用了JavaScript里面的引用类型，之后的思路，和操作指针没什么区别，就是构造一棵树。 "},"面试/Js基础.html":{"url":"面试/Js基础.html","title":"JS基础","keywords":"","body":"Js基础 Js基础 1.内置类型 2.Typeof 3.类型转换 3.1.转Boolean 3.2.对象转基本类型 3.3.四则运算符 3.4.== 操作符 3.5.比较运算符 4.原型 5.new 6.instanceof 7.this 8.执行上下文 9.闭包 10.深浅拷贝 1.内置类型 JS 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（Object）。 基本类型有六种： null undefined boolean number string symbol 其中 JS 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754标准实现，在使用中会遇到某些 Bug。NaN 也属于 number 类型，并且 NaN 不等于自身。 对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型 let a = 111 // 这只是字面量，不是 number 类型 a.toString() // 使用时候才会转换为对象类型 对象（Object）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。 let a = { name: 'FE' } let b = a b.name = 'EF' console.log(a.name) // EF 2.Typeof typeof 对于基本类型，除了 null 都可以显示正确的类型 typeof 1 // 'number' typeof '1' // 'string' typeof undefined // 'undefined' typeof true // 'boolean' typeof Symbol() // 'symbol' typeof b // b 没有声明，但是还会显示 undefined typeof 对于对象，除了函数都会显示 object typeof [] // 'object' typeof {} // 'object' typeof console.log // 'function' 对于 null 来说，虽然它是基本类型，但是会显示 object，这是一个存在很久了的 Bug typeof null // 'object' PS：为什么会出现这种情况呢？因为在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。 如果我们想获得一个变量的正确类型，可以通过 Object.prototype.toString.call(xx)。这样我们就可以获得类似 [object Type] 的字符串。 let a // 我们也可以这样判断 undefined a === undefined // 但是 undefined 不是保留字，能够在低版本浏览器被赋值 let undefined = 1 // 这样判断就会出错 // 所以可以用下面的方式来判断，并且代码量更少 // 因为 void 后面随便跟上一个组成表达式 // 返回就是 undefined a === void 0 3.类型转换 3.1.转Boolean 在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象。 3.2.对象转基本类型 对象在转换基本类型时，首先会调用 valueOf 然后调用 toString。并且这两个方法你是可以重写的。 let a = { valueOf() { return 0 } } 当然你也可以重写 Symbol.toPrimitive ，该方法在转基本类型时调用优先级最高。 let a = { valueOf() { return 0; }, toString() { return '1'; }, [Symbol.toPrimitive]() { return 2; } } 1 + a // => 3 '1' + a // => '12' 3.3.四则运算符 只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。 1 + '1' // '11' 2 * '2' // 4 [1, 2] + [2, 1] // '1,22,1' // [1, 2].toString() -> '1,2' // [2, 1].toString() -> '2,1' // '1,2' + '2,1' = '1,22,1' 对于加号需要注意这个表达式 'a' + + 'b' 'a' + + 'b' // -> \"aNaN\" // 因为 + 'b' -> NaN // 你也许在一些代码中看到过 + '1' -> 1 3.4.== 操作符 上图中的 toPrimitive 就是对象转基本类型。 这里来解析一道题目 [] == ![] // -> true ，下面是这个表达式为何为 true 的步骤 // [] 转成 true，然后取反变成 false [] == false // 根据第 8 条得出 [] == ToNumber(false) [] == 0 // 根据第 10 条得出 ToPrimitive([]) == 0 // [].toString() -> '' '' == 0 // 根据第 6 条得出 0 == 0 // -> true 3.5.比较运算符 如果是对象，就通过 toPrimitive 转换对象 如果是字符串，就通过 unicode 字符索引来比较 4.原型 每个函数都有 prototype 属性，除了 Function.prototype.bind()，该属性指向原型。 每个对象都有 __proto__属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 _proto_ 来访问。 对象可以通过 __proto__来寻找不属于该对象的属性，__proto__将对象连接起来组成了原型链。 5.new 新生成了一个对象 链接到原型 绑定 this 返回新对象 在调用 new 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 new function create() { // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === 'object' ? result : obj } 对于实例对象来说，都是通过 new 产生的，无论是 function Foo() 还是 let a = { b : 1 } 。 对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题。 function Foo() {} // function 就是个语法糖 // 内部等同于 new Function() let a = { b: 1 } // 这个字面量内部也是使用了 new Object() 对于 new 来说，还需要注意下运算符优先级。 function Foo() { return this; } Foo.getName = function () { console.log('1'); }; Foo.prototype.getName = function () { console.log('2'); }; new Foo.getName(); // -> 1 new Foo().getName(); // -> 2 从上图可以看出，new Foo() 的优先级大于 new Foo ，所以对于上述代码来说可以这样划分执行顺序 new (Foo.getName()); (new Foo()).getName(); 对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；对于后者来说，先执行 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。 6.instanceof instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 我们也可以试着实现一下 instanceof function instanceof(left, right) { // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) { if (left === null) return false if (prototype === left) return true left = left.__proto__ } } 7.this this 是很多人会混淆的概念，但是其实他一点都不难，你只需要记住几个规则就可以了。 function foo() { console.log(this.a) } var a = 1 foo() var obj = { a: 2, foo: foo } obj.foo() // 以上两者情况 `this` 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况 // 以下情况是优先级最高的，`this` 只会绑定在 `c` 上，不会被任何方式修改 `this` 指向 var c = new foo() c.a = 3 console.log(c.a) // 还有种就是利用 call，apply，bind 改变 this，这个优先级仅次于 new 以上几种情况明白了，很多代码中的 this 应该就没什么问题了，下面让我们看看箭头函数中的 this function a() { return () => { return () => { console.log(this) } } } console.log(a()()()) 箭头函数其实是没有 this 的，这个函数中的 this 只取决于他外面的第一个不是箭头函数的函数的 this。在这个例子中，因为调用 a 符合前面代码中的第一个情况，所以 this 是 window。并且 this 一旦绑定了上下文，就不会被任何代码改变。 8.执行上下文 当执行 JS 代码时，会产生三种执行上下文 全局执行上下文 函数执行上下文 eval 执行上下文 每个执行上下文中都有三个重要的属性 变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问 作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定了） this var a = 10 function foo(i) { var b = 20 } foo() 对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文。 stack = [ globalContext, fooContext ] 对于全局上下文来说，VO 大概是这样的 globalContext.VO === globe globalContext.VO = { a: undefined, foo: , } 对于函数 foo 来说，VO 不能访问，只能访问到活动对象（AO） fooContext.VO === foo.AO fooContext.AO { i: undefined, b: undefined, arguments: <> } // arguments 是函数独有的对象(箭头函数没有) // 该对象是一个伪数组，有 `length` 属性且可以通过下标访问元素 // 该对象中的 `callee` 属性代表函数本身 // `caller` 属性代表函数的调用者 对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过 [[Scope]] 属性查找上级变量 fooContext.[[Scope]] = [ globalContext.VO ] fooContext.Scope = fooContext.[[Scope]] + fooContext.VO fooContext.Scope = [ fooContext.VO, globalContext.VO ] 接下来让我们看一个老生常谈的例子，var b() // call b console.log(a) // undefined var a = 'Hello world' function b() { console.log('call b') } 想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 VO），JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升 b() // call b second function b() { console.log('call b fist') } function b() { console.log('call b second') } var b = 'Hello world' var 会产生很多错误，所以在 ES6中引入了 let。let 不能在声明前使用，但是这并不是常说的 let 不会提升，let 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使用。 对于非匿名的立即执行函数需要注意以下一点 var foo = 1 (function foo() { foo = 10 console.log(foo) }()) // -> ƒ foo() { foo = 10 ; console.log(foo) } 因为当 JS 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 foo，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。 specialObject = {}; Scope = specialObject + Scope; foo = new FunctionExpression; foo.[[Scope]] = Scope; specialObject.foo = foo; // {DontDelete}, {ReadOnly} delete Scope[0]; // remove specialObject from the front of scope chain 9.闭包 闭包的定义很简单：函数 A 返回了一个函数 B，并且函数 B 中使用了函数 A 的变量，函数 B 就被称为闭包。 function A() { let a = 1 function B() { console.log(a) } return B } 你是否会疑惑，为什么函数 A 已经弹出调用栈了，为什么函数 B 还能引用到函数 A 中的变量。因为函数 A 中的变量这时候是存储在堆上的。现在的 JS 引擎可以通过逃逸分析辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。 经典面试题，循环中使用闭包解决 var 定义函数的问题 for ( var i=1; i 首先因为 setTimeout 是个异步函数，所有会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6。 解决办法两种，第一种使用闭包 for (var i = 1; i 第二种就是使用 setTimeout 的第三个参数 for ( var i=1; i 第三种就是使用 let 定义 i 了 for ( let i=1; i 因为对于 let 来说，他会创建一个块级作用域，相当于 { // 形成块级作用域 let i = 0 { let ii = i setTimeout( function timer() { console.log( ii ); }, i*1000 ); } i++ { let ii = i } i++ { let ii = i } ... } 10.深浅拷贝 这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。 let a = { age: 1, jobs: { first: 'FE' } } let b = JSON.parse(JSON.stringify(a)) a.jobs.first = 'native' console.log(b.jobs.first) // FE 但是该方法也是有局限性的： 会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 let obj = { a: 1, b: { c: 2, d: 3, }, } obj.c = obj.b obj.e = obj.a obj.b.c = obj.c obj.b.d = obj.b obj.b.e = obj.b.c let newObj = JSON.parse(JSON.stringify(obj)) console.log(newObj) 如果你有这么一个循环引用对象，你会发现你不能通过该方法深拷贝 在遇到函数、 undefined 或者 symbol 的时候，该对象也不能正常的序列化 let a = { age: undefined, sex: Symbol('male'), jobs: function() {}, name: 'yck' } let b = JSON.parse(JSON.stringify(a)) console.log(b) // {name: \"yck\"} 你会发现在上述情况中，该方法会忽略掉函数和 undefined 。 但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 lodash 的深拷贝函数。 如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel function structuralClone(obj) { return new Promise(resolve => { const {port1, port2} = new MessageChannel(); port2.onmessage = ev => resolve(ev.data); port1.postMessage(obj); }); } var obj = {a: 1, b: { c: b }} // 注意该方法是异步的 // 可以处理 undefined 和循环引用对象 (async () => { const clone = await structuralClone(obj) })() "},"手撸代码无敌/":{"url":"手撸代码无敌/","title":"手撸代码无敌","keywords":"","body":"手撸代码无敌 new instanceof 防抖和节流 Promise 实现 Generator 实现 Proxy call, apply, bind 不用call和apply方法模拟实现ES5的bind方法 curry Template 封装Ajax和Promise js-tree js复杂判断的更优雅写法 JavaScript优雅的实现方式 函数式代码 js编程黑科技 自己实现简单的shift() 迭代函数与迭代函数的实现 startsWith() endsWith() trim() String.prototype.repeat() String.prototype.padStart() String.prototype.padEnd() 实现一个JSON.stringify 实现一个JSON.parse 实现一个继承 Js深拷贝 封装Ajax和Promise 实现系统Math.max方法 通用进制转换 "},"手撸代码无敌/new.html":{"url":"手撸代码无敌/new.html","title":"new","keywords":"","body":"new A. 新生成了一个对象 链接到原型 绑定 this 返回新对象 在调用 new 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 new function create() { // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === 'object' ? result : obj } 对于实例对象来说，都是通过 new 产生的，无论是 function Foo() 还是 let a = { b : 1 } 。 对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题。 function Foo() {} // function 就是个语法糖 // 内部等同于 new Function() let a = { b: 1 } // 这个字面量内部也是使用了 new Object() 对于 new 来说，还需要注意下运算符优先级。 function Foo() { return this; } Foo.getName = function () { console.log('1'); }; Foo.prototype.getName = function () { console.log('2'); }; new Foo.getName(); // -> 1 new Foo().getName(); // -> 2 从上图可以看出，new Foo() 的优先级大于 new Foo ，所以对于上述代码来说可以这样划分执行顺序 new (Foo.getName()); (new Foo()).getName(); 对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；对于后者来说，先执行 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。 B. new操作符做了这些事： 它创建了一个全新的对象。 它会被执行[[Prototype]]（也就是__proto__）链接。 它使this指向新创建的对象。。 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用将返回该对象引用。 function New(func) { var res = {}; if (func.prototype !== null) { res.__proto__ = func.prototype; } var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); if ((typeof ret === \"object\" || typeof ret === \"function\") && ret !== null) { return ret; } return res; } var obj = New(A, 1, 2); // equals to var obj = new A(1, 2); "},"手撸代码无敌/instanceof.html":{"url":"手撸代码无敌/instanceof.html","title":"instanceof","keywords":"","body":"instanceof instanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 我们也可以试着实现一下 instanceof function instanceof(left, right) { // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) { if (left === null) return false if (prototype === left) return true left = left.__proto__ } } "},"手撸代码无敌/防抖和节流.html":{"url":"手撸代码无敌/防抖和节流.html","title":"防抖和节流","keywords":"","body":"防抖和节流 防抖和节流 防抖 节流 手写防抖(Debouncing)和节流(Throttling) 防抖(Debouncing)实现 节流(Throttling)实现 结合实践 防抖 你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。 这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。 PS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。 我们先来看一个袖珍版的防抖理解一下防抖的实现： // func是用户传入需要防抖的函数 // wait是等待时间 const debounce = (func, wait = 50) => { // 缓存一个定时器id let timer = 0 // 这里返回的函数是每次用户实际调用的防抖函数 // 如果已经设定过定时器了就清空上一次的定时器 // 开始一个新的定时器，延迟执行用户传入的方法 return function(...args) { if (timer) clearTimeout(timer) timer = setTimeout(() => { func.apply(this, args) }, wait) } } // 不难看出如果用户调用该函数的间隔小于wait的情况下，上一次的时间还未到就被清除了，并不会执行函数 这是一个简单版的防抖，但是有缺陷，这个防抖只能在最后调用。一般的防抖会有immediate选项，表示是否立即调用。这两者的区别，举个栗子来说： 例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用延迟执行的防抖函数，它总是在一连串（间隔小于wait的）函数触发之后调用。 例如用户给interviewMap点star的时候，我们希望用户点第一下的时候就去调用接口，并且成功之后改变star按钮的样子，用户就可以立马得到反馈是否star成功了，这个情况适用立即执行的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于wait才会触发。 下面我们来实现一个带有立即执行选项的防抖函数 // 这个是用来获取当前时间戳的 function now() { return +new Date() } /** * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行 * * @param {function} func 回调函数 * @param {number} wait 表示时间窗口的间隔 * @param {boolean} immediate 设置为ture时，是否立即调用函数 * @return {function} 返回客户调用函数 */ function debounce (func, wait = 50, immediate = true) { let timer, context, args // 延迟执行函数 const later = () => setTimeout(() => { // 延迟函数执行完毕，清空缓存的定时器序号 timer = null // 延迟执行的情况下，函数会在延迟函数中执行 // 使用到之前缓存的参数和上下文 if (!immediate) { func.apply(context, args) context = args = null } }, wait) // 这里返回的函数是每次实际调用的函数 return function(...params) { // 如果没有创建延迟执行函数（later），就创建一个 if (!timer) { timer = later() // 如果是立即执行，调用函数 // 否则缓存参数和调用上下文 if (immediate) { func.apply(this, params) } else { context = this args = params } // 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个 // 这样做延迟函数会重新计时 } else { clearTimeout(timer) timer = later() } } } 整体函数实现的不难，总结一下。 对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 null，就可以再次点击了。 对于延时执行函数来说的实现：清除定时器ID，如果是延迟调用就调用函数 节流 防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。 /** * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait * * @param {function} func 回调函数 * @param {number} wait 表示时间窗口的间隔 * @param {object} options 如果想忽略开始函数的的调用，传入{leading: false}。 * 如果想忽略结尾函数的调用，传入{trailing: false} * 两者不能共存，否则函数不能执行 * @return {function} 返回客户调用函数 */ _.throttle = function(func, wait, options) { var context, args, result; var timeout = null; // 之前的时间戳 var previous = 0; // 如果 options 没传则设为空对象 if (!options) options = {}; // 定时器回调函数 var later = function() { // 如果设置了 leading，就将 previous 设为 0 // 用于下面函数的第一个 if 判断 previous = options.leading === false ? 0 : _.now(); // 置空一是为了防止内存泄漏，二是为了下面的定时器判断 timeout = null; result = func.apply(context, args); if (!timeout) context = args = null; }; return function() { // 获得当前时间戳 var now = _.now(); // 首次进入前者肯定为 true // 如果需要第一次不执行函数 // 就将上次时间戳设为当前的 // 这样在接下来计算 remaining 的值时会大于0 if (!previous && options.leading === false) previous = now; // 计算剩余时间 var remaining = wait - (now - previous); context = this; args = arguments; // 如果当前调用已经大于上次调用时间 + wait // 或者用户手动调了时间 // 如果设置了 trailing，只会进入这个条件 // 如果没有设置 leading，那么第一次会进入这个条件 // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了 // 其实还是会进入的，因为定时器的延时 // 并不是准确的时间，很可能你设置了2秒 // 但是他需要2.2秒才触发，这时候就会进入这个条件 if (remaining wait) { // 如果存在定时器就清理掉否则会调用二次回调 if (timeout) { clearTimeout(timeout); timeout = null; } previous = now; result = func.apply(context, args); if (!timeout) context = args = null; } else if (!timeout && options.trailing !== false) { // 判断是否设置了定时器和 trailing // 没有的话就开启一个定时器 // 并且不能不能同时设置 leading 和 trailing timeout = setTimeout(later, remaining); } return result; }; }; 手写防抖(Debouncing)和节流(Throttling) scroll 事件本身会触发页面的重新渲染，同时 scroll 事件的 handler 又会被高频度的触发, 因此事件的 handler 内部不应该有复杂操作，例如 DOM 操作就不应该放在事件处理中。针对此类高频度触发事件问题（例如页面 scroll ，屏幕 resize，监听用户输入等），有两种常用的解决方法，防抖和节流。 防抖(Debouncing)实现 典型例子：限制 鼠标连击 触发。 一个比较好的解释是： 当一次事件发生后，事件处理器要等一定阈值的时间，如果这段时间过去后 再也没有 事件发生，就处理最后一次发生的事件。假设还差 0.01 秒就到达指定时间，这时又来了一个事件，那么之前的等待作废，需要重新再等待指定时间。 // 防抖动函数 function debounce(fn, wait = 50, immediate) { let timer; return function() { if (immediate) { fn.apply(this, arguments); } if (timer) clearTimeout(timer); timer = setTimeout(() => { fn.apply(this, arguments); }, wait); }; } 节流(Throttling)实现 可以理解为事件在一个管道中传输，加上这个节流阀以后，事件的流速就会减慢。实际上这个函数的作用就是如此，它可以将一个函数的调用频率限制在一定阈值内，例如 1s，那么 1s 内这个函数一定不会被调用两次 简单的节流函数: function throttle(fn, wait) { let prev = new Date(); return function() { const args = arguments; const now = new Date(); if (now - prev > wait) { fn.apply(this, args); prev = new Date(); } } } 结合实践 通过第三个参数来切换模式。 const throttle = function(fn, delay, isDebounce) { let timer let lastCall = 0 return function (...args) { if (isDebounce) { if (timer) clearTimeout(timer) timer = setTimeout(() => { fn(...args) }, delay) } else { const now = new Date().getTime() if (now - lastCall "},"手撸代码无敌/Proxy.html":{"url":"手撸代码无敌/Proxy.html","title":"Proxy","keywords":"","body":"Proxy Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作 let p = new Proxy(target, handler); // `target` 代表需要添加代理的对象 // `handler` 用来自定义对象中的操作 可以很方便的使用 Proxy 来实现一个数据绑定和监听 let onWatch = (obj, setBind, getLogger) => { let handler = { get(target, property, receiver) { getLogger(target, property) return Reflect.get(target, property, receiver); }, set(target, property, value, receiver) { setBind(value); return Reflect.set(target, property, value); } }; return new Proxy(obj, handler); }; let obj = { a: 1 } let value let p = onWatch(obj, (v) => { value = v }, (target, property) => { console.log(`Get '${property}' = ${target[property]}`); }) p.a = 2 // bind `value` to `2` p.a // -> Get 'a' = 2 "},"手撸代码无敌/Promise实现.html":{"url":"手撸代码无敌/Promise实现.html","title":"Promise 实现","keywords":"","body":"Promise 实现 Promise 实现 根据 Promise / A+ 规范来实现 实现二 面试够用版 大厂专供版 Promise 是 ES6 新增的语法，解决了回调地狱的问题。 可以把 Promise 看成一个状态机。初始是 pending 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 或者 rejected 状态，状态一旦改变就不能再次变化。 then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定除了 pending 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 then 调用就失去意义了。 对于 then 来说，本质上可以把它看成是 flatMap 根据 Promise / A+ 规范来实现 // 三种状态 const PENDING = \"pending\"; const RESOLVED = \"resolved\"; const REJECTED = \"rejected\"; // promise 接收一个函数参数，该函数会立即执行 function MyPromise(fn) { let _this = this; _this.currentState = PENDING; _this.value = undefined; // 用于保存 then 中的回调，只有当 promise // 状态为 pending 时才会缓存，并且每个实例至多缓存一个 _this.resolvedCallbacks = []; _this.rejectedCallbacks = []; _this.resolve = function (value) { if (value instanceof MyPromise) { // 如果 value 是个 Promise，递归执行 return value.then(_this.resolve, _this.reject) } setTimeout(() => { // 异步执行，保证执行顺序 if (_this.currentState === PENDING) { _this.currentState = RESOLVED; _this.value = value; _this.resolvedCallbacks.forEach(cb => cb()); } }) }; _this.reject = function (reason) { setTimeout(() => { // 异步执行，保证执行顺序 if (_this.currentState === PENDING) { _this.currentState = REJECTED; _this.value = reason; _this.rejectedCallbacks.forEach(cb => cb()); } }) } // 用于解决以下问题 // new Promise(() => throw Error('error)) try { fn(_this.resolve, _this.reject); } catch (e) { _this.reject(e); } } MyPromise.prototype.then = function (onResolved, onRejected) { var self = this; // 规范 2.2.7，then 必须返回一个新的 promise var promise2; // 规范 2.2.onResolved 和 onRejected 都为可选参数 // 如果类型不是函数需要忽略，同时也实现了透传 // Promise.resolve(4).then().then((value) => console.log(value)) onResolved = typeof onResolved === 'function' ? onResolved : v => v; onRejected = typeof onRejected === 'function' ? onRejected : r => throw r; if (self.currentState === RESOLVED) { return (promise2 = new MyPromise(function (resolve, reject) { // 规范 2.2.4，保证 onFulfilled，onRjected 异步执行 // 所以用了 setTimeout 包裹下 setTimeout(function () { try { var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (reason) { reject(reason); } }); })); } if (self.currentState === REJECTED) { return (promise2 = new MyPromise(function (resolve, reject) { setTimeout(function () { // 异步执行onRejected try { var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (reason) { reject(reason); } }); })); } if (self.currentState === PENDING) { return (promise2 = new MyPromise(function (resolve, reject) { self.resolvedCallbacks.push(function () { // 考虑到可能会有报错，所以使用 try/catch 包裹 try { var x = onResolved(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (r) { reject(r); } }); self.rejectedCallbacks.push(function () { try { var x = onRejected(self.value); resolutionProcedure(promise2, x, resolve, reject); } catch (r) { reject(r); } }); })); } }; // 规范 2.3 function resolutionProcedure(promise2, x, resolve, reject) { // 规范 2.3.1，x 不能和 promise2 相同，避免循环引用 if (promise2 === x) { return reject(new TypeError(\"Error\")); } // 规范 2.3.2 // 如果 x 为 Promise，状态为 pending 需要继续等待否则执行 if (x instanceof MyPromise) { if (x.currentState === PENDING) { x.then(function (value) { // 再次调用该函数是为了确认 x resolve 的 // 参数是什么类型，如果是基本类型就再次 resolve // 把值传给下个 then resolutionProcedure(promise2, value, resolve, reject); }, reject); } else { x.then(resolve, reject); } return; } // 规范 2.3.3.3.3 // reject 或者 resolve 其中一个执行过得话，忽略其他的 let called = false; // 规范 2.3.3，判断 x 是否为对象或者函数 if (x !== null && (typeof x === \"object\" || typeof x === \"function\")) { // 规范 2.3.3.2，如果不能取出 then，就 reject try { // 规范 2.3.3.1 let then = x.then; // 如果 then 是函数，调用 x.then if (typeof then === \"function\") { // 规范 2.3.3.3 then.call( x, y => { if (called) return; called = true; // 规范 2.3.3.3.1 resolutionProcedure(promise2, y, resolve, reject); }, e => { if (called) return; called = true; reject(e); } ); } else { // 规范 2.3.3.4 resolve(x); } } catch (e) { if (called) return; called = true; reject(e); } } else { // 规范 2.3.4，x 为基本类型 resolve(x); } } 实现二 我们来过一遍Promise/A+规范： 三种状态 pending | fulfilled(resolved) | rejected 当处于pending状态的时候，可以转移到fulfilled(resolved)或者rejected状态 当处于fulfilled(resolved)状态或者rejected状态的时候，就不可变。 必须有一个then异步执行方法，then接受两个参数且必须返回一个promise： // onFulfilled 用来接收promise成功的值 // onRejected 用来接收promise失败的原因 promise1=promise.then(onFulfilled, onRejected); 来回顾下Promise用法： var promise = new Promise((resolve, reject) => { if (操作成功) { resolve(value); } else { reject(error); } }); promise.then( function(value) { // success }, function(value) { // failure } ); 面试够用版 function myPromise(constructor) { let self = this; self.status = \"pending\"; //定义状态改变前的初始状态 self.value = undefined; //定义状态为resolved的时候的状态 self.reason = undefined; //定义状态为rejected的时候的状态 function resolve(value) { //两个===\"pending\"，保证了状态的改变是不可逆的 if (self.status === \"pending\") { self.value = value; self.status = \"resolved\"; } } function reject(reason) { //两个===\"pending\"，保证了状态的改变是不可逆的 if (self.status === \"pending\") { self.reason = reason; self.status = \"rejected\"; } } //捕获构造异常 try { constructor(resolve, reject); } catch (e) { reject(e); } } 同时，需要在myPromise的原型上定义链式调用的then方法： myPromise.prototype.then = function(onFullfilled, onRejected) { let self = this; switch (self.status) { case \"resolved\": onFullfilled(self.value); break; case \"rejected\": onRejected(self.reason); break; default: } }; 测试一下： var p=new myPromise(function(resolve,reject){resolve(1)}); p.then(function(x){console.log(x)}) //输出1 大厂专供版 const PENDING = \"pending\"; const FULFILLED = \"fulfilled\"; const REJECTED = \"rejected\"; function Promise(excutor) { let that = this; // 缓存当前promise实例对象 that.status = PENDING; // 初始状态 that.value = undefined; // fulfilled状态时 返回的信息 that.reason = undefined; // rejected状态时 拒绝的原因 that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数 that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数 function resolve(value) { // value成功态时接收的终值 if (value instanceof Promise) { return value.then(resolve, reject); } // 实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。 setTimeout(() => { // 调用resolve 回调对应onFulfilled函数 if (that.status === PENDING) { // 只能由pending状态 => fulfilled状态 (避免调用多次resolve reject) that.status = FULFILLED; that.value = value; that.onFulfilledCallbacks.forEach(cb => cb(that.value)); } }); } function reject(reason) { // reason失败态时接收的拒因 setTimeout(() => { // 调用reject 回调对应onRejected函数 if (that.status === PENDING) { // 只能由pending状态 => rejected状态 (避免调用多次resolve reject) that.status = REJECTED; that.reason = reason; that.onRejectedCallbacks.forEach(cb => cb(that.reason)); } }); } // 捕获在excutor执行器中抛出的异常 // new Promise((resolve, reject) => { // throw new Error('error in excutor') // }) try { excutor(resolve, reject); } catch (e) { reject(e); } } Promise.prototype.then = function(onFulfilled, onRejected) { const that = this; let newPromise; // 处理参数默认值 保证参数后续能够继续执行 onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : value => value; onRejected = typeof onRejected === \"function\" ? onRejected : reason => { throw reason; }; if (that.status === FULFILLED) { // 成功态 return (newPromise = new Promise((resolve, reject) => { setTimeout(() => { try { let x = onFulfilled(that.value); resolvePromise(newPromise, x, resolve, reject); // 新的promise resolve 上一个onFulfilled的返回值 } catch (e) { reject(e); // 捕获前面onFulfilled中抛出的异常 then(onFulfilled, onRejected); } }); })); } if (that.status === REJECTED) { // 失败态 return (newPromise = new Promise((resolve, reject) => { setTimeout(() => { try { let x = onRejected(that.reason); resolvePromise(newPromise, x, resolve, reject); } catch (e) { reject(e); } }); })); } if (that.status === PENDING) { // 等待态 // 当异步调用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中 return (newPromise = new Promise((resolve, reject) => { that.onFulfilledCallbacks.push(value => { try { let x = onFulfilled(value); resolvePromise(newPromise, x, resolve, reject); } catch (e) { reject(e); } }); that.onRejectedCallbacks.push(reason => { try { let x = onRejected(reason); resolvePromise(newPromise, x, resolve, reject); } catch (e) { reject(e); } }); })); } }; "},"手撸代码无敌/Generator实现.html":{"url":"手撸代码无敌/Generator实现.html","title":"Generator实现","keywords":"","body":"Generator 实现 Generator 是 ES6 中新增的语法，和 Promise 一样，都可以用来异步编程 // 使用 * 表示这是一个 Generator 函数 // 内部可以通过 yield 暂停代码 // 通过调用 next 恢复执行 function* test() { let a = 1 + 2; yield 2; yield 3; } let b = test(); console.log(b.next()); // > { value: 2, done: false } console.log(b.next()); // > { value: 3, done: false } console.log(b.next()); // > { value: undefined, done: true } 从以上代码可以发现，加上 * 的函数执行后拥有了 next 函数，也就是说函数执行后返回了一个对象。每次调用 next 函数可以继续执行被暂停的代码。以下是 Generator 函数的简单实现 // cb 也就是编译过的 test 函数 function generator(cb) { return (function() { var object = { next: 0, stop: function() {} }; return { next: function() { var ret = cb(object); if (ret === undefined) return { value: undefined, done: true }; return { value: ret, done: false }; } }; })(); } // 如果你使用 babel 编译后可以发现 test 函数变成了这样 function test() { var a; return generator(function(_context) { while (1) { switch ((_context.prev = _context.next)) { // 可以发现通过 yield 将代码分割成几块 // 每次执行 next 函数就执行一块代码 // 并且表明下次需要执行哪块代码 case 0: a = 1 + 2; _context.next = 4; return 2; case 4: _context.next = 6; return 3; // 执行完毕 case 6: case \"end\": return _context.stop(); } } }); } "},"手撸代码无敌/call-apply-bind.html":{"url":"手撸代码无敌/call-apply-bind.html","title":"call, apply, bind","keywords":"","body":"call, apply, bind call, apply, bind 区别 首先说下前两者的区别。 call 和 apply 都是为了解决改变 this 的指向。作用都是相同的，只是传参的方式不同。 除了第一个参数外，call 可以接收一个参数列表，apply 只接受一个参数数组。 let a = { value: 1 } function getValue(name, age) { console.log(name) console.log(age) console.log(this.value) } getValue.call(a, 'yck', '24') getValue.apply(a, ['yck', '24']) 模拟实现 call 和 apply 可以从以下几点来考虑如何实现 不传入第一个参数，那么默认为 window 改变了 this 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？ call Function.prototype.myCall = function (context) { var context = context || window // 给 context 添加一个属性 // getValue.call(a, 'yck', '24') => a.fn = getValue context.fn = this // 将 context 后面的参数取出来 var args = [...arguments].slice(1) // getValue.call(a, 'yck', '24') => a.fn('yck', '24') var result = context.fn(...args) // 删除 fn delete context.fn return result } apply Function.prototype.myApply = function (context) { var context = context || window context.fn = this var result // 需要判断是否存储第二个参数 // 如果存在，就将第二个参数展开 if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } bind bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化。 Function.prototype.myBind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error') } var _this = this var args = [...arguments].slice(1) // 返回一个函数 return function F() { // 因为返回了一个函数，我们可以 new F()，所以需要判断 if (this instanceof F) { return new _this(...args, ...arguments) } return _this.apply(context, args.concat(...arguments)) } } "},"手撸代码无敌/不用call和apply方法模拟实现ES5的bind方法.html":{"url":"手撸代码无敌/不用call和apply方法模拟实现ES5的bind方法.html","title":"不用call和apply方法模拟实现ES5的bind方法","keywords":"","body":"1. 不用call和apply方法模拟实现ES5的bind方法 1. 不用call和apply方法模拟实现ES5的bind方法 1.1 什么是call和apply方法 总结一句话介绍call和apply 1.2 分析call和apply的原理 1.3 实现apply方法 1.3.1 模拟实现第一步 1.3.2 模拟实现第二步 1.3.3 模拟实现第三步 1.3.4 模拟实现第四步 1.3.5 模拟实现第五步 1.4 实现Call方法 call完整实现 1.5 实现bind方法 1.5.1 bind语法： 1.5.2 用一句话总结bind的用法 1.5.3 bind在实际中的应用 1.5.4 bind初级实现 1.5.4.1 初级实现的加分项 1.5.4.2 柯里化（curring）实现 1.5.4.3 构造函数场景下的兼容 1.5.4.4 更严谨的做法 最终实现 ------------- 2. apply 实现 bind 2.1 简单实现 2.2 完整实现 说明 2.3 bind实现2 2.3.1 [].shift.call(arguments) 的含义 2.3.2 返回函数 来自朋友去某信用卡管家的做的一道面试题，用原生JavaScript模拟ES5的bind方法，不准用call和apply方法。 简单粗暴地来说，call，apply，bind是用于绑定this指向的 1.1 什么是call和apply方法 我们单独看看ECMAScript规范对apply的定义，看个大概就行： Function.prototype.apply (thisArg, argArray) 通过定义简单说一下call和apply方法，他们就是参数不同，作用基本相同 每个函数都包含两个非继承而来的方法：apply()和call()。 他们的用途相同，都是在特定的作用域中调用函数。 接收参数方面不同，apply()接收两个参数，一个是函数运行的作用域(this)，另一个是参数数组。 call()方法第一个参数与apply()方法相同，但传递给函数的参数必须列举出来。 简单的demo var jawil = { name: \"jawil\", sayHello: function (age) { console.log(\"hello, i am \", this.name + \" \" + age + \" years old\"); } }; var lulin = { name: \"lulin\", }; jawil.sayHello(24); // hello, i am jawil 24 years old 然后看看使用apply和call之后的输出： jawil.sayHello.call(lulin, 24);// hello, i am lulin 24 years old jawil.sayHello.apply(lulin, [24]);// hello, i am lulin 24 years old 总结一句话介绍call和apply call()方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法。 apply()方法在使用一个指定的this值和参数值必须是数组类型的前提下调用某个函数或方法。 1.2 分析call和apply的原理 注意红色框中的部分，f.call(o)其原理就是先通过 o.m = f 将 f作为o的某个临时属性m存储，然后执行m，执行完毕后将m属性删除。 jawil.sayHello.call(lulin, 24)执行的过程： // 第一步 lulin.fn = jawil.sayHello // 第二步 lulin.fn() // 第三步 delete lulin.fn 1.3 实现apply方法 1.3.1 模拟实现第一步 // 第一版 Function.prototype.applyOne = function(context) { // 首先要获取调用call的函数，用this可以获取 context.fn = this; context.fn(); delete context.fn; } //简单写一个不带参数的demo var jawil = { name: \"jawil\", sayHello: function (age) { console.log(this.name); } }; var lulin = { name: \"lulin\", }; //看看结果： jawil.sayHello.applyOne(lulin)//lulin 1.3.2 模拟实现第二步 最一开始也讲了，apply函数还能给定参数执行函数。举个例子： Function.prototype.applyTwo = function(context) { var args = arguments[1]; //获取传入的数组参数 context.fn = this; //假想context对象预先不存在名为fn的属性 var fnStr = 'context.fn('; for (var i = 0; i 1.3.3 模拟实现第三步 其实还有几个小地方需要注意： A. this参数可以传null或者不传，当为null的时候，视为指向window // demo1 var name = 'jawil'; function sayHello() { console.log(this.name); } sayHello.apply(null); // 'jawil' // demo2 var name = 'jawil'; function sayHello() { console.log(this.name); } sayHello.apply(); // 'jawil' B. 函数是可以有返回值的 var obj = { name: 'jawil' } function sayHello(age) { return { name: this.name, age: age } } console.log(sayHello.apply(obj,[24]));// {name: \"jawil\", age: 24} 此时的第三版apply模拟方法 //原生JavaScript封装apply方法，第三版 Function.prototype.applyThree = function(context) { var context = context || window var args = arguments[1] //获取传入的数组参数 context.fn = this //假想context对象预先不存在名为fn的属性 if (args == void 0) { //没有传入参数直接执行 return context.fn() } var fnStr = 'context.fn(' for (var i = 0; i 1.3.4 模拟实现第四步 其实一开始就埋下了一个隐患，我们看看这段代码： Function.prototype.applyThree = function(context) { var context = context || window var args = arguments[1] //获取传入的数组参数 context.fn = this //假想context对象预先不存在名为fn的属性 ...... } 就是这句话， context.fn = this //假想context对象预先不存在名为fn的属性,这就是一开始的隐患,我们只是假设，但是并不能防止contenx对象一开始就没有这个属性，要想做到完美，就要保证这个context.fn中的fn的唯一性。 于是自然而然的想到了强大的ES6 Symbol() 看看下面这个栗子🌰： var a = {}; var name = Symbol(); a.name = 'jawil'; a[name] = 'lulin'; console.log(a.name,a[name]); //jawil,lulin Symbol值作为属性名时，该属性还是公开属性，不是私有属性。 这个有点类似于java中的protected属性（protected和private的区别：在类的外部都是不可以访问的，在类内的子类可以继承protected不可以继承private） 但是这里的Symbol在类外部也是可以访问的，只是不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。但有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。 看看第四版的实现demo，想必大家了解上面知识已经猜得到怎么写了，很简单。 直接加个var fn = Symbol()就行了，，， //原生JavaScript封装apply方法，第四版 Function.prototype.applyFour = function(context) { var context = context || window var args = arguments[1] //获取传入的数组参数 var fn = Symbol() context[fn] = this //假想context对象预先不存在名为fn的属性 if (args == void 0) { //没有传入参数直接执行 return context[fn]() } var fnStr = 'context[fn](' for (var i = 0; i 1.3.5 模拟实现第五步 ES5 没有 Sybmol，属性名称只可能是一个字符串，如果我们能做到这个字符串不可预料，那么就基本达到目标。要达到不可预期，一个随机数基本上就解决了。 //简单模拟Symbol属性 function jawilSymbol(obj) { var unique_proper = \"00\" + Math.random(); if (obj.hasOwnProperty(unique_proper)) { arguments.callee(obj)//如果obj已经有了这个属性，递归调用，直到没有这个属性 } else { return unique_proper; } } //原生JavaScript封装apply方法，第五版 Function.prototype.applyFive = function(context) { var context = context || window var args = arguments[1] //获取传入的数组参数 var fn = jawilSymbol(context); context[fn] = this //假想context对象预先不存在名为fn的属性 if (args == void 0) { //没有传入参数直接执行 return context[fn]() } var fnStr = 'context[fn](' for (var i = 0; i 1.4 实现Call方法 //原生JavaScript封装call方法 Function.prototype.callOne = function(context) { return this.applyFive(([].shift.applyFive(arguments), arguments) //巧妙地运用上面已经实现的applyFive函数 } call完整实现 Function.prototype.applyFive = function(context) { var context = context || window var args = arguments[1] //获取传入的数组参数 var fn = Symbol(); context[fn] = this //假想context对象预先不存在名为fn的属性 if (args == void 0) { //没有传入参数直接执行 return context[fn]() } var fnStr = 'context[fn](' for (var i = 0; i 1.5 实现bind方法 bind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind() 的第一个参数, 它的参数是 bind() 的其他参数和其原本的参数，bind返回的绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的this值被忽略，同时调用时的参数被提供给模拟函数。。 1.5.1 bind语法： fun.bind(thisArg[, arg1[, arg2[, ...]]]) bind方法传递给调用函数的参数可以逐个列出，也可以写在数组中。bind方法与call、apply最大的不同就是前者返回一个绑定上下文的函数，而后两者是直接执行了函数。由于这个原因，上面的代码也可以这样写: jawil.sayHello.bind(lulin)(24); //hello, i am lulin 24 years old jawil.sayHello.bind(lulin)([24]); //hello, i am lulin 24 years old bind方法还可以这样写 fn.bind(obj, arg1)(arg2) 1.5.2 用一句话总结bind的用法 该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入bind方法的第一个参数作为this，传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。 1.5.3 bind在实际中的应用 实际使用中我们经常会碰到这样的问题： function Person(name){ this.nickname = name; this.distractedGreeting = function() { setTimeout(function(){ console.log(\"Hello, my name is \" + this.nickname); }, 500); } } var alice = new Person('jawil'); alice.distractedGreeting(); //Hello, my name is undefined 这个时候输出的this.nickname是undefined，原因是this指向是在运行函数时确定的，而不是定义函数时候确定的，再因为setTimeout在全局环境下执行，所以this指向setTimeout的上下文：window。 以前解决这个问题的办法通常是缓存this，例如： function Person(name){ this.nickname = name; this.distractedGreeting = function() { var self = this; // 使用bind。上面的例子中被更新为 function Person(name){ this.nickname = name; this.distractedGreeting = function() { setTimeout(function(){ console.log(\"Hello, my name is \" + this.nickname); }.bind(this), 500); // 1.5.4 bind初级实现 Function.prototype.bind = function (context) { var that = this; var argsArray = Array.prototype.slice.callOne(arguments); return function () { return that.applyFive(context, argsArray.slice(1)) } } 基本原理是使用apply进行模拟。函数体内的this，就是需要绑定this的实例函数，或者说是原函数。最后我们使用apply来进行参数（context）绑定，并返回。 同时，将第一个参数（context）以外的其他参数，作为提供给原函数的预设参数，这也是基本的“颗粒化（curring）”基础。 1.5.4.1 初级实现的加分项 上面的实现（包括后面的实现），其实是一个典型的“Monkey patching(猴子补丁)”，即“给内置对象扩展方法”。所以，如果面试者能进行一下“嗅探”，进行兼容处理，就是锦上添花了。 Function.prototype.bind = Function.prototype.bind || function (context) { ... } 1.5.4.2 柯里化（curring）实现 上述的实现方式中，我们返回的参数列表里包含：atgsArray.slice(1)，他的问题在于存在预置参数功能丢失的现象。 想象我们返回的绑定函数中，如果想实现预设传参（就像bind所实现的那样），就面临尴尬的局面。真正实现颗粒化的“完美方式”是： Function.prototype.bind = Function.prototype.bind || function (context) { var that = this; var args = Array.prototype.slice.callOne(arguments, 1); return function () { var innerArgs = Array.prototype.slice.callOne(arguments); var finalArgs = args.concat(innerArgs); return that.applyFive(context, finalArgs); } } bind返回的函数如果作为构造函数，搭配new关键字出现的话，我们的绑定this就需要“被忽略”。 1.5.4.3 构造函数场景下的兼容 有了上边的讲解，不难理解需要兼容构造函数场景的实现： Function.prototype.bind = Function.prototype.bind || function (context) { var that = this; var args = Array.prototype.slice.callOne(arguments, 1); var F = function () {}; F.prototype = this.prototype; var bound = function () { var innerArgs = Array.prototype.slice.callOne(arguments); var finalArgs = args.concat(innerArgs); return that.apply(this instanceof F ? this : context || this, finalArgs); } bound.prototype = new F(); return bound; } 1.5.4.4 更严谨的做法 我们需要调用bind方法的一定要是一个函数，所以可以在函数体内做一个判断： if (typeof this !== \"function\") { throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\"); } 最终实现 //简单模拟Symbol属性 function jawilSymbol(obj) { var unique_proper = \"00\" + Math.random(); if (obj.hasOwnProperty(unique_proper)) { arguments.callee(obj)//如果obj已经有了这个属性，递归调用，直到没有这个属性 } else { return unique_proper; } } //原生JavaScript封装apply方法，第五版 Function.prototype.applyFive = function(context) { var context = context || window var args = arguments[1] //获取传入的数组参数 var fn = jawilSymbol(context); context[fn] = this //假想context对象预先不存在名为fn的属性 if (args == void 0) { //没有传入参数直接执行 return context[fn]() } var fnStr = 'context[fn](' for (var i = 0; i 测试demo var obj = { name: 'jawil' } function sayHello(age) { return { name: this.name, age: age } } console.log(sayHello.bind(obj,24)());// 完美输出{name: \"jawil\", age: 24} ------------- 2. apply 实现 bind 2.1 简单实现 // 将bind方法的参数提取出来拼接返回的闭包函数中 Function.prototype.bind = function(context){ var that = this; var args = Array.prototype.slice.call(arguments, 1); return function() { // 预设参数一定是args在前拼接 return that.apply(context, args.concat(Array.prototype.slice.call(arguments))); } }; 2.2 完整实现 通过设置一个中转构造函数F，使绑定后的函数与调用bind()的函数处于同一原型链上，用new操作符调用绑定后的函数，返回的对象也能正常使用instanceof，因此这是最严谨的bind()实现。 Function.prototype.bind = function (context) { if (typeof this !== \"function\") { throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\"); } var args = Array.prototype.slice.call(arguments, 1), that = this, Fn = function () {}, fBound = function () { // this instanceof Fn === true时,说明返回的 Fn 被当做new的构造函数调用 return that.apply( this instanceof Fn && context ? this : context || window, // 获取调用时(fBound)的传参.bind 返回的函数入参往往是这么传递的 args.concat(Array.prototype.slice.call(arguments)) ); }; Fn.prototype = this.prototype; fBound.prototype = new Fn(); return fBound; }; 说明 第一个是参数，agruments的使用 var args = Array.prototype.slice.call(arguments, 1), 这里是将bind函数的参数数组取出来，第一个参数不要（就是不要context）也就是要被绑定方法的那个对象， 第二个是 args.concat(Array.prototype.slice.call(arguments))); 这里是用了数组的方法，把参数插在参数数组后面，要注意，这个函数是要被return 出去然后执行的，他的参数数组是return出去的那个fBound函数的参数数组，所以上下两个参数数组是不一样的，有点像柯里化。 第二个是上下文，在其中上下文的变化比较难理解，bind函数主要就是为了绑定上下文来使用的 that = this 这里是保存了对象的上下文，紧接着下面的apply方法让要被绑定的那个对象可以使用该上下文 Fn.prototype = this.prototype; fBound.prototype = new Fn(); 这里是以Fn为中介把this.prototype这个原对象的属性给fBound，确保fBound是在定义的时候的那个上下文里面执行。本来 bound.prototype = self.prototype 就可以将原属性集成过来了，但是这样两个对象属性都指向同一个地方，修改 bound.prototype 将会造成self.prototype 也发生改变，这样并不是我们的本意。所以通过一个空函数 nop 做中转，能有效的防止这种情况的发生。 2.3 bind实现2 if (!Function.prototype.bind) { Function.prototype.bind = function () { var self = this, // 保存原函数 context = [].shift.call(arguments), // 保存需要绑定的this上下文 args = [].slice.call(arguments); // 剩余的参数转为数组 return function () { // 返回一个新函数 self.apply(context,[].concat.call(args, [].slice.call(arguments))); } } } 2.3.1 [].shift.call(arguments) 的含义 [].shift 等同于 Array.prototype.shift Array.prototype.shift === [].shift 两者其实是同一个函数，只是调用的方式存在差异，一个是通过原型的方式直接在类上调用；一个是通过实例化，继承过来，然后再调用。 [].slice.call([\"a\", \"b\"]); //[\"a\", \"b\"] Array.from([\"a\", \"b\"]).slice(); //[\"a\", \"b\"] context = [].shift.call(arguments) 这一句就是把参数中的第一个剪切出来，赋给 context，那么也就相当于起到了将 参数中的 this 保存的目的。 args = [].slice.call(arguments); 这一句，将除了 this 上下文的所有参数，传给了 args ，以备后来使用。 2.3.2 返回函数 return function () { // 返回一个新函数 self.apply(context,[].concat.call(args, [].slice.call(arguments))); } 因为bind 绑定了上下文，因此 self.apply 的第一个参数，是之前我们保存的 context。接下来，我们将 bind 的其余参数和调用bind后返回的函数在执行的过程中接收的参数进行拼接，作为一个数组传入apply的第二个参数中去。这就完美的实现了 bind 函数的功能， "},"手撸代码无敌/curry.html":{"url":"手撸代码无敌/curry.html","title":"curry","keywords":"","body":"深入详解函数的柯里化 深入详解函数的柯里化 简单实现 柯里化的题 柯里化通用式 柯里化与bind 柯里化的特点 -------- 通用版 ES6骚写法 柯里化是指这样一个函数(假设叫做createCurry)，他接收函数A作为参数，运行后能够返回一个新的函数。并且这个新的函数能够处理函数A的剩余参数。 简单实现 // 简单实现，参数只能从右到左传递 function createCurry(func, args) { var arity = func.length; var args = args || []; return function() { var _args = [].slice.call(arguments); [].push.apply(_args, args); // 如果参数个数小于最初的func.length，则递归调用，继续收集参数 if (_args.length 柯里化的题 // 实现一个add方法，使计算结果能够满足如下预期： add(1)(2)(3) = 6; add(1, 2, 3)(4) = 10; add(1)(2)(3)(4)(5) = 15; 实现 function add() { // 第一次执行时，定义一个数组专门用来存储所有的参数 var _args = [].slice.call(arguments); // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值 var adder = function () { var _adder = function() { // [].push.apply(_args, [].slice.call(arguments)); _args.push(...arguments); return _adder; }; // 利用隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回 _adder.toString = function () { return _args.reduce(function (a, b) { return a + b; }); } return _adder; } // return adder.apply(null, _args); return adder(..._args); } var a = add(1)(2)(3)(4); // f 10 var b = add(1, 2, 3, 4); // f 10 var c = add(1, 2)(3, 4); // f 10 var d = add(1, 2, 3)(4); // f 10 // 可以利用隐式转换的特性参与计算 console.log(a + 10); // 20 console.log(b + 20); // 30 console.log(c + 30); // 40 console.log(d + 40); // 50 // 也可以继续传入参数，得到的结果再次利用隐式转换参与计算 console.log(a(10) + 100); // 120 console.log(b(10) + 100); // 120 console.log(c(10) + 100); // 120 console.log(d(10) + 100); // 120 柯里化通用式 var currying = function(fn) { var args = [].slice.call(arguments, 1); return function() { // 主要还是收集所有需要的参数到一个数组中，便于统一计算 var _args = args.concat([].slice.call(arguments)); return fn.apply(null, _args); } } var sum = currying(function() { var args = [].slice.call(arguments); return args.reduce(function(a, b) { return a + b; }) }, 10) console.log(sum(20, 10)); // 40 console.log(sum(10, 5)); // 25 柯里化与bind Object.prototype.bind = function(context) { var _this = this; var args = [].slice.call(arguments, 1); return function() { return _this.apply(context, args) } } 柯里化的特点 接收单一参数，将更多的参数通过回调函数来搞定 返回一个新函数，用于处理所有的想要传入的参数； 需要利用call/apply与arguments对象收集参数； 返回的这个函数正是用来处理收集起来的参数。 -------- 通用版 function multi() { var args = Array.prototype.slice.call(arguments); var fn = function() { var newArgs = args.concat(Array.prototype.slice.call(arguments)); return multi.apply(this, newArgs); } fn.toString = function() { return args.reduce(function(a, b) { return a * b; }) } return fn; } function multiFn(a, b, c) { return a * b * c; } var multi = curry(multiFn); multi(2)(3)(4); multi(2,3,4); multi(2)(3,4); multi(2,3)(4); ES6骚写法 const curry = (fn, arr = []) => (...args) => ( arg => arg.length === fn.length ? fn(...arg) : curry(fn, arg) )([...arr, ...args]) let curryTest=curry((a,b,c,d)=>a+b+c+d) curryTest(1,2,3)(4) //返回10 curryTest(1,2)(4)(3) //返回10 curryTest(1,2)(3,4) //返回10 "},"手撸代码无敌/Template.html":{"url":"手撸代码无敌/Template.html","title":"Template","keywords":"","body":"一行代码实现一个简单的模板字符串替换 一行代码实现一个简单的模板字符串替换 起始 实现 1. 基本实现(有缺陷) 2. 基本实现 3. 基本实现 +1 4. 实现完整 for/in 循环获取 obj 的 key 值 、 Object.key()、 Object.getOwnPropertyNames()、 Reflect.ownKeys()区别 demo 理解 最后实现 MDN str.replace(regexp|substr, newSubStr|function) 实现code 分析 起始 主要是思路，可以使用 ES6 语法模拟 ES6的模板字符串的这个功能。后端返回的一般都是 JSON 的数据格式，所以我们按照下面的规则进行模拟。 需求描述 实现一个 render(template, context) 方法，将 template 中的占位符用 context 填充。 要求： 不需要有控制流成分（如 循环、条件 等等），只要有变量替换功能即可级联的变量也可以展开被转义的的分隔符 { 和 } 不应该被渲染，分隔符与变量之间允许有空白字符 var obj = {name:\"二月\",age:\"15\"}; var str = \"{{name}}很厉害，才{{age}}岁\"; // 输出：二月很厉害，才15岁。 实现 1. 基本实现(有缺陷) let str = \"{{name}}很厉害，才{{age}}岁\" let obj = {name: '二月', age: 15} function test(str, obj){ let _s = str.replace(/\\{\\{(\\w+)\\}\\}/g, '$1') let result for(let k in obj) { _s = _s.replace(new RegExp(k, 'g'), obj[k]) } return _s } const s = test(str, obj) 最基本的是实现了，但是代码还是有很多问题没考虑到，首先 Object 的 key 值不一定只是 \\w， 还有就是如果字符串是这种的： let str = \"{{name}}很name厉害，才{{age}}岁\"` 会输出 ：二月很厉害二月害，才15岁 思路 代码的作用目标是 str，先用正则匹配出 和，然后用分组获取括号的 name,age,最后用 replace 方法把 和 替换成 name 和 age，最后字符串就成了 name很name厉害，才age岁，最后 for in 循环的时候才导致一起都被替换掉了。 用 for in 循环完全没必要，能不用 for in 尽量不要用 for in，for in 会遍历自身以及原型链所有的属性。 2. 基本实现 var str = \"{{name}}很厉害，才{{age}}岁\"; var str2 = \"{{name}}很厉name害，才{{age}}岁{{name}}\"; var obj = {name: '周杰伦', age: 15}; function fun(str, obj) { var arr; arr = str.match(/{{[a-zA-Z\\d]+}}/g); for(var i=0;i 3. 基本实现 +1 function a(str, obj) { var str1 = str; for (var key in obj) { var re = new RegExp(\"{{\" + key + \"}}\", \"g\"); str1 = str1.replace(re, obj[key]); } console.log(str1); } const str = \"{{name}}很厉name害{{name}}，才{{age}}岁\"; const obj = { name: \"jawil\", age: \"15\" }; a(str, obj); 把 obj 的 key 值遍历，然后拼成 ，最后用 `obj[key]` 也就是 `value` 把 整个给替换了 4. 实现完整 function parseString(str, obj) { Object.keys(obj).forEach(key => { str = str.replace(new RegExp(`{{${key}}}`,'g'), obj[key]); }); return str; } const str = \"{{name}}很厉name害{{name}}，才{{age}}岁\"; const obj = { name: \"jawil\", age: \"15\" }; console.log(parseString(str, obj)); 没用 for...in 循环就是为了考虑不必要的循环，因为 for...in 循环会遍历原型链所有的可枚举属性，造成不必要的循环。 for/in 循环获取 obj 的 key 值 、 Object.key()、 Object.getOwnPropertyNames()、 Reflect.ownKeys()区别 for...in循环：会遍历对象自身的属性，以及原型属性，for...in 循环只遍历可枚举(不包括 enumerable为 false )属性。像 Array 和 Object 使用内置构造函数所创建的对象都会继承自 Object.prototype 和 String.prototype 的不可枚举属性; Object.key()：可以得到自身可枚举的属性,但得不到原型链上的属性; Object.getOwnPropertyNames()：可以得到自身所有的属性(包括不可枚举),但得不到原型链上的属性, Symbols 属性也得不到. Reflect.ownKeys()：该方法用于返回对象的所有属性，基本等同于 Object.getOwnPropertyNames() 与 Object.getOwnPropertySymbols 之和。 demo 理解 const parent = { a: 1, b: 2, c: 3 }; const child = { d: 4, e: 5, [Symbol()]: 6 }; child.__proto__ = parent; Object.defineProperty(child, \"d\", { enumerable: false }); for (var attr in child) { console.log(\"for...in:\", attr);// a,b,c,e } console.log(\"Object.keys:\", Object.keys(child));// [ 'e' ] console.log(\"Object.getOwnPropertyNames:\", Object.getOwnPropertyNames(child)); // [ 'd', 'e' ] console.log(\"Reflect.ownKeys:\", Reflect.ownKeys(child)); // [ 'd', 'e', Symbol() ] 最后实现 MDN str.replace(regexp|substr, newSubStr|function) 通过 MDN 文档里面写的 str.replace(regexp|substr, newSubStr|function) ，我们可以发现 replace 方法可以传入 function 回调函数， function (replacement) 一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果 参考这个指定一个函数作为参数。 你可以指定一个函数作为第二个参数。在这种情况下，当匹配执行后， 该函数就会执行。 函数的返回值作为替换字符串。 (注意: 上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是， 如果第一个参数是正则表达式， 并且其为全局匹配模式， 那么这个方法将被多次调用， 每次匹配都会被调用。 下面是该函数的参数： 变量名 代表的值 match 匹配的子串。（对应于上述的$&。） p1,p2, ... 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）例如, 如果是用 /(\\a+)(\\b+)/这个来匹配， p1就是匹配的 \\a+, p2 就是匹配的 \\b+。 offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） string 被匹配的原字符串。 (精确的参数个数依赖于replace()的第一个参数是否是一个正则表达式对象， 以及这个正则表达式中指定了多少个括号子串。) 下面的例子将会使 newString 变成'abc - 12345 - #$*%'： function replacer(match, p1, p2, p3, offset, string) { // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(' - '); } var newString = 'abc12345#$*%'.replace(/([^\\d]*)(\\d*)([^\\w]*)/, replacer); console.log(newString); // abc - 12345 - #$*% 依据上边最终实现 function render(template, context) { return template.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => context[key]); } const template = \"{{name}}很厉name害，才{{age}}岁\"; const context = { name: \"jawil\", age: \"15\" }; console.log(render(template, context)); 实现code function render(template, context) { return template.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => context[key]); } // 最终挂到String String.prototype.render = function (context) { return this.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => context[key.trim()]); }; 分析 该函数的返回值(obj[key]=jawil)将替换掉第一个参数(match==)匹配到的结果。 简单分析一下：.*? 是正则固定搭配用法，表示非贪婪匹配模式，尽可能匹配少的，什么意思呢？举个简单的例子。 举个🌰： 源字符串：aatest1bbtest2cc 正则表达式一：.* 匹配结果一：test1bbtest2 正则表达式二：.*? 匹配结果二：test1（这里指的是一次匹配结果，不使用/g，所以没包括test2） 所以：正则匹配到，分组获取 `name`，然后把 替换成 obj[name](jawil) 发现还有一个小问题，如果有空格的话就会匹配失败，类似这种写法： const template = \"{{name }}很厉name害，才{{age }}岁\"; 所以在上面的基础上还要去掉空格，其实也很简单，用正则或者 String.prototype.trim() 方法都行 function render(template, context) { return template.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => context[key.trim()]); } const template = \"{{name }}很厉name害，才{{age }}岁\"; const context = { name: \"jawil\", age: \"15\" }; console.log(render(template, context)); 将函数挂到 String 的原型链，得到最终版本 甚至，我们可以通过修改原型链，实现一些很酷的效果： String.prototype.render = function (context) { return this.replace(/\\{\\{(.*?)\\}\\}/g, (match, key) => context[key.trim()]); }; 如果{}中间不是数字，则{}本身不需要转义，所以最终最简洁的代码： String.prototype.render = function (context) { return this.replace(/{{(.*?)}}/g, (match, key) => context[key.trim()]); }; 之后，我们便可以这样调用啦： \"{{name}}很厉name害，才{{ age }}岁\".render({ name: \"jawil\", age: \"15\" }); "},"手撸代码无敌/封装Ajax和Promise.html":{"url":"手撸代码无敌/封装Ajax和Promise.html","title":"封装Ajax和Promise","keywords":"","body":"封装Ajax 和 Promise 原生js (一) function getJSON(url) { return new Promise(function(resolve, reject) { var XHR = new XMLHttpRequest(); XHR.open('GET', url, true); XHR.send(); XHR.onreadystatechange = function() { if (XHR.readyState == 4) { if (XHR.status == 200) { try { var response = JSON.parse(XHR.responseText); resolve(response); } catch (e) { reject(e); } } else { reject(new Error(XHR.statusText)); } } } }) } getJSON(url).then(resp => console.log(resp)); 原生js (二) // (原生js)封装Promise对象二 var jsGetAjaxPromise = function(param){ return new Promise(function(resolve, reject ){ var xhr = new XMLHttpRequest(); xhr.open('get', param.url, true); xhr.onload = resolve; xhr.onerror = reject; xhr.send(); }) } // 调用示例 var p1 = jsGetAjaxPromise({ // 启动第一个任务 url: 'cross-domain1.txt' // 要获取的文件地址 }); p1.then(function(response){ // 处理第一个异步任务的结果(每次调用then都会返回一个新创建的Promise对象) console.log(response); return jsGetAjaxPromise({ // 启动第二个任务 url: 'cross-domain2.txt' }) }).then(function(response2){ // 处理第二个任务的结果 console.log(response2); return jsGetAjaxPromise({ // 启动第三个任务 url: 'cross-domain3.txt' }) }).then(function(response3){ // 处理第二个任务的结果 console.log(response3); }).catch(function(err){ console.log(err); }); 改写成jquery实现 // (jquery)封装Promise对象和ajax过程 var jqGetAjaxPromise = function(param){ return new Promise(function(resolve, reject){ $.ajax({ url: param.url, type: 'get', data: param.data || '', success: function(data){ resolve(data); }, error: function(error){ reject(error) } }); }); }; // 调用示例 var p2 = jqGetAjaxPromise({ url: 'cross-domain1.txt' }); p2.then(function(data){ console.log(data); return jqGetAjaxPromise({ url:'cross-domain2.txt' }); }).then(function(data2){ console.log(data2); }).catch(function(err){ console.log(err); }); axios function myGet(url, params) { return new Promise((resolve, reject) => { axios.get(url, params).then(function (response) { resolve(response.data) }) .catch(function (err) { reject(err) }) }) } myGet(url,params).then(function(data){console.log(data)}).catch(function(){}) XMLHttpRequest 的 readystatechange 事件和 load 事件的区别 分别在 onreadystatechange 和 onload 里写入代码： xhr.onload = function () { console.log(`load:xhr.readyState == ${xhr.readyState} ,xhr.status=${xhr.status}`); } xhr.onreadystatechange = function () { console.log(`readystatechange:xhr.readyState == ${xhr.readyState} ,xhr.status=${xhr.status}`); } xhr.open(...); xhr.send(...); 输出结果如下： readystatechange : xhr.readyState == 1 ,xhr.status=200 readystatechange : xhr.readyState == 2 ,xhr.status=200 readystatechange : xhr.readyState == 3 ,xhr.status=200 readystatechange : xhr.readyState == 4 ,xhr.status=200 load : xhr.readyState == 4 ,xhr.status=200 可以看到，readystatechange 事件先于 load 事件执行。load 事件就相当于 readyState 的值为 4 后触发的事件。如果不需要跟踪请求返回之前的过程时，用 load 事件更省事儿。 然而... load 事件并不总是被触发。比如当网络错误时，目标地址访问不了时，会触发 error 事件，load 事件就不会被触发。404 之类的错误只是服务器返回的状态代码，并不是请求过程错误，所以 load 事件会触发，而 error 事件反而不会触发。 如果需要无论哪种情况都被触发的话，请用 loadend 事件。 OK！既然有 loadend 事件，当然还会有 loadstart 事件！ 这些事件的触发顺序是： readystatechange > loadstart > readystatechange > readystatechange > progress > readystatechange > load / error > loadend readystatechange 每次触发时 readyState 值不同。 "},"手撸代码无敌/js-tree.html":{"url":"手撸代码无敌/js-tree.html","title":"js-tree","keywords":"","body":"js 无限分类递归树 js数据集生成tree var data = [ { id: 1, name: \"一级分类：1\", pid: 0, }, { id: 2, name: \"二级分类：1\", pid: 1, }, { id: 3, name: \"三级分类：3\", pid: 2, }, { id: 4, name: \"一级分类：2\", pid: 0, }, { id: 7, name: \"f级分类：2\", pid: 4, }, { id: 10, name: \"f级分类：2\", pid: 7, }, { id: 9, name: \"f级分类：2\", pid: 10, }, { id: 12, name: \"f级分类：2\", pid: 9, }, { id: 15, name: \"f级分类：2\", pid: 12, }, { id: 13, name: \"f级分类：2\", pid: 15, }, ]; function toTree(data) { // 删除 所有 children,以防止多次调用 data.forEach(function (item) { delete item.children; }); // 将数据存储为 以 id 为 KEY 的 map 索引数据列 var map = {}; data.forEach(function (item) { map[item.id] = item; }); // console.log(map); var val = []; data.forEach(function (item) { // 以当前遍历项，的pid,去map对象中找到索引的id var parent = map[item.pid]; // 好绕啊，如果找到索引，那么说明此项不在顶级当中,那么需要把此项添加到，他对应的父级中 if (parent) { (parent.children || ( parent.children = [] )).push(item); } else { //如果没有在map中找到对应的索引ID,那么直接把 当前的item添加到 val结果集中，作为顶级 val.push(item); } }); return val; } console.log(toTree(data)) js 对象数组 根据某个共同字段 分组 var arr = [ {\"id\":\"1001\", \"name\":\"值1\", \"value\":\"111\" }, {\"id\":\"1001\", \"name\":\"值1\", \"value\":\"11111\"}, {\"id\":\"1002\", \"name\":\"值2\", \"value\":\"25462\"}, {\"id\":\"1002\", \"name\":\"值2\", \"value\":\"23131\"}, {\"id\":\"1002\", \"name\":\"值2\", \"value\":\"2315432\"}, {\"id\":\"1003\", \"name\":\"值3\", \"value\":\"333333\"} ]; var getTree = arr => { let map = {}, result = []; for(let i = 0; i work instance const { groupids } = this.props.orgDepartment; const provinceOptions = [], cityData = [], cityOptions = []; const getStationCities = arr => { let obj = {}, result = []; for(let i = 0, len = arr.length; i "},"手撸代码无敌/js复杂判断的更优雅写法.html":{"url":"手撸代码无敌/js复杂判断的更优雅写法.html","title":"js复杂判断的更优雅写法","keywords":"","body":"JavaScript 复杂判断的更优雅写法 JavaScript 复杂判断的更优雅写法 一. 先看一段代码 if/else switch 更简单的写法(一) 提取为对象 Object 更简单的写法(二) 提取为Map对象 Map Map对象和Object对象 二. 以前按钮点击时候只需要判断status，现在还需要判断用户的身份 if/else Map清爽实现 Object对象实现 觉得把查询条件拼成字符串有点别扭，还有一种方案，用Map对象，以Object对象作为key： 三. 再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办， 最差的情况是这样 好一点的写法是将处理逻辑函数进行缓存： Map优势更加凸显，可以用正则类型作为key Map无限可能 总结 以上实现了8种逻辑判断写法 一. 先看一段代码 if/else /** * 按钮点击事件 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status) => { if (status == 1) { sendLog('processing') jumpTo('IndexPage') } else if (status == 2) { sendLog('fail') jumpTo('FailPage') } else if (status == 3) { sendLog('fail') jumpTo('FailPage') } else if (status == 4) { sendLog('success') jumpTo('SuccessPage') } else if (status == 5) { sendLog('cancel') jumpTo('CancelPage') } else { sendLog('other') jumpTo('Index') } } switch 通过代码可以看到这个按钮的点击逻辑：根据不同活动状态做两件事情，发送日志埋点和跳转到对应页面，大家可以很轻易的提出这段代码的改写方案，switch出场： /** * 按钮点击事件 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status) => { switch (status) { case 1: sendLog('processing') jumpTo('IndexPage') break case 2: case 3: sendLog('fail') jumpTo('FailPage') break case 4: sendLog('success') jumpTo('SuccessPage') break case 5: sendLog('cancel') jumpTo('CancelPage') break default: sendLog('other') jumpTo('Index') break } } 这样看起来比if/else清晰多了，case 2和case 3逻辑一样的时候，可以省去执行语句和break，则case 2的情况自动执行case 3的逻辑。 更简单的写法(一) 提取为对象 Object const actions = { '1': ['processing', 'IndexPage'], '2': ['fail', 'FailPage'], '3': ['fail', 'FailPage'], '4': ['success', 'SuccessPage'], '5': ['cancel', 'CancelPage'], 'default': ['other', 'Index'], } /** * 按钮点击事件 * @param {number} status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status) => { let action = actions[status] || actions['default'], logName = action[0], pageName = action[1] sendLog(logName) jumpTo(pageName) } 上面代码确实看起来更清爽了，这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况。 更简单的写法(二) 提取为Map对象 Map const actions = new Map([ [1, ['processing', 'IndexPage']], [2, ['fail', 'FailPage']], [3, ['fail', 'FailPage']], [4, ['success', 'SuccessPage']], [5, ['cancel', 'CancelPage']], ['default', ['other', 'Index']] ]) /** * 按钮点击事件 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status) => { let action = actions.get(status) || actions.get('default') sendLog(action[0]) jumpTo(action[1]) } Map对象和Object对象 一个对象通常都有自己的原型，所以一个对象总有一个\"prototype\"键。 一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。 你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。 二. 以前按钮点击时候只需要判断status，现在还需要判断用户的身份 if/else /** * 按钮点击事件 * @param {number} status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团 * @param {string} identity 身份标识：guest客态 master主态 */ const onButtonClick = (status, identity) => { if (identity == 'guest') { if (status == 1) { //do sth } else if (status == 2) { //do sth } else if (status == 3) { //do sth } else if (status == 4) { //do sth } else if (status == 5) { //do sth } else { //do sth } } else if (identity == 'master') { if (status == 1) { //do sth } else if (status == 2) { //do sth } else if (status == 3) { //do sth } else if (status == 4) { //do sth } else if (status == 5) { //do sth } else { //do sth } } } 当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍， Map清爽实现 const actions = new Map([ ['guest_1', () => { /*do sth*/ }], ['guest_2', () => { /*do sth*/ }], ['guest_3', () => { /*do sth*/ }], ['guest_4', () => { /*do sth*/ }], ['guest_5', () => { /*do sth*/ }], ['master_1', () => { /*do sth*/ }], ['master_2', () => { /*do sth*/ }], ['master_3', () => { /*do sth*/ }], ['master_4', () => { /*do sth*/ }], ['master_5', () => { /*do sth*/ }], ['default', () => { /*do sth*/ }], ]) /** * 按钮点击事件 * @param {string} identity 身份标识：guest客态 master主态 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团 */ const onButtonClick = (identity, status) => { let action = actions.get(`${identity}_${status}`) || actions.get('default') action.call(this) } 把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用。 Object对象实现 const actions = { 'guest_1': () => { /*do sth*/ }, 'guest_2': () => { /*do sth*/ }, //.... } const onButtonClick = (identity, status) => { let action = actions[`${identity}_${status}`] || actions['default'] action.call(this) } 觉得把查询条件拼成字符串有点别扭，还有一种方案，用Map对象，以Object对象作为key： const actions = new Map([ [{ identity: 'guest', status: 1 }, () => { /*do sth*/ }], [{ identity: 'guest', status: 2 }, () => { /*do sth*/ }], //... ]) const onButtonClick = (identity, status) => { let action = [...actions].filter(([key, value]) => (key.identity == identity && key.status == status)) action.forEach(([key, value]) => value.call(this)) } 这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key 三. 再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办， 最差的情况是这样 const actions = new Map([ [{ identity: 'guest', status: 1 }, () => { /* functionA */ }], [{ identity: 'guest', status: 2 }, () => { /* functionA */ }], [{ identity: 'guest', status: 3 }, () => { /* functionA */ }], [{ identity: 'guest', status: 4 }, () => { /* functionA */ }], [{ identity: 'guest', status: 5 }, () => { /* functionB */ }], //... ]) 好一点的写法是将处理逻辑函数进行缓存： const actions = () => { const functionA = () => { /*do sth*/ } const functionB = () => { /*do sth*/ } return new Map([ [{ identity: 'guest', status: 1 }, functionA], [{ identity: 'guest', status: 2 }, functionA], [{ identity: 'guest', status: 3 }, functionA], [{ identity: 'guest', status: 4 }, functionA], [{ identity: 'guest', status: 5 }, functionB], //... ]) } const onButtonClick = (identity, status) => { let action = [...actions()].filter(([key, value]) => (key.identity == identity && key.status == status)) action.forEach(([key, value]) => value.call(this)) } 这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那就需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的，可以这样实现: Map优势更加凸显，可以用正则类型作为key const actions = () => { const functionA = () => { /*do sth*/ } const functionB = () => { /*do sth*/ } return new Map([ [/^guest_[1-4]$/, functionA], [/^guest_5$/, functionB], //... ]) } const onButtonClick = (identity, status) => { let action = [...actions()].filter(([key, value]) => (key.test(`${identity}_${status}`))) action.forEach(([key, value]) => value.call(this)) } Map无限可能 假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写: const actions = () => { const functionA = () => { /*do sth*/ } const functionB = () => { /*do sth*/ } const functionC = () => { /*send log*/ } return new Map([ [/^guest_[1-4]$/, functionA], [/^guest_5$/, functionB], [/^guest_.*$/, functionC], //... ]) } const onButtonClick = (identity, status) => { let action = [...actions()].filter(([key, value]) => (key.test(`${identity}_${status}`))) action.forEach(([key, value]) => value.call(this)) } 也就是说利用数组循环的特性，符合正则条件的逻辑都会被执行，那就可以同时执行公共逻辑和单独逻辑，因为正则的存在，你可以打开想象力解锁更多的玩法 总结 以上实现了8种逻辑判断写法 if/else switch 一元判断时：存到Object里 一元判断时：存到Map里 多元判断时：将condition拼接成字符串存到Object里 多元判断时：将condition拼接成字符串存到Map里 多元判断时：将condition存为Object存到Map里 多元判断时：将condition写作正则存到Map里 "},"手撸代码无敌/JavaScript优雅的实现方式.html":{"url":"手撸代码无敌/JavaScript优雅的实现方式.html","title":"JavaScript优雅的实现方式","keywords":"","body":"JavaScript 优雅的实现方式 JavaScript 优雅的实现方式 1、简短优雅地实现 sleep 函数 1.1 普通版 1.2 Promise 版本 1.3 Generator 版本 1.4 Async/Await 版本 1.5 不要忘了开源的力量 2、获取时间戳 2.1 普通版 2.2 进阶版 2.3 终极版 3. 数组去重 3.1 普通版 复杂度 O(n^2) 3.2 进阶版 3.3 时间复杂度为O(n) 3.4 终极版 4. 数字格式化 1234567890 --> 1,234,567,890 4.1 普通版 4.2 进阶版 4.3 正则版 4.4 API版 5、交换两个整数 5.1 普通版 5.2 进阶版 5.3 终极版 利用一个数异或本身等于０和异或运算符合交换率 5.4 究极版 ES6 6、将 argruments 对象(类数组)转换成数组 6.1 普通版 6.2 进阶版 6.3 ES6 版本 7、数字取整 2.33333 => 2 7.1 普通版 7.2 进阶版 7.3 黑科技版 7.3.1 ~~number 7.3.2 number | 0 7.3.3 number ^ 0 7.3.4 number 8、数组求和 8.1 普通版 8.2 优雅版 8.3 终极版 1、简短优雅地实现 sleep 函数 很多语言都有 sleep 函数，显然 js 没有，那么如何能简短优雅地实现这个方法？ 1.1 普通版 function sleep(sleepTime) { for(var start = +new Date; +new Date - start 优点：简单粗暴，通俗易懂。 缺点：这是最简单粗暴的实现，确实 sleep 了，也确实卡死了，CPU 会飙升，无论你的服务器 CPU 有多么 Niubility。 1.2 Promise 版本 function sleep(time) { return new Promise(resolve => setTimeout(resolve, time)) } const t1 = +new Date() sleep(3000).then(() => { const t2 = +new Date() console.log(t2 - t1) }) 优点：这种方式实际上是用了 setTimeout，没有形成进程阻塞，不会造成性能和负载问题。 缺点：虽然不像 callback 套那么多层，但仍不怎么美观，而且当我们需要在某过程中需要停止执行（或者在中途返回了错误的值），还必须得层层判断后跳出，非常麻烦，而且这种异步并不是那么彻底，还是看起来别扭。 1.3 Generator 版本 function sleep(delay) { return function(cb) { setTimeout(cb.bind(this), delay) }; } function* genSleep() { const t1 = +new Date() yield sleep(3000) const t2 = +new Date() console.log(t2 - t1) } async(genSleep) function async(gen) { const iter = gen() function nextStep(it) { if (it.done) return if (typeof it.value === \"function\") { it.value(function(ret) { nextStep(iter.next(ret)) }) } else { nextStep(iter.next(it.value)) } } nextStep(iter.next()) } 优点：同 Promise 优点，另外代码就变得非常简单干净，没有 then 那么生硬和恶心。 缺点：但不足也很明显，就是每次都要执行 next() 显得很麻烦，虽然有 co（第三方包）可以解决，但就多包了一层，不好看，错误也必须按 co 的逻辑来处理，不爽。 co 之所以这么火并不是没有原因的，当然不是仅仅实现 sleep 这么无聊的事情，而是它活生生的借着generator/yield 实现了很类似 async/await 的效果！这一点真是让我三观尽毁刮目相看。 const co = require(\"co\") function sleep(delay) { return function(cb) { setTimeout(cb.bind(this), delay) } } co(function*() { const t1 = +new Date() yield sleep(3000) const t2 = +new Date() console.log(t2 - t1) }) 1.4 Async/Await 版本 function sleep(delay) { return new Promise(reslove => { setTimeout(reslove, delay) }) } !async function test() { const t1 = +new Date() await sleep(3000) const t2 = +new Date() console.log(t2 - t1) }() 优点：同 Promise 和 Generator 优点。 Async/Await 可以看做是 Generator 的语法糖，Async 和 Await 相较于 * 和 yield 更加语义，另外各个函数都是扁平的，不会产生多余的嵌套，代码更加清爽易读。 缺点： ES7 语法存在兼容性问题，有 babel 一切兼容性都不是问题 1.5 不要忘了开源的力量 在 javascript 优雅的写 sleep 等于如何优雅的不优雅 这里有 C++ 实现的模块：https://github.com/ErikDubbelboer/node-sleep const sleep = require(\"sleep\") const t1 = +new Date() sleep.msleep(3000) const t2 = +new Date() console.log(t2 - t1) 优点：能够实现更加精细的时间精确度，而且看起来就是真的 sleep 函数，清晰直白。 缺点：缺点需要安装这个模块，^_^，这也许算不上什么缺点。 2、获取时间戳 上面第一个用多种方式实现 sleep 函数，我们可以发现代码有 +new Date()获取时间戳的用法，这只是其中的一种，下面就说一下其他两种以及 +new Date()的原理。 2.1 普通版 var timestamp=new Date().getTime() 优点：具有普遍性，大家都用这个 缺点：目前没有发现 2.2 进阶版 var timestamp = (new Date()).valueOf() valueOf 方法返回对象的原始值(Primitive,'Null','Undefined','String','Boolean','Number'五种基本数据类型之一)，可能是字符串、数值或 bool 值等，看具体的对象。 优点：说明开发者原始值有一个具体的认知，让人眼前一亮。 缺点: 目前没有发现 2.3 终极版 var timestamp = +new Date() 优点：对 JavaScript 隐式转换掌握的比较牢固的一个表现 缺点：目前没有发现 现在就简单分析一下为什么 +new Date() 拿到的是时间戳。 一言以蔽之，这是隐式转换的玄学，实质还是调用了 valueOf() 的方法。 一元+ 运算符 一元 + 运算符将其操作数转换为 Number 类型并反转其正负。注意负的 +0 产生 -0，负的 -0 产生 +0。产生式 UnaryExpression : - UnaryExpression 按照下面的过程执行。 令 expr 为解释执行 UnaryExpression 的结果 . 令 oldValue 为 ToNumber(GetValue(expr)). 如果 oldValue is NaN ，return NaN. 返回 oldValue 取负（即，算出一个数字相同但是符号相反的值）的结果。 +new Date() 相当于 ToNumber(new Date()) 我们再来看看 ECMAScript 规范对 ToNumber 的定义： 我们知道 new Date() 是个对象，满足上面的 ToPrimitive()，所以进而成了 ToPrimitive(new Date())。 接着我们再来看看 ECMAScript 规范对 ToPrimitive 的定义，一层一层来，抽丝剥茧。 ToPrimitive(obj,preferredType) JavaScript 引擎内部转换为原始值 ToPrimitive(obj,preferredType) 函数接受两个参数，第一个 obj 为被转换的对象，第二个preferredType 为希望转换成的类型（默认为空，接受的值为 Number 或 String） 在执行 ToPrimitive(obj,preferredType) 时如果第二个参数为空并且 obj 为 Date 的实例时，此时 preferredType 会被设置为 String，其他情况下 preferredType 都会被设置为Number 如果 preferredType 为 Number，ToPrimitive 执行过程如下： 如果obj为原始值，直接返回； 否则调用 obj.valueOf()，如果执行结果是原始值，返回之； 否则调用 obj.toString()，如果执行结果是原始值，返回之； 否则抛异常。 如果 preferredType 为 String，将上面的第2步和第3步调换，即： 如果obj为原始值，直接返回； 否则调用 obj.toString()，如果执行结果是原始值，返回之； 否则调用 obj.valueOf()，如果执行结果是原始值，返回之； 否则抛异常。 首先我们要明白 obj.valueOf() 和 obj.toString() 还有原始值分别是什么意思,这是弄懂上面描述的前提之一: toString 用来返回对象的字符串表示。 var obj = {}; console.log(obj.toString());//[object Object] var arr2 = []; console.log(arr2.toString());//\"\"空字符串 var date = new Date(); console.log(date.toString());//Sun Feb 28 2016 13:40:36 GMT+0800 (中国标准时间) valueOf 方法返回对象的原始值，可能是字符串、数值或 bool 值等，看具体的对象。 var obj = { name: \"obj\" } console.log(obj.valueOf()) //Object {name: \"obj\"} var arr1 = [1] console.log(arr1.valueOf()) //[1] var date = new Date() console.log(date.valueOf())//1456638436303 如代码所示，三个不同的对象实例调用valueOf返回不同的数据 原始值指的是 'Null','Undefined','String','Boolean','Number','Symbol' 6种基本数据类型之一，上面已经提到过这个概念，这里再次申明一下。 最后分解一下其中的过程：+new Date(): 运算符 new 的优先级高于一元运算符 +，所以过程可以分解为： var time=new Date(); +time 根据上面提到的规则相当于：ToNumber(time) time 是个日期对象，根据 ToNumber 的转换规则，所以相当于：ToNumber(ToPrimitive(time)) 根据 ToPrimitive 的转换规则：ToNumber(time.valueOf())，time.valueOf() 就是 原始值 得到的是个时间戳，假设 time.valueOf()=1503479124652 所以 ToNumber(1503479124652) 返回值是 1503479124652 这个数字。 分析完毕 3. 数组去重 注：暂不考虑对象字面量，函数等引用类型的去重，也不考虑 NaN, undefined, null等特殊类型情况。 数组样本：[1, 1, '1', '2', 1] 3.1 普通版 复杂度 O(n^2) 无需思考，我们可以得到 O(n^2) 复杂度的解法。定义一个变量数组 res 保存结果，遍历需要去重的数组，如果该元素已经存在在 res 中了，则说明是重复的元素，如果没有，则放入 res 中。 var a = [1, 1, '1', '2', 1] function unique(arr) { var res = [] for (var i = 0, len = arr.length; i 优点： 没有任何兼容性问题，通俗易懂，没有任何理解成本 缺点： 看起来比较臃肿比较繁琐，时间复杂度比较高O(n^2) 3.2 进阶版 var a = [1, 1, '1', '2', 1] function unique(arr) { return arr.filter(function(ele,index,array){ return array.indexOf(ele) === index//很巧妙,这样筛选一对一的,过滤掉重复的 }) } console.log(unique(a)) // [1, 2, \"1\"] 优点：很简洁，思维也比较巧妙，直观易懂。 缺点：不支持 IE9 以下的浏览器，时间复杂度还是O(n^2) 3.3 时间复杂度为O(n) var a = [1, 1, '1', '2', 1] function unique(arr) { var obj = {} return arr.filter(function(item, index, array){ return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) }) } console.log(unique(a)) // [1, 2, \"1\"] 优点：hasOwnProperty 是对象的属性(名称)存在性检查方法。对象的属性可以基于 Hash 表实现，因此对属性进行访问的时间复杂度可以达到O(1); filter 是数组迭代的方法，内部还是一个 for 循环，所以时间复杂度是 O(n)。 缺点：不兼容 IE9 以下浏览器，其实也好解决，把 filter 方法用 for 循环代替或者自己模拟一个 filter 方法。 3.4 终极版 以 Set 为例，ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 const unique = a => [...new Set(a)] 优点：ES6 语法，简洁高效，我们可以看到，去重方法从原始的 14 行代码到 ES6 的 1 行代码，其实也说明了 JavaScript 这门语言在不停的进步，相信以后的开发也会越来越高效。 缺点：兼容性问题，现代浏览器才支持，有 babel 这些都不是问题。 4. 数字格式化 1234567890 --> 1,234,567,890 4.1 普通版 function formatNumber(str) { let arr = [], count = str.length while (count >= 3) { arr.unshift(str.slice(count - 3, count)) count -= 3 } // 如果是不是3的倍数就另外追加到上去 str.length % 3 && arr.unshift(str.slice(0, str.length % 3)) return arr.toString() } console.log(formatNumber(\"1234567890\")) // 1,234,567,890 优点：自我感觉比网上写的一堆 for循环 还有 if-else 判断的逻辑更加清晰直白。 缺点：太普通 4.2 进阶版 function formatNumber(str) { // [\"0\", \"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\"] return str.split(\"\").reverse().reduce((prev, next, index) => { return ((index % 3) ? next : (next + ',')) + prev }) } console.log(formatNumber(\"1234567890\")) // 1,234,567,890 优点：把 JS 的 API 玩的了如指掌 缺点：可能没那么好懂，不过读懂之后就会发出我怎么没想到的感觉 4.3 正则版 function formatNumber(str) { return str.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',') } console.log(formatNumber(\"123456789\")) // 1,234,567,890 下面简单分析下正则/\\B(?=(\\d{3})+(?!\\d))/g： /\\B(?=(\\d{3})+(?!\\d))/g：正则匹配边界\\B，边界后面必须跟着(\\d{3})+(?!\\d); (\\d{3})+：必须是1个或多个的3个连续数字; (?!\\d)：第2步中的3个数字不允许后面跟着数字; (\\d{3})+(?!\\d)：所以匹配的边界后面必须跟着3*n（n>=1）的数字。 最终把匹配到的所有边界换成,即可达成目标。 优点：代码少，浓缩的就是精华 缺点：需要对正则表达式的位置匹配有一个较深的认识，门槛大一点 4.4 API版 (1234567890).toLocaleString('en-US') // 1,234,567,890 还可以使用 Intl对象 - MDN Intl 对象是 ECMAScript 国际化 API 的一个命名空间，它提供了精确的字符串对比，数字格式化，日期和时间格式化。Collator，NumberFormat 和 DateTimeFormat 对象的构造函数是 Intl 对象的属性。 new Intl.NumberFormat().format(1234567890) // 1,234,567,890 优点：简单粗暴，直接调用 API 缺点：Intl兼容性不太好，不过 toLocaleString的话 IE6 都支持 5、交换两个整数 let a = 3,b = 4 变成 a = 4, b = 3 5.1 普通版 首先最常规的办法，引入一个 temp 中间变量 let a = 3,b = 4 let temp = a a = b b = temp console.log(a, b) 优点：一眼能看懂就是最好的优点 缺点：硬说缺点就是引入了一个多余的变量 5.2 进阶版 在不引入中间变量的情况下也能交互两个变量 let a = 3,b = 4 a += b b = a - b a -= b console.log(a, b) 优点：比起楼上那种没有引入多余的变量，比上面那一种稍微巧妙一点 缺点：当然缺点也很明显，整型数据溢出，比如说对于32位字符最大表示有符号数字是2147483647，也就是Math.pow(2,31)-1，如果是2147483645和2147483646交换就失败了。 5.3 终极版 利用一个数异或本身等于０和异或运算符合交换率。 let a = 3,b = 4 a ^= b b ^= a a ^= b console.log(a, b) 利用一个数异或本身等于０和异或运算符合交换率 下面用竖式进行简单说明：(10进制化为二进制) a = 011 (^) b = 100 则 a = 111(a ^ b的结果赋值给a，a已变成了7) (^) b = 100 则 b = 011(b^a的结果赋给b，b已经变成了3) (^) a = 111 则 a = 100(a^b的结果赋给a，a已经变成了4) 从上面的竖式可以清楚的看到利用异或运算实现两个值交换的基本过程。 下面从深层次剖析一下： 对于开始的两个赋值语句，a = a ^ b，b = b ^ a，相当于b = b ^ (a ^ b) = a ^ b ^ b，而b ^ b 显然等于0。因此b = a ^ 0，显然结果为a。 同理可以分析第三个赋值语句，a = a ^ b = (a ^ b) ^ a = b 注： ^ 即”异或“运算符。 它的意思是判断两个相应的位值是否为”异“，为”异\"(值不同)就取真（1）;否则为假（0）。 ^ 运算符的特点是与0异或，保持原值；与本身异或，结果为0。 优点：不存在引入中间变量，不存在整数溢出 缺点：前端对位操作这一块可能了解不深，不容易理解 5.4 究极版 ES6 var a = 3,b = 4; [b, a] = [a, b] 6、将 argruments 对象(类数组)转换成数组 {0:1,1:2,2:3,length:3}这种形式的就属于类数组，就是按照数组下标排序的对象，还有一个 length 属性，有时候我们需要这种对象能调用数组下的一个方法，这时候就需要把把类数组转化成真正的数组。 6.1 普通版 var makeArray = function(array) { var ret = [] if (array != null) { var i = array.length if (i == null || typeof array === \"string\") ret[0] = array else while (i) ret[--i] = array[i]; } return ret } makeArray({0:1,1:2,2:3,length:3}) //[1,2,3] 优点：通用版本，没有任何兼容性问题 缺点：太普通 6.2 进阶版 var arr = Array.prototype.slice.call(arguments); 简单的说就是根据参数，返回数组的一部分的 copy。所以了解其内部实现才能确定它是如何工作的。所以查看 V8 源码中的 Array.js 可以看到如下的代码： slice.call 的作用原理就是，利用 call，将 slice 的方法作用于 arrayLike，slice 的两个参数为空，slice 内部解析使得 arguments.lengt 等于0的时候 相当于处理 slice(0) ： 即选择整个数组，slice 方法内部没有强制判断必须是 Array 类型，slice 返回的是新建的数组（使用循环取值）”，所以这样就实现了类数组到数组的转化，call 这个神奇的方法、slice 的处理缺一不可。 直接看 slice 怎么实现的吧。其实就是将 array-like 对象通过下标操作放进了新的 Array 里面： // This will work for genuine arrays, array-like objects, // NamedNodeMap (attributes, entities, notations), // NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes), // and will not fail on other DOM objects (as do DOM elements in IE = 0) ? start : Math.max(0, len + start); // Handle negative value for \"end\" var upTo = (typeof end == 'number') ? Math.min(end, len) : len; if (end 0) { cloned = new Array(size); if (this.charAt) { for (i = 0; i 优点：最常用的版本，兼容性较强 缺点：ie 低版本，无法处理 dom 集合的 slice call 转数组。（虽然具有数值键值、length 符合ArrayLike 的定义，却报错）搜索资料得到 ：因为 ie 下的 dom 对象是以 com 对象的形式实现的，js 对象与com对象不能进行转换 。 6.3 ES6 版本 使用 `Array.from`, 值需要对象有 leng`th 属性, 就可以转换成数组 var arr = Array.from(arguments); 扩展运算符 var args = [...arguments]; ES6 中的扩展运算符...也能将某些数据结构转换成数组，这种数据结构必须有便利器接口。 优点：直接使用内置 API，简单易维护 缺点：兼容性，使用 babel 的 profill 转化可能使代码变多，文件包变大 7、数字取整 2.33333 => 2 7.1 普通版 const a = parseInt(2.33333) 7.2 进阶版 const a = Math.trunc(2.33333) Math.trunc() 方法会将数字的小数部分去掉，只保留整数部分。 特别要注意的是：Internet Explorer 不支持这个方法，不过写个 Polyfill 也很简单： Math.trunc = Math.trunc || function(x) { if (isNaN(x)) { return NaN; } if (x > 0) { return Math.floor(x); } return Math.ceil(x); }; 7.3 黑科技版 7.3.1 ~~number 双波浪线 ~~ 操作符也被称为“双按位非”操作符。你通常可以使用它作为代替 Math.trunc() 的更快的方法。 console.log(~~47.11) // -> 47 console.log(~~1.9999) // -> 1 console.log(~~3) // -> 3 console.log(~~[]) // -> 0 console.log(~~NaN) // -> 0 console.log(~~null) // -> 0 失败时返回0,这可能在解决 Math.trunc() 转换错误返回 NaN 时是一个很好的替代。 但是当数字范围超出 ±2^31−1 即：2147483647 时，异常就出现了： // 异常情况 console.log(~~2147493647.123) // -> -2147473649 🙁 7.3.2 number | 0 | (按位或) 对每一对比特位执行或（OR）操作。 console.log(20.15|0); // -> 20 console.log((-20.15)|0); // -> -20 console.log(3000000000.15|0); // -> -1294967296 7.3.3 number ^ 0 ^ (按位异或)，对每一对比特位执行异或（XOR）操作。 console.log(20.15^0); // -> 20 console.log((-20.15)^0); // -> -20 console.log(3000000000.15^0); // -> -1294967296 🙁 7.3.4 number console.log(20.15 20 console.log((-20.15) -1294967296 🙁 上面这些按位运算符方法执行很快，当你执行数百万这样的操作非常适用，速度明显优于其他方法。但是代码的可读性比较差。还有一个特别要注意的地方，处理比较大的数字时（当数字范围超出 ±2^31−1 即：2147483647），会有一些异常情况。使用的时候明确的检查输入数值的范围。 8、数组求和 8.1 普通版 let arr = [1, 2, 3, 4, 5] function sum(arr){ let x = 0 for(let i = 0; i 优点：通俗易懂，简单粗暴 缺点：没有亮点，太通俗 8.2 优雅版 let arr = [1, 2, 3, 4, 5] function sum(arr) { return arr.reduce((a, b) => a + b) } sum(arr) //15 优点：简单明了，数组迭代器方式清晰直观 缺点：不兼容 IE 9以下浏览器 8.3 终极版 let arr = [1, 2, 3, 4, 5] function sum(arr) { return eval(arr.join(\"+\")) } sum(arr) //15 优点：让人一时看不懂的就是\"好方法\"。 缺点： eval 不容易调试。用 chromeDev 等调试工具无法打断点调试，所以麻烦的东西也是不推荐使用的… 性能问题，在旧的浏览器中如果你使用了eval，性能会下降10倍。在现代浏览器中有两种编译模式：fast path和slow path。fast path是编译那些稳定和可预测（stable and predictable）的代码。而明显的，eval 不可预测，所以将会使用 slow path ，所以会慢。 "},"手撸代码无敌/函数式代码.html":{"url":"手撸代码无敌/函数式代码.html","title":"函数式代码","keywords":"","body":"函数式代码 函数式代码 先看代码 old-school 正常的版本 old-school 函数式的版本 Javascript的箭头函数 匿名函数的递归 动用高阶函数的递归 回顾之前的程序 先看代码 这个代码平淡无奇，就是从一个数组中找到一个数，O(n)的算法，找不到就返回 null。 正常的 old-school 的方式 old-school 正常的版本 //正常的版本 function find (x, y) { for ( let i = 0; i 结果到了函数式成了下面这个样子（好像上面的那些代码在下面若影若现，不过又有点不太一样，为了消掉if语言，让其看上去更像一个表达式，动用了 ? 号表达式）： old-school 函数式的版本 //函数式的版本 const find = ( f => f(f) ) ( f => (next => (x, y, i = 0) => ( i >= x.length) ? null : ( x[i] == y ) ? i : next(x, y, i+1))((...args) => (f(f))(...args))) let arr = [0,1,2,3,4,5] console.log(find(arr, 2)) // 2 console.log(find(arr, 8)) // null Javascript的箭头函数 var simple = a => a > 15 ? 15 : a; simple(16); // 15 simple(10); // 10 let max = (a, b) => a > b ? a : b; // Easy array filtering, mapping, ... var arr = [5, 6, 13, 0, 1, 18, 23]; var sum = arr.reduce((a, b) => a + b); // 66 var even = arr.filter(v => v % 2 == 0); // [6, 0, 18] var double = arr.map(v => v * 2); // [10, 12, 26, 0, 2, 36, 46] 上面前两个 simple 和 max 的例子都把这箭头函数赋值给了一个变量，于是它就有了一个名字。 有时候，某些函数在声明的时候就是调用的时候，尤其是函数式编程中，一个函数还对外返回函数的时候。比如下在这个例子： function MakePowerFn(power) { return function PowerFn(base) { return Math.pow(base, power); } } power3 = MakePowerFn(3); //制造一个X的3次方的函数 power2 = MakePowerFn(2); //制造一个X的2次方的函数 console.log(power3(10)); //10的3次方 = 1000 console.log(power2(10)); //10的2次方 = 100 其实，在 MakePowerFn 函数里的那个 PowerFn 根本不需要命名，完全可以写成： function MakePowerFn(power) { return function(base) { return Math.pow(base, power); } } 如果用箭头函数，可以写成： MakePowerFn = power => { return base => { return Math.pow(base, power); } } 更简洁（如果用表达式的话，就不需要 { 和 }， 以及 return 语句 ）： MakePowerFn = power => base => Math.pow(base, power) 加上括号，和换行可能会更清楚一些 MakePowerFn = (power) => ( (base) => (Math.pow(base, power)) ) 匿名函数的递归 函数式编程立志于用函数表达式消除有状态的函数，以及for/while循环，所以，在函数式编程的世界里是不应该用for/while循环的，而要改用递归（递归的性能很差，所以，一般是用尾递归来做优化，也就是把函数的计算的状态当成参数一层一层的往下传递，这样语言的编译器或解释器就不需要用函数栈来帮你保存函数的内部变量的状态了）。 一般来说，递归的代码就是函数自己调用自己，比如我们求阶乘的代码： function fact(n){ return n==0 ? 1 : n * fact(n-1); }; result = fact(5); 在匿名函数下，这个递归该怎么写呢？对于匿名函数来说，我们可以把匿名函数当成一个参数传给另外一个函数，因为函数的参数有名字，所以就可以调用自己了。 如下所示： function combinator(func) { func(func); } 这个是不是有点作弊的嫌疑？Anyway，我们再往下，把上面这个函数整成箭头函数式的匿名函数的样子。 （func) => (func(func)) 现在你似乎就不像作弊了吧。把上面那个求阶乘的函数套进来是这个样子： 首先，先重构一下fact，把fact中自己调用自己的名字去掉： function fact(func, n) { return n==0 ? 1 : n * func(func, n-1); } fact(fact, 5); //输出120 然后，我们再把上面这个版本变成箭头函数的匿名函数版： var fact = (func, n) => ( n==0 ? 1 : n * func(func, n-1) ) fact(fact, 5) 这里，我们依然还要用一个fact来保存这个匿名函数，我们继续，我们要让匿名函数声明的时候，就自己调用自己。 也就是说，我们要把 (func, n) => ( n==0 ? 1 : n * func(func, n-1) ) 这个函数当成调用参数，传给下面这个函数： (func, x) => func(func, x) 最终我们得到下面的代码： ( (func, x) => func(func, x) ) ( //函数体 (func, n) => ( n==0 ? 1 : n * func(func, n-1) ), //第一个调用参数 5 //第二调用参数 ); 动用高阶函数的递归 但是上面这个递归的匿名函数在自己调用自己，所以，代码中有hard code的实参。我们想实参去掉，如何去掉呢？我们可以参考前面说过的那个 MakePowerFn 的例子，不过这回是递归版的高阶函数了。 HighOrderFact = function(func){ return function(n){ return n==0 ? 1 : n * func(func)(n-1); }; }; 我们可以看，上面的代码简单说来就是，需要一个函数做参数，然后返回这个函数的递归版本。那么，我们怎么调用呢？ fact = HighOrderFact(HighOrderFact); fact(5); 连起来写就是： HighOrderFact ( HighOrderFact ) ( 5 ) 但是，这样让用户来调用很不爽，所以，以我们一个函数把 HighOrderFact ( HighOrderFact ) 给代理一下： fact = function ( hifunc ) { return hifunc ( hifunc ); } ( //调用参数是一个函数 function (func) { return function(n){ return n==0 ? 1 : n * func(func)(n-1); }; } ); fact(5); //于是我们就可以直接使用了 用箭头函数重构一下，是不是简洁了一些？ fact = (highfunc => highfunc ( highfunc ) ) ( func => n => n==0 ? 1 : n * func(func)(n-1) ); 上面就是我们最终版的阶乘的函数式代码。 回顾之前的程序 我们再来看那个查找数组的正常程序： //正常的版本 function find (x, y) { for ( let i = 0; i 先把for干掉，搞成递归版本： function find (x, y, i=0) { if ( i >= x.length ) return null; if ( x[i] == y ) return i; return find(x, y, i+1); } 然后，写出带实参的匿名函数的版本（注：其中的if代码被重构成了 ？号表达式）： ( (func, x, y, i) => func(func, x, y, i) ) ( //函数体 (func, x, y, i=0) => ( i >= x.length ? null : x[i] == y ? i : func (func, x, y, i+1) ), //第一个调用参数 arr, //第二调用参数 2 //第三调用参数 ) 最后，引入高阶函数，去除实参： const find = ( highfunc => highfunc( highfunc ) ) ( func => (x, y, i = 0) => ( i >= x.length ? null : x[i] == y ? i : func (func) (x, y, i+1) ) ); 注：函数式编程装逼时一定要用const字符，这表示我写的函数里的状态是 immutable 的，天生骄傲！ 再注：这个比原来版的那个简单了很多，原来版本的那个又在函数中套了一套 next， 而且还动用了不定参数，当然，如果你想装逼装到天上的，理论上来说，你可以套N层，呵呵。 "},"手撸代码无敌/js编程黑科技.html":{"url":"手撸代码无敌/js编程黑科技.html","title":"js编程黑科技","keywords":"","body":"js 编程黑科技 js 编程黑科技 1、单行写一个评级组件 2、 如何装逼用代码骂别人SB 3、 如何用代码优雅的证明自己NB 4、 JavaScript 错误处理的方式的正确姿势 5、 从一行代码里面学点JavaScript 6、论如何优雅的取随机字符串 7. (10)\"toString\" === \"10\" 8、匿名函数自执行 9、另外一种undefined -> void 0 10、 论如何优雅的取整 11、如何优雅的实现金钱格式化：1234567890 --> 1,234,567,890 12、逗号运算符 13、论如何最佳的让两个整数交换数值 算术运算 黑科技办法: 异或运算 ES5 数据交换 ES6 解构赋值 14、实现标准JSON的深拷贝 15、不用Number、parseInt和parseFloat和方法把\"1\"字符串转换成数字 16、parseInt(0.0000008) === 8 [17、 ++[[]][+[]]++[]] == 10 18、new Set实现去重 19、用最短的代码实现一个长度为m(6)且值都n(8)的数组 20、取出一个数组中的最大值和最小值 21、 将argruments对象转换成数组 22、 从一个数组中找到一个数，O(n)的算法，找不到就返回 null。 1、单行写一个评级组件 \"★★★★★☆☆☆☆☆\".slice(5 - rate, 10 - rate); // 定义一个变量rate是1到5的值，然后执行上面代码，看图 var rate = 1; \"★★★★★☆☆☆☆☆\".slice(5 - rate, 10 - rate); 2、 如何装逼用代码骂别人SB (!(~+[])+{})[--[~+\"\"][+[]]*[~+[]] + ~~!+[]]+({}+[])[[~!+[]]*~+[]] 3、 如何用代码优雅的证明自己NB ([][[]]+[])[+!![]]+([]+{})[!+[]+!![]] console.log(([][[]]+[])[+!![]] + ([]+{})[!+[]+!![]]) 4、 JavaScript 错误处理的方式的正确姿势 try { something } catch (e) { window.location.href = \"http://stackoverflow.com/search?q=[js]+\" + e.message; } 5、 从一行代码里面学点JavaScript [].forEach.call($$(\"*\"),function(a){ a.style.outline=\"1px solid #\"+(~~(Math.random()*(1 翻译成正常语言就是这样的 Array.prototype.forEach.call(document.querySelectorAll('*'), dom => dom.style.outline = `1px solid #${parseInt(Math.random() * Math.pow(2,24)).toString(16)}`) 接下来在浏览器控制看看：something magic happens 6、论如何优雅的取随机字符串 Math.random().toString(16).substring(2) // 13位 Math.random().toString(36).substring(2) // 11位 7. (10)\"toString\" === \"10\" (10)[\"toString\"]() === \"10\" 8、匿名函数自执行 ( function() {}() ); ( function() {} )(); [ function() {}() ]; ~ function() {}(); ! function() {}(); + function() {}(); - function() {}(); delete function() {}(); typeof function() {}(); void function() {}(); new function() {}(); new function() {}; var f = function() {}(); 1, function() {}(); 1 ^ function() {}(); 1 > function() {}(); // ... 9、另外一种undefined -> void 0 从来不需要声明一个变量的值是undefined，因为JavaScript会自动把一个未赋值的变量置为undefined。所有如果你在代码里这么写，会被鄙视的 var data = undefined; var data = void 0; void在JavaScript中是一个操作符，对传入的操作不执行并且返回undefined。void后面可以跟()来用，例如void(0)，看起来是不是很熟悉？没错，在HTML里阻止带href的默认点击操作时，都喜欢把href写成javascript:void(0)，实际上也是依靠void操作不执行的意思。 10、 论如何优雅的取整 var a = ~~2.33 var b= 2.33 | 0 var c= 2.33 >> 0 11、如何优雅的实现金钱格式化：1234567890 --> 1,234,567,890 用正则魔法实现： var test1 = '1234567890' var format = test1.replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',') console.log(format) // 1,234,567,890 非正则的优雅实现： function formatCash(str) { return str.split('').reverse().reduce((prev, next, index) => { return ((index % 3) ? next : (next + ',')) + prev }) } console.log(formatCash('1234567890')) // 1,234,567,890 12、逗号运算符 var a = 0; var b = ( a++, 99 ); console.log(a); // 1 console.log(b); // 99 13、论如何最佳的让两个整数交换数值 算术运算 var a=1, b=2; a += b; b = a - b; a -= b; var a = 1, b = 2; a = a + b; // a = 3, b = 2 b = a - b; // a = 3, b = 1 a = a - b; // a = 2, b = 1 缺点也很明显，整型数据溢出，对于32位字符最大表示数字是2147483647，如果是2147483645和2147483646交换就失败了。 黑科技办法: 异或运算 a ^= b; b ^= a; a ^= b; var a = 1, // 二进制：0001 b = 2; // 二进制：0010 a = a ^ b; // 计算结果：a = 0011, b = 0010 b = a ^ b; // 计算结果：a = 0011, b = 0001 a = a ^ b; // 计算结果：a = 0010, b = 0001 ES5 数据交换 var a = 1, b = 2, tmp; tmp = a; a = b; b = tmp; ES6 解构赋值 let a = 1, b = 2; [a, b] = [b, a]; 14、实现标准JSON的深拷贝 var a = { a: 1, b: { c: 1, d: 2 } } var b=JSON.parse(JSON.stringify(a)) 不考虑IE的情况下，标准JSON格式的对象蛮实用，不过对于undefined和function的会忽略掉。 15、不用Number、parseInt和parseFloat和方法把\"1\"字符串转换成数字 不准用强制类型转换，那么就想到了强大了隐式转换 var a =1 +a 16、parseInt(0.0000008) === 8 17、 ++[[]][+[]]+[+[]] == 10 18、new Set实现去重 [...new Set([1, \"1\", 2, 1, 1, 3])] // [1, \"1\", 2, 3] Array.from(new Set([1, \"1\", 2, 1, 1, 3])) // [1, \"1\", 2, 3] 19、用最短的代码实现一个长度为m(6)且值都n(8)的数组 Array(6).fill(8) // [8, 8, 8, 8, 8, 8] 20、取出一个数组中的最大值和最小值 var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411]; var maxInNumbers = Math.max.apply(Math, numbers); var minInNumbers = Math.min.apply(Math, numbers); 21、 将argruments对象转换成数组 // ES5 var argArray = Array.prototype.slice.call(arguments); // ES6 var argArray = Array.from(arguments) 22、 从一个数组中找到一个数，O(n)的算法，找不到就返回 null。 正常的版本: function find (x, y) { for ( let i = 0; i 结果到了函数式成了下面这个样子（好像上面的那些代码在下面若影若现，不过又有点不太一样，为了消掉if语言，让其看上去更像一个表达式，动用了 ? 号表达式）： 函数式的版本 const find = (f => f(f))(f => (next => (x, y, i = 0) => (i >= x.length) ? null : (x[i] == y) ? i : next(x, y, i + 1))((...args) => (f(f))(...args))) let arr = [0,1,2,3,4,5] console.log(find(arr, 2)) console.log(find(arr, 8)) "},"手撸代码无敌/简单的shift.html":{"url":"手撸代码无敌/简单的shift.html","title":"自己实现简单的shift()","keywords":"","body":"自己实现简单的shift() shift()方法从数组中删除第一个元素，并返回该元素的值，此方法会改变数组的长度。 如果数组为空则返回undefined。 此方法会改变数组自身。 Array.prototype.shift = function () { var temp = this[0]; for (var i = 1; i "},"手撸代码无敌/迭代函数与迭代函数的实现.html":{"url":"手撸代码无敌/迭代函数与迭代函数的实现.html","title":"迭代函数与迭代函数的实现","keywords":"","body":"JavaScript的迭代函数与迭代函数的实现 ES5提供的迭代函数 forEach(): 对数组中的每一项运行给定函数,无返回值 every()： 对数组中的每一项运行给定函数,如果该函数每一项都返回true,则返回true some(): 对数组中的每一项运行给定函数,如果该函数任意一项返回true,则返回true map(): 数组中的每一项运行给定函数,返回每次函数调用的结果组成的数组 filter(): 对数组中的每一项运行给定函数,该函数会返回true的项组成的数组 参数说明 let array = [1,2,3,4,5,6,7,8,9] array.forEach((element,index,array) => { console.log(`当前遍历元素${element}`); console.log(`当前元素位置${index}`); console.log(`数组本身${array}`); }) > 当前遍历元素1 > 当前元素位置0 > 数组本身1,2,3,4,5,6,7,8,9 > 当前遍历元素2 > 当前元素位置1 > 数组本身1,2,3,4,5,6,7,8,9 > 当前遍历元素3 > 当前元素位置2 > 数组本身1,2,3,4,5,6,7,8,9 forEach可以说是最常用的一个迭代方法了,该方法没有返回值,与for循环的效果一样 forEach的第二个参数,js高程上说明 是运行该函数的作用域对象,可以看一下经典的例子 let obj2 = { name: '张三', times:[1,2,3], print:function () { this.times.forEach(function(res) { console.log(this.name); },this) } } // 迭代函数内部的function默认指向windows 第二个参数调整了this指向 obj2.print() // 张三 // 张三 // 张三 箭头函数的写法 let obj2 = { name: '张三', times:[1,2,3], print:function () { this.times.forEach(res => { console.log(name); }) } } // 箭头函数this指向父级,所以他不需要调整this obj2.print() // 张三 // 张三 // 张三 every(判断函数) 对数组中的每一项运行给定函数,如果该函数每一项都返回true,则返回true 默认返回false var array = [1,2,3,4,5,6,7,8,9] var result = array.every(e => {}) console.log(result); // // false 全部ture才会返回true var array = [1,2,3,4,5,6,7,8,9] var result = array.every(e => { return e > 0 }) console.log(result); > true var array = [1,2,3,4,5,6,7,8,9] var result = array.every(e => { return e > 1 }) console.log(result); // false some(判断函数) 对数组中的每一项运行给定函数,如果该函数任意一项返回true,则返回true 默认返回false var array = [1,2,3,4,5,6,7,8,9] var result = array.some(e => {}) console.log(result); // // false 全部false才会返回false var array = [1,2,3,4,5,6,7,8,9] var result = array.some(e => { return e > 8 }) console.log(result); var array = [1,2,3,4,5,6,7,8,9] var result = array.some(e => { return e > 9 }) console.log(result); // false filter(过滤函数) 对数组中的每一项运行给定函数,该函数会返回true的项组成的数组 var array = [1,2,3,4,5,6,7,8,9] var result = array.filter(e => { return e>5 }) console.log(result); // [6, 7, 8, 9] map(处理函数) 对数组中的每一项运行给定函数,返回每次函数调用的结果组成的数组 var array = [1,2,3,4,5,6,7,8,9] var result = array.map(e => { return e>5 }) console.log(result); > [false, false, false, false, false, true, true, true, true] var array = [1,2,3,4,5,6,7,8,9] var result = array.map(e => { return e*2 }) console.log(result); // [2, 4, 6, 8, 10, 12, 14, 16, 18] forEach(迭代函数) 对数组中的每一项运行给定函数,无返回值 var array = [1,2,3,4,5,6,7,8,9] var arraypush = [] var result = array.forEach(e => { if (e > 5) { arraypush.push(e) } }) console.log(arraypush); // [6, 7, 8, 9] 最纯粹的迭代函数,似乎forEach是处理外部数组最好的选择 自实现迭代器 实现forEach 首先明显forEach是Array上的原型链上的函数所以第一件事就是创建一个原型方法 Array.prototype.MyforEach = function (){} forEach 第一个参数为一个匿名函数 第二个参数为this指向 所以 Array.prototype.MyforEach = function (fn,obj){} forEach会迭代调用它的数组所以内部肯定是循环 Array.prototype.MyforEach = function (fn,obj){ let len = this.length for (let i = 0; i 但还没有考虑this指向的事情,所以还需要添加一些调整this的代码 Array.prototype.MyforEach = function (fn,obj){ let len = this.length if (obj != undefined) { fn = fn.bind(obj) } for (let i = 0; i 实现map map与forEach的区别是 map中如果是运算,会返回每次函数调用的新的结果组成的数组 map中如果是判断,会返回每次迭代结果组成的数组 所以只要在迭代函数内部创建一个数组,每次迭代都push进去,最后返回出去就好 Array.prototype.Mymap = function (fn,obj){ var resultData = [] var len = this.length if (obj != undefined) { fn = fn.bind(obj) } for (let i = 0; i 实现 some every some与every都会有一个特点 默认返回false 不同的地方在于 some要求 全部返回false返回false ​every要求 全部返回true返回true // -- every -- Array.prototype.Myevery = function (fn,obj) { var len = this.length if (obj != undefined) { fn = fn.bind(obj) } for (let i = 0; i 实现fliter Array.prototype.Myfilter = function (fn, obj) { let resultData = [] var len = this.length if (obj != undefined) { fn = fn.bind(obj) } for (let i = 0; i { return e>5 }) console.log(result); // [6, 7, 8, 9] "},"手撸代码无敌/startsWith.html":{"url":"手撸代码无敌/startsWith.html","title":"startsWith()","keywords":"","body":"ES6 startsWith() Polyfill /*! http://mths.be/startswith v0.2.0 by @mathias */ if (!String.prototype.startsWith) { (function() { 'use strict'; // needed to support `apply`/`call` with `undefined`/`null` var defineProperty = (function() { // IE 8 only supports `Object.defineProperty` on DOM elements try { var object = {}; var $defineProperty = Object.defineProperty; var result = $defineProperty(object, object, object) && $defineProperty; } catch(error) {} return result; }()); var toString = {}.toString; var startsWith = function(search) { if (this == null) { throw TypeError(); } var string = String(this); if (search && toString.call(search) == '[object RegExp]') { throw TypeError(); } var stringLength = string.length; var searchString = String(search); var searchLength = searchString.length; var position = arguments.length > 1 ? arguments[1] : undefined; // `ToInteger` var pos = position ? Number(position) : 0; if (pos != pos) { // better `isNaN` pos = 0; } var start = Math.min(Math.max(pos, 0), stringLength); // Avoid the `indexOf` call if no match is possible if (searchLength + start > stringLength) { return false; } var index = -1; while (++index "},"手撸代码无敌/endsWith.html":{"url":"手撸代码无敌/endsWith.html","title":"endsWith()","keywords":"","body":"ES6 endsWith() Polyfill if (!String.prototype.endsWith) { String.prototype.endsWith = function(search, this_len) { if (this_len === undefined || this_len > this.length) { this_len = this.length; } return this.substring(this_len - search.length, this_len) === search; }; } "},"手撸代码无敌/trim.html":{"url":"手撸代码无敌/trim.html","title":"String.prototype.trim()","keywords":"","body":"String.prototype.trim() if (!String.prototype.trim) { String.prototype.trim = function () { return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''); }; } "},"手撸代码无敌/repeat.html":{"url":"手撸代码无敌/repeat.html","title":"String.prototype.repeat()","keywords":"","body":"String.prototype.repeat() repeat() 构造并返回一个新字符串，该字符串包含被连接在一起的指定数量的字符串的副本。 语法 /** * str: String * count: Number */ let resultString = str.repeat(count); 示例 \"abc\".repeat(-1) // RangeError: repeat count must be positive and less than inifinity \"abc\".repeat(0) // \"\" \"abc\".repeat(1) // \"abc\" \"abc\".repeat(2) // \"abcabc\" \"abc\".repeat(3.5) // \"abcabcabc\" 参数count将会被自动转换成整数. \"abc\".repeat(1/0) // RangeError: repeat count must be positive and less than inifinity ({toString : () => \"abc\", repeat : String.prototype.repeat}).repeat(2) //\"abcabc\",repeat是一个通用方法,也就是它的调用者可以不是一个字符串对象. polyfill if (!String.prototype.repeat) { String.prototype.repeat = function(count) { 'use strict'; if (this == null) { throw new TypeError('can\\'t convert ' + this + ' to object'); } var str = '' + this; count = +count; if (count != count) { count = 0; } if (count = 1 >>= 1; if (count == 0) { break; } str += str; } return rpt; } } "},"手撸代码无敌/padStart.html":{"url":"手撸代码无敌/padStart.html","title":"String.prototype.padStart()","keywords":"","body":"String.prototype.padStart() padStart() 方法用另一个字符串填充当前字符串(重复，如果需要的话)，以便产生的字符串达到给定的长度。填充从当前字符串的开始(左侧)应用的。 str.padStart(targetLength [, padString]) targetLength 当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 padString 可选 填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的缺省值为 \" \"（U+0020）。 返回值 在原字符串开头填充指定的填充字符串直到目标长度所形成的新字符串。 示例 'abc'.padStart(10); // \" abc\" 'abc'.padStart(10, \"foo\"); // \"foofoofabc\" 'abc'.padStart(6,\"123465\"); // \"123abc\" 'abc'.padStart(8, \"0\"); // \"00000abc\" 'abc'.padStart(1); // \"abc\" polyfill 如果原生环境不支持该方法，在其他代码之前先运行下面的代码，将创建 String.prototype.padStart() 方法。 // https://github.com/uxitten/polyfill/blob/master/string.polyfill.js // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padStart if (!String.prototype.padStart) { String.prototype.padStart = function padStart(targetLength,padString) { targetLength = targetLength>>0; //floor if number or convert non-number to 0; padString = String((typeof padString !== 'undefined' ? padString : ' ')); if (this.length > targetLength) { return String(this); } else { targetLength = targetLength-this.length; if (targetLength > padString.length) { padString += padString.repeat(targetLength/padString.length); //append to original to ensure we are longer than needed } return padString.slice(0,targetLength) + String(this); } }; } "},"手撸代码无敌/padEnd.html":{"url":"手撸代码无敌/padEnd.html","title":"String.prototype.padEnd()","keywords":"","body":"String.prototype.padEnd() padEnd() 方法会用一个字符串填充当前字符串（如果需要的话则重复填充），返回填充后达到指定长度的字符串。从当前字符串的末尾（右侧）开始填充。 str.padEnd(targetLength [, padString]) targetLength 当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。 padString 可选 填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断。此参数的缺省值为 \" \"（U+0020）。 返回值 在原字符串末尾填充指定的填充字符串直到目标长度所形成的新字符串。 示例 'abc'.padEnd(10); // \"abc \" 'abc'.padEnd(10, \"foo\"); // \"abcfoofoof\" 'abc'.padEnd(6, \"123456\"); // \"abc123\" 'abc'.padEnd(1); // \"abc\" polyfill 如果原生环境不支持该方法，在其他代码之前先运行下面的代码，将创建 String.prototype.padEnd() 方法。 // https://github.com/uxitten/polyfill/blob/master/string.polyfill.js // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd if (!String.prototype.padEnd) { String.prototype.padEnd = function padEnd(targetLength,padString) { targetLength = targetLength>>0; //floor if number or convert non-number to 0; padString = String((typeof padString !== 'undefined' ? padString: '')); if (this.length > targetLength) { return String(this); } else { targetLength = targetLength-this.length; if (targetLength > padString.length) { padString += padString.repeat(targetLength/padString.length); //append to original to ensure we are longer than needed } return String(this) + padString.slice(0,targetLength); } }; } "},"手撸代码无敌/实现一个JSON.stringify.html":{"url":"手撸代码无敌/实现一个JSON.stringify.html","title":"实现一个JSON.stringify","keywords":"","body":""},"手撸代码无敌/实现一个JSON.parse.html":{"url":"手撸代码无敌/实现一个JSON.parse.html","title":"实现一个JSON.parse","keywords":"","body":"实现一个JSON.parse JSON.parse(text[, reviver]) 用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)。 第一种：直接调用 eval function jsonParse(opt) { return eval('(' + opt + ')'); } jsonParse(jsonStringify({x : 5})) // Object { x: 5} jsonParse(jsonStringify([1, \"false\", false])) // [1, \"false\", falsr] jsonParse(jsonStringify({b: undefined})) // Object { b: \"undefined\"} 避免在不必要的情况下使用 eval，eval() 是一个危险的函数， 他执行的代码拥有着执行者的权利。如果你用 eval()运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码。 它会执行JS代码，有XSS漏洞。 如果你只想记这个方法，就得对参数json做校验。 var rx_one = /^[\\],:{}\\s]*$/; var rx_two = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g; var rx_three = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g; var rx_four = /(?:^|:|,)(?:\\s*\\[)+/g; if ( rx_one.test( json .replace(rx_two, \"@\") .replace(rx_three, \"]\") .replace(rx_four, \"\") ) ) { var obj = eval(\"(\" +json + \")\"); } 第二种：Function 核心：Function与eval有相同的字符串参数特性。 var func = new Function(arg1, arg2, ..., functionBody); 在转换JSON的实际应用中，只需要这么做。 var jsonStr = '{ \"age\": 20, \"name\": \"jack\" }' var json = (new Function('return ' + jsonStr))(); eval 与 Function 都有着动态编译js代码的作用，但是在实际的编程中并不推荐使用。 "},"手撸代码无敌/实现一个继承.html":{"url":"手撸代码无敌/实现一个继承.html","title":"实现一个继承","keywords":"","body":"实现一个继承 寄生组合式继承 一般只建议写这种，因为其它方式的继承会在一次实例中调用两次父类的构造函数或有其它缺点。 核心实现是：用一个 F 空的构造函数去取代执行了 Parent 这个构造函数。 function Parent(name) { this.name = name; } Parent.prototype.sayName = function() { console.log('parent name:', this.name); } function Child(name, parentName) { Parent.call(this, parentName); this.name = name; } function create(proto) { function F(){} F.prototype = proto; return new F(); } Child.prototype = create(Parent.prototype); Child.prototype.sayName = function() { console.log('child name:', this.name); } Child.prototype.constructor = Child; var parent = new Parent('father'); parent.sayName(); // parent name: father var child = new Child('son', 'father'); "},"手撸代码无敌/JS深拷贝.html":{"url":"手撸代码无敌/JS深拷贝.html","title":"Js深拷贝","keywords":"","body":"手写一个JS深拷贝 手写一个JS深拷贝 乞丐版 面试够用版 乞丐版 var newObj = JSON.parse( JSON.stringify( someObj ) ); 面试够用版 function deepCopy(obj){ //判断是否是简单数据类型， if(typeof obj == \"object\"){ //复杂数据类型 var result = obj.constructor == Array ? [] : {}; for(let i in obj){ result[i] = typeof obj[i] == \"object\" ? deepCopy(obj[i]) : obj[i]; } }else { //简单数据类型 直接 == 赋值 var result = obj; } return result; } "},"手撸代码无敌/实现系统Math.max方法.html":{"url":"手撸代码无敌/实现系统Math.max方法.html","title":"实现系统Math.max方法","keywords":"","body":"实现系统Math.max方法 // 自己定义一个对象，实现系统的 max 方法 function Mymax() { // 添加一个方法 this.getMax = function () { // 假设这个数是最大值 var max = arguments[0]; for(var i = 0; i "},"手撸代码无敌/通用进制转换.html":{"url":"手撸代码无敌/通用进制转换.html","title":"通用进制转换","keywords":"","body":"通用进制转换 function Stack() { let items = []; this.push = function(element) { items.push(element); }; this.pop = function() { return items.pop(); }; this.peek = function() { return items[items.length - 1]; }; this.isEmpty = function() { return items.length == 0; }; this.size = function() { return items.length; }; this.clear = function() { items = []; }; this.print = function() { console.log(items.toString()); }; this.toString = function() { return items.toString(); }; } //233 == 11101001 //2x(10x10) + 3x(10) + 3x(1) function divideBy2(decNumber) { var remStack = new Stack(), rem, binaryString = \"\"; while (decNumber > 0) { rem = Math.floor(decNumber % 2); remStack.push(rem); decNumber = Math.floor(decNumber / 2); } while (!remStack.isEmpty()) { binaryString += remStack.pop().toString(); } return binaryString; } console.log(divideBy2(233)); console.log(divideBy2(10)); console.log(divideBy2(1000)); /* * The folow algorithm converts from base 10 to any base */ function baseConverter(decNumber, base) { var remStack = new Stack(), rem, baseString = \"\", digits = \"0123456789ABCDEF\"; while (decNumber > 0) { rem = Math.floor(decNumber % base); remStack.push(rem); decNumber = Math.floor(decNumber / base); } while (!remStack.isEmpty()) { baseString += digits[remStack.pop()]; } return baseString; } console.log(baseConverter(100345, 2)); console.log(baseConverter(100345, 8)); console.log(baseConverter(100345, 16)); "},"设计模式/":{"url":"设计模式/","title":"设计模式","keywords":"","body":"JavaScript设计模式与开发实践 所有设计模式的实现都遵循一条原则，即“找出程序中变化的地方，并将变化封装起来”。一个程序的设计总是可以分为可变的部分和不变的部分。当我们找出可变的部分，并且把这部分封装起来，那么剩下的就是不变和稳定的部分。 JavaScript没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。JavaScript也没有在语言层面提供对抽象类和接口的支持。所以在JavaScript用设计模式编写代码的时候，要跟传统面向对象语言加以区分。 单例模式 策略模式 代理模式 迭代器模式 发布-订阅模式(观察者模式) 命令模式 组合模式 模板方法模式 享元模式 职责链模式 中介者模式 装饰者模式 状态模式 适配器模式 ES5&&ES6实现观察者模式 策略设计模式和ES6的Proxy代理模式 "},"设计模式/单例模式.html":{"url":"设计模式/单例模式.html","title":"单例模式","keywords":"","body":"单例模式 单例模式的定义是：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如线程池、全军缓存、浏览器中的window对象等。 惰性单例-点击登录弹出登录浮窗 登录 // 创建实例对象的职责 let createLoginLayer = function () { let div = document.createElement('div') div.innerHTML = '我是登录浮窗' div.style.display = 'none' document.body.appendChild(div) return div } let createIframeLayer = function () { let iframe = document.createElement('iframe') document.body.appendChild(iframe) return iframe } // 管理单例的职责 let getSingle = function (fn) { let result return function () { return result || (result = fn.apply(this, arguments)) } } // 创建div浮窗 let createSingleLoginLayer = getSingle(createLoginLayer) // 点击多次都只会创建一个新的登录浮层div document.getElementById('loginBtn').onclick = function () { let loginLayer = createSingleLoginLayer() loginLayer.style.display = 'block'; } "},"设计模式/策略模式.html":{"url":"设计模式/策略模式.html","title":"策略模式","keywords":"","body":"策略模式 策略模式的定义是：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。 策略模式的目的就是将算法的使用和算法的实现分离开来。说的更详细点就是：定义一些列的算法，把它们各自封装成策略类，算法被封装在策略类内部的方法里。在客户对Context发起请求的时候，Context总是把请求委托给这些策略对象中间的某一个进行计算。 // 普通实现 let calculateBonusCommon = (performanceLevel, salary) => { if (performanceLevel === 'S') { return salary * 4 } if (performanceLevel === 'A') { return salary * 3 } if (performanceLevel === 'B') { return salary * 2 } } console.log(calculateBonusCommon('B', 20000)) console.log(calculateBonusCommon('S', 50000)) // 策略模式实现 // 策略类 let strategies = { 'S': (salary) => salary * 4, 'A': (salary) => salary * 3, 'C': (salary) => salary * 2 } // 环境类 let calculateBonus = (level, salary) => strategies[level](salary) console.log(calculateBonus('S', 20000)) console.log(calculateBonus('A', 10000)) 通过使用策略模式重构代码，我们消除了原程序中大片的条件分支语句。 "},"设计模式/代理模式.html":{"url":"设计模式/代理模式.html","title":"代理模式","keywords":"","body":"代理模式 代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。 代理模式的关键是，当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理之后，再把请求转交给本体对象。 虚拟代理实现图片预加载 // 加载图片 let myImage = (function () { let imgNode = document.createElement('img') document.body.appendChild(imgNode) return { setSrc: function (src) { imgNode.src = src } } })() // 代理对象proxyImage let proxyImage = (function () { let img = new Image img.onload = function () { myImage.setSrc(this.src) } return { setSrc: function (src) { myImage.setSrc('./loading.gif') img.src = src } } })() proxyImage.setSrc('https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1521956229659&di=36a2ea375f48e8328b3cab79e8b1ea0e&imgtype=0&src=http%3A%2F%2Ff0.topitme.com%2F0%2Fa9%2F3e%2F1164210455aae3ea90o.jpg') 如果有一天我们不再需要预加载，那么就不再需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了setSrc方法，在客户看来，代理对象和本体是一致的。 // 乘积 let mult = function () { console.log('开始计算乘积') let a = 1 for (let i = 0, l = arguments.length; i "},"设计模式/迭代器模式.html":{"url":"设计模式/迭代器模式.html","title":"迭代器模式","keywords":"","body":"迭代器模式 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。 let each = function (ary, callback) { for (let i = 0, l = ary.length; i "},"设计模式/发布-订阅模式[观察者模式].html":{"url":"设计模式/发布-订阅模式[观察者模式].html","title":"发布-订阅模式(观察者模式)","keywords":"","body":"发布-订阅模式(观察者模式) 发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript开发中，我们一般用事件模型来代替传统的发布-订阅模式。 下面看实现发布-订阅模式的步骤 首先要指定好谁充当发布者。 然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者。 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数 // 全局发布-订阅对象 let Event = (function () { // 缓存列表，存放订阅者的回调函数 let clientList = {} let listen, trigger, remove // 增加订阅者 listen = (key, fn) => { if (!clientList[key]) { clientList[key] = [] } clientList[key].push(fn) }, // 发布消息 trigger = (...value) => { let key = Array.prototype.shift.call(value) let fns = clientList[key] // 如果没有绑定的对应的消息 if (!fns || fns.length === 0) { return false } for ( let i = 0, fn; fn = fns[i++]; ) { fn.apply(this, value) } }, // 取消订阅事件 remove = (key, fn) => { let fns = clientList[key] // 如果key对应的消息没有被人订阅，则直接返回 if (!fns) { return false } if (!fn) { // 如果没有传入具体的回调函数，表示需要取消key对应消息的所有订阅 fns && (fns.length = 0) } else { for (let l = fns.length - 1; l >= 0; l--) { let _fn = fns[l] if (_fn === fn) { fns.splice(l, 1) // 删除订阅者的回调函数 } } } } return { listen, trigger, remove } })() // 小明订阅消息 Event.listen('squareMeter88', fn1 = function (price, squareMeter) { console.log('小明先生：') console.log('price = ' + price) console.log('squareMeter = ' + squareMeter) }) // 小红订阅消息 Event.listen('squareMeter88', fn2 = function (price, squareMeter) { console.log('小红小姐：') console.log('price = ' + price) console.log('squareMeter = ' + squareMeter) }) // 售楼处发布消息 Event.trigger('squareMeter88', 10000, 88) Event.remove('squareMeter88', fn1) Event.trigger('squareMeter88', 15000, 88) Node.js中事件的发布与订阅 const Emitter = require('events').EventEmitter; const emitter = new Emitter(); emitter.on('someEvent',function(stream){ console.log(stream + 'from eventHandler1'); }); emitter.on('someEvent',function(stream){ console.log(stream + 'from eventHandler2'); }); emitter.emit('someEvent','I am a stream!'); 上面Node.js的 emitter对象中的 emitter.on是指发布事件”someEvent”，而emitter.emit是指触发事件,事件名称为”someEvent”.从而执行回调函数。在Node.js中我们可以发布很多事件，事件名称为someEvent，这样每一个回调就实现了一个业务逻辑，这样代码耦合性降低了。 自己实现一个事件的发布订阅类 class PubSub { constructor() { this.eventList = {}; } on(eventName, handle) { if (!(eventName in this.eventList)) { this.eventList[eventName] = []; } this.eventList[eventName].push(handle); return this; } emit(eventName, ...data) { const currentEvent = this.eventList[eventName]; if (Object.prototype.toString.call(currentEvent) !== \"[object Array]\") { return false; } currentEvent.forEach(item => { item.apply(null, data); }); return this; } } const pubsub = new PubSub(); // 订阅A事件 pubsub.on(\"A\", (...args) => { console.log(args); }); // 订阅B事件 pubsub.on(\"B\", (...args) => { console.log(args); }); // 发布A事件 pubsub.emit(\"A\", { name: \"zhaoyiming\", work: \"FE\" }); // 发布B事件 pubsub.emit(\"B\", \"event B\"); "},"设计模式/命令模式.html":{"url":"设计模式/命令模式.html","title":"命令模式","keywords":"","body":"命令模式 命令模式中的命令（command）指的是一个执行某些特定事情的指令。 命令模式最常见的应用场景是：有时候需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，使得请求发送者和请求接收者能够消除彼此之间的耦合关系。 let button1 = document.getElementById('button1') let button2 = document.getElementById('button2') let button3 = document.getElementById('button3') let MenuBar = { refresh: function() { console.log('刷新菜单界面') } } let SubMenu = { add: function () { console.log('增加子菜单') }, del: function () { console.log('删除子菜单') } } // 接收者被封闭在闭包产生的环境中，执行命令的操作可以更加简单，仅仅执行回调函数即可 let RefreshMenuBarCommand = function (receiver) { return { execute: function () { receiver.refresh() } } } let AddSubMenuBarCommand = function (receiver) { return { execute: function () { receiver.add() } } } let DelSubMenuBarCommand = function (receiver) { return { execute: function () { receiver.del() } } } // setCommand函数负责往按钮上面安装命令 let setCommand = function (button, command) { button.onclick = function () { command.execute() } } let refreshMenuBarCommand = RefreshMenuBarCommand(MenuBar) setCommand(button1, refreshMenuBarCommand) let addSubMenuBarCommand = AddSubMenuBarCommand(SubMenu) setCommand(button2, addSubMenuBarCommand) let delSubMenuBarCommand = DelSubMenuBarCommand(SubMenu) setCommand(button2, delSubMenuBarCommand) 宏命令是一组命令的集合，通过执行宏命令的方式，可以一次执行一批命令。 let closeDoorCommand = { execute: function () { console.log('关门') } } let openPcCommand = { execute: function () { console.log('开电脑') } } let openQQCommand = { execute: function () { console.log('登录QQ') } } let MacroCommand = function () { return { commandsList: [], add: function (command) { this.commandsList.push(command) }, execute: function() { for (let i =0, command; command = this.commandsList[i++];) { command.execute() } } } } let macroCommand = MacroCommand() macroCommand.add(closeDoorCommand) macroCommand.add(openPcCommand) macroCommand.add(openQQCommand) macroCommand.execute() "},"设计模式/组合模式.html":{"url":"设计模式/组合模式.html","title":"组合模式","keywords":"","body":"组合模式 组合模式就是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的“孙对象”构成的。组合模式将对象组合成树形结构，以表示“部分-整体”的层次结构。除了用来表示树形结构之外，组合模式的另一个好处是通过对象的多态性表现，使得用户对单个对象和组合对象的使用具有一致性。 // 组合模式-扫描文件夹 // 文件夹 let Folder = function (name) { this.name = name this.files = [] } Folder.prototype.add = function (file) { this.files.push(file) } Folder.prototype.scan = function () { console.log('开始扫描文件夹：' + this.name) for(let i = 0, file; file = this.files[i++];) { file.scan() } } // 文件 let File = function (name) { this.name = name } File.prototype.add = function () { throw new Error('文件下面不能再添加文件') } File.prototype.scan = function () { console.log('开始扫描文件：' + this.name) } // 创建文件夹 let folder = new Folder('学习资料') let folder1 = new Folder('Javascript') let folder2 = new Folder('JQuery') // 创建文件 let file1 = new File('Javascript 设计模式与开发实践') let file2 = new File('精通JQuery') let file3 = new File('重构与模式') folder1.add(file2) folder2.add(file3) folder.add(file1) folder.add(file2) folder.add(file3) folder.add(folder1) folder.add(folder2) folder.scan() "},"设计模式/模板方法模式.html":{"url":"设计模式/模板方法模式.html","title":"模板方法模式","keywords":"","body":"模板方法模式 模板方法模式是一种只需使用继承就可以实现的非常简单的模式。模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。在模板方法模式中，子类实现中的相同部分被上移到父类中，而将不同的部分留待子类来实现。这也很好地体现了泛化的思想。 let Beverage = function () {} Beverage.prototype.boilWater = function () { console.log('把水煮沸') } Beverage.prototype.brew = function () { throw new Error('子类必须重写brew方法') } Beverage.prototype.pourInCup = function () { throw new Error('子类必须重写pourInCup方法') } Beverage.prototype.addCondiments = function () { throw new Error('子类必须重写addCondiments方法') } // 钩子方法 Beverage.prototype.customerWantsCondiments = function () { return true // 默认需要调料 } // 模板方法 Beverage.prototype.init = function () { this.boilWater() this.brew() this.pourInCup() // 如果挂钩返回true。则需要调料 if (this.customerWantsCondiments()) { this.addCondiments() } } // 泡茶 let Tea = function () {} Tea.prototype = new Beverage() Tea.prototype.brew = function () { console.log('用沸水浸泡茶叶') } Tea.prototype.pourInCup = function () { console.log('把茶倒进杯子') } Tea.prototype.addCondiments = function () { console.log('加柠檬') } Tea.prototype.customerWantsCondiments = function () { return window.confirm('请问需要调料吗？') } let tea = new Tea() tea.init() //泡咖啡 let Coffee = function () {} Coffee.prototype = new Beverage() Coffee.prototype.brew = function () { console.log('用沸水冲泡咖啡') } Coffee.prototype.pourInCup = function () { console.log('把咖啡倒进杯子') } Coffee.prototype.addCondiments = function () { console.log('加牛奶和糖') } let coffee = new Coffee() coffee.init() 利用好莱坞原则，下面的代码可以达到和继承一样的效果 let Beverage = function(param) { let boilWater = function() { console.log(\"把水煮沸\"); }; let brew = param.brew || function() { throw new Error(\"必须传递brew方法\"); }; let pourInCup = param.pourInCup || function() { throw new Error(\"必须传递pourInCup方法\"); }; let addCondiments = param.addCondiments || function() { throw new Error(\"必须传递addCondiments方法\"); }; let customerWantsCondiments = param.customerWantsCondiments ? true : false; let F = function() {}; // 模板方法 F.prototype.init = function() { boilWater(); brew(); pourInCup(); if (customerWantsCondiments) { addCondiments(); } }; return F; }; let Coffee = Beverage({ brew: function() { console.log(\"用沸水冲泡咖啡\"); }, pourInCup: function() { console.log(\"把咖啡倒入杯子\"); }, addCondiments: function() { console.log(\"加糖和牛奶\"); } }); let coffee = new Coffee(); coffee.init(); let Tea = Beverage({ brew: function() { console.log(\"用沸水泡茶\"); }, pourInCup: function() { console.log(\"把茶倒入杯子\"); }, customerWantsCondiments: false }); let tea = new Tea(); tea.init(); "},"设计模式/享元模式.html":{"url":"设计模式/享元模式.html","title":"享元模式","keywords":"","body":"享元模式 享元模式是一种用于性能优化的模式。享元模式的核心是运用共享技术来有效支持大量细粒度的对象。 享元模式要求将对象的属性划分为内部状态和外部状态，把所有内部状态相同的对象都指定为同一个共享的对象。而外部状态可以从对象身上剥离出来，并存储在外部。 享元模式文件上传 // uploadType是内部状态，fileName和fileSize是根据场景而变化，每个文件fileName和 // fileSize都不一样，fileName和fileSize没有办法被共享，它们只能被划分为外部状态 let Upload = function (uploadType) { this.uploadType = uploadType } Upload.prototype.delFile = function (id) { uploadManager.setExternalState(id, this) if (this.fileSize 文件名称：' + fileName + ',文件大小：' + fileSize + '' + '删除' dom.querySelector('.delFile').onclick = function () { flyWeightObj.delFile(id) } document.body.appendChild(dom) uploadDatabase[id] = { fileName: fileName, fileSize: fileSize, dom: dom } return flyWeightObj }, setExternalState: function (id, flyWeightObj) { let uploadData = uploadDatabase[id] for (let i in uploadData) { flyWeightObj[i] = uploadData[i] } } } })() // 触发上传动作 let id = 0 window.startUpload = function (uploadType, files) { for (let i = 0, file; file = files[i++];) { let uploadObj = uploadManager.add(++id, uploadType, file.fileName, file.fileSize) } } startUpload('plugin', [ { fileName: '1.txt', fileSize: 1000 }, { fileName: '2.html', fileSize: 3000 }, { fileName: '3.txt', fileSize: 5000 } ]) startUpload('flash', [ { fileName: '4.txt', fileSize: 1000 }, { fileName: '5.html', fileSize: 3000 }, { fileName: '6.txt', fileSize: 5000 } ]) "},"设计模式/职责链模式.html":{"url":"设计模式/职责链模式.html","title":"职责链模式","keywords":"","body":"职责链模式 职责链模式的定义是：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 let order500 = function (orderType, pay, stock) { if (orderType === 1 && pay) { console.log('500元定金预购，得到100优惠券') } else { return 'nextSuccessor' } } let order200 = function (orderType, pay, stock) { if(orderType === 2 && pay) { console.log('200元定金预购，得到50优惠券') } else { return 'nextSuccessor' } } let orderNomal = function (orderType, pay, stock) { if (stock > 0) { console.log('普通购买，无优惠券') } else { console.log('手机库存不足') } } // 用AOP实现职责链 Function.prototype.after = function (fn) { let self = this return function () { let ret = self.apply(this, arguments) if (ret === 'nextSuccessor') { return fn.apply(this, arguments) } return ret } } let order = order500.after(order200).after(orderNomal) order(1, true, 500) order(2, true, 500) order(3, true, 500) order(1, false, 0) "},"设计模式/中介者模式.html":{"url":"设计模式/中介者模式.html","title":"中介者模式","keywords":"","body":"中介者模式 中介者模式的作用就是解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各个对象之间耦合松散，而且可以独立地改变它们之间的交互。 /** * @description player对象的原型方法中，不负责具体的执行逻辑，而是把操作转交给中介者对象。 * @param {any} name * @param {any} teamColor */ function Player (name, teamColor) { this.state = 'live' // 玩家状态 this.name = name // 角色名字 this.teamColor = teamColor // 队伍颜色 } // 玩家胜利 Player.prototype.win = function () { console.log('winner: ' + this.name) } // 玩家失败 Player.prototype.lose = function () { console.log('loser: ' + this.name) } // 玩家死亡 Player.prototype.die = function () { this.state = 'dead' // 给中介者发送消息，玩家死亡 playerDirector.ReceiveMessage('playerDead', this) } // 移除玩家 Player.prototype.remove = function () { // 给中介者发送消息，移除一个玩家 playerDirector.ReceiveMessage('removePlayer', this) } // 玩家换队 Player.prototype.changeTeam = function (color) { // 给中介者发送消息，玩家换队 playerDirector.ReceiveMessage('changeTeam', this, color) } /** * @description 工厂函数 */ let playerFactory = function (name, teamColor) { // 创造一个新的玩家对象 let newPlayer = new Player(name, teamColor) // 给中介者发送消息，新增玩家 playerDirector.ReceiveMessage('addPlayer', newPlayer) return newPlayer } /** * @description 中介者 */ let playerDirector = (function () { // 保存所有玩家 let players = {} // 中介者可以执行的操作 let operations = {} /******************* 新增一个玩家　******************/ operations.addPlayer = function (player) { // 玩家队伍的颜色 let teamColor = player.teamColor // 如果该颜色的玩家还没有成立队伍，则新成立一个队伍 players[teamColor] = players[teamColor] || [] // 添加玩家进队伍 players[teamColor].push(player) } /******************* 移除一个玩家　******************/ operations.removePlayer = function (player) { // 玩家的队伍颜色 let teamColor = player.teamColor // 该队伍的所有成员 let teamPlayers = players[teamColor] || [] // 遍历删除 for (let i = teamPlayers.length - 1; i >=0; i--) { if(teamPlayers[i] === player) { teamPlayers.splice(i, 1) } } } /******************* 玩家换队　******************/ operations.changeTeam = function (player, newTeamColor) { operations.removePlayer(player) player.teamColor = newTeamColor operations.addPlayer(player) } /******************* 玩家死亡　******************/ operations.playerDead = function (player) { // 玩家的队伍颜色 let teamColor = player.teamColor // 玩家所在队伍 let teamPlayers = players[teamColor] let all_dead = true for (let i = 0, player; player = teamPlayers[i++];) { if (player.state !== 'dead') { all_dead = false break } } if (all_dead) { // 本队所有玩家都输了 for(let i = 0, player; player = teamPlayers[i++];) { player.lose() } for (let color in players) { if (color !== teamColor) { // 其他队伍的玩家 let teamPlayers = players[color] // 其他队伍所有玩家胜利 for (let i = 0, player; player = teamPlayers[i++];) { player.win() } } } } } /********* 负责接收player对象发送的消息　*********/ let ReceiveMessage = function () { let message = Array.prototype.shift.call(arguments) operations[message].apply(this, arguments) } return { ReceiveMessage: ReceiveMessage } })() // 红队 let player1 = playerFactory('皮蛋', 'red') let player2 = playerFactory('小乖', 'red') let player3 = playerFactory('小强', 'red') let player4 = playerFactory('小雪', 'red') let player5 = playerFactory('小明', 'red') // 蓝队 let player6 = playerFactory('黑妞', 'blue') let player7 = playerFactory('兔头', 'blue') let player8 = playerFactory('胖墩', 'blue') let player9 = playerFactory('海盗', 'blue') let player10 = playerFactory('大仙', 'blue') // 黄队 let player11 = playerFactory('大牛', 'yellow') let player12 = playerFactory('小王', 'yellow') let player13 = playerFactory('小刘', 'yellow') let player14 = playerFactory('小陈', 'yellow') let player15 = playerFactory('小马', 'yellow') player1.remove() player2.changeTeam('yellow') player3.die() player4.die() player5.die() "},"设计模式/装饰者模式.html":{"url":"设计模式/装饰者模式.html","title":"装饰者模式","keywords":"","body":"装饰者模式 装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。 Function.prototype.before = function (beforefn) { // 保存原函数的引用 let _self = this // 返回包含了原函数好新函数的代理函数 return function () { // 执行函数，且保证this不会被劫持，新函数接受的参数也会 // 原封不动地传入原函数，新函数在原函数之前执行 beforefn.apply(this, arguments) // 执行原函数并返回原函数的执行结果，并且保证this不被劫持 return _self.apply(this, arguments) } } Function.prototype.after = function (afterfn) { let _self = this return function () { let ret = _self.apply(this, arguments) afterfn.apply(this, arguments) return ret } } window.onload = function () { console.log('1') } window.onload = (window.onload() || function () {}).after(function () { console.log('2') }).after(function () { console.log('3') }).after(function () { console.log('4') }) "},"设计模式/状态模式.html":{"url":"设计模式/状态模式.html","title":"状态模式","keywords":"","body":"状态模式 状态模式的定义：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 状态模式的关键是区分事物内部的状态，事物内部状态的改变往往会带来事物的行为改变。状态模式把事物的每种状态都封装成单独的类，跟此种状态有关的行为都被封装在这个类的内部。 // 每个状态都必须实现buttonWasPressed方法 let State = function () { } State.prototype.buttonWasPressed = function () { throw new Error('父类的buttonWasPressed方法必须被重写') } // OffLightState let OffLightState = function (light) { this.light = light } OffLightState.prototype = new State() OffLightState.prototype.buttonWasPressed = function () { console.log('弱光') // 切换状态到weakLightState this.light.setState(this.light.weakLightState) } // WeakLightState let WeakLightState = function (light) { this.light = light } WeakLightState.prototype = new State() WeakLightState.prototype.buttonWasPressed = function () { console.log('强光') this.light.setState(this.light.strongLightState) } // StrongLightState let StrongLightState = function (light) { this.light = light } StrongLightState.prototype = new State() StrongLightState.prototype.buttonWasPressed = function () { console.log('关灯') this.light.setState(this.light.offLightState) } // Light类 let Light = function () { this.offLightState = new OffLightState(this) this.weakLightState = new WeakLightState(this) this.strongLightState = new StrongLightState(this) this.button = null } Light.prototype.init = function () { let button = document.createElement('button') let self = this this.button = document.body.appendChild(button) this.button.innerHTML = '开关' this.currState = this.offLightState this.button.onclick = function () { self.currState.buttonWasPressed() } } Light.prototype.setState = function (newState) { this.currState = newState } let light = new Light() light.init() "},"设计模式/适配器模式.html":{"url":"设计模式/适配器模式.html","title":"适配器模式","keywords":"","body":"适配器模式 适配器模式主要用来解决两个已有接口之间不匹配的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。 let googleMap = { show: function () { console.log('开始渲染谷歌地图') } } let baiduMap = { show: function () { console.log('开始渲染谷歌地图') } } let sosoMap = { display: function () { console.log('开始渲染搜搜地图') } } // 适配器模式 let sosoMapAdapter = { show: function () { return sosoMap.display() } } let renderMap = function (map) { if (map.show instanceof Function) { map.show() } } renderMap(googleMap) renderMap(baiduMap) renderMap(sosoMapAdapter) "},"设计模式/策略设计模式和ES6的Proxy代理模式.html":{"url":"设计模式/策略设计模式和ES6的Proxy代理模式.html","title":"策略设计模式和ES6的Proxy代理模式","keywords":"","body":"探索两种优雅的表单验证——策略设计模式和ES6的Proxy代理模式 探索两种优雅的表单验证——策略设计模式和ES6的Proxy代理模式 常规验证 1.问题 2.思路 3. 策略模式 4. 用策略模式重构表单校验 4.1具体策略角色——编写策略类 4.2抽象策略角色——编写Validator类 4.3环境角色——客户端调用代码 4.4策略模式的优缺点 4.5策略模式的意义 关于ES6d的Proxy对象 1、概述 2、利用Proxy重构表单验证 在一个Web项目中，注册，登录，修改用户信息，下订单等功能的实现都离不开提交表单。这篇文章就阐述了如何编写相对看着舒服的表单验证代码。 假设我们正在编写一个注册的页面，在点击注册按钮之前，有如下几条校验逻辑。 [x] 所有选项不能为空 [x] 用户名长度不能少于6位 [x] 密码长度不能少于6位 [x] 手机号码必须符合格式 [x] 邮箱地址必须符合格式 简要说明： 这里我们前端只做浏览器端的校验。很多工具可以在表单检验过后、浏览器发送请求前截取表单数据，攻击者可以修改请求中的数据，从而绕过 JavaScript，将恶意数据注入服务器，这样会增加XSS（全称 Cross Site Scripting）攻击的机率。对于一般的网站，都不赞成采用浏览器端的表单验证方法。浏览器端和服务器端双重验证方法在浏览器端验证方法基础上增加服务器端的验证，其原理如图所示，该方法增加服务器端的验证，弥补了传统浏览器端验证的缺点。若表单输入不符合要求，浏览器端的 Javascript 验证能很快地给出响应，而服务器端的验证则可以防止恶意用户绕过 Javascript 验证，保证最终数据的准确性。 常规验证 HTML代码： 探索几种表单验证最佳实践方式 请输入用户名: 请输入密码: 请输入手机号码: 请输入邮箱: Submit JavaScript代码： let registerForm = document.querySelector('#registerForm') registerForm.addEventListener('submit', function() { if (registerForm.userName.value === '') { alert('用户名不能为空！') return false } if (registerForm.userName.length 1.问题 这样编写代码，的确能够完成业务的需求，能够完成表单的验证，但是存在很多问题，比如： registerForm.addEventListener绑定的函数比较庞大，包含了很多的if-else语句，看着都恶心，这些语句需要覆盖所有的校验规则。 registerForm.addEventListener绑定的函数缺乏弹性，如果增加了一种新的校验规则，或者想要把密码的长度校验从6改成8，我们都必须深入registerForm.addEventListener绑定的函数的内部实现，这是违反了开放-封闭原则的。 算法的复用性差，如果程序中增加了另一个表单，这个表单也需要进行一些类似的校验，那我们很可能将这些校验逻辑复制得漫天遍野。 2.思路 不使用过多的 if - else 语句 // 获取表单form元素 let registerForm = document.querySelector('#registerForm') // 创建表单校验实例 let validator = new Validator(); // 编写校验配置 validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空') validator.add(registerForm.userName, 'minLength:6', '用户名长度不能小于6') // 开始校验，并接收错误信息 let errorMsg = validator.start() // 如果有错误信息输出，说明校验未通过 if(errorMsg){ alert(errorMsg) return false//阻止表单提交 } 3. 策略模式 策略模式，单纯的看它的名字”策略“，指的是做事情的方法，比如我们想到某个地方旅游，你可以有几种策略供选择： 飞机，嗖嗖嗖直接就到了，节省时间。 火车，可以选择高铁出行，专为飞机恐惧症者提供。 徒步，不失为一个锻炼身体的选择。 other method…… 在程序设计中，我们也经常遇到类似的情况，要实现一种方案有多种方案可以选择，比如，一个压缩文件的程序，即可选择zip算法，也可以选择gzip算法。 所以，做一件事你会有很多方法，也就是所谓的策略，而我们今天要讲的策略模式也就是这个意思，它的核心思想是，将做什么和谁去做相分离。所以，一个完整的策略模式要有两个类，一个是策略类，一个是环境类(主要类)，环境类接收请求，但不处理请求，它会把请求委托给策略类，让策略类去处理，而策略类的扩展是很容易的，这样，使得我们的代码易于扩展 4. 用策略模式重构表单校验 策略模式的组成 抽象策略角色：策略类，通常由一个接口或者抽象类实现。具体策略角色：包装了相关的算法和行为。环境角色：持有一个策略类的引用，最终给客户端用的 4.1具体策略角色——编写策略类 策略类很简单，它是由一组验证方法组成的对象，即策略对象，重构表单校验的代码，很显然第一步我们要把这些校验逻辑都封装成策略对象： /*策略对象*/ const strategies = { isNonEmpty(value, errorMsg) { return value === '' ? errorMsg : void 0 }, minLength(value, length, errorMsg) { return value.length 4.2抽象策略角色——编写Validator类 根据我们的思考，我们使用add方法添加验证配置，如下： validator.add(registerForm.userName, 'isNonEmpty', '用户名不能为空') validator.add(registerForm.userName, 'minLength:6', '用户名长度不能小于6') add方法接受三个参数，第一个参数是表单字段，第二个参数是策略对象中策略方法的名字，第三个参数是验证未通过的错误信息。然后使用 start 方法开始验证，若验证未通过，返回验证错误信息，如下： let errorMsg = validator.start() add方法第一个参数我们说过了，是要验证的表单元素，第二个参数是一个字符串，使用 冒号(:) 分割，前面是策略方法名称，后面是传给这个方法的参数，第三个参数仍然是错误信息。 但是这种参数配置还是有问题，我们的要求是多种校验规则，比如用户名既不能为空，又要满足用户名长度不小于6，并不是单一的，上面的为什么要写两次，这种看着就不舒服，这时候我就需要对配置参数做一点小小的改动，我们用数组来传递多个校验规则： validator.add(registerForm.userName, [{ strategy: 'isNonEmpty', errorMsg: '用户名不能为空！' }, { strategy: 'minLength:6', errorMsg: '用户名长度不能小于6位！' }]) 最后是Validator类的实现： /*Validator类*/ class Validator { constructor() { this.cache = [] //保存校验规则 } add(dom, rules) { for (let rule of rules) { let strategyAry = rule.strategy.split(':') //例如['minLength',6] let errorMsg = rule.errorMsg //'用户名不能为空' this.cache.push(() => { let strategy = strategyAry.shift() //用户挑选的strategy strategyAry.unshift(dom.value) //把input的value添加进参数列表 strategyAry.push(errorMsg) //把errorMsg添加进参数列表，[dom.value,6,errorMsg] return strategies[strategy].apply(dom, strategyAry) }) } } start() { for (let validatorFunc of this.cache) { let errorMsg = validatorFunc()//开始校验，并取得校验后的返回信息 if (errorMsg) {//r如果有确切返回值，说明校验没有通过 return errorMsg } } } } 4.3环境角色——客户端调用代码 使用策略模式重构代码以后，我们仅仅通过‘配置’的方式就可以完成一个表单的校验，这些校验规则也可以复用在程序的任何地方，还能作为插件的形式，方便地被移植到其他项目中。 /*客户端调用代码*/ let registerForm = document.querySelector('#registerForm') const validatorFunc = () => { let validator = new Validator() validator.add(registerForm.userName, [{ strategy: 'isNonEmpty', errorMsg: '用户名不能为空！' }, { strategy: 'minLength:6', errorMsg: '用户名长度不能小于6位！' }]) validator.add(registerForm.passWord, [{ strategy: 'isNonEmpty', errorMsg: '密码不能为空！' }, { strategy: 'minLength:', errorMsg: '密码长度不能小于6位！' }]) validator.add(registerForm.phoneNumber, [{ strategy: 'isNonEmpty', errorMsg: '手机号码不能为空！' }, { strategy: 'isMoblie', errorMsg: '手机号码格式不正确！' }]) validator.add(registerForm.emailAddress, [{ strategy: 'isNonEmpty', errorMsg: '邮箱地址不能为空！' }, { strategy: 'isEmail', errorMsg: '邮箱地址格式不正确！' }]) let errorMsg = validator.start() return errorMsg } registerForm.addEventListener('submit', function() { let errorMsg = validatorFunc() if (errorMsg) { alert(errorMsg) return false } }, false) 在修改某个校验规则的时候，只需要编写或者改写少量的代码。比如我们想要将用户名输入框的校验规则改成用户名不能少于4个字符。可以看到，这时候的修改是毫不费力的。代码如下： validator.add(registerForm.userName, [{ strategy: 'isNonEmpty', errorMsg: '用户名不能为空！' }, { strategy: 'minLength:4', errorMsg: '用户名长度不能小于4位！' }]) 4.4策略模式的优缺点 策略模式利用组合、委托和多态等技术思想，可以有效的避免多种条件选择语句； 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它易于切换，易于理解，易于拓展； 策略模式中的算法也可以复用在系统的其它地方，从而避免了许多重复的复制黏贴的工作； 在策略模式利用组合和委托来让Context拥有执行算法的能力，这也是继承一种更轻便的替代方案。 当然，策略模式也有一些缺点，但掌握了策略模式，这些缺点并不严重。 编写难度加大，代码量变多了，这是最直观的一个缺点，也算不上缺点，毕竟不能完全以代码多少来衡量优劣。 首先，使用策略模式会在程序中增加许多策略类或者策略对象，但实际上这比把它们负责的逻辑堆砌在Context中要好。 其次，要使用策略模式，必须了解所有的strategy，必须了解各个strategy之间的不同点，这样才能选择一个合适的strategy。比如，我们要选择一种合适的旅游出行路线，必须先了解选择飞机、火车、自行车等方案的细节。此时strategy要向客户暴露它的所有实现，这是违反最少知识原则的。 4.5策略模式的意义 策略模式使开发人员能够开发出由许多可替换的部分组成的软件，并且各个部分之间是弱连接的关系。 弱连接的特性使软件具有更强的可扩展性，易于维护；更重要的是，它大大提高了软件的可重用性。 关于ES6d的Proxy对象 策略模式固然可行，但是包装的有点多了，而且不便于书写，代码书写量增加了不少，也就是有一定门槛，那有没有更好的实现方式呢？我们能不能通过一层代理，在设置属性时候就去拦截它呢？这就是今天要讲到的ES6的Proxy对象。 1、概述 Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 let obj = new Proxy({}, { get (target, key, receiver) { console.log(`getting ${key}!`) return Reflect.get(target, key, receiver) }, set (target, key, value, receiver) { console.log(`setting ${key}!`) return Reflect.set(target, key, value, receiver) } }) 上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。 obj.count = 1 // setting count! ++obj.count // getting count! // setting count! // 2 上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 let proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 下面是另一个拦截读取属性行为的例子。 var proxy = new Proxy({}, { get: function(target, property) { return 35; } }); proxy.time // 35 proxy.name // 35 proxy.title // 35 上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。 2、利用Proxy重构表单验证 利用proxy拦截不符合要求的数据 function validator(target, validator, errorMsg) { return new Proxy(target, { _validator: validator, set(target, key, value, proxy) { let errMsg = errorMsg if (value == '') { alert(`${errMsg[key]}不能为空！`) return target[key] = false } let va = this._validator[key] if (!!va(value)) { return Reflect.set(target, key, value, proxy) } else { alert(`${errMsg[key]}格式不正确`) return target[key] = false } } }) } 负责校验的逻辑代码 const validators = { name(value) { return value.length > 6 }, passwd(value) { return value.length > 6 }, moblie(value) { return /^1(3|5|7|8|9)[0-9]{9}$/.test(value) }, email(value) { return /^\\w+([+-.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/.test(value) } } 客户端调用代码 const errorMsg = { name: '用户名', passwd: '密码', moblie: '手机号码', email: '邮箱地址' } const vali = validator({}, validators, errorMsg) let registerForm = document.querySelector('#registerForm') registerForm.addEventListener('submit', function() { let validatorNext = function*() { yield vali.name = registerForm.userName.value yield vali.passwd = registerForm.passWord.value yield vali.moblie = registerForm.phoneNumber.value yield vali.email = registerForm.emailAddress.value } let validator = validatorNext() validator.next(); !vali.name || validator.next(); //上一步的校验通过才执行下一步 !vali.passwd || validator.next(); !vali.moblie || validator.next(); }, false) 优点：条件和对象本身完全隔离开,后续代码的维护,代码整洁度,以及代码健壮性和复用性变得非常强。 缺点：兼容性不好，有babel怕啥，粗糙版，很多细节其实还可以优化，这里只提供一种思路。 "},"设计模式/ES5&&ES6实现观察者模式.html":{"url":"设计模式/ES5&&ES6实现观察者模式.html","title":"ES5 && ES6 实现观察者模式","keywords":"","body":"ES5 && ES6 实现观察者模式 观察者模式:观察者模式（Observer mode）指的是函数自动观察数据对象， 一旦对象有变化，函数就会自动执行。而js中最常见的观察者模式就是事件触发机制。 现在，让我们重新实现一个自定义事件。 ES5实现 要实现一个自定义事件，首先要想清楚我们要干什么。 要有一个对象，存储着它自己的触发函数，所以他的触发函数应该是这种类型 handler = { type1: type2: ... } 这个对象的触发函数可能有很多种，比如一个onclick可能触发多个事件，那么handler的属性应该是一个数组，每个数组的值都是一个函数 handler = { type1: [func1,func2...], type2: [func2,func4...], ... } 现在这个对象的主体部分已经思考好了，现在就是要它‘动起来’，给它添加各种动作。 一个事件可能有哪些动作呢？ add：添加事件某种类型的函数， remove: 移除某种类型的函数， fire：触发某种类型的函数, once:触发某种类型的函数，然后移除掉这个函数， 那么现在我们的自定义事件的骨架已经搭建好了。 ```js eventOb={ //函数储存 handler:{ type1:[func1,func2...], type2:[func2,func4...], ... }, //主要事件 add:function(){}, remove:function(){}, fire:function(){}, once:function(){}, } ``` 下面开始填充这些函数， 1. add 添加一个事件监听，首先传入参数应该是 事件类型type，和触发函数 func，传入的时候检测有没有这个函数，有了就不重复添加，那么代码并不难，应该是下面这样。 add: function (type,func) { //检测type是否存在 if(eventOb.handleFunc[type]) { //检测事件是否存在，不存在则添加 if(eventOb.handleFunc[type].indexOf(func)===-1) { eventOb.handleFunc[type].push(func); } } else { eventOb.handleFunc[type]=[func]; } }, 2. remove remove也需要指明传入类型和函数，和add很相像，首先我们就写成下面的样子 remove: function (type,func) { let target = eventOb.handleFunc[type]; let index=target.indexOf(func); target.splice(index,1); }, 看起来很简单，但是remove有一个潜在的需求，就是如果你的事件不存在，它应该会报错。而这里不会报错，index在func不存在的时候是-1；这时候不能正确的删除，也不会报错。 所以我们需要改进一下。 remove: function (type,func) { try{ let target = eventOb.handleFunc[type]; let index=target.indexOf(func); if(index===-1)throw error; target.splice(index,1); }catch (e){ console.error('别老想搞什么飞机，删除我有的东西！'); } }, 当index=-1抛出一个错误，好了，解决的很简陋，但是效果还行。 3. fire 触发一个点击事件肯定是要触发它全部的函数，这里也是一样，所以只需要传入type，然后事件可能不存在，像上面一样处理。 fire:function (type,func) { try{ let target = eventOb.handleFunc[type]; let count = target.length; for (var i = 0; i 看起来很还好。但是。。。嗯。先说once。 4. once once这里应该相当简单。感觉起来是这样。。。fire，然后remove？来试试 fire: function (type,func) { try{ let target = eventOb.handleFunc[type]; if(arguments.length===1) { //不传func则全部触发 let count = target.length; for (var i = 0; i 这样once就写好了？ 试试，对一个不存在的事件触发once，发现once会报两个错误， 这样当然不太好，想想，嗯可以给fire一个返回值，当fire报错就return false不执行remove 最后的once长这样 once: function (type,func) { eventOb.fire(type, func)? eventOb.remove(type, func):null; } 并且在fire上面 need code的地方补上return true 和return false，大功告成~ 完整代码: var eventOb = { // 函数储存 handleFunc:{}, add: function (type,func) { if(eventOb.handleFunc[type]){ //检测事件是否存在，不存在则添加 if(eventOb.handleFunc[type].indexOf(func)===-1){ eventOb.handleFunc[type].push(func); } }else{ eventOb.handleFunc[type]=[func]; } }, fire: function (type,func) { try{ let target = eventOb.handleFunc[type]; if(arguments.length===1) { // 不传func则全部触发 let count = target.length; for (var i = 0; i ES6 上面的一个实例我们发现是不能继承的，只有一个实例，我们要用ES5把它改造成一个可以继承的函数的话（并且使用最佳的组合继承模式），首先要把handleFunc挂载在this上，然后把方法挂载在eventOb的prototype上，使用es6则更显而易见。 class eventObs { constructor(){ this.handleFunc={} } add(type,func){ if(this.handleFunc[type]){ if(this.handleFunc[type].indexOf(func)===-1){ this.handleFunc[type].push(func); } }else{ this.handleFunc[type]=[func]; } }; fire(type,func){ try{ if(arguments.length===1) { let target = this.handleFunc[type]; let count = target.length; for (var i = 0; i "},"算法/":{"url":"算法/","title":"算法","keywords":"","body":"算法 算法思想 十大经典算法排序总结对比 快速排序 数组去重 冒泡排序 插入排序 选择排序 归并排序 二分法 排序数组 自己实现冒泡排序可视化 数组去重的十四种方法 Deepclone js数组里面任意两个数的和与目标值 反转字符串 仅仅反转字母 反转字符串中的元音字母 整数反转 两数相加 无重复字符的最长子串 寻找两个有序数组的中位数 最长回文子串 回文数 Z字形变换 字符串转换整数 (atoi) 正则表达式匹配 盛最多水的容器 接雨水 除自身以外数组的乘积 整数转罗马数字 罗马数字转整数 整数转换英文表示 数组类算法js(双指针) 两数之和 两数之和II-输入有序数组 两数之和 IV 输入BST 三数之和 最接近的三数之和 四数之和 最长公共前缀 电话号码的字母组合 删除链表的倒数第N个节点 有效的括号 括号生成 合并两个有序链表 合并两个有序数组 合并K个排序链表 删除排序数组中的重复项 删除排序数组中的重复项 II 移除元素 实现strStr() 串联所有单词的子串 最小覆盖子串 下一个排列 全排列 全排列 II 最长有效括号 搜索旋转排序数组 搜索旋转排序数组 II 寻找旋转排序数组中的最小值 寻找旋转排序数组中的最小值 II 在排序数组中查找元素的第一个和最后一个位置 第一个错误的版本 搜索插入位置 有效的数独 解数独 报数 压缩字符串 组合 组合总和 组合总和 II 组合总和 III 缺失的第一个正数 缺失数字 只出现一次的数字 找不同 寻找重复数 找到所有数组中消失的数字 情侣牵手 字符串相乘 加一 数组形式的整数加法 字符串相加 通配符匹配 跳跃游戏 跳跃游戏 II 旋转图像 字母异位词分组 有效的字母异位词 找到字符串中所有字母异位词 字符串的排列 Pow(x, n) 超级次方 x的平方根 有效的完全平方数 平方数之和 最大子序和 买卖股票的最佳时机 买卖股票的最佳时机 II 买卖股票的最佳时机 III 买卖股票的最佳时机 IV 最佳买卖股票时机含冷冻期 买卖股票的最佳时机含手续费 一个通用方法团灭 6 道股票问题 股票价格跨度 三个无重叠子数组的最大和 合并区间 插入区间 最后一个单词的长度 螺旋矩阵 螺旋矩阵 II 第k个排列 路径总和 路径总和 II 路径总和 III 求根到叶子节点数字之和 相同的树 图像渲染 岛屿的周长 岛屿的最大面积 边框着色 二分查找 不同路径 不同路径 II 最小路径和 斐波那契数 零钱兑换 零钱兑换 II N皇后 N皇后 II 颜色分类 子集 单词搜索 分治动态规划备忘录的区别 背包问题 背包问题 II "},"算法/算法思想.html":{"url":"算法/算法思想.html","title":"算法思想","keywords":"","body":"算法思想 算法思想 质数判断和筛选 十大排序 冒泡排序 单向冒泡 双向冒泡 选择排序 插入排序 快速排序 快速排序之填坑 快速排序之交换 归并排序 桶排序 基数排序 计数排序 常规计数排序 优化计数排序 堆排序 希尔排序 洗牌算法 二叉树 构造二叉树 根据先序遍历和中序遍历构造二叉树 根据后序遍历和中序遍历构造二叉树 遍历二叉树 先序遍历 递归 迭代 中序遍历 递归 迭代 后序遍历 递归 迭代 层序遍历 二叉排序树 KMP算法 质数判断和筛选 普通的质数判断方法。 function judge(n) { for(let i=2, len=Math.sqrt(n); i 厄拉多塞筛法，时间复杂度O(n * loglog n)：从 2 开始遍历，把 2 的倍数都标记为 false（表示不是素数），再从 2 的下一位素数 3 开始也同样标记其倍数。以此类推，最后仍为 true 的则为素数。 function choosePrimes(n = 10000) { // 标记是否为素数 let mark = Array(n).fill(true); // 存放素数 let primes = []; let index = 0; for(let i=2; i 十大排序 冒泡排序 通过相邻元素的比较和交换，使得每一趟循环都能找到未有序数组的最大值或最小值。 最好：O(n)，只需要冒泡一次数组就有序了。 最坏：O(n²) 平均：O(n²) 单向冒泡 function bubbleSort(nums) { for(let i=0, len=nums.length; i nums[j+1]) { [nums[j], nums[j+1]] = [nums[j+1], nums[j]]; mark = false; } } if(mark) return nums; } } 双向冒泡 普通的冒泡排序在一趟循环中只能找出一个最大值或最小值，双向冒泡则是多一轮循环既找出最大值也找出最小值。 function bubbleSort_twoWays(nums) { let low = 0; let high = nums.length - 1; while(low nums[i+1]) { [nums[i], nums[i+1]] = [nums[i+1], nums[i]]; mark = false; } } high--; // 找到最小值放到左边 for(let j=high; j>low; j--) { if(nums[j] 选择排序 和冒泡排序相似，区别在于选择排序是将每一个元素和它后面的元素进行比较和交换。 最好：O(n²) 最坏：O(n²) 平均：O(n²) function selectSort(nums) { for(let i=0, len=nums.length; i nums[j]) { [nums[i], nums[j]] = [nums[j], nums[i]]; } } } } 插入排序 以第一个元素作为有序数组，其后的元素通过在这个已有序的数组中找到合适的位置并插入。 最好：O(n)，原数组已经是升序的。 最坏：O(n²) 平均：O(n²) function insertSort(nums) { for(let i=1, len=nums.length; i= 0 && temp 快速排序 选择一个元素作为基数（通常是第一个元素），把比基数小的元素放到它左边，比基数大的元素放到它右边（相当于二分），再不断递归基数左右两边的序列。 最好：O(n * logn)，所有数均匀分布在基数的两边，此时的递归就是不断地二分左右序列。 最坏：O(n²) ，所有数都分布在基数的一边，此时划分左右序列就相当于是插入排序。 平均：O(n * logn) 快速排序动图演示： 参考学习链接： 算法 3：最常用的排序——快速排序 三种快速排序以及快速排序的优化 应用：TopK问题 数组中的第K个最大元素 快速排序之填坑 从右边向中间推进的时候，遇到小于基数的数就赋给左边（一开始是基数的位置），右边保留原先的值等之后被左边的值填上。 function quickSort(nums) { // 递归排序基数左右两边的序列 function recursive(arr, left, right) { if(left >= right) return; let index = partition(arr, left, right); recursive(arr, left, index - 1); recursive(arr, index + 1, right); return arr; } // 将小于基数的数放到基数左边，大于基数的数放到基数右边，并返回基数的位置 function partition(arr, left, right) { // 取第一个数为基数 let temp = arr[left]; while(left = temp) right--; arr[left] = arr[right]; while(left 快速排序之交换 从左右两边向中间推进的时候，遇到不符合的数就两边交换值。 function quickSort1(nums) { function recursive(arr, left, right) { if(left >= right) return; let index = partition(arr, left, right); recursive(arr, left, index - 1); recursive(arr, index + 1, right); return arr; } function partition(arr, left, right) { let temp = arr[left]; let p = left + 1; let q = right; while(p temp) q--; if(p 归并排序 递归将数组分为两个序列，有序合并这两个序列。 最好：O(n * logn) 最坏：O(n * logn) 平均：O(n * logn) 参考学习链接： 图解排序算法(四)之归并排序 归并排序：其基本思想是分治策略，先进行划分，然后再进行合并。 假设要对数组C进行归并排序，步骤是： 先将C划分为两个数组A和B（即把数组C从中间分开） 再分别对数组A、B重复步骤1的操作，逐步划分，直到不能再划分为止(每个子数组只剩下一个元素)，这样，划分的过程就结束了。如： [12 20 30 21 15 33 26 19 40 25] 划分为: [12 20 30 21 15] [33 26 19 40 25] [12 20] [30 21 15] [33 26] [19 40 25] [12] [20] [30] [21 15] [33] [26] [19] [40 25] [12] [20] [30] [21] [15] [33] [26] [19] [40] [25] 然后从下层往上层不断合并数组，每一层合并相邻的两个子数组，合并的过程是每次从待合并的两个子数组中选取一个最小的元素，然后把这个元素放到合并后的数组中，不断重复直到把两个子数组的元素都放到合并后的数组为止。 依次类推，直到合并到最上层结束，这时数据的排序已经完成了。 function merge(left, right) { var result = []; while (left.length > 0 && right.length > 0) { if (left[0] 桶排序 取 n 个桶，根据数组的最大值和最小值确认每个桶存放的数的区间，将数组元素插入到相应的桶里，最后再合并各个桶。 最好：O(n)，每个数都在分布在一个桶里，这样就不用将数插入排序到桶里了(类似于计数排序以空间换时间)。 最坏：O(n²)，所有的数都分布在一个桶里。 平均：O(n + k)，k表示桶的个数。 参考学习链接： 拜托，面试别再问我桶排序了！！！ function bucketSort(nums) { // 桶的个数，只要是正数即可 let num = 5; let max = Math.max(...nums); let min = Math.min(...nums); // 计算每个桶存放的数值范围，至少为1， let range = Math.ceil((max - min) / num) || 1; // 创建二维数组，第一维表示第几个桶，第二维表示该桶里存放的数 let arr = Array.from(Array(num)).map(() => Array().fill(0)); nums.forEach(val => { // 计算元素应该分布在哪个桶 let index = parseInt((val - min) / range); // 防止index越界，例如当[5,1,1,2,0,0]时index会出现5 index = index >= num ? num - 1 : index; let temp = arr[index]; // 插入排序，将元素有序插入到桶中 let j = temp.length - 1; while(j >= 0 && val { nums[i] = res[i]; }) return nums } 基数排序 使用十个桶 0-9，把每个数从低位到高位根据位数放到相应的桶里，以此循环最大值的位数次。但只能排列正整数，因为遇到负号和小数点无法进行比较。 最好：O(n * k)，k表示最大值的位数。 最坏：O(n * k) 平均：O(n * k) 参考学习链接： 算法总结系列之五: 基数排序(Radix Sort) function radixSort(nums) { // 计算位数 function getDigits(n) { let sum = 0; while (n) { sum++; n = parseInt(n / 10); } return sum; } // 第一维表示位数即0-9，第二维表示里面存放的值 let arr = Array.from(Array(10)).map(() => Array()); let max = Math.max(...nums); let maxDigits = getDigits(max); for (let i = 0, len = nums.length; i = 0; i--) { // 循环每一个桶 for (let j = 0; j { nums[index] = +res[index]; }); return nums; } 计数排序 以数组元素值为键，出现次数为值存进一个临时数组，最后再遍历这个临时数组还原回原数组。因为 JavaScript 的数组下标是以字符串形式存储的，所以计数排序可以用来排列负数，但不可以排列小数。 最好：O(n + k)，k是最大值和最小值的差。 最坏：O(n + k) 平均：O(n + k) 常规计数排序 function countingSort(nums) { let arr = []; let max = Math.max(...nums); let min = Math.min(...nums); // 装桶 for(let i=0, len=nums.length; i 0) { nums[index++] = i; arr[i]--; } } return nums; } 优化计数排序 把每一个数组元素都加上 min 的相反数，来避免特殊情况下的空间浪费，通过这种优化可以把所开的空间大小从 max+1 降低为 max-min+1，max 和 min 分别为数组中的最大值和最小值。 比如数组 [103, 102, 101, 100]，普通的计数排序需要开一个长度为 104 的数组，而且前面 100 个值都是 undefined，使用该优化方法后可以只开一个长度为 4 的数组。 function countingSort(nums) { let arr = []; let max = Math.max(...nums); let min = Math.min(...nums); // 加上最小值的相反数来缩小数组范围 let add = -min; for(let i=0, len=nums.length; i 0) { nums[index++] = i; temp--; } } return nums; } 堆排序 根据数组建立一个堆（类似完全二叉树），每个结点的值都大于左右结点（最大堆，通常用于升序），或小于左右结点（最小堆，通常用于降序）。对于升序排序，先构建最大堆后，交换堆顶元素（表示最大值）和堆底元素，每一次交换都能得到未有序序列的最大值。重新调整最大堆，再交换堆顶元素和堆底元素，重复 n-1 次后就能得到一个升序的数组。 最好：O(n * logn)，logn是调整最大堆所花的时间。 最坏：O(n * logn) 平均：O(n * logn) 参考学习链接： 常见排序算法 - 堆排序 (Heap Sort) 图解排序算法(三)之堆排序 function heapSort(nums) { // 调整最大堆，使index的值大于左右节点 function adjustHeap(nums, index, size) { // 交换后可能会破坏堆结构，需要循环使得每一个父节点都大于左右结点 while(true) { let max = index; let left = index * 2 + 1; // 左节点 let right = index * 2 + 2; // 右节点 if(left =0; i--) { adjustHeap(nums, i, size); } } buildHeap(nums); // 循环n-1次，每次循环后交换堆顶元素和堆底元素并重新调整堆结构 for(let i=nums.length-1; i>0; i--) { [nums[i], nums[0]] = [nums[0], nums[i]]; adjustHeap(nums, 0, i); } } 希尔排序 通过某个增量 gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至 1。希尔排序类似于插入排序，只是一开始向前移动的步数从 1 变成了 gap。 最好：O(n * logn)，步长不断二分。 最坏：O(n * logn) 平均：O(n * logn) 参考学习链接： 图解排序算法(二)之希尔排序 function shellSort(nums) { let len = nums.length; // 初始步数 let gap = parseInt(len / 2); // 逐渐缩小步数 while(gap) { // 从第gap个元素开始遍历 for(let i=gap; i=0; j-=gap) { if(nums[j] > nums[j+gap]) { [nums[j], nums[j+gap]] = [nums[j+gap], nums[j]]; } else { break; } } } gap = parseInt(gap / 2); } } 洗牌算法 洗牌算法其实就是随机打乱数组，实现思路是：遍历数组元素，将当前元素和前面未有序序列中任意一个数进行交换，保证每个元素和其他元素交换的概率是等大的。 let arr = [0, 1, 2, 3, 4]; for(let i=arr.length-1; i>0; i--) { let index = parseInt(Math.random() * (i + 1)); [arr[i], arr[index]] = [arr[index], arr[i]]; } 有一种更简单的方法也可以打乱数组：arr.sort(() => Math.random() - 0.5)。但据说这种方法得到的数组并不能达到真正的乱序，具体原因我现在还不清楚，得之后我深入研究了再做补充。 二叉树 构造二叉树 根据先序遍历和中序遍历构造二叉树 var buildTree = function(preorder, inorder) { function build(preL, preR, inL, inR) { if(preL > preR || inL > inR) { return null; } let node = new TreeNode(preorder[preL]); // 在中序遍历中找出根节点，以此区分左右子树 let index = 0; for(let i=inL; i 根据后序遍历和中序遍历构造二叉树 var buildTree = function(inorder, postorder) { function build(l1, r1, l2, r2) { if(l1 > r1 || l2 > r2) return null; let index = 0; let root = new TreeNode(); root.val = postorder[r2]; for(let i=l1; i 遍历二叉树 先序遍历 递归 function preorderTraversal(root) { let res = []; function print(root) { if(!root) return root; res.push(root.val); print(root.left); print(root.right); } print(root); return res; }; 迭代 function preorderTraversal(root) { if(root === null) return []; let res = []; let stack = [root]; while(stack.length) { let top = stack.shift(); res.push(top.val); // 使用 unshift 而不是 push 才能保证左子树会先于右子树被访问到 if(top.right) stack.unshift(top.right); if(top.left) stack.unshift(top.left); } return res; } 中序遍历 递归 function inorderTraversal(root) { let res = []; function print(root) { if(root === null) return root; print(root.left); res.push(root.val); print(root.right); } print(root); return res; }; 迭代 function inorderTraversal(root) { let cur = root; let stack = []; let res = []; while(cur || stack.length !== 0) { // 先遍历左子树到底部 if(cur) { stack.unshift(cur); cur = cur.left; } // 再遍历右子树 else { cur = stack.shift(); res.push(cur.val); cur = cur.right; } } return res; }; 后序遍历 递归 var postorderTraversal = function(root) { let res = []; function print(root) { if(!root) return root; print(root.left); print(root.right); res.push(root.val); } print(root); return res; }; 迭代 function postorderTraversal(root) { if(root === null) return []; let res = []; let stack = [root]; while(stack.length) { let top = stack.shift(); // 使用 unshift 而不是 push 才能保证右子树会先于左子树被访问到，只要再把值插入到结果数组头部即可得到后序遍历 if(top.left) stack.unshift(top.left); if(top.right) stack.unshift(top.right); res.unshift(top.val); } return res; } 层序遍历 function levelOrder(root) { if(root === null) return []; let queue = []; let res = []; queue.push(root); // 每一层的节点数量 let sum = 1; while(queue.length) { let temp = []; while(sum--) { let top = queue.shift(); temp.push(top.val); if(top.left) queue.push(top.left); if(top.right) queue.push(top.right); } res.push(temp); sum = queue.length; } return res; }; 二叉排序树 二叉排序树 / 二叉查找树 / 二叉搜索树：左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于或等于它的根结点的值，并且左右子树都是二叉排序树。所以只要构建一棵二叉排序树，对其进行中序遍历即可得到一个升序序列。 class BinaryTree { constructor() { this.root = { val: undefined, lchild: {}, rchild: {} }; } // 根据参数数组构建二叉排序树 createBST(arr) { arr.forEach(val => { this.insertBST(this.root, val); }) } // 向二叉排序树中插入结点 insertBST(root, val) { // 空树或叶子结点 if(root.val === undefined) { root.val = val; root.lchild = {}; root.rchild = {}; } else if(val = root.val) { this.insertBST(root.rchild, val); } } // 中序遍历(左根右)，返回一个升序的数组 ascendingOrder() { let res = []; function fn(root) { if(root.val === undefined) return; fn(root.lchild); res.push(root.val); fn(root.rchild); } fn(this.root); return res; } // 中序遍历(右根左)，返回一个降序的数组 descendingOrder() { let res = []; function fn(root) { if(root.val === undefined) return; fn(root.rchild); res.push(root.val); fn(root.lchild); } fn(this.root); return res; } } // 测试代码 let tree = new BinaryTree(); tree.createBST([22, 44]); tree.createBST([2, 4, 165, 516, -316, 165, 0, 1, 164]); tree.insertBST(tree.root, 15); console.log(tree.ascendingOrder()); console.log(tree.descendingOrder()); KMP算法 在一个字符串 str 中查找字符串 s，暴力算法从每个 str[i] 开始匹配s，如果遇到不匹配的字符就回到 i+1 的位置上继续从头匹配，所以时间复杂度是 0(n * m)。KMP 算法则是在每次遇到不匹配的字符时，不去回溯 i，而是根据不匹配时 j 的 next 值去回溯模式串 s。所以 KMP 算法的时间复杂度是 O(n + m)。 测试地址 参考学习链接： 阮一峰的网络日志：字符串匹配的KMP算法 KMP 算法 // 计算next数组，next[i]表示str[i]前面字符串的最长公共前后缀 // 如 abcdabe，next[6]=2，最长公共前后缀是ab。 function getNext(str) { let len = str.length; // i表示str的下标 let i = 0, j = -1; let next = []; // next[0]前面没有字符串了，所以置为-1 next[0] = -1; // 因为if中是先i++再给next[i]赋值，所以循环到len-1就够了 while(i "},"算法/十大经典算法排序总结对比.html":{"url":"算法/十大经典算法排序总结对比.html","title":"十大经典算法排序总结对比","keywords":"","body":"十大经典算法排序总结对比 十大经典算法排序总结对比 十大排序时间空间复杂度比较图 1. 冒泡排序（Bubble Sort） 2. 选择排序（Selection Sort） 3.1 插入排序（Insertion Sort） 3.2 插入排序的优化：二分排序(拆半插入) 4. 希尔排序（Shell Sort） 5. 归并排序（Merge Sort） 6. 快速排序（Quick Sort） 6.2 快速排序之填坑 6.3 快速排序之交换 7. 堆排序（Heap Sort） 8. 计数排序（Counting Sort） 8.1 常规计数排序 8.2 优化计数排序 9. 桶排序（Bucket Sort） 10. 基数排序（Radix Sort） 十大排序时间空间复杂度比较图 主流排序算法概览 名词解释： n: 数据规模 k: “桶”的个数 In-place: 占用常数内存，不占用额外内存 Out-place: 占用额外内存 稳定性: 排序后2个相等键值的顺序和排序之前它们的顺序相同 注：基数排序中：r是关键字的基数，d是长度，n是关键字的个数 1. 冒泡排序（Bubble Sort） 基本思想：每次比较两相邻的数,当发现它们的排序与排序要求相反时，就将它们互换。这样小的数往下沉，大的数往上冒 冒泡排序动图演示： // 1 function bubbleSort(arr) { let i = arr.length - 1; while (i >= 0) { for (let j = 0; j arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } i--; } return arr; } // 2 function bubbleSort(arr) { for (i = 0; i arr[j + 1]) { var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } return arr; } 2. 选择排序（Selection Sort） 基本思想：每次选择待排序的元素中最小的值，放置在序列的首位 在时间复杂度上表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。 选择排序动图演示： 步骤: 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 function selectionSort(arr) { var len = arr.length; var minIndex, temp; for (var i = 0; i 3.1 插入排序（Insertion Sort） 基本思想：在序号i之前的元素(0到i-1)已经排好序，本趟需要找到i对应的元素x (此时即arr[i]) 的正确位置k,在寻找位置k的过程中与序号i-1到0的元素依次进行比较。如果x小于比较元素，则比较元素向后移动一位；否则，结束移位，将x插入当前位置k 插入排序的工作原理: 通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 步骤: 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤 2~5。 插入排序动图演示： // 插入排序 const insertionSort = arr => { const len = arr.length; if (len = 0 && arr[preIndex] > current) { //前置条件之一: 待比较元素比当前元素大 arr[preIndex + 1] = arr[preIndex]; //将待比较元素后移一位 preIndex--; //游标前移一位 } // arr[preIndex+1] = current; if (preIndex + 1 != i) { //避免同一个元素赋值给自身 arr[preIndex + 1] = current; //将当前元素插入预留空位 console.log(\"array :\", arr); } } return arr; }; 3.2 插入排序的优化：二分排序(拆半插入) 插入排序也有一种优化算法，叫做拆半插入。 思想: 折半插入排序是直接插入排序的升级版，鉴于插入排序第一部分为已排好序的数组, 我们不必按顺序依次寻找插入点, 只需比较它们的中间值与待插入元素的大小即可。 与插入排序思想差不多，但是二分排序是在插入第i个元素时，对前面的0~i-1元素进行折半，先跟它们中间的元素进行比较。如果小，那么对前半进行折半；如果大，那么对后半进行折半。依次进行，直到left>right。然后再把第i个元素前一位与目标位置之间的所有元素向后移动一位，再将目标元素放入正确位置上。 注意：和直接插入排序类似，折半插入排序每次交换的是相邻的且值为不同的元素，它并不会改变值相同的元素之间的顺序，因此它是稳定的。 步骤: 取 0 ~ i-1 的中间点 ( m = (i-1)>>1 )，array[i] 与 array[m] 进行比较，若 array[i] 重复步骤 1，每次缩小一半的查找范围，直至找到插入的位置。 将数组中插入位置之后的元素全部后移一位。 在指定位置插入第 i 个元素。 注：x>>1 是位运算中的右移运算，表示右移一位，等同于 x 除以 2 再取整，即 x>>1 == Math.floor(x/2) 。 // 折半插入排序 const binaryInsertionSort = array => { const len = array.length; if (len > 1; // 注: x>>1 是位运算中的右移运算, 表示右移一位, 等同于 x 除以 2 再取整, 即 x>>1 == Math.floor(x/2) . if (array[i] >= array[m]) { //值相同时, 切换到高半区，保证稳定性 low = m + 1; //插入点在高半区 } else { high = m - 1; //插入点在低半区 } } for (j = i; j > low; j--) { //步骤 3: 插入位置之后的元素全部后移一位 array[j] = array[j - 1]; console.log(\"array2 :\", JSON.parse(JSON.stringify(array))); } array[low] = current; //步骤 4: 插入该元素 } console.log(\"array2 :\", JSON.parse(JSON.stringify(array))); return array; }; // 折半插入排序 function binarySort(arr) { for (let i = 0; i temp) { right = mid - 1; } else { left = mid + 1; } } for (let j = i - 1; j >= left; j--) { arr[j + 1] = arr[j]; } if (left !== i) { arr[left] = temp; } } return arr; } console.log(binarySort([7, 3, 4, 5, 10, 7, 8, 2])); /* * @param { Array } arr 有序的数组 ⚠️注意：是有序的有序的有序的 * @param { Number } data 要查找的数据 * @return { Number } 返回查找到的位置，未查找到放回-1值 **/ function binSearch(arr, data) { let upperBound = arr.length - 1, lowerBound = 0; while (lowerBound data) { upperBound = mid + 1; } else { return mid; } } return -1; // 你朋友选要猜的数据在1-100范围之外 } 4. 希尔排序（Shell Sort） 基本思想：先取一个小于n的整数d1作为第一个增量，把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2重复上述的分组和排序，直至所取的增量dt=1(dt，即所有记录放在同一组中进行直接插入排序为止。 希尔排序是插入排序的一种更高效率的实现。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。在这里，我就使用了这种方法。 function shellSort(arr) { var len = arr.length, temp, gap = 1; while (gap 0; gap = Math.floor(gap / 3)) { for (var i = gap; i = 0 && arr[j] > temp; j -= gap) { arr[j + gap] = arr[j]; } arr[j + gap] = temp; } } return arr; } 图解: 通过某个增量 gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至 1。希尔排序类似于插入排序，只是一开始向前移动的步数从 1 变成了 gap。 function shellSort(arr) { let len = arr.length; // 初始步数 let gap = parseInt(len / 2); // 逐渐缩小步数 while (gap) { // 从第gap个元素开始遍历 for (let i = gap; i = 0; j -= gap) { if (arr[j] > arr[j + gap]) { [arr[j], arr[j + gap]] = [arr[j + gap], arr[j]]; } else { break; } } } gap = parseInt(gap / 2); } return arr; } 5. 归并排序（Merge Sort） 基本思想: 将待排序序列分为若干个子序列，每个子序列是有序的，然后将有序子序列合并为整体有序序列。 作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第2种方法） 自下而上的迭代 和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。 归并排序动图演示 function merge(left, right) { var result = []; while (left.length > 0 && right.length > 0) { if (left[0] // 融合两个有序数组，这里实际上是将数组 arr 分为两个数组 function mergeArray(arr, first, mid, last, temp) { let i = first; let m = mid; let j = mid + 1; let n = last; let k = 0; while (i 6. 快速排序（Quick Sort） 又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 快速排序动图演示： function quickSort(arr) { //如果数组 基本思想：选择一个基准元素(通常选择第一个元素)，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有元素都比基准元素小，另外一部分的所有元素大于或等于基准元素大。同样方法依次分割；整个排序过程可以递归进行。 function quickSort(arr) { if (arr.length = pivot) { right.push(arr[i]); } else { left.push(arr[i]); } } return [...quickSort(left), pivot, ...quickSort(right)]; } 1、快速排序的基本思想： 快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 2、快速排序的三个步骤： 选择基准：在待排序列中，按照某种方式挑出一个元素，作为 \"基准\"（pivot） 分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大 递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。 3、选择基准的方式 6.2 快速排序之填坑 从右边向中间推进的时候，遇到小于基数的数就赋给左边（一开始是基数的位置），右边保留原先的值等之后被左边的值填上。 function quickSort(nums) { // 递归排序基数左右两边的序列 function recursive(arr, left, right) { if(left >= right) return; let index = partition(arr, left, right); recursive(arr, left, index - 1); recursive(arr, index + 1, right); return arr; } // 将小于基数的数放到基数左边，大于基数的数放到基数右边，并返回基数的位置 function partition(arr, left, right) { // 取第一个数为基数 let temp = arr[left]; while(left = temp) right--; arr[left] = arr[right]; while(left 6.3 快速排序之交换 从左右两边向中间推进的时候，遇到不符合的数就两边交换值。 function quickSort1(nums) { function recursive(arr, left, right) { if(left >= right) return; let index = partition(arr, left, right); recursive(arr, left, index - 1); recursive(arr, index + 1, right); return arr; } function partition(arr, left, right) { let temp = arr[left]; let p = left + 1; let q = right; while(p temp) q--; if(p 7. 堆排序（Heap Sort） 堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列 堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字的记录变得简单 用大根堆排序的基本思想 先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区 再将关键字最大的记录R[1]（即堆顶）和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key 由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。然后再次将R[1..n-1]中关键字最大的记录R[1]和该区间的最后一个记录R[n-1]交换，由此得到新的无序区R[1..n-2]和有序区R[n-1..n]，且仍满足关系R[1..n-2].keys≤R[n-1..n].keys，同样要将R[1..n-2]调整为堆。…… 直到无序区只有一个元素为止。 堆排序动图演示： function heapSort(nums) { // 调整最大堆，使index的值大于左右节点 function adjustHeap(nums, index, size) { // 交换后可能会破坏堆结构，需要循环使得每一个父节点都大于左右结点 while(true) { let max = index; let left = index * 2 + 1; // 左节点 let right = index * 2 + 2; // 右节点 if(left =0; i--) { adjustHeap(nums, i, size); } } buildHeap(nums); // 循环n-1次，每次循环后交换堆顶元素和堆底元素并重新调整堆结构 for(let i=nums.length-1; i>0; i--) { [nums[i], nums[0]] = [nums[0], nums[i]]; adjustHeap(nums, 0, i); } return nums; } 8. 计数排序（Counting Sort） 计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 计数排序动图演示： 以数组元素值为键，出现次数为值存进一个临时数组，最后再遍历这个临时数组还原回原数组。因为 JavaScript 的数组下标是以字符串形式存储的，所以计数排序可以用来排列负数，但不可以排列小数。 最好：O(n + k)，k是最大值和最小值的差。 最坏：O(n + k) 平均：O(n + k) 8.1 常规计数排序 function countingSort(nums) { let arr = []; let max = Math.max(...nums); let min = Math.min(...nums); // 装桶 for(let i=0, len=nums.length; i 0) { nums[index++] = i; arr[i]--; } } return nums; } 8.2 优化计数排序 把每一个数组元素都加上 min 的相反数，来避免特殊情况下的空间浪费，通过这种优化可以把所开的空间大小从 max+1 降低为 max-min+1，max 和 min 分别为数组中的最大值和最小值。 比如数组 [103, 102, 101, 100]，普通的计数排序需要开一个长度为 104 的数组，而且前面 100 个值都是 undefined，使用该优化方法后可以只开一个长度为 4 的数组。 function countingSort(nums) { let arr = []; let max = Math.max(...nums); let min = Math.min(...nums); // 加上最小值的相反数来缩小数组范围 let add = -min; for(let i=0, len=nums.length; i 0) { nums[index++] = i; temp--; } } return nums; } 9. 桶排序（Bucket Sort） 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的N个数据均匀的分配到K个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 可以设定10个桶，申请额外的空间bucket[10]来作为辅助空间。其中，每个桶bucket[i]来存放[10i, 10i+9]的元素链表。 上图所示： 待排序的数组为unsorted[16] 桶空间是buket[10] 扫描所有元素之后，元素被放到了自己对应的桶里 每个桶内，使用插入排序，保证一直是有序的 例如，标红的元素66, 67, 62最终会在一个桶里，并且使用插入排序桶内保持有序。 最终，每个桶按照次序输出，排序完毕。 function bucketSort(nums) { // 桶的个数，只要是正数即可 let num = 5; let max = Math.max(...nums); let min = Math.min(...nums); // 计算每个桶存放的数值范围，至少为1， let range = Math.ceil((max - min) / num) || 1; // 创建二维数组，第一维表示第几个桶，第二维表示该桶里存放的数 let arr = Array.from(Array(num)).map(() => Array().fill(0)); nums.forEach(val => { // 计算元素应该分布在哪个桶 let index = parseInt((val - min) / range); // 防止index越界，例如当[5,1,1,2,0,0]时index会出现5 index = index >= num ? num - 1 : index; let temp = arr[index]; // 插入排序，将元素有序插入到桶中 let j = temp.length - 1; while (j >= 0 && val { nums[i] = res[i]; }); return nums; } 10. 基数排序（Radix Sort） 基数排序有两种方法： MSD 从高位开始进行排序 LSD 从低位开始进行排序 基数排序 vs 计数排序 vs 桶排序 这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值 LSD基数排序动图演示： // LSD Radix Sort // helper function to get the last nth digit of a number var getDigit = function(num, nth) { // get last nth digit of a number var ret = 0; while (nth--) { ret = num % 10; num = Math.floor((num - ret) / 10); } return ret; }; // radixSort function radixSort(arr) { var max = Math.floor(Math.log10(Math.max.apply(Math, arr))), // get the length of digits of the max value in this array digitBuckets = [], idx = 0; for (var i = 0; i 0) { for (j = 0; j function radixSort(nums) { // 计算位数 function getDigits(n) { let sum = 0; while (n) { sum++; n = parseInt(n / 10); } return sum; } // 第一维表示位数即0-9，第二维表示里面存放的值 let arr = Array.from(Array(10)).map(() => Array()); let max = Math.max(...nums); let maxDigits = getDigits(max); for (let i = 0, len = nums.length; i = 0; i--) { // 循环每一个桶 for (let j = 0; j { nums[index] = +res[index]; }); return nums; } "},"算法/快速排序.html":{"url":"算法/快速排序.html","title":"快速排序","keywords":"","body":"快速排序 1、快速排序的基本思想： 快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 2、快速排序的三个步骤： 选择基准：在待排序列中，按照某种方式挑出一个元素，作为 \"基准\"（pivot） 分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大 递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。 3、选择基准的方式 快速排序动图演示： function quickSort(arr) { //如果数组 基本思想：选择一个基准元素(通常选择第一个元素)，通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有元素都比基准元素小，另外一部分的所有元素大于或等于基准元素大。同样方法依次分割；整个排序过程可以递归进行。 function quickSort(arr) { if (arr.length = pivot) { right.push(arr[i]); } else { left.push(arr[i]); } } return [...quickSort(left), pivot, ...quickSort(right)]; } 从右边向中间推进的时候，遇到小于基数的数就赋给左边（一开始是基数的位置），右边保留原先的值等之后被左边的值填上。 function quickSort(nums) { // 递归排序基数左右两边的序列 function recursive(arr, left, right) { if(left >= right) return; let index = partition(arr, left, right); recursive(arr, left, index - 1); recursive(arr, index + 1, right); return arr; } // 将小于基数的数放到基数左边，大于基数的数放到基数右边，并返回基数的位置 function partition(arr, left, right) { // 取第一个数为基数 let temp = arr[left]; while(left = temp) right--; arr[left] = arr[right]; while(left 快速排序之交换 从左右两边向中间推进的时候，遇到不符合的数就两边交换值。 function quickSort1(nums) { function recursive(arr, left, right) { if(left >= right) return; let index = partition(arr, left, right); recursive(arr, left, index - 1); recursive(arr, index + 1, right); return arr; } function partition(arr, left, right) { let temp = arr[left]; let p = left + 1; let q = right; while(p temp) q--; if(p "},"算法/数组去重.html":{"url":"算法/数组去重.html","title":"数组去重","keywords":"","body":"数组去重 数组去重 实现一 补充 3.1 普通版 复杂度 O(n^2) 3.2 进阶版 3.3 时间复杂度为O(n) 3.4 终极版 实现一 // A.方法1：使用Set + Array function uniqueArray(arr){ return Array.from(new Set(arr)); } // B.方法2：使用splice function uniqueArray(arr){ for(var i = 0; i 补充 注：暂不考虑对象字面量，函数等引用类型的去重，也不考虑 NaN, undefined, null等特殊类型情况。 数组样本：[1, 1, '1', '2', 1] 3.1 普通版 复杂度 O(n^2) 无需思考，我们可以得到 O(n^2) 复杂度的解法。定义一个变量数组 res 保存结果，遍历需要去重的数组，如果该元素已经存在在 res 中了，则说明是重复的元素，如果没有，则放入 res 中。 var a = [1, 1, '1', '2', 1] function unique(arr) { var res = [] for (var i = 0, len = arr.length; i 优点： 没有任何兼容性问题，通俗易懂，没有任何理解成本 缺点： 看起来比较臃肿比较繁琐，时间复杂度比较高O(n^2) 3.2 进阶版 var a = [1, 1, '1', '2', 1] function unique(arr) { return arr.filter(function(ele,index,array){ return array.indexOf(ele) === index//很巧妙,这样筛选一对一的,过滤掉重复的 }) } console.log(unique(a)) // [1, 2, \"1\"] 优点：很简洁，思维也比较巧妙，直观易懂。 缺点：不支持 IE9 以下的浏览器，时间复杂度还是O(n^2) 3.3 时间复杂度为O(n) var a = [1, 1, '1', '2', 1] function unique(arr) { var obj = {} return arr.filter(function(item, index, array){ return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true) }) } console.log(unique(a)) // [1, 2, \"1\"] 优点：hasOwnProperty 是对象的属性(名称)存在性检查方法。对象的属性可以基于 Hash 表实现，因此对属性进行访问的时间复杂度可以达到O(1); filter 是数组迭代的方法，内部还是一个 for 循环，所以时间复杂度是 O(n)。 缺点：不兼容 IE9 以下浏览器，其实也好解决，把 filter 方法用 for 循环代替或者自己模拟一个 filter 方法。 3.4 终极版 以 Set 为例，ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 const unique = a => [...new Set(a)] 优点：ES6 语法，简洁高效，我们可以看到，去重方法从原始的 14 行代码到 ES6 的 1 行代码，其实也说明了 JavaScript 这门语言在不停的进步，相信以后的开发也会越来越高效。 缺点：兼容性问题，现代浏览器才支持，有 babel 这些都不是问题。 "},"算法/冒泡排序.html":{"url":"算法/冒泡排序.html","title":"冒泡排序","keywords":"","body":"冒泡排序 思想 冒泡排序只会操作相邻的两个数据。 每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。 一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。 特点 优点：排序算法的基础，简单实用易于理解。 缺点：比较次数多，效率较低。 实现 // 冒泡排序（未优化） const bubbleSort = arr => { console.time('改进前冒泡排序耗时'); const length = arr.length; if (length arr[j + 1]) { const temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } console.log('改进前 arr :', arr); console.timeEnd('改进前冒泡排序耗时'); }; 优化：当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。 // 冒泡排序（已优化） const bubbleSort2 = arr => { console.time('改进后冒泡排序耗时'); const length = arr.length; if (length arr[j + 1]) { const temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; hasChange = true; // 表示有数据交换 } } if (!hasChange) break; // 如果 false 说明所有元素已经到位，没有数据交换，提前退出 } console.log('改进后 arr :', arr); console.timeEnd('改进后冒泡排序耗时'); }; 测试 // 测试 const arr = [7, 8, 4, 5, 6, 3, 2, 1]; bubbleSort(arr); // 改进前 arr : [1, 2, 3, 4, 5, 6, 7, 8] // 改进前冒泡排序耗时: 0.43798828125ms const arr2 = [7, 8, 4, 5, 6, 3, 2, 1]; bubbleSort2(arr2); // 改进后 arr : [1, 2, 3, 4, 5, 6, 7, 8] // 改进后冒泡排序耗时: 0.318115234375ms 分析 第一，冒泡排序是原地排序算法吗 ？ 冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。 第二，冒泡排序是稳定的排序算法吗 ？在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序。所以冒泡排序是稳定的排序算法。 第三，冒泡排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n)，当数据已经是正序时。 最差情况：T(n) = O(n2)，当数据是反序时。 平均情况：T(n) = O(n2)。 动画 动画地址(https://algorithm-visualizer.org/brute-force/bubble-sort) 两个for循环 外层 for 循环控制循环次数 内层 for 循环进行两数交换，找每次的最大数，排到最后 设置一个标志位，减少不必要的循环 var examplearr = [8, 94, 15, 88, 55, 76, 21, 39]; function bubbleSort(arr) { for (i = 0; i arr[j + 1]) { var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } return arr; } bubbleSort(examplearr); console.log(examplearr); while function bubbleSort(arr) { let i = arr.length - 1; while (i >= 0) { for (let j = 0; j arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } i--; } return arr; } 为什么我们在冒泡排序算法的内部循环中使用length-i-1？ 在每次外迭代之后，第i个最大元素位于正确的位置。所以在第一次迭代之后，最大的元素在最右侧。不需要在下一轮比较这个元素。在第二次迭代之后，第二大元素位于最右侧的-1位置。所以这两个最大的元素已经排序了，不必在下一轮考虑它们。 假设仅仅为了举例而有10个元素的数组。 第一步 i = 0, j goes from 0 to 9( = 10 - 0 - 1) 所以它遍历整个数组。现在，每次当前元素比下一个更大时，我们将它们切换（by if(arr[j] > arr[j+1])），因此在第一次迭代结束时，在最后一个位置，我们将拥有数组的最大元素。 第二步 i = 1, j goes from 0 to 8( = 10 - 1 - 1) 我们可以注意到我们排除了最后一个（第9）的位置，但是我们知道它已经是上一步的最大值，所以处于正确的位置。在这次迭代结束时，我们将在第8个位置有第2个最大元素，并且过程继续。 "},"算法/插入排序.html":{"url":"算法/插入排序.html","title":"插入排序","keywords":"","body":"插入排序 插入排序 一、直接插入 思想 步骤 动画 实现 测试 分析 二、拆半插入 思想 步骤 插入排序又为分为 直接插入排序 和优化后的 拆半插入排序 与 希尔排序，我们通常说的插入排序是指直接插入排序。 一、直接插入 思想 一般人打扑克牌，整理牌的时候，都是按牌的大小（从小到大或者从大到小）整理牌的，那每摸一张新牌，就扫描自己的牌，把新牌插入到相应的位置。 插入排序的工作原理：通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 步骤 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤 2~5。 动画 动画演示地址 https://algorithm-visualizer.org/brute-force/insertion-sort 实现 // 插入排序 const insertionSort = array => { const len = array.length; if (len = 0 && array[preIndex] > current) { //前置条件之一: 待比较元素比当前元素大 array[preIndex + 1] = array[preIndex]; //将待比较元素后移一位 preIndex--; //游标前移一位 } if (preIndex + 1 != i) { //避免同一个元素赋值给自身 array[preIndex + 1] = current; //将当前元素插入预留空位 console.log(\"array :\", array); } } return array; }; 测试 // 测试 const array = [5, 4, 3, 2, 1]; console.log(\"原始 array :\", array); insertionSort(array); // 原始 array: [5, 4, 3, 2, 1] // array: [4, 5, 3, 2, 1] // array: [3, 4, 5, 2, 1] // array: [2, 3, 4, 5, 1] // array: [1, 2, 3, 4, 5] 分析 第一，插入排序是原地排序算法吗 ？插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，所以，这是一个原地排序算法。 第二，插入排序是稳定的排序算法吗 ？在插入排序中，对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。 第三，插入排序的时间复杂度是多少 ？ 最佳情况：T(n) = O(n)，当数据已经是正序时。 最差情况：T(n) = O(n2)，当数据是反序时。 平均情况：T(n) = O(n2)。 二、拆半插入 插入排序也有一种优化算法，叫做拆半插入。 思想 折半插入排序是直接插入排序的升级版，鉴于插入排序第一部分为已排好序的数组, 我们不必按顺序依次寻找插入点, 只需比较它们的中间值与待插入元素的大小即可。 步骤 取 0 ~ i-1 的中间点 ( m = (i-1)>>1 )，array[i] 与 array[m] 进行比较，若 array[i] 重复步骤 1，每次缩小一半的查找范围，直至找到插入的位置。 将数组中插入位置之后的元素全部后移一位。 在指定位置插入第 i 个元素。 注：x>>1 是位运算中的右移运算，表示右移一位，等同于 x 除以 2 再取整，即 x>>1 == Math.floor(x/2) 。 // 折半插入排序 const binaryInsertionSort = array => { const len = array.length; if (len > 1; // 注: x>>1 是位运算中的右移运算, 表示右移一位, 等同于 x 除以 2 再取整, 即 x>>1 == Math.floor(x/2) . if (array[i] >= array[m]) { //值相同时, 切换到高半区，保证稳定性 low = m + 1; //插入点在高半区 } else { high = m - 1; //插入点在低半区 } } for (j = i; j > low; j--) { //步骤 3: 插入位置之后的元素全部后移一位 array[j] = array[j - 1]; console.log('array2 :', JSON.parse(JSON.stringify(array))); } array[low] = current; //步骤 4: 插入该元素 } console.log('array2 :', JSON.parse(JSON.stringify(array))); return array; }; 测试 const array2 = [5, 4, 3, 2, 1]; console.log('原始 array2:', array2); binaryInsertionSort(array2); // 原始 array2: [5, 4, 3, 2, 1] // array2 : [5, 5, 3, 2, 1] // array2 : [4, 5, 5, 2, 1] // array2 : [4, 4, 5, 2, 1] // array2 : [3, 4, 5, 5, 1] // array2 : [3, 4, 4, 5, 1] // array2 : [3, 3, 4, 5, 1] // array2 : [2, 3, 4, 5, 5] // array2 : [2, 3, 4, 4, 5] // array2 : [2, 3, 3, 4, 5] // array2 : [2, 2, 3, 4, 5] // array2 : [1, 2, 3, 4, 5] 注意：和直接插入排序类似，折半插入排序每次交换的是相邻的且值为不同的元素，它并不会改变值相同的元素之间的顺序，因此它是稳定的。 "},"算法/选择排序.html":{"url":"算法/选择排序.html","title":"选择排序","keywords":"","body":"选择排序 选择排序 思路 步骤 动画 实现 分析 思路 选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。 步骤 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 动画 动画演示地址 https://algorithm-visualizer.org/brute-force/selection-sort 实现 const selectionSort = array => { const len = array.length; let minIndex, temp; for (let i = 0; i 测试 // 测试 const array = [5, 4, 3, 2, 1]; console.log('原始array:', array); selectionSort(array); // 原始 array: [5, 4, 3, 2, 1] // array: [1, 4, 3, 2, 5] // array: [1, 2, 3, 4, 5] // array: [1, 2, 3, 4, 5] // array: [1, 2, 3, 4, 5] 分析 第一，选择排序是原地排序算法吗 ？选择排序空间复杂度为 O(1)，是一种原地排序算法。 第二，选择排序是稳定的排序算法吗 ？选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。所以，选择排序是一种不稳定的排序算法。 第三，选择排序的时间复杂度是多少 ？无论是正序还是逆序，选择排序都会遍历 n2 / 2 次来排序，所以，最佳、最差和平均的复杂度是一样的。 最佳情况：T(n) = O(n2)。 最差情况：T(n) = O(n2)。 平均情况：T(n) = O(n2)。 "},"算法/归并排序.html":{"url":"算法/归并排序.html","title":"归并排序","keywords":"","body":"Javascript排序算法之合并排序（归并排序） Javascript排序算法之合并排序（归并排序） JS实现归并排序 图解排序算法之归并排序 分而治之 JS实现归并排序 归并排序：其基本思想是分治策略，先进行划分，然后再进行合并。 归并排序动图演示 假设要对数组C进行归并排序，步骤是： 先将C划分为两个数组A和B（即把数组C从中间分开） 再分别对数组A、B重复步骤1的操作，逐步划分，直到不能再划分为止(每个子数组只剩下一个元素)，这样，划分的过程就结束了。如： [12 20 30 21 15 33 26 19 40 25] 划分为: [12 20 30 21 15] [33 26 19 40 25] [12 20] [30 21 15] [33 26] [19 40 25] [12] [20] [30] [21 15] [33] [26] [19] [40 25] [12] [20] [30] [21] [15] [33] [26] [19] [40] [25] 然后从下层往上层不断合并数组，每一层合并相邻的两个子数组，合并的过程是每次从待合并的两个子数组中选取一个最小的元素，然后把这个元素放到合并后的数组中，不断重复直到把两个子数组的元素都放到合并后的数组为止。 依次类推，直到合并到最上层结束，这时数据的排序已经完成了。 function merge(left, right) { var result = []; while (left.length > 0 && right.length > 0) { if (left[0] 图解排序算法之归并排序 基本思想 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案\"修补\"在一起，即分而治之)。 分而治之 可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。 合并相邻有序子序列 再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。 代码实现 // 融合两个有序数组，这里实际上是将数组 arr 分为两个数组 function mergeArray(arr, first, mid, last, temp) { let i = first; let m = mid; let j = mid + 1; let n = last; let k = 0; while (i "},"算法/二分法.html":{"url":"算法/二分法.html","title":"二分法","keywords":"","body":"二分法 在开始之前，我们来玩一个猜数字游戏： 规则：在数字1-100之间，你朋友选择要猜的数字之后，由你来猜数字。你每猜一个数字，你的朋友将会作出下面三种回应之一： 猜对了 猜大了 猜小了 这个游戏很简单，如果我们使用二分查找的策略进行的话，我们只需要经过短短的几次就确定我们要查找的数据了。 那么二分查找的原理是什么呢？ 二分查找又称为折半查找，对有序的列表每次进行对半查找。就是这么简单@～@！ 代码实现走一波： /* * @param { Array } arr 有序的数组 ⚠️注意：是有序的有序的有序的 * @param { Number } data 要查找的数据 * @return { Number } 返回查找到的位置，未查找到放回-1值 **/ function binSearch(arr, data) { let upperBound = arr.length - 1, lowerBound = 0; while (lowerBound data) { upperBound = mid + 1; } else { return mid; } } return -1; // 你朋友选要猜的数据在1-100范围之外 } 在数组里查找数据，找到数据所在的索引 // 在数组里面查找数据，找到数据所在位置的索引 var arr = new Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); var a = 2; //方法一 console.log(arr.indexOf(a)); //方法二 for (var i = 0; i arr[zjx]) { //如果中间值大于要查找的数 minx = zjx; //中间值赋给最小值，然后继续循环 } else { maxx = zjx; //如果中间值小于要查找的数，中间值赋给最大值，然后继续循环 } } 二分法查找的前提: 数组必须为有序 思路：找到数组的中间数zjx和要查找的数a,若a,则要查找的数在中间数zjx的左边，就把数组二分，只在左边查找，右边同理,直到找到要查找的数。 二分法对于数据特别多的情况能极大的节约效率。 在上面的二分法中： 首先定义最大值 maxx，最小值 minx 中间值 zjx 也可以再循环中定义 我们不能确定循环的次数，所以这里使用 while 循环 首先找出中间值，中间值等于最大值和最小值的和除以2 如果要查找的数等于中间值，输出 如果中间值大于要查找的数，说明要查找的数比中间值小，在中间值左边，然后把中间值作为最大，继续循环 如果中间值小于要查找的数，说明要查找的数比中间值大，在中间值右边，然后把中间值作为最小，继续循环 如果遇到还剩下两个数的情况，这两个值就一个大的是最大值，一个小的是最小值，取出的中间值因为在程序中去掉了分数，只留整数，所以中间值也就是最小值，这时判断要查找的数是否是中间值即最小值右边的数即最大值，如果是，输出 "},"算法/排序数组.html":{"url":"算法/排序数组.html","title":"排序数组","keywords":"","body":"排序数组 排序数组 题目 1.sort 2.冒泡排序，从后向前遍历。 3.冒泡排序，从前向后遍历。 4.双向冒泡 5.选择排序 6.快速排序，填坑法 7.快速排序，交换两节点 8.归并排序 9.插入排序 10.桶排序 11.基数排序 12.计数排序 13.计数排序优化， 14.堆排序 15.希尔排序 题目 给定一个整数数组 nums，将该数组升序排列。 示例 1： 输入：[5,2,3,1] 输出：[1,2,3,5] 示例 2： 输入：[5,1,1,2,0,0] 输出：[0,0,1,1,2,5] 提示： 1 1.sort var sortArray = function(nums) { return nums.sort((a, b) => a - b); }; 2.冒泡排序，从后向前遍历。 var sortArray = function(nums) { for(let i=nums.length-1; i>0; i--) { // 如果一轮比较中没有需要交换的数据，则说明数组已经有序 let mark = true; for(let j=0; j nums[j+1]) { [nums[j], nums[j+1]] = [nums[j+1], nums[j]]; mark = false; } } if(mark) return nums; } return nums; } 3.冒泡排序，从前向后遍历。 var sortArray = function(nums) { for(let i=0, len=nums.length; i nums[j+1]) { [nums[j], nums[j+1]] = [nums[j+1], nums[j]]; mark = false; } } if(mark) return nums; } return nums; } 4.双向冒泡 var sortArray = function(nums) { for(let i=0, len=nums.length; i nums[j+1]) { [nums[j], nums[j+1]] = [nums[j+1], nums[j]]; mark = false; } } // 找到最小值放到左边 for(let t=len-i-2; t>0; t--) { if(nums[t] 5.选择排序 var sortArray = function(nums) { for(let i=0, len=nums.length; i nums[j]) { [nums[i], nums[j]] = [nums[j], nums[i]]; } } } return nums; } 6.快速排序，填坑法 var sortArray = function(nums) { function quickSort(arr, left, right) { if(left >= right) return arr; // 确定基数的位置 let index = partition(arr, left, right); quickSort(arr, left, index - 1); quickSort(arr, index + 1, right); return arr; } function partition(arr, left, right) { // 取第一个数为基数 let temp = arr[left]; while(left = temp) right--; arr[left] = arr[right]; while(left 7.快速排序，交换两节点 var sortArray = function(nums) { function partition(arr, left, right) { let temp = arr[left]; let p = left + 1; let q = right; while(p temp) q--; if(p = right) return arr; let index = partition(arr, left, right); quickSort(arr, left, index - 1); quickSort(arr, index + 1, right); return arr; } return quickSort(nums, 0, nums.length-1); }; 8.归并排序 var sortArray = function(nums) { function merge(l1, r1, l2, r2) { let arr = []; let index = 0; let i = l1, j = l2; while(i = right) return nums; let mid = parseInt((right - left) / 2) + left; mergeSort(left, mid); mergeSort(mid+1, right); merge(left, mid, mid+1, right); return nums; } return mergeSort(0, nums.length-1); }; 9.插入排序 var sortArray = function(nums) { for(let i=1, len=nums.length; i= 0 && temp 10.桶排序 将数组元素有序分配到n个桶里，最后再合并各个桶 var sortArray = function(nums) { function bucketSort(nums) { // 桶的个数，只要是正数即可 let num = 5; let max = Math.max(...nums); let min = Math.min(...nums); // 计算每个桶存放的数值范围，至少为1， let range = Math.ceil((max - min) / num) || 1; // 创建二维数组，第一维表示第几个桶，第二维表示该桶里存放的数 let arr = Array.from(Array(num)).map(() => Array()); nums.forEach(val => { // 计算元素应该分布在哪个桶 let index = parseInt((val - min) / range); // 防止index越界，例如当[5,1,1,2,0,0]时index会出现5 index = index >= num ? num - 1 : index; let temp = arr[index]; // 插入排序，将元素有序插入到桶中 let j = temp.length - 1; while(j >= 0 && val { nums[i] = res[i]; }) } bucketSort(nums); return nums; } 11.基数排序 使用十个桶0-9，把每个数从低位到高位根据位数放到相应的桶里。只能排列正整数 function radixSort(nums) { // 计算位数 function getDigits(n) { let sum = 0; while(n) { sum++; n = parseInt(n / 10); } return sum; } let arr = Array.from(Array(10)).map(() => Array()); let max = Math.max(...nums); let maxDigits = getDigits(max); for(let i=0, len=nums.length; i=0; i--) { // 循环每一个桶 for(let j=0; j { nums[index] = +res[index]; }) } 12.计数排序 以数组元素值为键，出现次数为值存进一个临时数组，最后再遍历这个临时数组还原回原数组。 因为js的数组下标是以字符串形式存储的，所以计数排序可以用来排列负数，但不可以排小数 var sortArray = function(nums) { function countingSort(nums) { let arr = []; let max = Math.max(...nums); let min = Math.min(...nums); for(let i=0, len=nums.length; i 0) { nums[index++] = i; arr[i]--; } } } countingSort(nums); return nums; } 13.计数排序优化， 把每一个数组元素都加上min的相反数，来避免特殊情况下的空间浪费。 可以把所开的空间大小从max+1降低为max-min+1。max和min分别为数组中的最大值和最小值 比如数组[103, 102, 101, 100]，普通的计数排序需要开一个长度为104的数组，而前面100个值都是undefined。使用这种优化方法后可以只开一个长度为4的数组。 var sortArray = function(nums) { function countingSort(nums) { let arr = []; let max = Math.max(...nums); let min = Math.min(...nums); // 加上最小值的相反数来缩小数组范围 let add = -min; for(let i=0, len=nums.length; i 0) { nums[index++] = i; temp--; } } } countingSort(nums); return nums; } 14.堆排序 根据数组建立一个堆（类似完全二叉树），每个结点的值都大于左右结点（最大堆，通常用于升序），或小于左右结点（最小堆，通常用于降序）。 对于升序排序，先构建最大堆后，交换堆顶元素（最大值）和堆底元素，每一次交换都能得到一个未有序序列的最大值。 重新调整最大堆，再交换堆顶元素和堆底元素。重复n-1次后就能得到一个升序的数组 var sortArray = function(nums) { function heapSort(nums) { // 调整最大堆，使index的值大于左右节点 function adjustHeap(nums, index, size) { // 交换后可能会破坏堆结构，需要循环使得每一个父节点都大于左右结点 while(true) { let max = index; // 左节点 let left = index * 2 + 1; // 右节点 let right = index * 2 + 2; if(left =0; i--) { adjustHeap(nums, i, size); } } buildHeap(nums); // 循环n-1次，每次循环后交换堆顶元素和堆底元素并重新调整堆结构 for(let i=nums.length-1; i>0; i--) { [nums[i], nums[0]] = [nums[0], nums[i]]; adjustHeap(nums, 0, i); } } heapSort(nums); return nums; } 15.希尔排序 类似插入排序，只是向前移动的步数变成gap，插入排序每次都只是向前移动1。 通过某个增量gap，将整个序列分给若干组，从后往前进行组内成员的比较和交换，随后逐步缩小增量至1. var sortArray = function(nums) { function shellSort(nums) { let len = nums.length; // 初始步数 let gap = parseInt(len / 2); // 逐步缩小步数 while(gap) { // 从第gap个元素开始遍历 for(let i=gap; i=0; j-=gap) { if(nums[j] > nums[j+gap]) { [nums[j], nums[j+gap]] = [nums[j+gap], nums[j]]; } else { break; } } } gap = parseInt(gap / 2); } } shellSort(nums); return nums; } "},"算法/自己实现冒泡排序可视化.html":{"url":"算法/自己实现冒泡排序可视化.html","title":"自己实现冒泡排序可视化","keywords":"","body":"自己实现冒泡排序可视化 先来个简单的版本，看效果图 实现这个效果，思路是这样的 先将需要排序的数组，进行冒泡排序，记录每一步的内容，存放在一个数组中 利用canvas，实现一个 darw 方法，能将一步的内容画到页面上 实现动画效果，利用定时器，每隔一段时间，调用 darw 方法，画出一步到页面上 实现这个效果还是需要会一点点canvas的，比如知道怎么画个长方形，怎么写几个字，换个颜色，如果不会的话，请到这里去看看。 代码 #main { width: 600px; height: 200px; position: relative; } function bubbleSort(arr) { // 冒泡排序算法，对数组进行排序，同时记录每一步操作，保存在一个数组中 function sort() { // virtualArr 用来存放 每一个步内容的数组 var virtualArr = [arr.slice()]; var max = arr.length; for (var i = 0; i arr[j + 1]) { var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; done = false; virtualArr.push(arr.slice()); } }; if(done){ break; }; } return virtualArr; } // 绘画，调用一次就画出一步的图像 function darw(arr){ var canvas = document.getElementById('myCanvas'); var ctx = canvas.getContext('2d'); // 获取 canvas画板的高度(确定每个长方形的 y 值时需要) var maxWidth = canvas.height; // 每个长方形的宽度 var width = 20; // 每个长方形之间的间隔 var space =20; // 清空画布 ctx.clearRect(0, 0, canvas.width, canvas.height); // 设置字体 ctx.font = \"18px serif\"; // 在页面上，画出一步的内容 for (var i = 0; i { setTimeout(() => darw(item), index * interval); }); } animation(); } var arr = [50,40,20,10,10]; bubbleSort(arr); 看上面的代码，能看出，实现效果主要靠的是三个函数 sort，实现冒泡排序，返回包括每一步的数组 darw ，画出一步的内容 animation ，实现动画效果，定时调用darw方法 上面实现的是比较简单的一版，下来看一版更加漂亮的，这是我在Codepen上找到的，改了些代码后，是这样了，看图 这一版是使用vue做的，在vuex中的mutations定义了 6个方法 来实现效果 reset，重置， swap，交换，实现图中两个绿色div，进行位移， activate，激活，实现图中两个红色div，变成绿色， deactivate，释放，实现图中两个绿色div，恢复成红色， lock，锁定，实现找到一个最大值后，将它变成蓝色， done，完成，返回 true 表示排序完成。 Bubble Sort Visualizer {{ value }} $transition-time: 200ms; $easing: cubic-bezier(0.175, 0.885, 0.320, 1.275); @import url('https://fonts.googleapis.com/css?family=Titillium+Web:700'); @import url('https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css'); *, *::before, *::after { box-sizing: border-box; } html { font: 700 16px/1 'Titillium Web', sans-serif; } body { margin: 40px 0; color: #fff; background-color: #000; } #app { width: 640px; margin: 0 auto; } .cards { position: relative; height: 400px; } .card-wrapper { position: absolute; bottom: 0; width: 6.25%; transition: transform $transition-time $easing; } .card { position: relative; height: 100%; margin: 0 5px; border: 1px solid #ff3179; background-color: #000; box-shadow: 0 0 25px #c2255c; } .card-active { filter: hue-rotate(200deg); } .card-locked { filter: hue-rotate(280deg); } .value { position: absolute; bottom: 5px; left: 0; right: 0; text-align: center; font-size: 1.25rem; } .control-panel { display: flex; align-items: center; justify-content: space-between; margin: 30px 5px 0; padding-top: 20px; border-top: 1px solid #fff; } h1 { margin: 0; font-size: 2.5rem; } button { appearance: none; background: none; border: none; color: #ff3179; font-size: 1.5rem; cursor: pointer; } @media only screen and (min-width: 880px) { #app { width: 800px; } .value { font-size: 1.5rem; } } @media only screen and (min-width: 1084px) { #app { width: 1024px; } .value { font-size: 1.75rem; } } const EVENT_DELAY = 200; // 交换的过渡时间 const HEIGHT_INCREMENT = 20; //高度的增量, 数组的某一个值 * 增量 = 长方形高度 const SORT_ARRAY = [16, 11, 4, 5, 5, 7]; // 进行冒泡排序的数组 const store = new Vuex.Store({ state: { values: [], // 值为 SORT_ARRAY 的副本 cards: [], // 可视化需要的数组，就是每一个长方形（div元素），数组的每一个值都代表一个div元素 done: true, // 表示是否排序完成，为true时，右下角出现重置按钮 // strValues 用来解决数组中出现重复的值，移动位置不对的情况 strValues: [] // 数组的一个副本，会将数组的值与下标拼起来，形成唯一的一个字符串 }, mutations: { // 重置，重新开始排序 reset(state, payload) { state.values = payload.values; // 遍历state.values，把state.values的每个值和下标拼接，形成唯一的字符串 // 值 和 下标 中间加上一个 符号，确保是唯一的，注意符号不能用\"\"空字符串 state.values.forEach((item, i) => state.strValues.push(item + \"&\" + i)); // 往 state.cards 中，添加对象，每个对象都代表一个需要排序的长方形（div元素） state.cards = []; for (let i = 0; i { card.sortIndex = state.strValues.indexOf(card.strValue); }); }, // 激活 // 用参数 payload的indexes属性中所有成员，与state.cards 的每个成员（card）的sortIndex属性与进行匹配， // 如果找到相等的，就将state.cards 的成员（card）的isActive设置为true activate(state, payload) { payload.indexes.forEach(index => { state.cards.forEach(card => { if (card.sortIndex === index) card.isActive = true; }); }); }, // 释放 // 用参数 payload的indexes属性中所有成员，与state.cards 的每个成员（card）的sortIndex属性与进行匹配， // 如果找到相等的，就将state.cards 的成员（card）的isActive设置为false deactivate(state, payload) { payload.indexes.forEach(index => { state.cards.forEach(card => { if (card.sortIndex === index) card.isActive = false; }); }); }, // 锁定 // 用参数 payload的indexes属性中所有成员，与state.cards 的每个成员（card）的sortIndex属性与进行匹配， // 如果找到相等的，就将state.cards 的成员（card）的isLocked设置为true lock(state, payload) { payload.indexes.forEach(index => { state.cards.forEach(card => { if (card.sortIndex === index) card.isLocked = true; }); }); }, // 完成 done(state) { state.done = true; } } }); Vue.component(\"sort-card\", { template: \"#sort-card-template\", props: [\"value\", \"sortIndex\", \"isActive\", \"isLocked\"], computed: { cardClassObject() { return { \"card-active\": this.isActive, \"card-locked\": this.isLocked }; } } }); new Vue({ el: \"#app\", store, created() { this.reset(SORT_ARRAY); }, methods: { // 重置 reset(arr) { // 获取传入数组的一个副本，因为重置功能需要不改变原数组 let values = arr.slice(); store.commit({ type: \"reset\", values: values }); // 排序数组，返回一个包括每步的值 和 每步状态的数组 let sequence = this.bubbleSort(values); // 遍历上边排序得到的数组，定时执行操作，实现动画效果 sequence.forEach((event, index) => { setTimeout(() => { store.commit(event); }, index * EVENT_DELAY); }); }, // 冒泡排序方法，返回包括每一步的数组 bubbleSort(values) { // sequence 为包括每一步内容的数组 let sequence = []; // swapped 为判断是否已经排序好的 标志位 let swapped; // indexLastUnsorted 用来减少不必要的循环 let indexLastUnsorted = values.length - 1; do { swapped = false; for (let i = 0; i values[i + 1]) { let temp = values[i]; values[i] = values[i + 1]; values[i + 1] = temp; swapped = true; // 满足交换的条件，就重新定义所有card的sortIndex属性 sequence.push({ type: \"swap\", indexes: [i, i + 1] }); } // 结束这次循环之前，把原来两个card的isActive的值为true的，设置为false sequence.push({ type: \"deactivate\", indexes: [i, i + 1] }); } // 外层循环，每循环完一次，就锁定最后一个card，下次这个card 就不参与循环 sequence.push({ type: \"lock\", indexes: [indexLastUnsorted] }); indexLastUnsorted--; } while (swapped); // 如果提前排序好了，把剩下的card全部锁定 let skipped = Array.from(Array(indexLastUnsorted + 1).keys()); sequence.push({ type: \"lock\", indexes: skipped }); // 修改done 为true，完成排序 sequence.push({ type: \"done\" }); console.log(\"包括每一步内容的数组\", sequence); return sequence; } } }); "},"算法/数组去重的十一种方法.html":{"url":"算法/数组去重的十一种方法.html","title":"数组去重的十四种方法","keywords":"","body":"数组去重的十四种方法 数组去重的十四种方法 Methods 1: 定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中。 Methods 2: 利用sort() Methods 3: 利用对象属性存在的特性，如果没有该属性则存入新数组。 Methods 4: 利用数组的indexOf下标属性来查询。 Methods 5: 利用数组原型对象上的includes方法。 Methods 6: 利用数组原型对象上的 filter 和 includes方法。 Methods 7: 利用数组原型对象上的 forEach 和 includes方法。 Methods 8: 利用for嵌套for，然后splice去重。 Methods 9: 利用数组原型对象上的 lastIndexOf 方法。 Methods 10: 利用 ES6的 set 方法。 Methods 11: 利用数组原型对象上的 filter 和 obj.hasOwnProperty方法 Methods 12: 利用递归去重 Methods 13: 利用Map数据结构去重 Methods 14: 利用reduce+includes 测试 Methods 1: 定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中。 function unique(arr) { var res = [arr[0]]; for (var i = 1; i Methods 2: 利用sort() 思路：先将原数组排序，在与相邻的进行比较，如果不同则存入新数组。 function unique2(arr) { var arr2 = arr.sort(); var res = [arr2[0]]; for (var i = 1; i Methods 3: 利用对象属性存在的特性，如果没有该属性则存入新数组。 function unique3(arr) { var res = []; var obj = {}; for (var i = 0; i Methods 4: 利用数组的indexOf下标属性来查询。 function unique4(arr) { if (!Array.isArray(arr)) { console.log('type error!') return } var res = []; for (var i = 0; i Methods 5: 利用数组原型对象上的includes方法。 function unique5(arr) { var res = []; for (var i = 0; i Methods 6: 利用数组原型对象上的 filter 和 includes方法。 function unique6(arr) { var res = []; res = arr.filter(function(item) { return res.includes(item) ? \"\" : res.push(item); }); return res; } console.log(\"------------方法六---------------\"); console.log(unique6([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])); // 同上 {}没有去重 Methods 7: 利用数组原型对象上的 forEach 和 includes方法。 function unique7(arr) { var res = []; arr.forEach(function(item) { res.includes(item) ? \"\" : res.push(item); }); return res; } console.log(\"------------方法七---------------\"); console.log(unique7([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])); Methods 8: 利用for嵌套for，然后splice去重。 function unique8(arr) { for (var i = 0; i Methods 9: 利用数组原型对象上的 lastIndexOf 方法。 function unique9(arr) { var res = []; for (var i = 0; i Methods 10: 利用 ES6的 set 方法。 function unique10(arr) { //Set数据结构，它类似于数组，其成员的值都是唯一的 return Array.from(new Set(arr)); // 利用Array.from将Set结构转换成数组 // return [...new Set(arr)] } console.log(\"------------方法十---------------\"); console.log(unique10([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])); Methods 11: 利用数组原型对象上的 filter 和 obj.hasOwnProperty方法 // 重点需要掌握 function unique11(arr) { var obj = {}; return arr.filter(function(item, index, array) { return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true); }); } console.log(\"------------方法十一---------------\"); console.log(unique11([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])); var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(unique11(arr)) // [1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}] // 所有的都去重 Methods 12: 利用递归去重 function unique12(arr) { var array = arr; var len = array.length; array.sort(function(a, b) { //排序后更加方便去重 return a - b; }); function loop(index) { if (index >= 1) { if (array[index] === array[index - 1]) { array.splice(index, 1); } loop(index - 1); //递归loop，然后数组去重 } } loop(len - 1); return array; } console.log(\"------------方法十二---------------\"); console.log(unique12([1, 1, 2, 3, 5, 3, 1, 5, 6, 7, 4])); Methods 13: 利用Map数据结构去重 function unique13(arr) { let map = new Map(); let array = new Array(); // 数组用于返回结果 for (let i = 0; i Methods 14: 利用reduce+includes function unique(arr) { return arr.reduce( (prev, cur) => (prev.includes(cur) ? prev : [...prev, cur]), [] ); } var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}]; console.log(\"------------方法十四---------------\"); console.log(unique(arr)); // [1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}, {…}] 测试 当我把数组的长度变得很大的时候（如下所示），测试了一下不同方法的执行时间长短，会发现方法三、四、五、六、七相对来说会更有优势，而方法八的执行速度似乎一直垫底。 //这里只是举例方法三（如果你把所有方法放在一起测试，会更直观的看到执行时间的差异） var time3 = new Date().getTime(); function unique3(arr){ var res = []; var obj = {}; for(var i=0; i "},"算法/Deepclone.html":{"url":"算法/Deepclone.html","title":"Deepclone","keywords":"","body":"Deepclone function deepcopy(obj) { if (tepeof obj != 'object') { return obj } var newObj = {}; for (var i in obj) { newObj[i] = deepcopy(obj[i]) } return newObj; } function deepcopy(p, c) { var c = c || {}; for (var i in p) { if (typeof p[i] === 'object') { c[i] = (p[i].constructor === Array) ? [] : {}; deepcopy(p[i], c[i]) } else { c[i] = p[i] } } return c; } function deepClone(data) { var type = getType(data); var obj; if (type === 'array') { obj = []; } else if (type === 'object') { obj = {}; } else { //不再具有下一层次 return data; } if (type === 'array') { for (var i = 0, len = data.length; i "},"算法/js数组里面任意两个数的和与目标值.html":{"url":"算法/js数组里面任意两个数的和与目标值.html","title":"js数组里面任意两个数的和与目标值","keywords":"","body":"js数组里面任意两个数的和与目标值 问题： 给定一个数组例如[1,3,4,6,7] ，再给定一个目标数，例如9。 写一个算法找出两个数他们相加等于目标数，返回他们在数组中的位置。给出一个解即可，同一个数字不能使用2次。 比如[1,3,4,6,7] 目标数为9，那么需要返回[1,3]。如果目标数为20，返回null。 hash实现： // 返回下标 const twoSum = (arr, target) => { let obj = {}; for (let i = 0; i { let obj = {}; for (let i = 0; i while const twoSum = (arr, target) => { const max = arr.length; let start = 0; let end = max -1; while(start target) { end--; continue } if(sum "},"算法/反转字符串.html":{"url":"算法/反转字符串.html","title":"反转字符串","keywords":"","body":"反转字符串 反转字符串 反转字符串 反转字符串 II 反转字符串中的单词 III 反转字符串 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[\"h\",\"e\",\"l\",\"l\",\"o\"] 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"] 示例 2： 输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] // 1. s.reverse() // JavaScript一次遍历 //遍历依次交换首尾元素 var reverseString = function(s) { let l = s.length; if (l 反转字符串 II 给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前k个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。 示例: 输入: s = \"abcdefg\", k = 2 输出: \"bacdfeg\" 要求: 该字符串只包含小写的英文字母。 给定字符串的长度和 k 在[1, 10000]范围内。 解答： 正则分组 var reverseStr = function(s, k) { return ( s // 按2k 个字符分成数组 .match(new RegExp(`(\\\\w){${2 * k}}|((\\\\w){1,${2 * k - 1}}$)`, \"g\")) // 每2k 个字符的前半部分逆序 后半部分不变 .map(str => [...str.slice(0, k)].reverse().join(\"\") + str.slice(k)) .join(\"\") ); // 组合每2k个项目成字符串 }; reverseStr(\"abcdefg\", 2) 公式规律分组 var reverseStr = function(s, k) { let res = \"\"; for (let i = 0; i 反转字符串中的单词 III 给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 示例 1: 输入: \"Let's take LeetCode contest\" 输出: \"s'teL ekat edoCteeL tsetnoc\" 注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 var reverseWords = function(s) { return s.split(' ').map(val => val.split('').reverse().join('')).join(' ') } "},"算法/仅仅反转字母.html":{"url":"算法/仅仅反转字母.html","title":"仅仅反转字母","keywords":"","body":"仅仅反转字母 仅仅反转字母 问题 js 双指针 左右匹配交换 JS，将字母抽成字符串逆转，将非字母的记录原来的索引，然后挨个插入到字母的字符串中 问题 给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。 示例 1： 输入：\"ab-cd\" 输出：\"dc-ba\" 示例 2： 输入：\"a-bC-dEf-ghIj\" 输出：\"j-Ih-gfE-dCba\" 示例 3： 输入：\"Test1ng-Leet=code-Q!\" 输出：\"Qedo1ct-eeLg=ntse-T!\" 提示： S.length 33 S 中不包含 \\ or \" js 双指针 左右匹配交换 var reverseOnlyLetters = function(S) { let left = 0; // 左指针 let right = S.length - 1; // 右指针 const charArr = S.split(\"\"); while (left JS，将字母抽成字符串逆转，将非字母的记录原来的索引，然后挨个插入到字母的字符串中 var reverseOnlyLetters = function(S) { let strArr = S.replace(/[^a-zA-Z]/g, \"\") .split(\"\") .reverse(); let arr = []; for (let i = 0; i "},"算法/反转字符串中的元音字母.html":{"url":"算法/反转字符串中的元音字母.html","title":"反转字符串中的元音字母","keywords":"","body":"反转字符串中的元音字母 反转字符串中的元音字母 问题 解答 问题 编写一个函数，以字符串作为输入，反转该字符串中的元音字母。 示例 1: 输入: \"hello\" 输出: \"holle\" 示例 2: 输入: \"leetcode\" 输出: \"leotcede\" 说明: 元音字母不包含字母\"y\"。 解答 先找出元音字母位置和所有元音字母，反着插入即可 注意输入字符串有大小写字母，还有数字等。 这里替代元音用的‘-1’。 var reverseVowels = function(s) { if (s.length var reverseVowels = function(s) { s = [...s]; let left = 0; let right = s.length - 1; while (left 双指针： var reverseVowels = function(s) { s = [...s]; let left = 0; // 左指针 let right = s.length - 1; // 右指针 while (left = 0 && !/[aeiou]/i.test(s[right])) { right--; } if (left var reverseVowels = function(s) { s = [...s]; let v = [\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", \"I\", \"O\", \"U\"]; let l = 0; let r = s.length - 1; while (l "},"算法/整数反转.html":{"url":"算法/整数反转.html","title":"整数反转","keywords":"","body":"整数反转 整数反转 问题 1 2 JS解法： 3 4 用了几种写法，这种最直白的方式，也是最快的！！！ 5 问题 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 1 /** * @param {number} x * @return {number} */ var reverse = function(x) { var isPositive, result; var temp = Math.abs(x); if (x > 0) { isPositive = true; } else { isPositive = false; } var t2 = (temp + \"\") .split(\"\") .reverse() .join(\"\") - 0; if (t2 2 JS解法： 先判断x是否满足条件，不满足直接置为0节省运算成本。 将满足条件的数字X的绝对值，转为字符串y,开始进行颠倒运算，思路为JS的字符串下标进行取值，用+=的方式拼接到新的字符串len上去， 输出经过判断的len的值：绝对值是否大于2**31，是否小于0，小于0拼接个减号上去，再转换为数字var reverse = function(x) { Math.abs(x) > 2 ** 31 - 1 ? (x = 0) : x; if (x == 0) return 0; let y = Math.abs(x).toString(), len = \"\"; for (var i = 0; i 2 ** 31 - 1 ? (len = 0) : x 3 思路 先把符号去掉，按正整数处理 把数字转成字符串，反转字符串 因为最大合法数字是10位数，正值为2147483647，负值为2147483648，所以大于10位的直接返回0；小于10位的一定没问题；等于10位的，直接按字符串比较大小。 代码 var reverse = function(x) { let fh = \"\", re; if(x10 || re.length === 10 && re > (x 4 用了几种写法，这种最直白的方式，也是最快的！！！ var reverse = function(x) { let flag = false if(x 0; i--){ x = 10*x + parseInt(s[i-1]) } if(flag){ x = -x } x = Math.abs(x)>(2**31-1)?0:x return x }; 5 var reverse = function(x) { //新建一个数保存输出数值 let y = 0; //判断x是否等于0,不等于0才进行一下步骤 while (x != 0) { //以x=123为例 let z = x % 10; //3,2,1 x = parseInt(x / 10); //12,1,0 y = y * 10 + z; //3,32,321 } //获取范围最大值和最小值 const maxY = Math.pow(2, 31) - 1; const minY = -Math.pow(2, 31); //判断是否溢出 if (y > maxY || y "},"算法/两数相加.html":{"url":"算法/两数相加.html","title":"两数相加","keywords":"","body":"两数相加 两数相加 问题 javascript 分解思路 160ms 2. 3. 4. JavaScript各种递归，各种速度被打败 问题 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -> 4 -> 3) + (5 -> 6 -> 4) 输出：7 -> 0 -> 8 原因：342 + 465 = 807 javascript 分解思路 160ms /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ var listToStr = function(list) { //倒序链表转为字符串 let str = \"\"; while (list) { val = list.val; list = list.next ? list.next : null; str += val; } return str .split(\"\") .reverse() .join(\"\"); }; var strToList = function(str) { //数字转为链表，且倒序 let arr = str.split(\"\"); let listNode = new ListNode(arr.shift()); return arr.reduce((ori, cur) => { let ln = new ListNode(cur); ln.next = ori; return ln; }, listNode); }; var add = function(a, b) { //两个字符串相加 var res = \"\", c = 0; a = a.split(\"\"); b = b.split(\"\"); while (a.length || b.length || c) { c += ~~a.pop() + ~~b.pop(); res = c % 10 + res; c = c > 9; } return res; }; /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var addTwoNumbers = function(l1, l2) { let sum = add(listToStr(l1), listToStr(l2)); return strToList(sum); }; 2. /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var addTwoNumbers = function(l1, l2) { let result = new ListNode(null); let nextRst = result; // 进位 let params = 0; // 传给下一个层级的值 let val = 0; // 传给当前层级的值 while (l1 != null || l2 != null) { // TODO let x = l1 != null ? l1.val : 0; let y = l2 != null ? l2.val : 0; val = (x + y + params) % 10; params = Math.floor((x + y + params) / 10); nextRst.next = new ListNode(val); nextRst = nextRst.next; if (l1 != null) l1 = l1.next; if (l2 != null) l2 = l2.next; } if (params) { nextRst.next = new ListNode(params); } return result.next; }; 3. var addTwoNumbers = function(l1, l2) { var l1Node = l1; var l2Node = l2; var args = []; // 存储对应的位置相加的结果 var needAdd1 = 0; // 先不考虑进位，对应的链表每一位相加 while (l1Node || l2Node) { // 考虑两个链表长度不同的情况 // var val1 = l1Node && l1Node.val || 0 // var val2 = l2Node && l2Node.val || 0 var val1 = l1Node ? l1Node.val : 0; var val2 = l2Node ? l2Node.val : 0; var temp = val1 + val2; args.push(temp); l1Node && (l1Node = l1Node.next); l2Node && (l2Node = l2Node.next); } // 考虑进位的问题 for (let i = 0; i 9) { args[i] -= 10; if (args[i + 1] === undefined) { args[i + 1] = 1; } else { args[i + 1] += 1; } } } // 把数组转成成链表(递归) function createList(...argu) { if (argu.length > 0) { var nodeStart = new ListNode(argu[0]); argu.shift(); nodeStart.next = createList(...argu); return nodeStart; } else { return null; } } return createList(...args); }; 4. JavaScript各种递归，各种速度被打败 链表递归作和，和为数组，数组进位处理，最终转链表。 // 定义节点 class Node { constructor(val) { this.val = val; this.next = null; } } // 定义链表 class NodeList { constructor(arr) { const nodeList = []; const root = new Node(arr.shift()); nodeList.push(root); arr.forEach((item, idx) => { const newNode = new Node(item); nodeList[idx].next = newNode; nodeList.push(newNode); }); nodeList.length = 0; return root; } } // 进位运算 function pushDigit(arr, idx) { const item = arr[idx]; if (item === void 0) { return arr; } if (arr[idx] >= 10) { arr[idx] = item - 10; arr[idx + 1] !== void 0 ? ++arr[idx + 1] : arr.push(1); } return pushDigit(arr, idx + 1); } var addTwoNumbers = function(l1, l2) { const sumArr = []; // 作和 function add(acc, item1, item2) { if (!item1 && !item2) { return acc; } item1 = item1 || {}; item2 = item2 || {}; acc.push(+(item1.val || 0) + +(item2.val || 0)); return add(acc, item1.next, item2.next); } add(sumArr, l1, l2); // 进位 const result = pushDigit(sumArr, 0); // 转链表 return new NodeList(result); }; "},"算法/无重复字符的最长子串.html":{"url":"算法/无重复字符的最长子串.html","title":"无重复字符的最长子串","keywords":"","body":"无重复字符的最长子串 无重复字符的最长子串 问题 1. 2. 3. JS仿照官方滑动窗口解法 4. 问题 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 1. ✔ Accepted ✔ 987/987 cases passed (108 ms) ✔ Your runtime beats 97.07 % of javascript submissions ✔ Your memory usage beats 90.12 % of javascript submissions (37.5 MB) 先出一个游标的解析方便后续的快速理解 字符串： \"abcadefcsd\" 第一次游标[0,0] 此时子串a 第二次游标[0,1] 此时子串ab 第三次游标[0,2] 此时子串abc 第四次游标[0,3] 由于a重复。所以第一个游标右移一位 第五次游标[1,4] 此时子串b 第六次游标[1,5] 此时子串bc 。。。。。。。 最后一次游标[9,9] 这样通过游标的方式来寻找无重复公共子串 但是第二次游标 第三次游标 和第四次 第五次游标 重复对中间的bc子串进行了检测。造成了浪费。 我们希望的检测过的子串不被二次重复检测 此时的过程 e.g 字符串： \"abcadefcsd\" 第一次游标[0,0] 此时子串a 第二次游标[0,1] 此时子串ab 第三次游标[0,2] 此时子串abc 第四次游标[0,3] 由于a重复和第一个a重复。所以第一个游标右移一位 第二个游标保持 第五次游标[1,4] 此时子串bcade 第六次游标[1,5] 此时子串bcadef 第七次游标[1,6] 此时子串bcadef 第八次游标[1,7] 此时第8个字符和子串第二个字母重复 所有第一个游标右移2位，第二个游标保持 第九次游标[3,8] 此时子串abdefc 。。。。。。。 所有最后通过裁剪子串。查找子串中重复字符的位置。来进行遍历 let str = s.slice(j,i); let target = s[i]; t = str.indexOf(target); 最终代码 var lengthOfLongestSubstring = function(s) { let num = 0, j = 0, t = 0; for (let i = 0; i 2. var lengthOfLongestSubstring = function(s) { let arr = []; let max_len = 0, count = 0; for (let r of s) { if (arr.includes(r)) { while (true) { if (arr.shift() == r) { break; } } arr.push(r); count = arr.length; } else { count++; max_len = Math.max(count, max_len); arr.push(r); } } return max_len; }; 3. JS仿照官方滑动窗口解法 var lengthOfLongestSubstring = function(s) { if (!s) return 0; let len = s.length; if (len === 1) return 1; let num = 0; let index = new Array(len); for (let i = 0, j = 0; i 4. 执行用时 : 112 ms, 在Longest Substring Without Repeating Characters的JavaScript提交中击败了99.51% 的用户 内存消耗 : 37.8 MB, 在Longest Substring Without Repeating Characters的JavaScript提交中击败了84.44% 的用户 var lengthOfLongestSubstring = function(s) { if (!s) return 0; let len = s.length; if (len === 1) return 1; let num = 0; let j = 0; let t = 0; for (let i = 1; i "},"算法/寻找两个有序数组的中位数.html":{"url":"算法/寻找两个有序数组的中位数.html","title":"寻找两个有序数组的中位数","keywords":"","body":"寻找两个有序数组的中位数 寻找两个有序数组的中位数 问题 官方 不考虑时间复杂度代码量比较小的版本: 3 4 问题 给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。 请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: nums1 = [1, 3] nums2 = [2] 则中位数是 2.0 示例 2: nums1 = [1, 2] nums2 = [3, 4] 则中位数是 (2 + 3)/2 = 2.5 官方 function f1(arr1, arr2) { if (arr1.length > arr2.length) { [arr1, arr2] = [arr2, arr1]; } const arr1Length = arr1.length, arr2Length = arr2.length; let iMin = 0, iMax = arr1Length; const halfLen = Math.floor((arr1Length + arr2Length + 1) / 2); // +1 这种情况单数时取maxleft while (iMin arr1[i]) { iMin = i + 1; } else if (i > iMin && arr1[i - 1] > arr2[j]) { iMax = i - 1; } else { let maxLeft = 0; if (i === 0) { maxLeft = arr2[j - 1]; } else if (j === 0) { maxLeft = arr1[i - 1]; } else { maxLeft = Math.max(arr1[i - 1], arr2[j - 1]); } if ((arr1Length + arr2Length) % 2 === 1) { return maxLeft; } let minRight = 0; if (i === arr1Length) { minRight = arr2[j]; } else if (j === arr2Length) { minRight = arr1[i]; } else { minRight = Math.min(arr2[j], arr1[i]); } return (maxLeft + minRight) / 2; } } return 0; } 不考虑时间复杂度代码量比较小的版本: 可以自己拿到 IDE 里去试试，当arr1 , arr2 数据量很大时，f1 和 f2 效率差异巨大。我试了一次，数组长度好像是千万。一个毫秒级，一个二十多秒。作为一个前端，对于前端那种数据量，f2 就够用啦。 function f2(arr1, arr2) { const tmp = arr1.concat(arr2).sort((a, b) => a - b); const tmp2 = tmp.slice( Math.ceil(tmp.length / 2) - 1, Math.floor(tmp.length / 2) + 1 ); // 切出来的长度为1或者2 let num = 0; tmp2.map(item => (num += item)); return num / tmp2.length; } 3 合并排序； 根据数组的奇偶数，套用公式var findMedianSortedArrays = function(nums1, nums2) { let arr = nums1.concat(nums2).sort((a, b) => a - b); let l = arr.length % 2; let odd = arr[(arr.length + 1) / 2 - 1]; let even = (arr[arr.length / 2 - 1] + arr[arr.length / 2]) / 2; if (l) return odd; return even; }; 4 var findMedianSortedArrays = function(nums1, nums2) { let reIndex = nums2.length - 1; //记录当前nums2的索引 for (let i = nums1.length - 1; i >= 0; i--) { while (nums1[i] -1) { nums1.splice(i + 1, 0, ...nums2.splice(reIndex, 1)); reIndex--; } } const arr = [...nums2, ...nums1]; const { length } = arr; return length % 2 ? arr[Math.floor(length / 2)] : (arr[length / 2] + arr[length / 2 - 1]) / 2; }; "},"算法/最长回文子串.html":{"url":"算法/最长回文子串.html","title":"最长回文子串","keywords":"","body":"最长回文子串 最长回文子串 问题 1. 2. javascript实现的中心扩展法 3. JS版 暴力破解 4. JS版 对称查找 问题 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 输入: \"babad\" 输出: \"bab\" 注意: \"aba\" 也是一个有效答案。 示例 2： 输入: \"cbbd\" 输出: \"bb\" 1. 字符串里的每个元素 item 都有两种情况： 可能是最大回文串的中心对称点； 如果item等于下一个元素next ，那么可能它俩一起 ( item + next ) 成为最大回文串的中心对称点； 传入的 string 先变成数组，然后遍历两次这个数组： 第一次遍历，以每个 item 自身为对称点，找到最大的回文串； 第二次遍历，判断 item 是否等于 next，若等于，则以当他俩一起为对称点，找到最大的回文串； 然后比较两个结果，返回更长的那个回文串 var longestPalindrome = function(s) { if (!s || !s.trim()) return \"\"; if (s.length === 1) return s; if (s.length === 2) return s[0] === s[1] ? s[0] + s[1] : s[0]; var sArray = s.split(\"\"); var x = [...new Set(sArray)]; var result; var result1; var result2; if (x.length === 1) return s; // 以item为对称点 找到回文串 result1 = sArray.reduce(function(memo, item, idx, self) { var ret; if (idx === 0) return memo; if (typeof self[idx - 1] !== \"string\" || self[idx - 1] !== self[idx + 1]) return memo; memo = (function() { var middle = idx; var i = 1; var result = item; while ( typeof self[middle + i] === \"string\" && typeof self[middle - i] === \"string\" && self[middle + i] === self[middle - i] ) { ++i; } if (i === 1) { return memo; } i = i - 1; result = self.slice(middle - i, middle + i + 1).join(\"\"); return result.length > ((memo && memo.length) || 1) ? result : memo; })(); return memo; }, sArray[0]); // 以item 和 next 两个一起为对称点 找到回文串 result2 = sArray.reduce(function(memo, item, idx, self) { // axxa 中心轴是两个字母 if (item !== self[idx + 1]) return memo; memo = (function() { var left = idx; var right = idx + 1; var i = 1; var result = item + item; while ( typeof self[right + i] === \"string\" && typeof self[left - i] === \"string\" && self[left - i] === self[right + i] ) { ++i; } if (i === 1) return result.length > ((memo && memo.length) || 1) ? result : memo; i = i - 1; result = self.slice(left - i, right + i + 1).join(\"\"); return result.length > ((memo && memo.length) || 1) ? result : memo; })(); return memo; }, sArray[0]); return result1.length > result2.length ? result1 : result2; }; 2. javascript实现的中心扩展法 var longestPalindrome = function(s) { if (s === \"\") return s; let maxStr = s[0]; let len = s.length; for (let i = 0; i maxStr.length ? tempX : maxStr; } return maxStr; }; 3. JS版 暴力破解 暴力破解获取所有可能的子串，判断是否是回文 var longestPalindrome = function(s) { var max = \"\"; var len = s.length; if (len 4. JS版 对称查找 一核对称:121、12321、1 双核对称:11、1221、123321 先枚举每一个字符，再针对该字符进行左右（双核对称时为当前字符和下一个字符）查找相等匹配 var longestPalindrome = function(s) { var max = \"\"; var len = s.length; if (len max.length ? max_new : max; } return max; }; function core(str, str_len, str_i) { var max_1 = loop(str_i - 1, str_i + 1); // 一核对称 str_len >= 3 str_i = 1 var max_2 = loop(str_i, str_i + 1); // 双核对称 str_len >= 2 str_i = 0 return max_1.length > max_2.length ? max_1 : max_2; function loop(pre, next) { if (!str[pre] || !str[next]) return str.slice(pre + 1, next); if (str.charAt(pre) === str.charAt(next)) return loop(pre - 1, next + 1); else return str.slice(pre + 1, next); } } "},"算法/回文数.html":{"url":"算法/回文数.html","title":"回文数","keywords":"","body":"回文数 回文数 题目 利用数组的reverse方法实现 JavaScript 99.26% 解法 3 JavaScript写回文数 Javascript两种不转换为字符串的解法 javascript不用字符串解法 题目 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 输入: 121 输出: true 示例 2: 输入: -121 输出: false 解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 输入: 10 输出: false 解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶:你能不将整数转为字符串来解决这个问题吗？ 利用数组的reverse方法实现 var isPalindrome = function(x) { let x1 = String(x); let arr = x1.split(\"\"); if (arr.reverse().join(\"\") == x1) return true; return false; }; JavaScript 99.26% 解法 简单暴力，虽然快于99%的js写法，但还是用了264ms var isPalindrome = function(x) { if (x 0; i--) { x += s[i - 1]; } if (s != x) { return false; } return true; }; 3 var isPalindrome = function(x) { if (x JavaScript写回文数 var isPalindrome = function(x) { //先判断特殊情况 //x = 0 为回文数 if (x == 0) { return true; } //x为负数或者x最后一位数为0,即不是回文数 if (x Javascript两种不转换为字符串的解法 第一种，反转整数,再判断反转后的整数是否和输入的整数相等： function f1(x) { let num = 0; const f = function(x) { if (Math.ceil(x / 10) !== 0 || (-10 2147483647 || num 第二种，先计算出整数的位数，再取每一位上的值，再判断对应位数的值是否相等。 function f(x) { let tmp = x; let capacity = 1; while (tmp / 10 >= 1 || tmp / 10 0) { tmpArr.push(Math.floor(x / Math.pow(10, i)) % 10); } else if (x javascript不用字符串解法 使用最简单的数学反转方法即可把不符合条件的先排除 但是结果不怎么理想哈哈 执行用时 : 428 ms, 在Palindrome Number的JavaScript提交中击败了62.65% 的用户 内存消耗 : 48.3 MB, 在Palindrome Number的JavaScript提交中击败了5.01% 的用户 var isPalindrome = function(x) { if (x "},"算法/Z字形变换.html":{"url":"算法/Z字形变换.html","title":"Z字形变换","keywords":"","body":"Z 字形变换 Z 字形变换 题目 解答1 解答2 题目 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 \"LEETCODEISHIRING\" 行数为 3 时，排列如下： L C I R E T O E S I I G E D H N 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：\"LCIRETOESIIGEDHN\"。 请你实现这个将字符串进行指定行数变换的函数： string convert(string s, int numRows); 示例 1: 输入: s = \"LEETCODEISHIRING\", numRows = 3 输出: \"LCIRETOESIIGEDHN\" 示例 2: 输入: s = \"LEETCODEISHIRING\", numRows = 4 输出: \"LDREOEIIECIHNTSG\" 解释: L D R E O E I I E C I H N T S G 解答1 找到 每个字符所在的行，然后放到对应的数组，最后拼接每行的字符串 rowindex是根据上一个字符的rowindex加1或减1（offset=1, offset=-1），如果numRows是3，rowindex的范围是[0,2]，因此可以检测到达边界的时候改变offset的符号 var convert = function(s, numRows) { var rows = new Array(numRows), ch, offset = 1, prevIndex = -1, rowIndex; for (let i = 0; i 0 && i % (numRows - 1) === 0) { offset = -offset; } if (!rows[rowIndex]) { rows[rowIndex] = \"\"; } rows[rowIndex] += ch; prevIndex = rowIndex; } return rows.join(\"\"); }; 解答2 按行排序，通过变量来控制下标的递增／递减 var convert = function(s, numRows) { // 通过一个数组来存储numRows个字符串 let arr = []; // 记录当前下标 let count = 0; // 当前应该是下标递增或是递减 let add = true; // 如果numRows为1，直接返回字符串s if (numRows === 1) { return s; } // 遍历给定字符串 for (let i = 0; i "},"算法/字符串转换整数.html":{"url":"算法/字符串转换整数.html","title":"字符串转换整数 (atoi)","keywords":"","body":"字符串转换整数 (atoi) 字符串转换整数 (atoi) 题目 解答 2 3. 题目 请你来实现一个 atoi 函数，使其能将字符串转换成整数。 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 在任何情况下，若函数不能进行有效的转换时，请返回 0。 说明： 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−232, 232 − 1]。如果数值超过这个范围，qing返回 INT_MAX (231 − 1) 或 INT_MIN (−231) 。 示例 1: 输入: \"42\" 输出: 42 示例 2: 输入: \" -42\" 输出: -42 解释: 第一个非空白字符为 '-', 它是一个负号。 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 示例 3: 输入: \"4193 with words\" 输出: 4193 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。 示例 4: 输入: \"words and 987\" 输出: 0 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。 示例 5: 输入: \"-91283472332\" 输出: -2147483648 解释: 数字 \"-91283472332\" 超过 32 位有符号整数范围。 因此返回 INT_MIN (−2^31) 。 解答 初看本题，很自然会想到用正则表达式，刷一下正则，再判断边界即可得出答案。题解里很多提交的代码都是这样做的，看上去很完美。 但这里的问题正是在“判断边界”这里。 首先，题目要求是32位整数，作为有符号数，其存储方式为： 长度32位，即32bit=4byte 最高位为符号位，符号位为1，表示负数，为0则表示正数 一个32位整数表示的最大正数为: 0x7FFFFFFF, 即最高位为0，其余31位全部为1，即2^31-1 一个32位整数表示的最小负数为: 0x80000000,即最高位为1，其余31位全部为0，即-2^31 (这里要了解所谓的“负权”) 所以题目给的上下边界值实际上是因为32位整数的存储方式而自然产生的。 现在假设原字符串 S 通过正则匹配后得出的结果 X 已经超出了Int32的范围，则将X强行转为Int32之后，必然导致X被截断（不考虑强转时程序报错的情况），从而会丢失X的高位部分。因为此时的X只有32位，它将必然位于上面提到的32位整数的上下限之间。换句话说，如果对正则的结果使用Int32类型进行强转，其边界校验实际上是无效的。 而之所以很多提交的代码有效，恰恰是因为编译环境使用了超过Int32的整数类型来保存类型转换的结果，譬如Int64。此时存储结果的空间足够大，不会有精度丢失。但问题是，无论有心还是无意，我们使用了超过Int32大小的数据类型来解决问题。而题目中有这样的限制条件： 假设我们的环境只能存储 32 位大小的有符号整数 而在没有更大的整数类型辅助的限制条件下，我们无法对string到int32的强制转换进行边界判断，意味着正则解法是存在严重瑕疵的。 明确说明一下：我认为只要是直接通过比较result与int_max,int_min大小的都是有问题的，比如max(min)这种，或者result>int_max, result 因此保险的方法还是老老实实遍历字符串，根据前一题即第七题的解法，我们可以找到校验整数是否越界溢出的解决方案。下面是一个javascript实现： var myAtoi2 = function(str) { var symbol = 1; var num = 0; var accepted = 0; for (var i = 0; i 0x0ccccccc || (num === 0x0ccccccc && tmp > 7)) { //正溢出 return 0x7fffffff; } if (num 8)) { //负溢出 return -0x80000000; } num = (num 2 var myAtoi = function(str) { // 替换掉e，防止parseFloat将 “12e16” 认成科学计数法 str = str.trim().replace(/e/g, \"a\"); let num = parseFloat(str); num = Number.isNaN(num) ? 0 : num; const edge = Math.pow(2, 31); return Math.max(-edge, Math.min(edge - 1, num)); }; 3. 分成两种情况进行考虑。一种是已经找到了合法字符，一种是未找到合法字符， 需要注意的是返回结果需要是一个整形，后台可能加了类型验证 对于内部出错的，建议检查在比较是否超出整数范围之前判断是否是NaN，由于是从字符串转过来的，在比较时，可能已经是NaN了，之后再比较是否超出整数范围时，就会出现内部出错。 var myAtoi = function(str) { let res = \"\", findedNum = false; if (str.length == 0) { return 0; } for (let i = 0; i Math.pow(2, 31) - 1) return Math.pow(2, 31) - 1; else if (resInt "},"算法/正则表达式匹配.html":{"url":"算法/正则表达式匹配.html","title":"正则表达式匹配","keywords":"","body":"正则表达式匹配 正则表达式匹配 题目 javascript犯规解法 javascript 动态规划求解 题目 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1: 输入: s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 输入: s = \"aa\" p = \"a*\" 输出: true 解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 示例 3: 输入: s = \"ab\" p = \".*\" 输出: true 解释: \".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。 示例 4: 输入: s = \"aab\" p = \"c*a*b\" 输出: true 解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 \"aab\"。 示例 5: 输入: s = \"mississippi\" p = \"mis*is*p*.\" 输出: false javascript犯规解法 var isMatch = function(str, mode) { let reg = new RegExp(mode); let r = str.match(reg); if (!r) return false; if (r[0] === str) { return true; } else { return false; } }; var isMatch = function(s, p) { var ss = \"[___match___]\" + s + \"[/__match__]\"; var exp = \"\\\\[___match___\\\\]\" + p + \"\\\\[/__match__\\\\]\"; var m = new RegExp(exp); return m.test(ss); }; javascript 动态规划求解 // 从正则表达式中提取模式，返回模式的数组 function tokenizer(p) { const tokens = []; let cur = 0; while (cur new Array(s.length + 1).fill(false)); // 空模式和空字符串必定可以匹配 dp[0][0] = true; // 将开头的带*模式初始化（可以匹配空字符串） for (let i = 0; i = 0 && regexp[k - 1].length === 2) { dp[i][j] = dp[i][j] || dp[k][j - 1]; k--; } dp[i][j] = dp[i][j] || dp[k][j - 1]; } } else { // 带*模式的情况 const pChar = token[0]; // 同样要求相等，回溯过程类似 if (pChar === char || pChar === \".\") { let k = i - 1; while (k - 1 >= 0 && regexp[k - 1].length === 2) { dp[i][j] = dp[i][j] || dp[k][j - 1]; k--; } // 需要注意的是带*模式允许匹配多个重复字符，以及空匹配，最后两个表达式对应的就是以上两种情况 dp[i][j] = dp[i][j] || dp[k][j - 1] || dp[i][j - 1] || dp[i - 1][j]; } else { // 当前字符与模式字符不相等，增加一个空匹配 dp[i][j] = dp[i - 1][j]; } } } } return dp[regexp.length][s.length]; }; "},"算法/盛最多水的容器.html":{"url":"算法/盛最多水的容器.html","title":"盛最多水的容器","keywords":"","body":"盛最多水的容器 盛最多水的容器 题目 Javascript 的两种解法 (js) 题目 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例: 输入: [1,8,6,2,5,4,8,3,7] 输出: 49 Javascript 的两种解法 (js) 看到题目第一反应是用两个for循环，计算每一种组合的长度并记录最大值: var maxArea = function(height) { max = 0; for (let i = 0; i 上述方法耗时较长，经过一番思考后探索到双指针法。从左右两边开始计算面积，应用较高的线来寻找较长的范围，从而获得较大的面积。因此当左值较小时，左指针增加，右值较小时，右指针减小。 var maxArea = function(height) { let left = 0, right = height.length - 1, max = 0; while (left max) { max = tmp; } if (height[left] "},"算法/接雨水.html":{"url":"算法/接雨水.html","title":"接雨水","keywords":"","body":"接雨水 接雨水 题目 与天帝论雨后水深 题目 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 感谢 Marcos 贡献此图。 示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1] 输出: 6 与天帝论雨后水深 若问雨水深何许，先当首寻最高峰。高峰两侧群山列，须将右侧倒个个。右山若较左山矮，右山山高累加和。左山不及右山高，距乘左山减加和。如此这般算将好，左右群山水深得。天帝赞叹算法妙，玄之又玄乐无穷。 var calWater = function(height) { let left = 0, v = 0, cv = 0; for (let i = 1; i = height[left]) { v += (i - left - 1) * height[left] - cv; left = i; cv = 0; } else { cv += height[i]; } } return v; }; /** * @param {number[]} height * @return {number} */ var trap = function(height) { let top = -Infinity, index = -1; for (let i = 0; i top) { top = height[i]; index = i; } } return ( calWater(height.slice(0, index + 1)) + calWater([0].concat(height.slice(index, height.length).reverse())) ); }; "},"算法/除自身以外数组的乘积.html":{"url":"算法/除自身以外数组的乘积.html","title":"除自身以外数组的乘积","keywords":"","body":"除自身以外数组的乘积 除自身以外数组的乘积 题目 分治法 3 4 5 题目 给定长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 输入: [1,2,3,4] 输出: [24,12,8,6] 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶： 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 分治法 基本思路：将数组分成两个部分，左半部分的元素依次乘上右半部分所有元素之积，以此类推，右半部分的元素依次乘上左半部分所有元素之积，即得到答案。 分治法的使用：将数组不断对半划分，直到单个元素，然后再两两进行上述基本思路的操作，最终得到答案。 var productExceptSelf = function(nums) { if (nums.length == 0) return nums; let res = new Array(nums.length); //用来保存结果的数组 res.fill(1); let merge = (mul1, mul2, l, r, mid) => { //左右两个部分的数组相互作积，并返回当前区域数组的积 for (let i = l; i { //划分数组，返回当前区域数组的积 if (l == r) { return nums[l]; } let mid = Math.floor((l + r) / 2); return merge(partation(l, mid), partation(mid + 1, r), l, r, mid); //递归调用划分函数 }; partation(0, nums.length - 1); return res; }; 3 var productExceptSelf = function(nums) { var arr = []; var l = 1, r = 1; for (var i = 0; i = 0; j--) { arr[j] *= r; r *= nums[j]; } return arr; }; 4 var productExceptSelf = function(nums) { const result = []; const left = []; const right = []; left[0] = 1; right[nums.length - 1] = 1; for (let i = 1; i = 0; i--) { right[i] = nums[i + 1] * right[i + 1]; } for (let i = 0; i 5 //[a，b，c，d，e] //从左乘一遍得到[1, a, ab, abc, abcd] //从右乘一遍得到[bcde,acde,abde,abce,abcd] var productExceptSelf = function(nums) { var k=nums[0], res=[1]; for(var i=1;i=0;i--){ res[i]*=k; k*=nums[i]; } return res; }; "},"算法/整数转罗马数字.html":{"url":"算法/整数转罗马数字.html","title":"整数转罗马数字","keywords":"","body":"整数转罗马数字 整数转罗马数字 题目 定义转换模板 方便延伸 穷举法 javascript 方便扩展 这个解法应该很容易理解 Javascript 题目 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1: 输入: 3 输出: \"III\" 示例 2: 输入: 4 输出: \"IV\" 示例 3: 输入: 9 输出: \"IX\" 示例 4: 输入: 58 输出: \"LVIII\" 解释: L = 50, V = 5, III = 3. 示例 5: 输入: 1994 输出: \"MCMXCIV\" 解释: M = 1000, CM = 900, XC = 90, IV = 4. 定义转换模板 方便延伸 var intToRoman = function(num) { num = num.toString(); let roman = \"\"; //定义 个，十，百，千 位的 基本位 ， 中间的 ，和 后一位 转换符号 const romanC = [ { jiben: \"I\", zhongjian: \"V\", xiage: \"X\" }, { jiben: \"X\", zhongjian: \"L\", xiage: \"C\" }, { jiben: \"C\", zhongjian: \"D\", xiage: \"M\" }, { jiben: \"M\", zhongjian: \"未定义万\", xiage: \"未定义十万\" } ]; for (var j = 0; j 4 && i 穷举法 var intToRoman = function(num) { // let map = { // 1: 'I', // 5: 'V', // 10: 'X', // 50: 'L', // 100: 'C', // 500: 'D', // 1000: 'M', // }; let map = [\"I\", \"V\", \"X\", \"L\", \"C\", \"D\", \"M\"]; let res = []; let numStr = num + \"\"; let len = numStr.length; for (let i = 0; i javascript 方便扩展 const transform = (val, arr) => { if (val 0) { s = transform(num % 10, arr[i]) + s; num = Math.floor(num / 10); i++; } return s; }; 这个解法应该很容易理解 var intToRoman = function(num) { var q = Math.floor(num / 1000); var b = Math.floor((num % 1000) / 100); var s = Math.floor((num % 100) / 10); var g = num % 10; var result = \"\"; var parse = function(n, x, y, z) { if (n 8) { return x.repeat(10 - n) + z; } return \"\"; }; //千位 if (q > 0) { result += \"M\".repeat(q); } //百位 result += parse(b, \"C\", \"D\", \"M\"); //十位 result += parse(s, \"X\", \"L\", \"C\"); //个位 result += parse(g, \"I\", \"V\", \"X\"); return result; }; Javascript var intToRoman = function(num) { // make a dictionary, let dict = [ [\"\", \"M\", \"MM\", \"MMM\"], [\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"], [\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"], [\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"] ]; //凑满4位数, 拆成数组，每个数字转成字典里对应的罗马数字，再转回字串 return (\"000\" + num) .replace(/.*(....)$/, \"$1\") .split(\"\") .map((n, i) => dict[i][+n]) .join(\"\"); }; "},"算法/罗马数字转整数.html":{"url":"算法/罗马数字转整数.html","title":"罗马数字转整数","keywords":"","body":"罗马数字转整数 罗马数字转整数 题目 思路 2. 3. 4. 题目 罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: \"III\" 输出: 3 示例 2: 输入: \"IV\" 输出: 4 示例 3: 输入: \"IX\" 输出: 9 示例 4: 输入: \"LVIII\" 输出: 58 解释: L = 50, V= 5, III = 3. 示例 5: 输入: \"MCMXCIV\" 输出: 1994 解释: M = 1000, CM = 900, XC = 90, IV = 4. 思路 首先将所有的组合可能性列出并添加到哈希表中 然后对字符串进行遍历，由于组合只有两种，一种是 1 个字符，一种是 2 个字符，其中 2 个字符优先于 1 个字符 先判断两个字符的组合在哈希表中是否存在，存在则将值取出加到结果 ans 中，并向后移2个字符。不存在则-将判断当前 1 个字符是否存在，存在则将值取出加到结果 ans 中，并向后移 1 个字符 遍历结束返回结果 ansvar romanToInt = function(s) { const map = { I: 1, IV: 4, V: 5, IX: 9, X: 10, XL: 40, L: 50, XC: 90, C: 100, CD: 400, D: 500, CM: 900, M: 1000 }; let ans = 0; for (let i = 0; i 2. var romanToInt = function(s) { const basicSign = { //列出所有大体的情况 I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }; let result = 0; let _arr = s.split(\"\"); // 假设没有特殊情况下 一一加加 result = _arr.reduce((total, num) => { return total + basicSign[num]; }, 0); // 第二步考虑特殊情况 将之前特殊情况找出来 const keys = [\"CM\", \"XC\", \"IV\", \"IX\", \"XL\", \"CD\"]; keys.forEach((item, index) => { if (s.indexOf(item) > -1) { result -= 2 * basicSign[item.split(\"\")[0]]; } }); return result; }; 3. var romanToInt = function(s) { var json1 = { IV: 4, IX: 9, XL: 40, XC: 90, CD: 400, CM: 900 }; var json2 = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }; var number = 0; for (var i = 0; i 0) { number += json1[str]; i++; } else { str = s.charAt(i); number += json2[str]; } } return number; }; 4. var romanToInt = function(s) { var romanToIntMap = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1000 }; var arr = s.split(\"\"); var result = 0; for (var i = 0; i "},"算法/整数转换英文表示.html":{"url":"算法/整数转换英文表示.html","title":"整数转换英文表示","keywords":"","body":"整数转换英文表示 整数转换英文表示 题目 1. 2.这道题目不难，完全是在考验各种边界情况是否考虑到了 题目 将非负整数转换为其对应的英文表示。可以保证给定输入小于 231 - 1 。 示例 1: 输入: 123 输出: \"One Hundred Twenty Three\" 示例 2: 输入: 12345 输出: \"Twelve Thousand Three Hundred Forty Five\" 示例 3: 输入: 1234567 输出: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\" 示例 4: 输入: 1234567891 输出: \"One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One\" 1. const _0_9 = [ \"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\" ]; const _10_19 = [ \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\" ]; const _20_90 = [ , , \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\" ]; const _100_bil = [\"Hundred\", \"Thousand\", \"Million\", \"Billion\"]; var numberToWords = function(num) { let strnum = num.toString(); var intPartFormat = num.toString().replace(/(\\d)(?=(?:\\d{3})+$)/g, \"$1,\"); //将整数部分逢三一断 let nums = intPartFormat.split(\",\"); let str = \"\"; let count = nums.length - 1; if (nums.length == 1 && Number(nums[0]) == 0) { return _0_9[0]; } for (let i = 0; i 0) { str += \" \" + _100_bil[count]; } count--; } return str; }; var format100 = function(nums) { let _aa = format10(nums.substr(1), \" \"); let index = nums[0]; let _num = _0_9[index]; return _num + \" \" + _100_bil[0] + _aa; }; var format10 = function(nums, pad = \"\") { console.log(nums); let cellstr = Number(nums).toString(); // console.log(nums,cellstr.length,nums[0] == '1'); if (cellstr.length == 1) { return format0(nums[1], pad); } else if (cellstr.length == 2) { if (nums[0] == \"1\") { // console.log(nums[1]); return pad + _10_19[nums[1]]; } else { return pad + _20_90[nums[0]] + format0(nums[1], \" \"); } } }; var format0 = function(nums, pad = \"\") { if (nums == \"0\") return \"\"; return pad + _0_9[nums]; }; 2.这道题目不难，完全是在考验各种边界情况是否考虑到了 const convertMap = { 1000000000: \"Billion\", 1000000: \"Million\", 1000: \"Thousand\", 100: \"Hundred\", 90: \"Ninety\", 80: \"Eighty\", 70: \"Seventy\", 60: \"Sixty\", 50: \"Fifty\", 40: \"Forty\", 30: \"Thirty\", 20: \"Twenty\", 19: \"Nineteen\", 18: \"Eighteen\", 17: \"Seventeen\", 16: \"Sixteen\", 15: \"Fifteen\", 14: \"Fourteen\", 13: \"Thirteen\", 12: \"Twelve\", 11: \"Eleven\", 10: \"Ten\", 9: \"Nine\", 8: \"Eight\", 7: \"Seven\", 6: \"Six\", 5: \"Five\", 4: \"Four\", 3: \"Three\", 2: \"Two\", 1: \"One\", 0: \"Zero\" }; const convertOrderList = Object.keys(convertMap) .map(k => { return { number: Number(k), word: convertMap[k] }; }) .sort((a, b) => b.number - a.number); function helper(num) { if (num === 0) { return \"\"; } if (num 0) { firstDigit = firstNum; unit = word; remain = num % number; break; } } return ((num "},"算法/数组类算法js[双指针].html":{"url":"算法/数组类算法js[双指针].html","title":"数组类算法js(双指针)","keywords":"","body":"数组类算法js(双指针) 数组类算法js(双指针) 双指针 1.移动零 2.移除元素 3.删除数组中的重复项 4. 删除排序数组中的重复项 II 双指针 启发：假设已经有了这个数组的任意两个元素之和的有序数组。那么利用二分查找法进行查找，但是排序需要平方时间 这个二分查找法启发我们，可以直接对两个数字的和进行一个有序的遍历 双指针如果取两个最小（和最小） 双指针如果取两个最大（和最大） 双指针如果取最小和最大（和居中） 对于平均查找时间来讲，居中的具有优势 证明双指针法为什么是有效的？ 如果存在答案，那么0 一个循环不变式：每次循环后i, j永远都是可能性取值的边界位置 证明： 初始化：初始化前，i, j 处于边界（处于边界的意思是：已经有效排除了所有该排除的可能性） 维持：（若某次操作前，i, j处于边界， 操作后，i, j还是处于边界） a) 若(i) + (j) > target 那么增加i为i1，(i1) + (j) > (i) + (j) > target，也即 任意移动i，所得的和都比target要大，因此排除掉了(j)位置的所有可能性 只能递减j b) 若(i) + (j) 双指针贪心 双指针法为什么可以找到所有的情况? 这里有一个循环不变式： small没加一个，表示small-1的所有可能性已经穷尽；并且也已经穷尽了big从small + 1到当前值的可能性 以target = 15为例说明： step1. small = 1, big =2，将big一直向右移动，直至sum(small - big) = 15，记录下来； 继续加到sum(small - big) = 21 > 15，此时small = 1, big = 6 这是如果big继续加大，那么sum只会更大，偏离target更多，因此 以small = 1起始的所有情况穷尽了 step2. 内部while循环 找到的是第一个sum > target的big值 此时small = 1, big = 6，在前面一个的时候sum = middle big > small >= midlle sum(small - big) > target 双指针窗口 为什么start和end这种移动方式就能找到所有 无重复的字符串 循环不变式：一直求得是以start开头的最长无重复字符串 说明：以abcdcbaefga为例 step1. start = 0 end一直累加，直到end指向4 这是以0开头的最长的无重复字符串 step2. 当end = 4时，因为此时start = 0，因为start - end之间含有两个c 因此，移动start = 1，此时还是有两个c，因此 此时的end - start无疑较小，继续累加，这是以1开头的最长无重复 start =2 ，此时还有两个c，继续累加，这是以2开头的最长无重复字符串 start = 3，无重复，此时需要累加end，以求得以3开头的最长无重复字符串 1.移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 var moveZeroes = function(nums) { let n = nums.length; for (let i = 0; i 双指针方法 var moveZeroes = function(nums) { let n = nums.length; let i = -1; for (let j = 0; j 2.移除元素 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 var removeElement = function(nums, val) { for (let i = 0; i 双指针方法 var removeElement = function(nums, val) { let n = nums.length; let rlen = 0; for (let i = 0; i 3.删除数组中的重复项 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 任意数组 方法[1,2,3,2,3,4,1,5] var removeDuplicates = function(nums) { let n = nums.length; let k = 1; for (let i = 1; i 排序的数组[0,0,1,1,1,2,2,3,3,4] var removeDuplicates = function(nums) { let n = nums.length; if (n == 0) return 0; for (let i = 1; i 双指针方法 var removeDuplicates = function(nums) { if (nums.length == 0) return 0; let i = 0; for (let j = 1; j 4. 删除排序数组中的重复项 II 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定 nums = [1,1,1,2,2,3], 函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,1,2,3,3], 函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 你不需要考虑数组中超出新长度后面的元素。 var removeDuplicates = function(nums) { let n = nums.length; let flag = false; //1个为false for (let i = 1; i 双指针方法 var removeDuplicates = function(nums) { let n = nums.length; if (n "},"算法/两数之和.html":{"url":"算法/两数之和.html","title":"两数之和","keywords":"","body":"两数之和 两数之和 问题 使用Object作为Map 暴力双for循环 使用Map函数 边存边比较 将上述改成尾递归的形势 空间换时间，快是快但是会有点占用空间，不过在数据量变大的时候优势明显。 使用es6的Map结构实现哈希表 问题 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 使用Object作为Map 执行用时 : 76 ms,JavaScript提交中击败了99.21% 的用户 var twoSum = function(nums, target) { let map = {}; for (let i = 0; i 暴力双for循环 用两个for循环来进行操作，优点是如果没接触过的话可能第一时间想到用这个方法，缺点是耗时太长，而且时间复杂度为O(n^2），不推荐使用 var twoSum = function(nums, target) { let arr = nums; let arrs = new Array(); for (let i = 0; i 使用Map函数 创建一个Map()，将要比较的数组中每个数所在的位置和数用Map数据结构存储起来，然后使用for循环来和map里面的数据进行比较，这里要注意一下，因为不能重复使用数组里面位置相同的数字，必须要对比一下map里面存储的位置与当前比较的数字的位置是否相同 var twoSum = function(nums, target) { let map = new Map(); let arr = new Array(); for (let i in nums) { map.set(nums[i], i); } for (let j = 0; j 边存边比较 非常简洁的一个方法，原理是先创建一个json空数组，以键值对的方式存储位置和对应的数字，然后for循环给的数组，当前数字不符合要求就存入json，然后再次比较，直到得到正确答案 var twoSum = function(nums, target) { const map = {}; for (let i = 0; i = 0) { return [map[target - nums[i]], i]; } map[nums[i]] = i; } }; 将上述改成尾递归的形势 执行速度比方法3快了40ms左右，记得使用尾递归优化 var twoSum = function(nums, target, i = 0, maps = {}) { const map = maps; if (map[target - nums[i]] >= 0) { return [map[target - nums[i]], i]; } else { map[nums[i]] = i; i++; if (i 空间换时间，快是快但是会有点占用空间，不过在数据量变大的时候优势明显。 var twoSum = function(nums, target) { let obj = {}; for (let i in nums) { obj[nums[i]] = i; } console.log(obj); for (let j = 0; j 使用es6的Map结构实现哈希表 var twoSum = function(nums, target) { let myMap = new Map(); for (let i = 0; i "},"算法/两数之和II-输入有序数组.html":{"url":"算法/两数之和II-输入有序数组.html","title":"两数之和II-输入有序数组","keywords":"","body":"两数之和 II - 输入有序数组 两数之和 II - 输入有序数组 题目 Javascript 版双指针 一遍哈希表 题目 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。 说明: 返回的下标值（index1 和 index2）不是从零开始的。 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 示例: 输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 Javascript 版双指针 相较于 Two Sum 1, 我们获取的是排序后的数列，因此较好的方法是用双指针，一个指向首位，一个指向末尾，通过对比两者指向元素之和与目标的大小，来遍历我们的数组: 执行用时 :80 ms, 在所有 JavaScript 提交中击败了89.08%的用户 /** * @param {number[]} numbers * @param {number} target * @return {number[]} */ var twoSum = function(numbers, target) { let left = 0; let right = numbers.length - 1; if (numbers.length target) { right--; } else if (numbers[left] + numbers[right] 一遍哈希表 124 ms 34.8 MB const twoSum = function(nums, target) { if ( Object.prototype.toString.call(nums) !== \"[object Array]\" || typeof target !== \"number\" ) { alert(\"input type incorrect\"); return; } const arrMap = new Map(); for (let i = 0; i "},"算法/两数之和IV输入BST.html":{"url":"算法/两数之和IV输入BST.html","title":"两数之和 IV 输入BST","keywords":"","body":"两数之和 IV 输入BST 两数之和 IV 输入BST 题目 BST的定义了解了是关键 解答 第一种思路：整理成数组，回到two sum 2 二分法定义 二分法 双指针 一遍哈希表 用对象呢？ 哈希表+两分法 第二种思路：用二叉树的特性 深度优先搜索 题目 给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。 案例 1: 输入: 5 / \\ 3 6 / \\ \\ 2 4 7 Target = 9 输出: True 案例 2: 输入: 5 / \\ 3 6 / \\ \\ 2 4 7 Target = 28 输出: False BST的定义了解了是关键 思路是遍历树，转换数据格式变为两数之和。需要注意的是 如果树为BST树，可转换为有序数字，使用双指针对撞法效率最高 解答 第一种思路：整理成数组，回到two sum 2 把二叉树变成原来的升序数组，然后再用two sum 2的解法来做 二分法定义 现在我们来玩一个猜数的游戏，假设有一个人要我们猜0-99之间的一个数。那么最好的方法就是从0-99的中间数49开始猜。如果要猜的数小于49，就猜24（0-48的中间数）；如果要猜的数大于49，就猜74（50-99的中间数）。重复这个过程来缩小猜测的范围，直到猜出正确的数字。二分查找的工作方法类似于此。 二分查找操作的数据集是一个有序的数据集。开始时，先找出有序集合中间的那个元素。如果此元素比要查找的元素大，就接着在较小的一个半区进行查找；反之，如果此元素比要找的元素小，就在较大的一个半区进行查找。在每个更小的数据集中重复这个查找过程，直到找到要查找的元素或者数据集不能再分割。 二分查找能应用于任何类型的数据，只要能将这些数据按照某种规则进行排序。然而，正因为它依赖于一个有序的集合，这使得它在处理那些频繁插入和删除操作的数据集时不太高效。这是因为，对于插入和操作来说，为了保证查找过程正常进行，必须保证数据集始终有序。相对于查找来说，维护一个有序数据集的代价更高。此外，元素必须存储在连续的空间中。因此，当待搜索的集合是相对静态的数据集时，此时使用二分查找是最好的选择。 二分查找的接口定义 bisearch int bisearch(void sorted, void target, int size, int esize, int (compare )(const void key1, const void *key2); 返回值：如果查找成功返回目标的索引值；否则返回-1。 描述：利用二分查找定位有序元素数组sorted中target。数组中的元素个数由size决定，每个元素的大小由esize决定。函数指针compare指向一个用户自定义的比较函数。如果key1大于key2，函数返回1，如果key1=key2，函数返回0，如果key1小于key2，函数返回-1。 复杂度：O（lg n），n为要查找的元素个数。 二分法 var findTarget = function(root, target) { if (!root) { // 基础判断 return false; } let nums = []; function inOrder(root) { if (!root) { return; } inOrder(root.left); nums.push(root.val); inOrder(root.right); } inOrder(root); // 以下是二分法的代码 for (let index = 0; index 双指针 var findTarget = function (root, target) { ... let low = 0; high = nums.length - 1; while (low target) { high-- } else { return true } } return false }; 一遍哈希表 var findTarget = function (root, target) { ... const arrMap = new Map() for (let i = 0; i 用对象呢？ var findTarget = function (root, target) { ... const map = {} for (let i = 0; i 哈希表+两分法 和two sum 2的方法不同，需要多做一步判断，不然会出现多次用同一个数的情况。例子是[2,3]，target=6，显然是应该返回false。然而不加判断会返回true。 第一遍找不到4，于是把访问过的3加入哈希表{3 => 1} 第二遍开始查哈希表，要找3，正好有3，就返回了true。然而这两个3都是nums的第二位，用了同一个数字了。 在two sum2中可以实现，因为给的target总是对的，因此就不会出现这种的情况，也就不需要多加一步判断了。 var findTarget = function (root, target) { ... const arrMap = new Map() for (let i = 0; i 第二种思路：用二叉树的特性 深度优先搜索 var findTarget = function (root, k) { let stack = [root] // 数组初始化，存入root let map = [] while (stack.length > 0) { let cur = stack.pop() // 每次把数组顶端的node拿出来 if (map.includes(k - cur.val)) { // 在map数组内查询是否有 return true } map.push(cur.val) // 没有就推入map数组 if (cur.left) { stack.push(cur.left) } if (cur.right) { stack.push(cur.right) } } return false }; Runtime: 152 ms, faster than 5.88% of JavaScript online submissions for Two Sum IV - Input is a BST. 因为右边是最后推入stack的，因此是从右往左的深度优先的查询。 不过感觉非常耗时……也许是因为map是数组的原因？.includes()查询比较耗时？ "},"算法/三数之和.html":{"url":"算法/三数之和.html","title":"三数之和","keywords":"","body":"三数之和 三数之和 题目 解析 热身 three sum 再优化 针对特殊用例优化 重构策略 思路 Three Sum Gif图解 原理 图解 题目 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ] 解析 热身 首先，先找一下它的简化版 2sum 来热热身。 最简单的想法就是把每两个都拿出来加一下，看看结果是不是我们想要的。但是直觉告诉我们，这样子并不高效。举一个很实际的例子就能明白。 比如这个周末你去参加线下相亲会，全场有且只有两个人才是真爱。于是我们每个人都要去找其他所有人聊天，去寻找 ta 是不是自己要找的另一半。每个人都要和每个人说话，这样时间复杂度很高，翻译成计算机的表示就是 O(n2)。 var twoSum = function(nums, target) { for (let i = 0; i 怎么样可以更高效一点？ 这时候要引入哈希表，其实就是一个登记册，写上你的名字和你的要求。如果每个人都提前在主持人那里登记一遍，然后只要大家依次再报出自己名字，主持人就能够识别到，ta 就是你要找的人。 var twoSum = function(nums, target) { let res = {} for (let i = 0; i 很容易看出来，上面的方案仍然可以优化。就是每个人都来问一下主持人，自己要找的人有没有来登记过，如果没有的话，就把自己的要求写下来，等着别人来找自己。 var twoSum = function(nums, target) { let res = {} for (let i = 0; i 2sum 问题最坏的情况是，第一个人和最后一个人配对，每个人都发了一次言。时间复杂度是 O(n)，空间复杂度也是 O(n)，因为主持人要用小本本记录下每个人的发言，最坏的时候，要把所有人的诉求都记一遍。 从生活经验中我们能感觉到什么方案是最好的，而且也能够知道，什么算法已经到达了优化的极限。这就是所谓的”只使用人类的聪明才智“就可以做出来。 当然， 如果没有编程的基础，可能不会想到哈希表-登记册这样的类比，但这应该只影响把解决方案转化为代码表达。想到解决方案这件事，其实是完全不依赖编码能力的。 three sum 好的，热身结束，现在来看 3sum 问题。这个问题复杂了一些，变成了一个人找两个人。 一个新的周末，你再次去现在参加了一个，额，这次不是相亲会，是参加一个街篮比赛，赛前当然要组队啦，现在要想一个方法找到队友。组队还有一个要求，就是队伍的平均实力要符合要求，比如菜鸟抱两个大腿，或者有王者带两个弱鸡。 我们先想一个保底的办法，再去慢慢优化。最简单的办法是，每个人都去依次拉上另一个人一起去找第三个人，这个时间复杂度是 O(n3)O(n3)。 var threeSum = function(nums) { let res = [] for (let i = 0; i 受到上题的启发，在凑齐两人以后，他们可以找主持人登记需求的第三人，而不需要在茫茫人海中去找队友。这样，我们就把问题优化成了每个人都要找其他每个人，即时间复杂度 O(n2)O(n2)，因为需要主持人记录数据，这里还有 O(n)O(n) 的空间复杂度。 var threeSum = function(nums) { let res = [] let hash = {} for (let i = 0; i 再优化 现在已经想到了可用的通用方案，根据题目的特点，看看还有哪里可以做一些优化。比如提前结束一些不可能的组合。 首先安排所有人按照顺序排队站好，这是一个需要花时间的操作，不过磨刀不误砍柴工，付出这个时间还是值得的。排序可以做到 O(nlogn)，这是优于 O(n^2)的。 作者：wonderful611 链接：https://leetcode-cn.com/problems/two-sum/solution/three-sum-ti-jie-by-wonderful611/ 来源：力扣（LeetCode） 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 然后我们选择一个人做C位，既然是C位，那么就需要左右各有一个人。先选择队伍最左边（最小值）和队伍最右边（最大值）两个人，加上你，算一下总和。如果大于 0，说明实力太强了，就把就把右侧的人选调左一位，反之，则调整左边的人选，增强一下实力。当某边选到紧挨着你的人的时候，就意味着组队结束，以你为 C位的所有可能都已经尝试完毕了。 var threeSum = function (nums) { let res = [] nums.sort((a, b) => a - b) // 先排个队，最左边是最弱（小）的，最右边是最强(大)的 for (let i = 1; i 0 && last > i) { // 实力太强，把大神那边右移一位 while (nums[last] === nums[--last]); } else { break // 某一边已经没有人选了 } } while (1) { } } return res } // 示意代码 未AC 于是我们开开心心的把解答发到了力扣，然后就得到了一个 WA（wrong answer）。因为力扣的测试用例往往会有很多边界数据，不针对这些特殊情况做考虑的话，几乎一定会翻车的。 针对特殊用例优化 我们刚刚的解法，会在 [0,0,0,0] 这个情况下败下阵来，此时有两个解决方案，第一种就是直接堵上漏洞，针对有问题的测试数据在代码中加补丁。如果运气好的话，可能下一次提交就会 AC 了。但是这种方法在竞赛中是不可取的，因为一次 WA 会有罚时。在工作中我们可能顺手就打补丁修了问题，然后等到测试报出其他问题再去修。如果测试恰好没有发现任何问题，这段代码就可以上线了。但是这样带来的问题，一是并没有在逻辑层面消除某一类特殊数据可能带来的问题，二是代码会很丑陋，变得难以维护。 所以更好的做法是：从这个不通过的数据提取特征，添加对应特征数据的处理逻辑，一次修复一类的错误，并且尽量保持代码的流畅。 此处的报错是由重复数据引起的，看样子完全一样的两个人没必要 C 位出道两次，但是在一个队伍中其实存在着有两个相同值的可能，比如 [-1, -1, 2] 这种组合。 于是我们新的问题就是：当有多个相同值的时候，选谁做 C 位？ 像在[-1, -1, 2]这个例子中，由第二个-1做了 C 位，我们用人类的聪明才智想一下就很容易想明白。如果一个负数要做 C 位，它必须要保证队里有一个正数，所以选择最右边的那个就可以。反过来看 [-2, 1, 1] 这个案例，为了保证至少有一个负数，我们选择最左边的重复值。 对于 0 这个特殊值来说，左右一定是对称的，有一个极特殊的情况就是队列里面有超过三个 0，此时只有选择中间的 0 才能保证不遗漏这种情况。除此之外，选择哪个0居中都是无所谓的。 重构策略 等等，分析到这里，好像把事情搞得过于复杂了。我们在选择第一个人的时候就分了三种情况。 重新思考一下，一开始选择 C 位，实则是为了利用有序数组快速筛选方案。因为这个人位于中间，所以才会有复杂的选取策略。如果第一次直接选择最左边的那个人，后面的策略依然类似，以双指针从最大最小两端相向而行，直到相遇，或者即将筛选出来三个符号相同的结果，即停止。好像仍然可以找到正确答案，同时也恰好避开了复杂的选 C 位情况。 我们可以进一步把一些明显出界的条件加上判断，再一次剪除部分无用尝试。 var threeSum = function (nums) { let res = [] let length = nums.length; nums.sort((a, b) => a - b) // 先排个队，最左边是最弱（小）的，最右边是最强(大)的 if (nums[0] = 0) { // 优化1: 整个数组同符号，则无解 for (let i = 0; i 0) break; // 优化2: 最左值为正数则一定无解 let first = i + 1 let last = length - 1 do { if (first >= last || nums[i] * nums[last] > 0) break // 两人选相遇，或者三人同符号，则退出 let result = nums[i] + nums[first] + nums[last] if (result === 0) { // 如果可以组队 res.push([nums[i], nums[first], nums[last]]) } if (result 面试中考察算法当然有可能就是比较纯粹的智商测试。既然你能够讲清楚这道题，至少说明你可以理解一个较复杂问题是如何解决的，思维和表达能力可以达到一定的水平。 另一种考察的可能，并不是要背算法，而是让面试者现场对问题进行分析，提出解决方案，然后进一步的转化为代码，再去验证。在这个过程中还可以持续的优化，包括对边界的优化补充，局部分支优化，甚至也包括对解法模型的优化。 这和我们日常的开发过程也很像。从需求抽象出技术方案，再转化为代码，经过联调测试，修bug，可能还有整合和重构。 思路 标签：数组遍历 首先对数组进行排序，排序后固定一个数nums[i]nums[i]，再使用左右指针指向nums[i]nums[i]后面的两端，数字分别为nums[L]nums[L]和nums[R]nums[R]，计算三个数的和sumsum判断是否满足为 00，满足则添加进结果集 如果nums[i]nums[i]大于 00，则三数之和必然无法等于 00，结束循环 如果nums[i]nums[i] == nums[i-1]nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过 当sumsum == 00 时，nums[L]nums[L] == nums[L+1]nums[L+1]则会导致结果重复，应该跳过，L++L++ 当sumsum == 00 时，nums[R]nums[R] == nums[R-1]nums[R−1]则会导致结果重复，应该跳过，R--R−− 时间复杂度：O(n^2)，n为数组长度 /** * @param {number[]} nums * @return {number[][]} */ var threeSum = function(nums) { let ans = []; nums.sort((a, b) => a - b); // 排序 const len = nums.length; if (nums == null || len 0) break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环 if (i > 0 && nums[i] == nums[i - 1]) continue; // 去重 let L = i + 1; let R = len - 1; while (L 0) R--; } } return ans; }; 画解 Three Sum Gif图解 原理 先将数组进行排序 从左侧开始，选定一个值为 定值 ，右侧进行求解，获取与其相加为 00 的两个值 类似于快排，定义首和尾 首尾与 定值 相加 等于 00，记录这三个值 小于 00，首部右移 大于 00，尾部左移 定值右移，重复该步骤 图解 var threeSum = function(nums) { // 最左侧值为定值，右侧所有值进行两边推进计算 let res = []; nums.sort((a, b) => a - b); let size = nums.length; if (nums[0] = 0) { // 保证有正数负数 let i = 0; while (i 0) break; // 最左侧大于0，无解 let first = i + 1; let last = size - 1; while (first 0) break; // 三数同符号，无解 let sum = nums[i] + nums[first] + nums[last]; if (sum === 0) { res.push([nums[i], nums[first], nums[last]]); } if (sum "},"算法/最接近的三数之和.html":{"url":"算法/最接近的三数之和.html","title":"最接近的三数之和","keywords":"","body":"最接近的三数之和 最接近的三数之和 题目 执行用时 :100 ms, 在所有 JavaScript 提交中击败了91.81%的用户 暴力法：复杂度太高 第二种方法 三个指针，固定一个指针，其两个以他为基础进行遍历。 题目 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 例如，给定数组 nums = [-1，2，1，-4], 和 target = 1. 与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2). 执行用时 :100 ms, 在所有 JavaScript 提交中击败了91.81%的用户 /** * @param {number[]} nums * @param {number} target * @return {number} */ var threeSumClosest = function(nums, target) { const len = nums.length; if (len a - b); // 结果，比存储 sum 方便，下面对比时不用再用 target - sum 对比 let res = target - (nums[0] + nums[1] + nums[2]); for (let i = 0; i target时，right-- while (nums[right] === nums[--right]); } // 存储与 target 最近的值 if (Math.abs(sum - target) 暴力法：复杂度太高 var threeSumClosest = function(nums, target) { let res = nums[0] + nums[1] + nums[2]; let abs = Math.abs(res - target); for (let i = 0; i 第二种方法 var threeSumClosest = function(nums, target) { nums.sort((a, b) => a - b); // 先排序 let res = nums[0] + nums[1] + nums[2]; let abs = Math.abs(res - target); for (let i = 0; i target) { end--; } else { return temp; // 若temp=target，直接输出结果 } } } return res; }; 三个指针，固定一个指针，其两个以他为基础进行遍历。 /** * @param {number[]} nums * @param {number} target * @return {number} */ var threeSumClosest = function(nums, target) { let len = nums.length; if (len a - b); let min = nums[0] + nums[1] + nums[2]; for (let x = 0; x target) { do { z--; } while (y "},"算法/四数之和.html":{"url":"算法/四数之和.html","title":"四数之和","keywords":"","body":"四数之和 四数之和 题目 解法 (JS) 类似“三数之和”，多加一层循环，注意要先排序 题目 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。 注意： 答案中不可以包含重复的四元组。 示例： 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 满足要求的四元组集合为： [ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2] ] 解法 (JS) 执行用时 :132 ms, 在所有 JavaScript 提交中击败了97.70%的用户 解法与三数之和思路相同，唯一不同时多一层循环，固定两位数字，用双指针寻找第三位及第四位数字。 /** * @param {number[]} nums * @param {number} target * @return {number[][]} */ var fourSum = function(nums, target) { if (nums.length a - b); const result = []; for (let i = 0; i 0 && nums[i] === nums[i - 1]) { continue; } // 若当前循环的前四位数字已大于 target if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) { break; } for (let j = i + 1; j i + 1 && nums[j] === nums[j - 1]) { continue; } let left = j + 1, right = nums.length - 1; while (left 类似“三数之和”，多加一层循环，注意要先排序 var fourSum = function(nums, target) { let len = nums.length; if (len a - b); let result = []; for (let a = 0; a target) { d--; } else { c++; } } do { b++; } while (b "},"算法/最长公共前缀.html":{"url":"算法/最长公共前缀.html","title":"最长公共前缀","keywords":"","body":"最长公共前缀 最长公共前缀 题目 思路 法二 双重循环，垂直扫描 题目 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 示例 1: 输入: [\"flower\",\"flow\",\"flight\"] 输出: \"fl\" 示例 2: 输入: [\"dog\",\"racecar\",\"car\"] 输出: \"\" 解释: 输入不存在公共前缀。 说明:所有输入只包含小写字母 a-z 。 思路 标签：链表 当字符串数组长度为 0 时则公共前缀为空，直接返回 令最长公共前缀 ans 的值为第一个字符串，进行初始化 遍历后面的字符串，依次将其与 ans 进行比较，两两找出公共前缀，最终结果即为最长公共前缀 如果查找过程中出现了 ans 为空的情况，则公共前缀不存在直接返回 时间复杂度：O(s)，s 为所有字符串的长度之和 /** * @param {string[]} strs * @return {string} */ var longestCommonPrefix = function(strs) { if (strs.length == 0) return \"\"; let ans = strs[0]; for (let i = 1; i 法二 首先利用sort的排序方法将数组按照编码排序，只需要校验array[0]和array[array.length-1]的值。 然后判断是否存在包含关系即array[0]包含于array[array.length-1] 最后对首尾两个值进行字符串匹配，得到公共前缀 /** * @param {string[]} strs * @return {string} */ var longestCommonPrefix = function(strs) { strs.sort(); //按编码排序 if (strs.length === 0) return \"\"; //空数组返回'' var first = strs[0], end = strs[strs.length - 1]; if (first === end || end.match(eval(\"/^\" + first + \"/\"))) { return first; //first包含于end返回first } for (var i = 0; i 双重循环，垂直扫描 先按各字符串长度排序，将长度最小的字符串赋值给最大公共前缀str，作为初始值 遍历字符串数组，使用str与strs[i]两两比对取得新的最大公共前缀赋值给str str长度等于0时直接返回'' /** * @param {string[]} strs * @return {string} */ var longestCommonPrefix = function(strs) { strs.sort((a, b) => a.length - b.length > 0); let str = strs[0] || \"\"; for (let i = 0; i "},"算法/电话号码的字母组合.html":{"url":"算法/电话号码的字母组合.html","title":"电话号码的字母组合","keywords":"","body":"电话号码的字母组合 电话号码的字母组合 题目 笛卡尔积 简单循环 没有设置边界值 一点、一点才能到达彼岸 题目 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：\"23\" 输出：[\"ad\", \"ae\", \"af\", \"bd\", \"be\", \"bf\", \"cd\", \"ce\", \"cf\"]. 说明:尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。 笛卡尔积 先列出2-9的所有枚举得到一串数字所对应的表数组 排除当输入为空的情况，当输入为一串长度大于2的数字时，我们可以用笛卡尔积来得出我们的所有可能 所以我们需要做的就是完成一个笛卡尔积的方法，一个数组的每一个项都是另一个的子集，所以我们需要用到map，当一个数组内部的值都被分配完后不能重复在重复计算，所以我们可以用reduce 所以我们的方法是一个map和reduce的集合方法 var descartFn = function(nums) { let t = nums.reduce((a, b) => { m = a.map(item => { return b.map(i => { return [...item, i]; }); }); f = m.reduce((c, d) => { return c.concat(d); }, []); return f; }); return t; }; 简单循环 /** * @param {string} digits * @return {string[]} */ var letterCombinations = function(digits) { let dig = { \"1\": [], \"2\": [\"a\", \"b\", \"c\"], \"3\": [\"d\", \"e\", \"f\"], \"4\": [\"g\", \"h\", \"i\"], \"5\": [\"j\", \"k\", \"l\"], \"6\": [\"m\", \"n\", \"o\"], \"7\": [\"p\", \"q\", \"r\", \"s\"], \"8\": [\"t\", \"u\", \"v\"], \"9\": [\"w\", \"x\", \"y\", \"z\"] }; let len = digits.length; let t = dig[digits[len - 1]] || []; for (let i = len - 2; i >= 0; i--) { let d = dig[digits[i]]; let t1 = []; for (let dVal of d) { for (let tVal of t) { t1.push(dVal + tVal); } } t = t1; } return t; }; 没有设置边界值 const str = \"23\"; const numMap = new Map([ [2, \"abc\"], [3, \"def\"], [4, \"ghi\"], [5, \"jkl\"], [6, \"mno\"], [7, \"pqrs\"], [8, \"tuv\"], [9, \"wxyz\"] ]); let combo = str => { let strArr = str.split(\"\"); console.log(strArr); let temArr = []; strArr.map(item => { temArr.push(numMap.get(parseInt(item))); }); console.log(temArr); temArr = temArr.map(item => { return item.split(\"\"); }); let len = temArr.length; for (let x = 0; x 2) { temArr.splice(0, 2, handle(temArr[0], temArr[1])); } else { return handle(temArr[0], temArr[1]); break; } } }; function handle(a, b) { let arr = []; a.map(char => { b.map(char2 => { arr.push(char + char2); }); }); return arr; } console.log(combo(str).length); 一点、一点才能到达彼岸 export default str => { // 建立电话号码键盘映射 let map = [\"\", 1, \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"]; // 把输入字符串按单字符分隔变成数组，234=>[2,3,4] let num = str.split(\"\"); // 保存键盘映射后的字母内容，如 23=>['abc','def'] let code = []; num.forEach(item => { if (map[item]) { code.push(map[item]); } }); let comb = arr => { // 临时变量用来保存前两个组合的结果 let tmp = []; // 最外层的循环是遍历第一个元素，里层的循环是遍历第二个元素 for (let i = 0, il = arr[0].length; i 1) { comb(arr); } else { return tmp; } return arr[0]; }; return comb(code); }; "},"算法/删除链表的倒数第N个节点.html":{"url":"算法/删除链表的倒数第N个节点.html","title":"删除链表的倒数第N个节点","keywords":"","body":"删除链表的倒数第N个节点 删除链表的倒数第N个节点 题目 先后指针 法二 法三 题目 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1->2->3->4->5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1->2->3->5. 说明： 给定的 n 保证是有效的。 进阶： 你能尝试使用一趟扫描实现吗？ 提示： Maintain two pointers and update one with a delay of n steps. 先后指针 先后指针：快指针先走n-1步后慢指针再开始从头节点开始走。当快指针走到最后一个结点的时候，慢指针就走到了倒数第N个结点。 证明： 假设总共有N个结点，则倒数第n个结点就是正数第N-n+1个结点。 从头结点正向走到第N-n+1个结点需要走N-n步。 而从头节点到链表最后一个结点需要走N-1步，所以还剩n+1步。 var removeNthFromEnd = function(head, n) { // 先指针先走n-1步 let fast = head; for (let i = 1; i 法二 JavaScript。不需要额外的node节点。有点像一辆高铁，先找到车头，当车头跑到终点时，车尾也到了 var removeNthFromEnd = function(head, n) { let curr = head, deleteNode = head, i = 0; while(i 法三 代码里设置初始状态两个指针都是null，比较抽象，可以新建一个辅助节点放在链表头之前，两个指针最开始都指向这个辅助节点，这样整个流程就可以统一了，避免了各种null的判断。 除此之外，还有两个解法可可以参考： 遍历一遍链表存到一个数组a里，直接a.splice(a.length-n, 1)，这个方法需要额外空间，而且还得再把数组转为链表，但是我认为最好想到了。 遍历一遍链表，得到链表长度l，再从头往后走l-n步就可以找到要删除的节点了。 var removeNthFromEnd = function(head, n) { //idx1指向要删除的节点之前的节点 let idx1 = null, idx2 = null; //idx2先向后走n步，这样idx1正好指向从idx2往前数n+1个节点 for (let i = 0; i "},"算法/有效的括号.html":{"url":"算法/有效的括号.html","title":"有效的括号","keywords":"","body":"有效的括号 有效的括号 题目 栈 字符串 栈 在官方解法基础上，加上了空字符串，字符串长度奇数和已右括号开头的特殊判断。 javascript 栈解题 栈的思路js解法 题目 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: \"()\" 输出: true 示例 2: 输入: \"()[]{}\" 输出: true 示例 3: 输入: \"(]\" 输出: false 示例 4: 输入: \"([)]\" 输出: false 示例 5: 输入: \"{[]}\" 输出: true 栈 字符串 栈 const MATCH = new Map([[\"(\", \")\"], [\"{\", \"}\"], [\"[\", \"]\"]]); const isString = s => typeof s === \"string\"; const isEmptyString = s => isString(s) && s.length === 0; const isEmptyArray = arr => Array.isArray(arr) && arr.length === 0; /** * @param {string} s * @return {boolean} */ var isValid = function(s) { if (!isString(s)) { return false; } if (isEmptyString(s)) { return true; } const arrS = s.split(\"\"); const openS = []; for (const a of arrS) { if (MATCH.has(a)) { openS.push(a); } else { const rightClose = MATCH.get(openS.pop()); const successMatch = rightClose === a; if (!successMatch) { return false; } } } if (isEmptyArray(openS)) { return true; } return false; }; 在官方解法基础上，加上了空字符串，字符串长度奇数和已右括号开头的特殊判断。 76 ms , 击败了js提交中 94.29% 的用户;内存消耗 : 33.7 MB , 击败了 js提交中71.23% 的用户 /** * @param {string} * @return {boolean} */ var isValid = function(s) { let len = s.length; let first = s[0]; if (len === 0) return true; // 奇数或右括号开头肯定不符合 if (len % 2 != 0 || [\")\", \"]\", \"}\"].indexOf(first) != -1) { return false; } // 栈，存入第一个字符。 let stack = [first]; const MAP = { \")\": \"(\", \"]\": \"[\", \"}\": \"{\" }; for (let i = 1; i 0 ? stack[length - 1] : null; let now = s[i]; if (MAP[now] === top) { stack.pop(); } else { stack.push(now); } } return stack.length === 0; }; javascript 栈解题 var isValid = function(s) { // 清除所有空格 let str = s.split(\" \").join(\"\"); // 如果全为空字符串则返回true if (str === \"\") { return true; } let len = s.split(\" \").join(\"\").length; // 如果是奇数并且是]})开头则返回false if (len % 2 !== 0 || str[0] === \")\" || str[0] === \"}\" || str[0] === \"]\") { return false; } // 创建一个栈 let stack = []; let current = null; let top = str[0]; let map = { \")\": \"(\", \"]\": \"[\", \"}\": \"{\" }; for (let i = 0; i 栈的思路js解法 枚举用反括号匹配，我们把对应的一正一反抵消就代表一对完整括号 比对步骤： 枚举匹配不到的一定是开始符号，压入。 枚举匹配到的分两种情况，一种是已经存在匹配项对应的开始符号，则可以抵消掉。 如果已有的不存在对应的开始符号则也需要压入 判断是否全部抵消掉 const enumObj = { \")\": \"(\", \"]\": \"[\", \"}\": \"{\" }; /** * @param {string} s * @return {boolean} */ var isValid = function(s) { let cache = []; let arr = s.split(\"\"); for (let i of arr) { if (enumObj[i]) { if (cache[cache.length - 1] === enumObj[i]) { cache.pop(); } else { cache.push(i); } } else { cache.push(i); } } return cache.length === 0; }; var isValid = function(s) { var c = { \"[\": \"]\", \"(\": \")\", \"{\": \"}\" }; var a = s.split(\"\"); var b = []; for (let i = 0; i "},"算法/括号生成.html":{"url":"算法/括号生成.html","title":"括号生成","keywords":"","body":"括号生成 括号生成 题目 标签 一 二 三 递归 题目 给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。 例如，给出 n = 3，生成结果为： [ \"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\" ] 标签 字符串 回溯算法 一 var generateParenthesis = function(n) { var result = []; function x(y, s, t) { if (t > n || t 二 执行用时 : 88 ms, 在Generate Parentheses的JavaScript提交中击败了98.17% 的用户 内存消耗 : 34.5 MB, 在Generate Parentheses的JavaScript提交中击败了93.91% 的用户 判断当前是否括号存在未匹配的括号时，为了省内存就用了个取巧的判断方法，匹配的对数*2 = 字符串长度就说明全部括号全闭合了。 /** * @param {number} n * @return {string[]} */ var generateParenthesis = function(n) { var pairs = 0, level = 0, list = [], str = \"\"; genOutput(list, level, pairs, str, n); return list; }; var genOutput = function(list, level, pairs, str, max, stack) { if (pairs == max) { list.push(str); } else { if (level == max) { genOutput(list, level, pairs + 1, str + \")\", max, stack); } else { if (pairs * 2 == str.length) { genOutput(list, level + 1, pairs, str + \"(\", max, stack); } else { genOutput(list, level + 1, pairs, str + \"(\", max, stack); genOutput(list, level, pairs + 1, str + \")\", max, stack); } } } }; 三 递归 /** * @param {number} n * @return {string[]} */ var generateParenthesis = function(n) { let result = []; generate(\"\", 0, 0); return result; function generate(substr, left, right) { if (left === n && right === n) { result.push(substr); } if (left "},"算法/合并两个有序链表.html":{"url":"算法/合并两个有序链表.html","title":"合并两个有序链表","keywords":"","body":"合并两个有序链表 合并两个有序链表 题目 标签 链表、递归 JavaScript 题解 用时击败了97.76%的用户 双指针 击败99.44% 题目 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 标签 链表 链表、递归 标签：链表、递归 这道题可以使用递归实现，新链表也不需要构造新节点，我们下面列举递归三个要素 终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束 返回值：每一层调用都返回排序好的链表头 本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理 O(m+n)，m 为 l1的长度，n 为 l2 的长度 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } */ /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var mergeTwoLists = function(l1, l2) { if (l1 === null) { return l2; } if (l2 === null) { return l1; } if (l1.val JavaScript 题解 用时击败了97.76%的用户 /** * Definition for singly-linked list. */ function ListNode(val) { this.val = val; this.next = null; } /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var mergeTwoLists = function(l1, l2) { if (l1 === null) return l2; if (l2 === null) return l1; let cur_l1 = l1, cur_l2 = l2, l3 = new ListNode(\"head\"); // 如果两个链表都走到了最后，则结束while循环。 while (!(cur_l1 === null && cur_l2 === null)) { // 将链表2的值更新到L3，并且L2的指针往下走。 if (!cur_l1 || (cur_l2 && cur_l1.val >= cur_l2.val)) { l3 = listPush(l3, new ListNode(cur_l2.val)); cur_l2 = cur_l2.next; } else { // 将链表1的值更新到L3，并且L1的指针往下走。 l3 = listPush(l3, new ListNode(cur_l1.val)); cur_l1 = cur_l1.next; } } return l3.next; }; function listPush(list, item) { let cur = list; while (cur.next !== null) { cur = cur.next; } cur.next = item; return list; } 双指针 击败99.44% /** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */ var mergeTwoLists = function(l1, l2) { let pHead = null; let p1 = l1; let p2 = l2; let p = null; if (!l1) { return l2; } else if (!l2) { return l1; } if (l1.val "},"算法/合并两个有序数组.html":{"url":"算法/合并两个有序数组.html","title":"合并两个有序数组","keywords":"","body":"合并两个有序数组 合并两个有序数组 题目 标签 解法 解题 两行代码解法 题目 给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例: 输入: nums1 = [1,2,3,0,0,0], m = 3 nums2 = [2,5,6], n = 3 输出: [1,2,2,3,5,6] 标签 数组 双指针 解法 主要这里要改变的是nums1，作为函数的参数，js属于值传递，所以在函数里面的数组的方法得改变数组本身，也就是说不能构造出一个新的数组，最后让nums1指向它，这样其实最后nums1指向的原数组并没有改变，而我们恰恰要改变的是原数组。所以应该使用一些可以改变数组本身的方法，如Array.push、Array.splice这些 以下是我的思路 /** * @param {number[]} nums1 * @param {number} m * @param {number[]} nums2 * @param {number} n * @return {void} Do not return anything, modify nums1 in-place instead. */ var merge = function(nums1, m, nums2, n) { let count1 = 0; let count2 = 0; let len = nums1.length; while (count1 nums2[count2]) { nums1.push(nums2[count2++]); } else { nums1.push(nums1[count1++]); } } if (count1 解题 思路 标签：从后向前数组遍历 因为nums1的空间都集中在后面，所以从后向前处理排序的数据会更好，节省空间，一边遍历一边将值填充进去 设置指针len1和len2分别指向nums1和nums2的有数字尾部，从尾部值开始比较遍历，同时设置指针len指向nums1的最末尾，每次遍历比较值大小之后，则进行填充 当len1 /** * @param {number[]} nums1 * @param {number} m * @param {number[]} nums2 * @param {number} n * @return {void} Do not return anything, modify nums1 in-place instead. */ var merge = function(nums1, m, nums2, n) { let len1 = m - 1; let len2 = n - 1; let len = m + n - 1; while (len1 >= 0 && len2 >= 0) { // 注意--符号在后面，表示先进行计算再减1，这种缩写缩短了代码 nums1[len--] = nums1[len1] > nums2[len2] ? nums1[len1--] : nums2[len2--]; } function arrayCopy(src, srcIndex, dest, destIndex, length) { dest.splice(destIndex, length, ...src.slice(srcIndex, srcIndex + length)); } // 表示将nums2数组从下标0位置开始，拷贝到nums1数组中，从下标0位置开始，长度为len2+1 arrayCopy(nums2, 0, nums1, 0, len2 + 1); }; 两行代码解法 var merge = function(nums1, m, nums2, n) { nums1.splice(m, n, ...nums2) nums1.sort((a, b) => (a - b)) return nums1 } "},"算法/合并K个排序链表.html":{"url":"算法/合并K个排序链表.html","title":"合并K个排序链表","keywords":"","body":"合并K个排序链表 合并K个排序链表 题目 标签 归并排序-合并K个排序链表 就是不断地2、2合并 题目 合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例: 输入: [ 1->4->5, 1->3->4, 2->6 ] 输出: 1->1->2->3->4->4->5->6 标签 堆 链表 分治算法 归并排序-合并K个排序链表 从代码中可以看出，我主要用了两个函数实现归并排序，第一个函数Partition用于2分数组Lists，第二个函数merge2Lists用于合并并排序两个链表。假设Lists的长度为L，那么Partition的时间开销就是二分法得到的Log(L)，而merge2Lists的时间开销应当是min(m1, m2)其中m1和m2为排序的两个链表的长度。 综上，时间复杂度等于Partition的时间开销乘以merge2Lists的时间开销，即O(min(m1, m2)logL) function partition(lists) { switch (lists.length) { case 0: return null; case 1: return lists[0]; case 2: return merge2Lists(lists[0], lists[1]); default: let mid = lists.length >> 1; return merge2Lists( partition(lists.slice(0, mid)), partition(lists.slice(mid, lists.length)) ); } } function merge2Lists(l0, l1) { let p0 = l0, p1 = l1, c = new ListNode(null), pc = c; while (p0 || p1) { if (p0 && p1) { if (p0.val 就是不断地2、2合并 var mergeKLists = function(lists) { if (lists.length == 0) return null; function x(list1, list2) { if (list1 == null) return list2; if (list2 == null) return list1; var x1 = list1.val, x2 = list2.val, head; if (x1 > x2) { head = list2; list2 = list2.next; } else { head = list1; list1 = list1.next; } var list = head; while (list1 !== null && list2 !== null) { x1 = list1.val; x2 = list2.val; if (x1 > x2) { list.next = list2; list2 = list2.next; } else { list.next = list1; list1 = list1.next; } list = list.next; } if (list1 == null) list.next = list2; else list.next = list1; return head; } return lists.reduce(function(a, b) { return x(a, b); }); }; "},"算法/删除排序数组中的重复项.html":{"url":"算法/删除排序数组中的重复项.html","title":"删除排序数组中的重复项","keywords":"","body":"删除排序数组中的重复项 删除排序数组中的重复项 题目 标签 js arrary 的 splice 方法 双指针 题目 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,2,2,3,3,4], 函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i 标签 数组 双指针 js arrary 的 splice 方法 /** * @param {number[]} nums * @return {number} */ var removeDuplicates = function(nums) { for (let i = 0; i 双指针 双指针的方法初看不能理解，其实按照最原始的解法，创建一个新的数组，当遇到旧数组的指针与当前数值指针值不一致时，赋值给新的数组。双指针的方法是巧妙的用一个数组代替了两个数组赋值的方式。 var removeDuplicates2 = function(nums) { if (nums.length === 0) { return 0; } let j = 0; for (let i = 0; i var removeDuplicates = function(nums) { let count = nums.length; for (let i = 0; i "},"算法/删除排序数组中的重复项II.html":{"url":"算法/删除排序数组中的重复项II.html","title":"删除排序数组中的重复项 II","keywords":"","body":"删除排序数组中的重复项 II 删除排序数组中的重复项 II 题目 标签 双指针，遍历一次中间隔一个元素就OK了 题目 给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素最多出现两次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例 1: 给定 nums = [1,1,1,2,2,3], 函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,0,1,1,1,1,2,3,3], 函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len = removeDuplicates(nums); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i 标签 数组 双指针 双指针，遍历一次中间隔一个元素就OK了 var removeDuplicates = function (nums) { let i = 0 while (i var removeDuplicates = function(nums) { for (var i = 2; i 比左右 var removeDuplicates = function(nums) { for (var i = 1; i "},"算法/移除元素.html":{"url":"算法/移除元素.html","title":"移除元素","keywords":"","body":"移除元素 移除元素 题目 标签 js原地移除特定元素 移除元素 题目 给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。 示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。 注意这五个元素可为任意顺序。 你不需要考虑数组中超出新长度后面的元素。 说明: 为什么返回数值是整数，但输出的答案是数组呢? 请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 你可以想象内部操作如下: // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 for (int i = 0; i 标签 数组 双指针 js原地移除特定元素 执行用时 : 76 ms , 在所有 JavaScript 提交中击败了 94.44% 的用户 内存消耗 : 33.6 MB , 在所有 JavaScript 提交中击败了 71.03% 思路 原地移除，改变原数组，选择splice() 如果数组里碰到相同的val，就splice掉这一项，此时数组项数就少了一个，i要往后退回一个，即i--， 结束～ var removeElement = function(nums, val) { for (let i = 0; i 移除元素 第一种思路 标签：拷贝覆盖 主要思路是遍历数组nums，每次取出的数字变量为num，同时设置一个下标ans 在遍历过程中如果出现数字与需要移除的值不相同时，则进行拷贝覆盖nums[ans] = num，ans自增1 如果相同的时候，则跳过该数字不进行拷贝覆盖，最后ans即为新的数组长度 这种思路在移除元素较多时更适合使用，最极端的情况是全部元素都需要移除，遍历一遍结束即可 时间复杂度：O(n)，空间复杂度：O(1) /** * @param {number[]} nums * @param {number} val * @return {number} */ var removeElement = function(nums, val) { let ans = 0; for (const num of nums) { if (num != val) { nums[ans] = num; ans++; } } return ans; }; 第二种思路 标签：交换移除 主要思路是遍历数组nums，遍历指针为i，总长度为ans 在遍历过程中如果出现数字与需要移除的值不相同时，则i自增1，继续下一次遍历 如果相同的时候，则将nums[i]与nums[ans-1]交换，即当前数字和数组最后一个数字进行交换，交换后就少了一个元素，故而ans自减1 这种思路在移除元素较少时更适合使用，最极端的情况是没有元素需要移除，遍历一遍结束即可 时间复杂度：O(n)，空间复杂度：O(1) var removeElement = function(nums, val) { let ans = nums.length; for (let i = 0; i "},"算法/实现strStr.html":{"url":"算法/实现strStr.html","title":"实现strStr()","keywords":"","body":"实现strStr() 实现strStr() 题目 标签 JavaScript 中有三个字符串方法都可以实现这个功能，分别是 indexOf , search, match js2 KMP 题目 实现 strStr() 函数。 strstr （PHP语言函数） strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串。如果是，则该函数返回str2在str1中首次出现的地址；否则，返回NULL 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。 示例 1: 输入: haystack = \"hello\", needle = \"ll\" 输出: 2 示例 2: 输入: haystack = \"aaaaa\", needle = \"bba\" 输出: -1 说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。 标签 字符串 双指针 JavaScript 中有三个字符串方法都可以实现这个功能，分别是 indexOf , search, match indexOf 是最切合要求的，原本就是题目中要求的功能： var strStr = function(haystack, needle) { return haystack.indexOf(needle); }; search 方法与 indexOf 方法功能基本一样，只是search支持正则作为参数，则indexOf不支持 var strStr = function(haystack, needle) { return haystack.search(needle); }; match 方法返回一个结果数组，在没有指定正则修饰符g的时候，会额外提供index属性来表示位置，只是如果没有查找到，match返回的值为null。 var strStr = function(haystack, needle) { let ret = haystack.match(needle); return ret === null ? -1 : ret.index; }; js2 var strStr = function(haystack, needle) { if(haystack === needle || needle.length === 0) return 0; for(let i=0; i KMP var strStr = function(haystack, needle) { // 计算next数组，next[i]表示str[i]前面字符串的最长公共前后缀 // 如 abcdabe，next[6]=2，最长公共前后缀是ab。 function getNext(str) { let len = str.length; // i表示str的下标 let i = 0, j = -1; let next = []; // next[0]前面没有字符串了，所以置为-1 next[0] = -1; // 因为if中是先i++再给next[i]赋值，所以循环到len-1就够了 while(i "},"算法/串联所有单词的子串.html":{"url":"算法/串联所有单词的子串.html","title":"串联所有单词的子串","keywords":"","body":"串联所有单词的子串 串联所有单词的子串 题目 非最快 JavaScript 实现，但是思路相对清晰，200ms JS枚举 JS2 题目 给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。 注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。 示例 1： 输入： s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"] 输出：[0,9] 解释： 从索引 0 和 9 开始的子串分别是 \"barfoor\" 和 \"foobar\" 。 输出的顺序不重要, [9,0] 也是有效答案。 示例 2： 输入： s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"] 输出：[] 非最快 JavaScript 实现，但是思路相对清晰，200ms var findSubstring = function(s, words) { if (s.length === 0 || words.length === 0) return []; const wordLength = words[0].length; const ret = []; const hash = {}; for (let i = 0; i -1) { count++; } } if (count === words.length) { ret.push(i); } } return ret; }; JS枚举 var findSubstring = function(s, words) { let f = words[0]; if (!f) { return []; } let wlen = f.length; let temp; let w = [...words]; let count = 0, left = 0, right = 0; let res = []; while (right + wlen JS2 var findSubstring = function(s, words) { if (s.length === 0 || words.length === 0) return []; //如果s或words为空则返回空 const len = words[0].length, lenarr = words.length; //len记录words中单词长度，lenarr记录words中单词数量 var i = 0, result = []; //i记录子串起始位置，result记录结果 while (i "},"算法/最小覆盖子串.html":{"url":"算法/最小覆盖子串.html","title":"最小覆盖子串","keywords":"","body":"最小覆盖子串 最小覆盖子串 题目 最后3个用例超时 滑动窗口算法通用思想 一、最小覆盖子串 二、找到字符串中所有字母异位词 三、无重复字符的最长子串 最后总结 题目 给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。 示例： 输入: S = \"ADOBECODEBANC\", T = \"ABC\" 输出: \"BANC\" 说明： 如果 S 中不存这样的子串，则返回空字符串 \"\"。 如果 S 中存在这样的子串，我们保证它是唯一的答案。 最后3个用例超时 /** * @param {string} s * @param {string} t * @return {string} */ var minWindow = function(s, t) { var tarr = t.split(\"\"), ltarr, lbj = new Array(t.length).fill(1), bj, result = []; for (var i = 0; i 0) { if (i > s.length - t.length) return s.slice(result[0], result[1] + 1); if (ii - i > result[1] - result[0]) { break; } } var index = ltarr.indexOf(s[ii]); if (index !== -1 && bj[index] === 1) { bj[index] = 0; ltarr[index] = \"\"; } if (bj.indexOf(1) === -1) { if (result.length == 0) { result = [i, ii]; } else { result = result[1] - result[0] > ii - i ? [i, ii] : result; } break; } } } return s.slice(result[0], result[1] + 1); }; 滑动窗口算法通用思想 本文详解「滑动窗口」这种高级双指针技巧的算法框架，带你秒杀几道难度较大的子字符串匹配问题： 最小覆盖子串 找到字符串中所有字母异位词 无重复字符的最长子串 最后抽象出一个简单的滑动窗口算法框架。 LeetCode 上至少有 9 道题目可以用此方法高效解决。但是有几道是 VIP 题目，有几道题目虽不难但太复杂，所以本文只选择点赞最高，较为经典的，最能够讲明白的三道题来讲解。第一题为了让读者掌握算法模板，篇幅相对长，后两题就基本秒杀了。 本文代码为 C++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解： unordered_map 就是哈希表（字典），它的一个方法 count(key) 相当于 containsKey(key) 可以判断键 key 是否存在。 可以使用方括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，C++ 会自动创建这个 key，并把 map[key] 赋值为 0。 所以代码中多次出现的 map[key]++ 相当于 Java 的 map.put(key, map.getOrDefault(key, 0) + 1)。 本文大部分代码都是图片形式，可以点开放大，更重要的是可以左右滑动方便对比代码。下面进入正题。 一、最小覆盖子串 题目不难理解，就是说要在 S(source) 中找到包含 T(target) 中全部字母的一个子串，顺序无所谓，但这个子串一定是所有可能子串中最短的。 如果我们使用暴力解法，代码大概是这样的： for (int i = 0; i 思路很直接吧，但是显然，这个算法的复杂度肯定大于 O(N^2)了，不好。 滑动窗口算法的思路是这样： 我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。 我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。 此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。 重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。 这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。 下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和窗口中的相应字符的出现次数。 初始状态： 增加 right，直到窗口 [left, right] 包含了 T 中所有字符： 现在开始增加 left，缩小窗口 [left, right]。 直到窗口中的字符串不再符合要求，left 不再继续移动。 之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。 如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。至于如何具体到问题，如何得出此题的答案，都是编程问题，等会提供一套模板，理解一下就会了。 上述过程可以简单地写出如下伪码框架： string s, t; // 在 s 中寻找 t 的「最小覆盖子串」 int left = 0, right = 0; string res = s; while(right 如果上述代码你也能够理解，那么你离解题更近了一步。现在就剩下一个比较棘手的问题：如何判断 window 即子串 s[left...right] 是否符合要求，是否包含 t 的所有字符呢？ 可以用两个哈希表当作计数器解决。用一个哈希表 needs 记录字符串 t 中包含的字符及出现次数，用另一个哈希表 window 记录当前「窗口」中包含的字符及出现的次数，如果 window 包含所有 needs 中的键，且这些键对应的值都大于等于 needs 中的值，那么就可以知道当前「窗口」符合要求了，可以开始移动 left 指针了。 现在将上面的框架继续细化： string s, t; // 在 s 中寻找 t 的「最小覆盖子串」 int left = 0, right = 0; string res = s; // 相当于两个计数器 unordered_map window; unordered_map needs; for (char c : t) needs[c]++; // 记录 window 中已经有多少字符符合要求了 int match = 0; while (right 上述代码已经具备完整的逻辑了，只有一处伪码，即更新 res 的地方，不过这个问题太好解决了，直接看解法吧！ string minWindow(string s, string t) { // 记录最短子串的开始位置和长度 int start = 0, minLen = INT_MAX; int left = 0, right = 0; unordered_map window; unordered_map needs; for (char c : t) needs[c]++; int match = 0; while (right 如果直接甩给你这么一大段代码，我想你的心态是爆炸的，但是通过之前的步步跟进，你是否能够理解这个算法的内在逻辑呢？你是否能清晰看出该算法的结构呢？ 这个算法的时间复杂度是 O(M + N)，M 和 N 分别是字符串 S 和 T 的长度。因为我们先用 for 循环遍历了字符串 T 来初始化 needs，时间 O(N)，之后的两个 whilewhile 循环最多执行 2M 次，时间 O(M)。 读者也许认为嵌套的 while 循环复杂度应该是平方级，但是你这样想，while 执行的次数就是双指针 left 和 right 走的总路程，最多是 2M 嘛。 二、找到字符串中所有字母异位词 这道题的难度是 Easy，但是评论区点赞最多的一条是这样： How can this problem be marked as easy??? 实际上，这个 Easy 是属于了解双指针技巧的人的，只要把上一道题的代码改中更新 res 部分的代码稍加修改就成了这道题的解： // C++ vector findAnagrams(string s, string t) { // 用数组记录答案 vector res; int left = 0, right = 0; unordered_map needs; unordered_map window; for (char c : t) needs[c]++; int match = 0; while (right 因为这道题和上一道的场景类似，也需要 window 中包含串 t 的所有字符，但上一道题要找长度最短的子串，这道题要找长度相同的子串，也就是「字母异位词」嘛。 三、无重复字符的最长子串 遇到子串问题，首先想到的就是滑动窗口技巧。 类似之前的思路，使用 window 作为计数器记录窗口中的字符出现次数，然后先向右移动 right，当 window 中出现重复字符时，开始移动 left 缩小窗口，如此往复： int lengthOfLongestSubstring(string s) { int left = 0, right = 0; unordered_map window; int res = 0; // 记录最长长度 while (right 1) { char c2 = s[left]; window[c2]--; left++; } res = max(res, right - left); } return res; } 需要注意的是，因为我们要求的是最长子串，所以需要在每次移动 right 增大窗口时更新 res，而不是像之前的题目在移动 left 缩小窗口时更新 res。 最后总结 通过上面三道题，我们可以总结出滑动窗口算法的抽象思想： int left = 0, right = 0; while (right 其中 window 的数据类型可以视具体情况而定，比如上述题目都使用哈希表充当计数器，当然你也可以用一个数组实现同样效果，因为我们只处理英文字母。 稍微麻烦的地方就是这个 valid 条件，为了实现这个条件的实时更新，我们可能会写很多代码。比如前两道题，看起来解法篇幅那么长，实际上思想还是很简单，只是大多数代码都在处理这个问题而已。 "},"算法/下一个排列.html":{"url":"算法/下一个排列.html","title":"下一个排列","keywords":"","body":"下一个排列 下一个排列 题目 循环；字典序 参考官方题解 题目 实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 必须原地修改，只允许使用额外常数空间。 以下是一些例子，输入位于左侧列，其相应输出位于右侧列。 1,2,3 → 1,3,2 3,2,1 → 1,2,3 1,1,5 → 1,5,1 循环；字典序 思路： 字典序：从右往左，找到第一个左值小于右值的数，然后从右往左，找到第一个大于该左值的数，交换这两个值，并将该左值(不包含)右边的进行从小到大进行排序(原来为降序，只需要改为升序)。 /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */ var nextPermutation = function(nums) { let len = nums.length; if (len = 0; i--) { if (nums[i] i; j--) { if (nums[i] 参考官方题解 var nextPermutation = function(nums) { let len = nums.length; if (len "},"算法/全排列.html":{"url":"算法/全排列.html","title":"全排列","keywords":"","body":"全排列 全排列 题目 标签 回溯算法 JS解法 递归 非递归方法 插入法 题目 给定一个没有重复数字的序列，返回其所有可能的全排列。 示例: 输入: [1,2,3] 输出: [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] 标签 回溯算法 回溯算法 思路： 方法一. 先对最后的几个进行排列，然后将下一个插入到该数组中 方法二. 先选出第一个排列，然后将剩下的进行插入 推荐方法二 // 方法一 /** * @param {number[]} nums * @return {number[][]} */ var permute = function(nums) { let len = nums.length; if (len JS解法 var permute = function(nums) { if (nums.length === 0) { return []; } if (nums.length === 1) { return [nums]; } let [num, ...restNums] = nums; return permute(restNums).reduce((res, iter) => { let iterRes = []; for (let i = 0; i 递归 不断将这个序列切分为第一个数字和后续的数字，将第一个数字分别和后续的数字都进行一次交换，并以此递归操作后续的的数字即可 var permute = function(nums) { let len = nums.length; let res = []; function fn(arr, start) { if(start > len-1) { // 需要浅拷贝一次，否则后续的交换操作会影响到res中已排列的序列 res.push(arr.slice(0)); return; } for(let i=start; i 非递归方法 /** * @param {number[]} nums * @return {number[][]} **/ var permute = function(nums) { let res = [], n = nums.length; nums.sort((a, b) => a - b); while (true) { res.push(nums.slice(0)); let i = n - 1; while (i >= 1) { if (nums[i] > nums[i - 1]) { for (let j = n - 1; j >= i; --j) { if (nums[j] > nums[i - 1]) { let t = nums[i - 1]; nums[i - 1] = nums[j]; nums[j] = t; break; } } for (let k = 0, len = (n - i) >> 1; k 插入法 const permute = nums => { let result = [[nums[0]]], j = undefined, arr = []; for (let i = 1; i { value.push(nums[i]); // 对上一次的全排列都插入新的排列数 // arr.push(JSON.parse(JSON.stringify(value))) arr.push([...value]); j = value.length - 1; while (j > 0) { // 将新排列数插入到不同位置 [value[j - 1], value[j]] = [value[j], value[j - 1]]; // arr.push(JSON.parse(JSON.stringify(value))) arr.push([...value]); j--; } }); result = arr; } return result; }; var nums = [1,2,3]; permute(nums) "},"算法/全排列II.html":{"url":"算法/全排列II.html","title":"全排列 II","keywords":"","body":"全排列 II 全排列 II 题目 递归，使用hash保证不重复选择 最后用set去重 最后用set去重 题目 给定一个可包含重复数字的序列，返回所有不重复的全排列。 示例: 输入: [1,1,2] 输出: [ [1,1,2], [1,2,1], [2,1,1] ] 递归，使用hash保证不重复选择 //执行用时 :124 ms, 在所有 JavaScript 提交中击败了84.40%的用户 //递归，使用hash保证不重复选择。如[1,1,2]第一位只选一次1 var permuteUnique = function(nums) { var res = []; function bfs(arr, result) { if (arr.length === 0) { res.push([...result]); return; } var hash = new Map(); for (var i = 0; i 最后用set去重 var permuteUnique = function(nums) { let res = []; function fn(arr, start) { if(start >= arr.length-1) { res.push(arr.slice(0)); return; } for(let i=start, len=arr.length; i { res[index] = val.join(','); }) return [...new Set(res)].map(val => { return val.split(','); }) }; 最后用set去重 var permuteUnique = function(nums) { let res = []; function fn(arr, start) { if(start >= arr.length-1) { res.push(arr.slice(0)); return; } for(let i=start, len=arr.length; i "},"算法/最长有效括号.html":{"url":"算法/最长有效括号.html","title":"最长有效括号","keywords":"","body":"最长有效括号 最长有效括号 题目 一。 js使用正则替换解决的思路,逃课成功 题目 给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 输入: \"(()\" 输出: 2 解释: 最长有效括号子串为 \"()\" 示例 2: 输入: \")()())\" 输出: 4 解释: 最长有效括号子串为 \"()()\" 一。 /** * m[i] 以第i个字符结尾的最长有效括号数 * str[i] === ')' && str[i - m[i-1]-1] ==='(' ? m[i] = m[i-1]+2 +m[i-m[i-1]-2] : m[i] = 0 * * @param {string} s * @return {number} **/ var longestValidParentheses = function(s) { var m = new Array(s.length); m[0] = 0; let res = 0; for (var i = 1; i 0 ? m[index] : 0); res = Math.max(res, m[i]); } else { m[i] = 0; } } return res; }; js使用正则替换解决的思路,逃课成功 var longestValidParentheses = function(s) { let _s = s.replace(/\\((K*)\\)/g, '$1K'); while (_s !== s) { s = _s; _s = s.replace(/\\((K*)\\)/g, '$1K'); } let lx = 0 result = 0; for (let i = 0; i result) result = lx; } else { lx = 0; } } return result * 2; }; "},"算法/搜索旋转排序数组.html":{"url":"算法/搜索旋转排序数组.html","title":"搜索旋转排序数组","keywords":"","body":"搜索旋转排序数组 搜索旋转排序数组 题目 二分法，递归执行 二分搜索增强版 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。 你可以假设数组中不存在重复的元素。 你的算法时间复杂度必须是 O(log n) 级别。 示例 1: 输入: nums = [4,5,6,7,0,1,2], target = 0 输出: 4 示例 2: 输入: nums = [4,5,6,7,0,1,2], target = 3 输出: -1 二分法，递归执行 思路：因为限定 O(log n)，所以使用二分法 数组分为两组，那么必定有一组是有序的，判断是否在这个有序的区间内； 如果在这个区间，继续二分法直到找到这个值； 如果不在这个区间，则将另一个区间继续这样寻找； 注意：由于是向下取整，最好先判断右侧是否为有序数组。 /** * @param {number[]} nums * @param {number} target * @return {number} */ var search = function(nums, target) { let len = nums.length; if (len === 0) return -1; return handler(0, len - 1, nums, target); }; function handler(l, r, nums, target) { if (l > r) return -1; let mid = (l + r) / 2 | 0; if (nums[mid] === target) return mid; if (nums[r] > nums[mid]) { if (nums[r] >= target && nums[mid] target) return handler(l, mid - 1, nums, target); return handler(mid + 1, r, nums, target) } } 二分搜索增强版 var search = function(nums, target) { if (nums.length === 0) return -1; function bSearch(nums, i, j, target) { if (i > j) return -1; const mid = ~~((i + j) / 2); if (nums[mid] === target) return mid; return shouldSearchInLeft() ? bSearch(nums, i, mid - 1, target) : bSearch(nums, mid + 1, j, target); function shouldSearchInLeft() { return nums[i] = target : // 非完全有序时的分割条件 (nums[i] = nums[i] && target nums[mid] && (target nums[j])); } } return bSearch(nums, 0, nums.length - 1, target); }; "},"算法/搜索旋转排序数组II.html":{"url":"算法/搜索旋转排序数组II.html","title":"搜索旋转排序数组 II","keywords":"","body":"搜索旋转排序数组 II 搜索旋转排序数组 II 题目 js 二分查找 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。 示例 1: 输入: nums = [2,5,6,0,0,1,2], target = 0 输出: true 示例 2: 输入: nums = [2,5,6,0,0,1,2], target = 3 输出: false 进阶:这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ var search = function(nums, target) { var num = [...new Set(nums)]; function erf(arr, target) { if (arr.length == 0) { return false; } if (arr.length == 1) { if (arr[0] !== target) { return false; } else { return true; } } var middle = parseInt(arr.length / 2); if (arr[middle] == target) { return true; } if (arr[middle] > arr[0]) { //左边有序 if (arr[0] target) { return erf(arr.slice(0, middle), target); } else { return erf(arr.slice(middle + 1), target); } } else { //右边有序 if (arr[middle] = target) { return erf(arr.slice(middle + 1), target); } else { return erf(arr.slice(0, middle), target); } } } } return erf(num, target); }; js 二分查找 var search = function(nums, target) { var left = 0, right = nums.length - 1, mid; while (left nums[mid] && target nums[right]) { if (target = nums[left]) { right = mid - 1; } else { left = mid + 1; } } else { right--; } } return false; }; "},"算法/寻找旋转排序数组中的最小值.html":{"url":"算法/寻找旋转排序数组中的最小值.html","title":"寻找旋转排序数组中的最小值","keywords":"","body":"寻找旋转排序数组中的最小值 寻找旋转排序数组中的最小值 题目 Math.min 右移操作符嘛，除以2的花哨写法 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 你可以假设数组中不存在重复元素。 示例 1: 输入: [3,4,5,1,2] 输出: 1 示例 2: 输入: [4,5,6,7,0,1,2] 输出: 0 Math.min Math.min.appy(null, arr) 右移操作符嘛，除以2的花哨写法 r-l >> 1 右移操作符嘛，除以2的花哨写法 左移 > 、无符号右移 >>> 简单记法： (a (2*b)); (a >> b) === Math.floor(a/(2**b)); var findMin = function(nums) { let l = 0; let r = nums.length - 1; while(l > 1); if(nums[mid] > nums[r]) { l = mid + 1; } else { r = mid; } } return nums[l] }; "},"算法/寻找旋转排序数组中的最小值II.html":{"url":"算法/寻找旋转排序数组中的最小值II.html","title":"寻找旋转排序数组中的最小值 II","keywords":"","body":"寻找旋转排序数组中的最小值 II 寻找旋转排序数组中的最小值 II 题目 JS 题目 假设按照升序排序的数组在预先未知的某个点上进行了旋转。 ( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。 请找出其中最小的元素。 注意数组中可能存在重复的元素。 示例 1： 输入: [1,3,5] 输出: 1 示例 2： 输入: [2,2,2,0,1] 输出: 0 说明： 这道题是 寻找旋转排序数组中的最小值 的延伸题目。允许重复会影响算法的时间复杂度吗？会如何影响，为什么？ 和Search in Rotated Sorted Array唯一的区别是这道题目中元素会有重复的情况出现。不过正是因为这个条件的出现，出现了比较复杂的case，甚至影响到了算法的时间复杂度。原来我们是依靠中间和边缘元素的大小关系，来判断哪一半是不受rotate影响，仍然有序的。而现在因为重复的出现，如果我们遇到中间和边缘相等的情况，我们就丢失了哪边有序的信息，因为哪边都有可能是有序的结果。假设原数组是{1,2,3,3,3,3,3}，那么旋转之后有可能是{3,3,3,3,3,1,2}，或者{3,1,2,3,3,3,3}，这样的我们判断左边缘和中心的时候都是3，如果我们要寻找1或者2，我们并不知道应该跳向哪一半。解决的办法只能是对边缘移动一步，直到边缘和中间不在相等或者相遇，这就导致了会有不能切去一半的可能。所以最坏情况（比如全部都是一个元素，或者只有一个元素不同于其他元素，而他就在最后一个）就会出现每次移动一步，总共是n步，算法的时间复杂度变成O(n)。 JS js 执行用时 : 68 ms, 在Find Minimum in Rotated Sorted Array II的JavaScript提交中击败了100.00% 的用户 内存消耗 : 34.5 MB, 在Find Minimum in Rotated Sorted Array II的JavaScript提交中击败了38.10% 的用户var findMin = function(nums) { var left = 0, right = nums.length - 1, mid; while(left nums[right]){ left = mid + 1; } else if(nums[mid] "},"算法/在排序数组中查找元素的第一个和最后一个位置.html":{"url":"算法/在排序数组中查找元素的第一个和最后一个位置.html","title":"在排序数组中查找元素的第一个和最后一个位置","keywords":"","body":"在排序数组中查找元素的第一个和最后一个位置 在排序数组中查找元素的第一个和最后一个位置 题目 标签 二分法，从中间向两侧逼近 思路简单，没用二分法查找 题目 给定一个按照升序排列的整数数组 nums，和一个目标值target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须是 O(log n) 级别。 如果数组中不存在目标值，返回 [-1, -1]。 示例 1: 输入: nums = [5,7,7,8,8,10], target = 8 输出: [3,4] 示例 2: 输入: nums = [5,7,7,8,8,10], target = 6 输出: [-1,-1] 标签 数组 二分查找 二分法，从中间向两侧逼近 思路：二分法 先找左边界，从右侧逼近； 再找右边界，从左侧逼近，注意：在跳出循环时，会出现两种情况：1. 该值等于target，2. 该值大于target /** * @param {number[]} nums * @param {number} target * @return {number[]} */ var searchRange = function(nums, target) { let result = [-1, -1]; let len = nums.length; if (len === 0) return result; let l = 0, r = len - 1; while (l = nums[mid]) l = mid + 1; else r = mid; } if (nums[r] === target) result[1] = r; else result[1] = r - 1; return result; }; 思路简单，没用二分法查找 var searchRange = function(nums, target) { let i = nums.indexOf(target); let j = nums.reverse().indexOf(target); if (j != -1) { j = nums.length - 1 - j; } return [i, j]; }; var searchRange = function(nums, target) { let arr = []; for (let i = 0; i "},"算法/第一个错误的版本.html":{"url":"算法/第一个错误的版本.html","title":"第一个错误的版本","keywords":"","body":"第一个错误的版本 第一个错误的版本 题目 标签 js,递归 JS2 JS3 题目 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。 示例: 给定 n = 5，并且 version = 4 是第一个错误的版本。 调用 isBadVersion(3) -> false 调用 isBadVersion(5) -> true 调用 isBadVersion(4) -> true 所以，4 是第一个错误的版本。 标签 二分查找 js,递归 var solution = function(isBadVersion) { /** * @param {integer} n Total versions * @return {integer} The first bad version */ return function(n) { const check = (start, end) => { if (end - start === 0) return start; let c = Math.floor((start + end) / 2); if (isBadVersion(c)) return check(start, c); else return check(c + 1, end); }; return check(1, n); }; }; JS2 let solution = function(isBadVersion) { return function(n) { let low = 1; while (low JS3 var solution = function(isBadVersion) { /** * @param {integer} n Total versions * @return {integer} The first bad version */ return function(n) { var left = 1; var right = n; var mid; while (left > 0; if (isBadVersion(mid)) { right = mid - 1; if (!isBadVersion(right)) { return mid; } } else { left = mid + 1; } } return mid; }; }; "},"算法/搜索插入位置.html":{"url":"算法/搜索插入位置.html","title":"搜索插入位置","keywords":"","body":"搜索插入位置 搜索插入位置 题目 标签 javaScript解法，用时100ms，内存消耗35M 感觉和two sum差不多，可以用哈希表和两分法 indexOf findIndex js版本 直接使用二分法排序 index++ 题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 标签 数组 二分查找 javaScript解法，用时100ms，内存消耗35M var searchInsert = function(nums, target) { let res = -1; //判断nums是否存在target的值 res = indexValue(nums, target); //如果不存在目标值，插入 if (res === -1) { // 先把目标值塞进数组 nums.push(target); // 将数组排序 nums.sort((a, b) => { if (a > b) return 1; if (a { let sub = -1; arr.map((val, i) => { if (val === target) sub = i; }); return sub; }; 感觉和two sum差不多，可以用哈希表和两分法 暴力解法Runtime: 52 ms, faster than 85.47% of JavaScript online submissions for Search Insert Position.Memory Usage: 34.3 MB, less than 41.45% of JavaScript online submissions for Search Insert Position. /** * @param {number[]} nums * @param {number} target * @return {number} */ var searchInsert = function(nums, target) { if (nums[0] > target) { return 0; } for (let i = 0; i = target) { return i; } } return nums.length; }; 双指针 var searchInsert = function(nums, target) { if (nums[0] > target) { return 0; } else if (nums[nums.length - 1] indexOf findIndex var searchInsert = function(nums, target) { if (nums.includes(target)) return nums.indexOf(target); return nums.findIndex(ele => ele > target) !== -1 ? nums.findIndex(ele => ele > target) : nums.length; }; js版本 思路一： 检测 nums 数组中是否已经存在target值，存在直接返回； 否则进行插入target，进行排序，再取下标进行返回。 var searchInsert = function (nums, target) { let res = nums.indexOf(target); if (res (a - b)); return nums.indexOf(target); }; return res; }; 思路二： 不管target是否存在，直接合并去重，排序; 再获取target 下标，进行返回。 //也可以一行解决 var searchInsert = function(nums, target) { return [...new Set(nums.concat(target))] .sort((a, b) => a - b) .findIndex(v => v == target); }; 直接使用二分法排序 直接使用二分法排序，与传统二分法不同的是，没有找到时传统二分法会返回-1，修改的二分法返回搜索区间的begin值，此时的begin值就是target需要插入的下标值 var searchInsert = function(nums, target) { let beg = 0, end = nums.length - 1; while (beg target) { end = mid - 1; } else { beg = mid + 1; } } return beg; }; index++ var searchInsert = function(nums, target) { let index = 0; for (let i = 0; i "},"算法/有效的数独.html":{"url":"算法/有效的数独.html","title":"有效的数独","keywords":"","body":"有效的数独 有效的数独 标签 JS JS2 Javascript 空间换时间 暴力穷举法 创建3个数组 Hash 题目 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 '.' 表示。 示例 1: 输入: [ [\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] 输出: true 示例 2: 输入: [ [\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"], [\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"], [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"], [\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"], [\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"], [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"], [\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"], [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"], [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"] ] 输出: false 解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 '.' 。 给定数独永远是 9x9 形式的。 标签 哈希表 JS /** * @param {character[][]} board * @return {boolean} */ var isValidSudoku = function(board) { let getBlockNo = (r, c) => 3 * Math.floor(r / 3) + Math.floor(c / 3); let blockMap = {}; for (let i = board.length; i--; ) { let line = board[i]; for (let j = line.length; j--; ) { let num = line[j]; if (num === \".\") continue; let blockNo = getBlockNo(i, j); let block = blockMap[blockNo]; if (block && block[num]) return false; for (let k = 3; k--; ) { let rowBlockNo = 3 * Math.floor(i / 3) + k; let colBlockNo = Math.floor(j / 3) + 3 * k; if (blockNo !== rowBlockNo) { let rowBlock = blockMap[rowBlockNo]; if (rowBlock && rowBlock[num] && i === rowBlock[num][0]) return false; } if (blockNo !== colBlockNo) { let colBlock = blockMap[colBlockNo]; if (colBlock && colBlock[num] && j === colBlock[num][1]) return false; } } if (block) block[num] = [i, j]; else blockMap[blockNo] = { [num]: [i, j] }; } } return true; }; JS2 var isValidSudoku = function(board) { let mapRow = new Set(); let mapColumn = new Set(); let mapBorder = new Set(); for (let i = 0; i Javascript 空间换时间 var isValidSudoku = function(board) { const resultHash = []; // 283 个元素，横向 纵向 3 * 3 各占 81 个 for (let i = 0; i 1) { return false; } } } } return true; }; 暴力穷举法 var isValidSudoku = function(board) { // 先按行遍历 for (let i = 0; i 创建3个数组 创建3个数组，分别代表列、行、区域，依次为一维、二维、三维数组。行列嵌套循环一次，先判断是否存在相同，再插入当前值。 96ms，100%。 var isValidSudoku = function(board) { let temp = \"\"; let area = [ [], [], [] ]; let col = []; for (let i = 0; i Hash var isValidSudoku = function(board) { for (var i = 0; i "},"算法/解数独.html":{"url":"算法/解数独.html","title":"解数独","keywords":"","body":"解数独 解数独 题目 标签 JS 题目 编写一个程序，通过已填充的空格来解决数独问题。 一个数独的解法需遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 空白格用 '.' 表示。 一个数独。 答案被标成红色。 Note: 给定的数独序列只包含数字 1-9 和字符 '.' 。 你可以假设给定的数独只有唯一解。 给定数独永远是 9x9 形式的。 标签 哈希表 回溯算法 JS /** * @param {character[][]} board * @return {void} Do not return anything, modify board in-place instead. */ var S = [[], [], [], [], [], [], [], [], []]; //初始值 var INIT = [[], [], [], [], [], [], [], [], []]; //备份初始值 var solveSudoku = function(board) { for (i = 0; i "},"算法/报数.html":{"url":"算法/报数.html","title":"报数","keywords":"","body":"报数 报数 题目 循环计数 正则计数， /(\\d)\\1*/g (反向引用)可以捕获相同数字 双指针法，第一个指针记录值，第二个指针记录数量 栈 递归算法 题目 报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下： 1. 1 2. 11 3. 21 4. 1211 5. 111221 1 被读作 \"one 1\" (\"一个一\") , 即 11。 11 被读作 \"two 1s\" (\"两个一\"）, 即 21。 21 被读作 \"one 2\", \"one 1\" （\"一个二\" , \"一个一\") , 即 1211。 给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。 注意：整数顺序将表示为一个字符串。 示例 1: 输入: 1 输出: \"1\" 示例 2: 输入: 4 输出: \"1211\" 循环计数 var countAndSay = function(n) { if (n == 1) return \"1\"; function say(str) { var result_str = \"\", i = 0; j = 0; while (j 正则计数， /(\\d)\\1*/g (反向引用)可以捕获相同数字 var countAndSay = function(n) { if (n == 1) return \"1\"; function say(str) { var reg = /(\\d)\\1*/g; var result = \"\"; var result_str = \"\"; while ((result = reg.exec(str))) { result_str += result[0].length + result[1]; } return result_str; } return say(countAndSay(n - 1)); }; 双指针法，第一个指针记录值，第二个指针记录数量 var countAndSay = function(n) { let num = \"1\"; let sum = \"\"; for (let l = 0; l 栈 var countAndSay = function(n) { let stark = []; let list = \"1\"; let result = \"\"; if (n === 1) { return list; } for (let i = 1; i { if (stark[0] === item || index === 0) { stark.unshift(item); } else { result = result + stark.length.toString() + stark[0].toString(); stark = []; stark.unshift(item); } }); if (stark.length != 0) { result = result + stark.length.toString() + stark[0].toString(); stark = []; } if (i === n - 1) { return result; } list = result; result = \"\"; } }; 递归算法 本题大意为 1项不做处理，直接返回本身1 2即解释说明1项，1项是1个1组成，所以为11 3项解释说明2项，2项是2个1组成，所以是21 4项解释说明3项，3项是1个2和1个1组成，所以是1211 5项同理，1个1项和1个2项和2个1项组成，即111221 同理推倒下去。。。 简单递归思路。在做这种需要依赖上一个资源进行计算的题目时，很容易让人联想到递归算法。 简单明确下本体的思路。 1、首先要明确的是递归终止条件。开头满足条件即返回 然后就是处理，用数组就是处理，用字符串性能消耗更大，我试过了。。。 先进行查找，如果相等，那么重合度k增加1，如果不相等，那么进行字符串（数组）拼接 最后用这个新的字符串调用自己进行处理成新的字符串。 var countAndSay = function(n) { return createStr(1, [\"1\"], n); function createStr(index, str, n) { if (index == n) return str.join(\"\"); //终止条件：查询到了第n个数了，立即返回，否则index+1 index++; let newChar = []; let k = 1; //保存该数存在次数：当查询到不等的时候，在下方重置k for (let j = 0; j "},"算法/压缩字符串.html":{"url":"算法/压缩字符串.html","title":"压缩字符串","keywords":"","body":"压缩字符串 压缩字符串 题目 JS 用正则 双指针 题目 给定一组字符，使用原地算法将其压缩。 压缩后的长度必须始终小于或等于原数组长度。 数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。 在完成原地修改输入数组后，返回数组的新长度。 进阶：你能否仅使用O(1) 空间解决问题？ 示例 1： 输入： [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"] 输出： 返回6，输入数组的前6个字符应该是：[\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"] 说明： \"aa\"被\"a2\"替代。\"bb\"被\"b2\"替代。\"ccc\"被\"c3\"替代。 示例 2： 输入： [\"a\"] 输出： 返回1，输入数组的前1个字符应该是：[\"a\"] 说明： 没有任何字符串被替代。 示例 3： 输入： [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"] 输出： 返回4，输入数组的前4个字符应该是：[\"a\",\"b\",\"1\",\"2\"]。 说明： 由于字符\"a\"不重复，所以不会被压缩。\"bbbbbbbbbbbb\"被“b12”替代。 注意每个数字在数组中都有它自己的位置。 注意： 所有字符都有一个ASCII值在[35, 126]区间内。 1 。 JS var compress = function(chars) { let count = 0; // 当前字符的累计总数 let char = chars[0]; // 当前字符 let index = 0; // 当前可放入压缩后字符的索引 for (let i = 0; i 1) { for (let j = 0; j 1) { for (let j = 0; j 用正则 var compress = function(chars) { let arrs = chars.join(\"\"); arrs = arrs.match(/(\\S)(\\1)*/g); let arr = []; for (const i in arrs) { arr.push(arrs[i][0]); if (arrs[i].length !== 1) { arr.push(arrs[i].length.toString()); } } arrs = arr.join(\"\").split(\"\"); let len = chars.length; for (let i = 0; i 双指针 var compress = function(chars) { let j = 0, count = 1; chars.push(0); for (let i = 1; i 1) { let temp = count.toString(); for (let k = 0; k "},"算法/组合.html":{"url":"算法/组合.html","title":"组合","keywords":"","body":"组合 组合 题目 标签 js 回溯 js 回溯 JS 经典回溯算法 题目 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。 示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ] 标签 回溯算法 js 回溯 var combine = function(n, k) { const arr = Array(n) .fill() .map((_, index) => index + 1); const buffer = []; const result = []; const backTrace = (index, target) => { if (target == 0) { return result.push(buffer.slice()); } if (index === arr.length) return; buffer.push(arr[index]); backTrace(index + 1, target - 1); buffer.pop(); backTrace(index + 1, target); }; backTrace(0, k); return result; }; js 回溯 var combine = function(n, k) { var results = []; dfs(0, []); return results; function dfs(index, array) { if (array.length == k) { results.push(array); return; } for (var i = index + 1; i JS 经典回溯算法 let combine = function(n, k) { let ans = [], res = []; function dfs(idx) { if (res.length === k) { ans.push(res.map(item => item)); } else if (res.length "},"算法/组合总和.html":{"url":"算法/组合总和.html","title":"组合总和","keywords":"","body":"组合总和 组合总和 题目 标签 递归以及判断合理即可通过 递归 JS DP 双指针 题目 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7, 所求解集为: [ [7], [2,2,3] ] 示例 2: 输入: candidates = [2,3,5], target = 8, 所求解集为: [ [2,2,2,2], [2,3,3], [3,5] ] 标签 数组 回溯算法 递归以及判断合理即可通过 var combinationSum = function(candidates, target) { let result = []; for (let i = 0; i 0) { result = result.concat( combinationSum(candidates.slice(i), left).map(arr => [candidate].concat(arr) ) ); } } return result; }; 递归 var combinationSum = function(candidates, target) { var res = [], hash = new Map(); var dfs = function(arr, sum, k) { if (sum === target) { var str = arr.join(\"-\"); if (hash.has(str)) return; hash.set(str, 1); res.push([...arr]); } if (sum > target) return; for (var i = k; i target) { return; } else { dfs([...arr, candidates[i]], sum + candidates[i], i); } } }; candidates.sort((a, b) => a - b); dfs([], 0, 0); return res; }; JS DP var combinationSum = function(candidates, target) { const dp = new Array(target + 1).fill(false); for (let i = 1; i (item += `,${candidates[i]}`) ); if (dp[j]) dp[j] = dp[j].concat(tempArr); else dp[j] = tempArr; } } } return dp[dp.length - 1] ? dp[dp.length - 1].map(item => item.split(\",\")) : []; }; 双指针 var combinationSum = function(candidates, target) { candidates.sort((x, y) => x - y); const count = (candidates, target) => { let res = []; for (let i = 0; i num)); } else if (left > 0) { res = res.concat( count(candidates.slice(i + 1), left).map(arr => Array.from({ length: x }, v => num).concat(arr) ) ); } x++; } } return res; }; return count(candidates, target); }; "},"算法/组合总和II.html":{"url":"算法/组合总和II.html","title":"组合总和 II","keywords":"","body":"组合总和 II 组合总和 II 题目 标签 动态规划 回溯 js 回溯 题目 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ] 示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [ [1,2,2], [5] ] 标签 数组 回溯算法 动态规划 var combinationSum = function(candidates, target) { var dp = []; //先排序解决顺序问题 例 （1，2）（2，1） candidates.sort((a, b) => a - b); for (let i = 0; i = c; i--) { for (item of dp[i - c]) { //使用Set去重, 子项要转化成 String dp[i].add(item + \",\" + c); } } } //最后把Set 转成 Array return Array.from(dp[target]).map(item => item.slice(1).split(\",\")); }; 回溯 var combinationSum2 = function(candidates, target) { candidates.sort((a, b) => a - b); var result = [], n = candidates.length; function backtrack(start, sum, list) { if (sum === target) { result.push(list); } for (let i = start; i target) break; //相同数字只允许循环的第一个递归，避免重复 if (candidates[i] === candidates[i - 1] && i > start) continue; backtrack(i + 1, sum + candidates[i], [...list, candidates[i]]); } } backtrack(0, 0, []); return result; }; js 回溯 var combinationSum2 = function(candidates, target) { const buffer = []; const result = []; const backTrace = (index, target) => { if (target == 0) { return result.push(buffer.slice()); } if (target arr.sort((a, b) => a - b)).map(arr => arr.join(\"|\")) ) ].map(item => item.split(\"|\").map(num => +num)); }; "},"算法/组合总和III.html":{"url":"算法/组合总和III.html","title":"组合总和 III","keywords":"","body":"组合总和 III 组合总和 III 题目 标签 js 回溯 js 递归 + 剪枝 js 时间可能比较长，但是便于理解回溯法 题目 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1: 输入: k = 3, n = 7 输出: [[1,2,4]] 示例 2: 输入: k = 3, n = 9 输出: [[1,2,6], [1,3,5], [2,3,4]] 标签 数组 回溯算法 js 回溯 var combinationSum3 = function(k, target) { const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9]; // backtrack let current = []; const result = []; const set = new Set(); const bt = (index, rest, target) => { if ((rest === 0 && target !== 0) || index > nums.length) { return; } if (rest === 0 && target === 0) { const currentSetItem = current .slice() .sort((a, b) => a - b) .join(\"|\"); if (!set.has(currentSetItem)) { result.push(current.slice()); set.add(currentSetItem); } return; } current.push(nums[index]); bt(index + 1, k - current.length, target - nums[index]); current.pop(); bt(index + 1, k - current.length, target); }; bt(0, k, target); return result; }; js 递归 + 剪枝 /** * @param {number} k * @param {number} n * @return {number[][]} */ var combinationSum3 = function(k, n) { let left = [...new Array(9)].map((item, index) => index + 1); let result = []; let digui = (start, value, arr) => { for (let i = start; i 0) { if (copy.length > 0) { let start1 = copy[copy.length - 1]; digui(start1, value - left[i], copy); } } } }; digui(0, n, []); return result; console.log(result); }; js 时间可能比较长，但是便于理解回溯法 var combinationSum3 = function(k, n) { let arr = [], res = []; const dfs = (index, num, target, count) => { if (count == 0) { if (num == target) { res.push([...arr]); return; } } else { for (let i = index + 1; i target) continue; arr.push(i); dfs(i, num + i, target, count - 1); arr.pop(); } } }; for (let i = 1; i "},"算法/缺失的第一个正数.html":{"url":"算法/缺失的第一个正数.html","title":"缺失的第一个正数","keywords":"","body":"缺失的第一个正数 缺失的第一个正数 题目 标签 官方解法的JavaScript版本 计数排序 点赞最高实现方法 题目 给定一个未排序的整数数组，找出其中没有出现的最小的正整数。 示例 1: 输入: [1,2,0] 输出: 3 示例 2: 输入: [3,4,-1,1] 输出: 2 示例 3: 输入: [7,8,9,11,12] 输出: 1 说明: 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的空间。 标签 数组 官方解法的JavaScript版本 时间复杂度 O(3n) 空间复杂度 O(1) var firstMissingPositive = function(nums) { var n = nums.length; //处理负数 //可以不处理超出 length+1 的值， 因为js数组没有越界问题 //由于 NaN 会影响判断 并且 结果最大为 length+1， 所以将边界增加到 length+1 //可以不添加边界，在结果判断NaN for (var i = 0; i 0) return i; } }; 计数排序 计数排序，适合整数排序，速度上越超比较排序的，算法在时间复杂度上，不管好坏平均都是O(n) = (n+k)； 但是需要一个额外的数组的下坐标来作为储存他们的值。 举例子： [3,1,2] ;在计数排序的思想下，我们先要用这个数组的长度来生成一个同等长度的临时数组 => [ , , ], 在循环[3,1,2]，根据他们的值对应到临时数组的下坐标，同时在这个临时数组所在下坐标设置一个标志符，我习惯设置成1，也就是这样了[1,1,1]，因为起始位置为1。 为什么循环临时数组长度+1的起始位置不为0？（有人可能会有疑问） 因为0不是正数，最小的正数是1，如果1也不算正数了，那么起始位置为2... 以下是我的算法答案，现在只是排在第二位 function findThat(nums) { var temMax = new Array(nums.length); for (var m = 0; m 点赞最高实现方法 var firstMissingPositive = function(nums) { let length = nums.length; var arr = nums.filter(num => num > 0); length = arr.length; let newArr = []; for (let i = 0; i "},"算法/缺失数字.html":{"url":"算法/缺失数字.html","title":"缺失数字","keywords":"","body":"缺失数字 缺失数字 题目 标签 利用对象，保存数组中数据，遍历对象查找缺失数值 120ms 待优化 求和 利用原数组，将当前遍历的数放到正确的位置上，最后找到数组中的空值 位移 js math 先计算0-n的总数 然后减去nums就是少的那个数 includes 题目 给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。 示例 1: 输入: [3,0,1] 输出: 2 示例 2: 输入: [9,6,4,2,3,5,7,0,1] 输出: 8 说明:你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现? 标签 位运算 数组 数学 利用对象，保存数组中数据，遍历对象查找缺失数值 var missingNumber = function(nums) { let l = nums.length; let obj = {}; nums.map(item => { obj[item] = item; }); let res = null; for (let i = 0; i 120ms 待优化 var missingNumber = function(nums) { nums.sort(function(a, b) { return a - b; }); for (var i = 0; i 求和 var missingNumber = function(nums) { if (nums.length == 0) return 0; var sum = nums.reduce(function(a, b) { return a + b; }); return ((nums.length + 1) * nums.length) / 2 - sum; }; 利用原数组，将当前遍历的数放到正确的位置上，最后找到数组中的空值 function swap(i, j, nums) { const tmp = nums[j]; nums[j] = nums[i]; nums[i] = tmp; } var missingNumber = function(nums) { let j = 0; while (j 位移 var missingNumber = function(nums) { let i = 0; return nums.reduce((a, b) => a ^ b ^ i++, nums.length); }; js math var missingNumber = function(nums) { const len = nums.length; const sum = (len * (len + 1)) / 2; // n个数的和 const currSum = nums.reduce((x, y) => x + y); // 当前数组和 return sum - currSum; }; 先计算0-n的总数 然后减去nums就是少的那个数 var missingNumber = function(nums) { let len = nums.length + 1; let allSum = 0; if (len % 2 == 0) { allSum = (len / 2) * (len - 1); } else { allSum = ((len - 1) / 2) * (len - 1) + (len - 1) / 2; } let sum = nums.reduce((sum, current) => sum + current); return allSum - sum; }; includes var missingNumber = function(nums) { let n = 0; while (nums.includes(n)) { n = n + 1; } return n; }; "},"算法/只出现一次的数字.html":{"url":"算法/只出现一次的数字.html","title":"只出现一次的数字","keywords":"","body":"只出现一次的数字 只出现一次的数字 题目 标签 位运算 JS Javascript 的两种姿势 题目 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1] 输出: 1 示例 2: 输入: [4,1,2,1,2] 输出: 4 标签 位运算 哈希波啊 位运算 思路 标签：位运算 本题根据题意，线性时间复杂度O(n)，很容易想到使用Hash映射来进行计算，遍历一次后结束得到结果，但是在空间复杂度上会达到O(n)，需要使用较多的额外空间 既满足时间复杂度又满足空间复杂度，就要提到位运算中的异或运算XOR，主要因为异或运算有以下几个特点： 一个数和0做XOR运算等于本身：a⊕0 = a 一个数和其本身做XOR运算等于0：a⊕a = 0 XOR运算满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b 故而在以上的基础条件上，将所有数字按照顺序做抑或运算，最后剩下的结果即为唯一的数字 时间复杂度：O(n)，空间复杂度：O(1) /** * @param {number[]} nums * @return {number} */ var singleNumber = function(nums) { let ans = 0; for (const num of nums) { ans ^= num; } return ans; }; JS var singleNumber = function (nums) { var obj = {} for (let i = 0; i Javascript 的两种姿势 var singleNumber = function(nums) { // 1: 80ms Beats 93.86% // var a = nums[0] // for(var i = 1 ; i "},"算法/找不同.html":{"url":"算法/找不同.html","title":"找不同","keywords":"","body":"找不同 找不同 题目 标签 js 一次循环 新增字母的ascii码 JS 位运算 JS 转换数组，循环判断并移除元素 题目 给定两个字符串 s 和 t，它们只包含小写字母。 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 请找出在 t 中被添加的字母。 示例: 输入： s = \"abcd\" t = \"abcde\" 输出： e 解释： 'e' 是那个被添加的字母。 标签 位运算 哈希表 js 一次循环 var findTheDifference = function(s, t) { // 取巧方法， 改变了原数据 for(let item of s){ t = t.replace(item, '') } return t }; 新增字母的ascii码 执行用时 : 88 ms, 在Find the Difference的JavaScript提交中击败了97.98% 的用户 因为只插入一个字母，所以2个字符串charCode和的 差 就是 新增字母的ascii码，转成字母即可 var findTheDifference = function(s, t) { let len = t.split('').length let sum = 0 for (let i = 0; i JS 执行用时 : 80 ms, 在Find the Difference的JavaScript提交中击败了98.01% 的用户 var findTheDifference = function(s, t) { let dic = {}; for (const c of s) { dic[c] = (dic[c] || 0) + 1; } for (const c of t) { if (c in dic && dic[c] > 0) dic[c]--; else return c; } }; 位运算 var findTheDifference = function(s, t) { let arr1 = s.split(\"\").map(val => val.charCodeAt(0)); let arr2 = t.split(\"\").map(val => val.charCodeAt(0)); let sum = 0; for (let i = 0; i JS var findTheDifference = function(s, t) { let arr = s.split(\"\"); for (let i = 0; i 转换数组，循环判断并移除元素 var findTheDifference = function(s, t) { //转换数组，循环判断并移除元素 var s = s.split(''); var t = t.split(''); for(var i=0;i "},"算法/寻找重复数.html":{"url":"算法/寻找重复数.html","title":"寻找重复数","keywords":"","body":"寻找重复数 寻找重复数 题目 标签 JS JS2 题目 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1: 输入: [1,3,4,2,2] 输出: 2 示例 2: 输入: [3,1,3,4,2] 输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 标签 数组 双指针 二分查找 JS var findDuplicate = function(nums) { let i = 0; while (nums[i] !== i) { if (nums[i] != nums[nums[i]]) { swap(nums, i, nums[i]); } else { return nums[i]; } } }; function swap(A, i, j) { let t = A[i]; A[i] = A[j]; A[j] = t; } JS2 以每个元素的值为角标，则必然有两个元素指向同一位置。遍历数组，将遍历过的元素表为负数，如果某一元素作为角标时指向一个负值，说明被指向的这个元素之前已经被遍历过了，作为角标的这个元素就是重复的值。 var findDuplicate = function(nums) { var i = 0; while(true){ var v = nums[i]; if(v > 0){ nums[i] = -nums[i]; i = v; } else { return i; } } }; "},"算法/找到所有数组中消失的数字.html":{"url":"算法/找到所有数组中消失的数字.html","title":"找到所有数组中消失的数字","keywords":"","body":"找到所有数组中消失的数字 找到所有数组中消失的数字 题目 标签 JS js ，除了返回数组之外没申请其他额外空间... JS3 JS4 题目 给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。 找到所有在 [1, n] 范围之间没有出现在数组中的数字。 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。 示例: 输入: [4,3,2,7,8,2,3,1] 输出: [5,6] 标签 数组 JS var findDisappearedNumbers = function(nums) { var len = nums.length; var res = []; //不去重，最后两个测试用例就超时 nums = [...new Set(nums)]; for(var j=1;j js ，除了返回数组之外没申请其他额外空间... /** * @param {number[]} nums * @return {number[]} */ var findDisappearedNumbers = function(nums) { let ret = []; for( var i = 0; i JS3 var findDisappearedNumbers = function(nums) { const arr = [...nums]; for (let i = 0; i 0 && (arr[nums[i] - 1] *= -1); } return arr.map((item, index) => item > 0 && index + 1).filter(Number); }; JS4 var findDisappearedNumbers = function(nums) { let ans=Array(nums.length).fill(null).map((_, h) => h+1); for(let i=0;i{return value!=0}); return ans; }; "},"算法/情侣牵手.html":{"url":"算法/情侣牵手.html","title":"情侣牵手","keywords":"","body":"情侣牵手 情侣牵手 题目 标签 JS 题目 N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。 人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N-2, 2N-1)。 这些情侣的初始座位 row[i] 是由最初始坐在第 i 个座位上的人决定的。 示例 1: 输入: row = [0, 2, 1, 3] 输出: 1 解释: 我们只需要交换row[1]和row[2]的位置即可。 示例 2: 输入: row = [3, 2, 0, 1] 输出: 0 解释: 无需交换座位，所有的情侣都已经可以手牵手了。 说明: len(row) 是偶数且数值在 [4, 60]范围内。 可以保证row 是序列 0...len(row)-1 的一个全排列。 标签 贪心算法 并查集 图 JS var minSwapsCouples = function(row) { let result = 0; for (let i = 0; i "},"算法/字符串相乘.html":{"url":"算法/字符串相乘.html","title":"字符串相乘","keywords":"","body":"字符串相乘 字符串相乘 题目 标签 各位相乘在相加 相乘同时相加 JS3 JS4 JS5 JS6 JS7 题目 给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。 示例 1: 输入: num1 = \"2\", num2 = \"3\" 输出: \"6\" 示例 2: 输入: num1 = \"123\", num2 = \"456\" 输出: \"56088\" 说明： num1 和 num2 的长度小于110。 num1 和 num2 只包含数字 0-9。 num1 和 num2 均不以零开头，除非是数字 0 本身。 不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。 标签 数学 字符串 各位相乘在相加 将每一位相乘的结果放入数组，让后吧数组里面的数字相加。 /** * @param {string} num1 * @param {string} num2 * @return {string} */ var multiply = function(num1, num2) { if ( (num1.length === 1 && num1[0] === \"0\") || (num2.length === 1 && num2[0] === \"0\") ) return \"0\"; let tArr = []; let num1Lidx = num1.length - 1, num2Lidx = num2.length - 1; for (let i = num1Lidx; i >= 0; i--) { let t = 0; let s = \"0\".repeat(num1Lidx - i); for (let j = num2Lidx; j >= 0; j--) { let sumT = Number(num1[i]) * Number(num2[j]) + t; t = (sumT / 10) | 0; s = (sumT % 10) + s; } if (t !== 0) s = t + s; tArr.push(s); } let res = \"\"; for (let i = 0; i = 0 || y >= 0; x--, y-- ) { let sumT = Number(x >= 0 ? tArr[i][x] : 0) + Number(y >= 0 ? res[y] : 0) + t; s = String(sumT % 10) + s; t = (sumT / 10) | 0; } res = t > 0 ? \"1\" + s : s; } return res; }; 相乘同时相加 长度为 n 和 m 相乘，则长度肯定小于 m + n + 1; 将每次相乘的结果放入数组中，在下次计算的时候加上当前位上的值. var multiply = function(num1, num2) { let num1Lidx = num1.length - 1, num2Lidx = num2.length - 1; let result = []; // m 长度 * n 长度，总长度不会超过 m + n + 1; for (let i = num1Lidx; i >= 0; i--) { for (let j = num2Lidx; j >= 0; j--) { let s = Number(num1[i]) * Number(num2[j]) + (result[i + j + 1] || 0); result[i + j + 1] = s % 10; result[i + j] = ((s / 10) | 0) + (result[i + j] || 0); } } while (result[0] === 0) { result.shift(); } return result.join(\"\") || \"0\"; }; JS3 依赖num1[i] * num2[j] will be placed at indices [i + j, i + j + 1] ，处理后再最每一个位上的数进行进位。 var multiply = function(num1, num2) { if (num1 == \"0\" || num2 == \"0\") return \"0\"; var m = num1.length, n = num2.length, pos = new Array(m + n).fill(0); for (var i = m - 1; i >= 0; i--) { for (var j = n - 1; j >= 0; j--) { var multiply = num1[i] * num2[j]; var p1 = i + j; var p2 = i + j + 1; pos[p1] += Math.floor(multiply / 10); pos[p2] += multiply % 10; } } for (var len = pos.length, k = len - 1; k >= 0; k--) { if (pos[k] > 9) { pos[k - 1] = pos[k - 1] + Math.floor(pos[k] / 10); pos[k] = pos[k] % 10; } } return pos.join(\"\").replace(/^0*/, \"\"); }; JS4 var multiply = function(num1, num2) { if (num1 == \"0\" || num2 == \"0\") return \"0\"; var res = new Array(num1.length + num2.length); for (var l = 0; l > 0; res[l] = res[l] % 10; str[l] = res[l]; } str = str.reverse().join(\"\"); // 去除结果字符串开头的0 var index = -1; for (var i = 0; i JS5 var multiply = function(num1, num2) { if (num1 == \"0\" || num2 == \"0\") return \"0\"; num1 = num1 + \"\"; num2 = num2 + \"\"; let l1 = num1.length, l2 = num2.length, store = new Array(l1 + l2 - 1).fill(0), t = 0, r = \"\"; for (let i = 0; i 0 ? t + r : r; }; JS6 const multiply = function(num1, num2) { if (!+num1 || !+num2) return \"0\"; const len1 = num1.length - 1; const len2 = num2.length - 1; const mulRes = new Array(num1.length + num2.length).fill(0); for (let i = len1; i >= 0; i--) { for (let j = len2; j >= 0; j--) { let mul = num1[i] * num2[j]; mul += mulRes[i + j + 1]; mulRes[i + j] += parseInt(mul / 10); mulRes[i + j + 1] = mul % 10; } } while (mulRes[0] === 0) { mulRes.shift(); } return mulRes.join(\"\"); }; JS7 var multiply = function(num1, num2) { if (num1 === \"0\" || num2 === \"0\") return \"0\"; var m, n, sum, over, res = []; for (m = num1.length; m--; ) { for (n = num2.length, over = 0; n--; ) { sum = num1[m] * num2[n] + over + (res[n] || 0); over = ~~(sum / 10); res[n] = sum % 10; } res.unshift(over); } return res.slice(res[0] === 0 ? 1 : 0).join(\"\"); }; "},"算法/加一.html":{"url":"算法/加一.html","title":"加一","keywords":"","body":"加一 加一 题目 标签 JS 速度快但占内存 递归解法 JS 题目 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 输入: [1,2,3] 输出: [1,2,4] 解释: 输入数组表示数字 123。 示例 2: 输入: [4,3,2,1] 输出: [4,3,2,2] 解释: 输入数组表示数字 4321。 标签 数组 JS 标签：数组遍历 这道题需要整理出来有哪几种情况，在进行处理会更舒服 末位无进位，则末位加一即可，因为末位无进位，前面也不可能产生进位，比如 45 => 46 末位有进位，在中间位置进位停止，则需要找到进位的典型标志，即为当前位 %10 后为 0，则前一位加 1，直到不为 0 为止，比如 499 => 500 末位有进位，并且一直进位到最前方导致结果多出一位，对于这种情况，需要在第 2 种情况遍历结束的基础上，进行单独处理，比如 999 => 1000 在下方的 Java 和 JavaScript 代码中，对于第三种情况，对其他位进行了赋值 0 处理，Java 比较 tricky 直接 new 数组即可，JavaScript 则使用了 ES6 语法进行赋值 时间复杂度：O(n) var plusOne = function(digits) { const len = digits.length; for (let i = len - 1; i >= 0; i--) { digits[i]++; digits[i] %= 10; if (digits[i] != 0) return digits; } digits = [...Array(len + 1)].map(_ => 0); digits[0] = 1; return digits; }; 速度快但占内存 var plusOne = function(digits) { let arr = digits.reverse(); for (let index = 0; index 递归解法 /** * 部分递归，如果当前位小于9则直接加1，否则递归调用直到到达首位递归结束 * 最坏时间复杂度O(n) ? * 最坏空间复杂度O() ? */ var recursivePlus = function(digits, i) { if (digits[i] JS 先在最后一位加一 从最后一位判断开始判断是否大于9 否,直接跳出循环 是,最后一位减10,往前一位加一 在判断是否大于9,循环 边界:第0位大于九的时候,直接在前面再一个1 var plusOne = function(digits) { let n = digits.length - 1; digits[n] += 1; while (n >= 0) { if (digits[n] > 9) { digits[n] -= 10; n = n - 1; } else { break; } if (n >= 0) { digits[n]++; } else { //第0位大于九的时候,直接在前面再一个1 digits.unshift(1); } } return digits; }; "},"算法/数组形式的整数加法.html":{"url":"算法/数组形式的整数加法.html","title":"数组形式的整数加法","keywords":"","body":"数组形式的整数加法 数组形式的整数加法 题目 标签 JS js 一个循环即可 JS3 按位相加 题目 对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。 给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。 示例 1： 输入：A = [1,2,0,0], K = 34 输出：[1,2,3,4] 解释：1200 + 34 = 1234 解释 2： 输入：A = [2,7,4], K = 181 输出：[4,5,5] 解释：274 + 181 = 455 示例 3： 输入：A = [2,1,5], K = 806 输出：[1,0,2,1] 解释：215 + 806 = 1021 示例 4： 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1 输出：[1,0,0,0,0,0,0,0,0,0,0] 解释：9999999999 + 1 = 10000000000 提示： 1 0 0 如果 A.length > 1，那么 A[0] != 0 标签 数组 JS var addToArrayForm = function(A, K) { K = K + \"\"; let arr = K.split(\"\"); arr = arr.reverse(); // 反转数组 if (A.length = 0; j--) { if (parseInt(A[j], 10) > 9 && j !== 0) { A[j] = parseInt(A[j], 10) % 10; A[j - 1] = parseInt(A[j - 1], 10) + 1; } if (parseInt(A[j], 10) > 9 && j === 0) { A[0] = parseInt(A[0], 10) % 10; A.unshift(1); } } return A; }; js 一个循环即可 var addToArrayForm = function(A, K) { if (K === 0) return A; K = String(K); // 将k转换为字符串 var rest = 0; // 记录是否需要进位 var al = A.length; var kl = K.length; var max = Math.max(al, kl); var ans = new Array(max + 1).fill(0); // 生成一个长度max + 1的数组 // A、K倒序相加，倒序填充 ans 数组 for (let i = max, j = 0, s = 0; i > 0; i--, j++) { s = (A[al - j - 1] || 0) + (+K[kl - j - 1] || 0) + rest; rest = 0; if (s > 9) { s -= 10; rest = 1; } ans[i] = s; } ans[0] += rest; if (ans[0] === 0) { ans.shift(); } return ans; }; JS3 /** * @param {number[]} A * @param {number} K * @return {number[]} */ var addToArrayForm = function(A, K) { let lenA = A.length, lenK = K.toString().length, sum = K, carry = K, num = [], len = Math.max(lenA, lenK); let AR = A.reverse(); for (let i = 0; i 按位相加 var addToArrayForm = function(A, K) { const numArr1 = A.reverse(); //A的反转形式[1,2,0,0]=>[0, 0, 2, 1] const numArr2 = K.toString() .split(\"\") .reverse() .map(x => +x); // K数字的数组反转形式 123=>[3,2, 1] const maxLength = Math.max(numArr1.length, numArr2.length); const res = []; // 结果 let carry = false; // 进位标记 for (let i = 0; i = 10; res.push(sum % 10); } if (carry) { res.push(1); } return res.reverse(); }; "},"算法/字符串相加.html":{"url":"算法/字符串相加.html","title":"字符串相加","keywords":"","body":"字符串相加 字符串相加 题目 标签 JS JS2 JS3 行波进位加法 JS4 JS5 JS6 JS7 ✨✨重点✨✨ JS8 大数相加 JS9 模拟进位 题目 给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 注意： num1 和num2 的长度都小于 5100. num1 和num2 都只包含数字 0-9. num1 和num2 都不包含任何前导零。 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。 标签 字符串 JS const addStrings = (a, b) => { a = [...a]; b = [...b]; let jw = 0; const result = []; while (a.length || b.length) { const ca = a.pop() || 0; const cb = b.pop() || 0; result.unshift((+ca + +cb + jw) % 10); if (+ca + +cb + jw >= 10) { jw = 1; } else { jw = 0; } } if (jw === 1) { result.unshift(1); } return result.join(\"\"); }; JS2 /* * @lc app=leetcode.cn id=415 lang=javascript * * [415] 字符串相加 */ /** * @param {string} num1 * @param {string} num2 * @return {string} */ var addStrings = function(num1, num2) { //这个简洁 var count = 0; var i = num1.length - 1; var j = num2.length - 1; var str = \"\"; while (i >= 0 || j >= 0 || count !== 0) { if (i >= 0) count += parseInt(num1[i--]); if (j >= 0) count += parseInt(num2[j--]); str = String(count % 10).concat(str); count = (count / 10) >> 0; } return str; //将num1与num2设置成相同长度的字符串，再逐位相加转换 /*var str = ''; var count = 0; var offset = Math.abs(num1.length-num2.length); if(num1.length > num2.length){ num2 = generateEqualsStr(num2); } if(num1.length -1;i--){ var a = 0, b = 0; if(i=10){ temp = temp - 10; count=1; }else{ count = 0; } str = String(temp).concat(str); } if(count === 1){ return '1'.concat(str); } return str;*/ }; JS3 行波进位加法 var addStrings = function(num1, num2) { let c = 0, str = \"\"; for ( let i = num1.length - 1, j = num2.length - 1; i >= 0 || j >= 0; --i, --j ) { let a = 0, b = 0; if (i >= 0) a = num1[i] | 0; if (j >= 0) b = num2[j] | 0; let n = a + b + c; str = (n % 10) + str; c = (n / 10) | 0; } return c > 0 ? c + str : str; }; JS4 var addStrings = function(num1, num2) { let len = num1.length > num2.length ? num1.length : num2.length; num1 = num1.padStart(len, 0); num2 = num2.padStart(len, 0); let carry = 0; let str = \"\"; for (let i = len - 1; i >= 0; i--) { let tem = parseInt(num1[i]) + parseInt(num2[i]) + carry; str += tem % 10; carry = parseInt(tem / 10); } if (carry) { str += carry; } return str .split(\"\") .reverse() .join(\"\"); }; JS5 var addStrings = function(num1, num2) { let arr1 = num1.split(\"\").reverse(), arr2 = num2.split(\"\").reverse(), len1 = arr1.length, len2 = arr2.length; let maxLen = len1 > len2 ? len1 : len2, result = \"\", carry = 0; for (let i = 0; i JS6 var addStrings = function(s1, s2) { var re = \"\"; if (s1.length >= s2.length) { s2 = Array(s1.length - s2.length + 1).join(0) + s2; } else { s1 = Array(s2.length - s1.length + 1).join(0) + s1; } var flag = 0; for (let i = 0; i JS7 ✨✨重点✨✨ var addStrings = function(num1, num2) { let a = num1.split(\"\"); let b = num2.split(\"\"); let c = 0; let res = \"\"; while (a.length || b.length || c) { c += ~~a.pop() + ~~b.pop(); res = (c % 10) + res; c = c > 9; } return res; }; JS8 大数相加 var addStrings = function(num1, num2) { let carry = 0; // 进位标记 let res = []; let index1 = num1.length - 1; let index2 = num2.length - 1; while (index1 >= 0 || index2 >= 0) { // index1或index2还有位可以相加 sum = (+num1[index1] || 0) + (+num2[index2] || 0) + carry; // index1 index2 可能为负数值转化为0 carry = sum >= 10 ? 1 : 0; res.push(sum % 10); index1--; index2--; } if (carry) { res.push(1); } return res.reverse().join(\"\"); }; JS9 模拟进位 /** * @param {string} num1 * @param {string} num2 * @returns {string} */ const addStrings = (num1, num2) => { let arr = []; let carry = 0; let len = num1.length > num2.length ? num1.length : num2.length; while (num1.length = 0; i--) { let sum = Number(num1[i]) + Number(num2[i]) + carry; if (sum >= 10) { arr.push(sum % 10); carry = 1; } else { carry = 0; arr.push(sum); } } return carry === 0 ? arr.reverse().join(\"\") : carry + arr.reverse().join(\"\"); }; "},"算法/通配符匹配.html":{"url":"算法/通配符匹配.html","title":"通配符匹配","keywords":"","body":"通配符匹配 通配符匹配 题目 标签 动态规划（空间优化） 题目 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。 '?' 可以匹配任何单个字符。 '*' 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。 示例 1: 输入: s = \"aa\" p = \"a\" 输出: false 解释: \"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 输入: s = \"aa\" p = \"*\" 输出: true 解释: '*' 可以匹配任意字符串。 示例 3: 输入: s = \"cb\" p = \"?a\" 输出: false 解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。 示例 4: 输入: s = \"adceb\" p = \"*a*b\" 输出: true 解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 \"dce\". 示例 5: 输入: s = \"acdcb\" p = \"a*c?b\" 输入: false 标签 字符串 动态规划 动态规划（空间优化） // JS动态规划（空间优化）版本 var isMatch = function(s, p) { let cur = new Array(s.length + 1).fill(false); cur[0] = true; for (const c of p) { if (c == \"*\") { let begin = cur.indexOf(true); if (begin == -1) { return false; } cur.fill(true, begin); } else { for (let j = s.length; j > 0; --j) { cur[j] = (c == \"?\" || c == s[j - 1]) && cur[j - 1]; } cur[0] = false; } } return cur[s.length]; }; "},"算法/跳跃游戏.html":{"url":"算法/跳跃游戏.html","title":"跳跃游戏","keywords":"","body":"跳跃游戏 跳跃游戏 题目 标签 贪心 js贪婪算法 JS 贪心 JS 题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例 1: 输入: [2,3,1,1,4] 输出: true 解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。 示例 2: 输入: [3,2,1,0,4] 输出: false 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 标签 数组 贪心算法 贪心 var canJump = function(nums) { var index = 0, nextindex, nextmax = nums[0]; while (nextmax js贪婪算法 var canJump = function(nums) { if (nums.length = nums.length - 1) { return true; } else if (Dp[i] == 0 && i JS 贪心 var canJump = function(nums) { let len = nums.length; let step = nums[0]; let lastNum = nums[0]; for (let i=1; i JS 思路： 如果不存在为 0 的数，那么肯定能到达最后一个位置 除最后一位外，如果 i 位置为 0，那么向前查找是否存在 j 位置使得 j + nums[j] > i 最后一位是否为 0 不影响结果，所以不用判断 /** * @param {number[]} nums * @return {boolean} */ var canJump = function(nums) { let len = nums.length; let pos = undefined; for (let i = len - 2; i >= 0; i--) { if (nums[i] === 0 && pos === undefined) pos = i; if (pos !== undefined && i + nums[i] > pos) pos = undefined } return pos === undefined }; "},"算法/跳跃游戏II.html":{"url":"算法/跳跃游戏II.html","title":"跳跃游戏 II","keywords":"","body":"跳跃游戏 II 跳跃游戏 II 题目 标签 贪心,跳到下一次可以到达最远的位置 题目 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例: 输入: [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明: 假设你总是可以到达数组的最后一个位置。 标签 数组 贪心算法 贪心,跳到下一次可以到达最远的位置 var jump = function(nums) { if (nums.length "},"算法/旋转图像.html":{"url":"算法/旋转图像.html","title":"旋转图像","keywords":"","body":"旋转图像 旋转图像 题目 转置加翻转 JS JS 题目 给定一个 n × n 的二维矩阵表示一个图像。 将图像顺时针旋转 90 度。 说明： 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。 示例 1: 给定 matrix = [ [1,2,3], [4,5,6], [7,8,9] ], 原地旋转输入矩阵，使其变为: [ [7,4,1], [8,5,2], [9,6,3] ] 示例 2: 给定 matrix = [ [ 5, 1, 9,11], [ 2, 4, 8,10], [13, 3, 6, 7], [15,14,12,16] ], 原地旋转输入矩阵，使其变为: [ [15,13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7,10,11] ] 转置加翻转 最直接的想法是先转置矩阵，然后翻转每一行。这个简单的方法已经能达到最优的时间复杂度O(N²) 时间复杂度：O(N²) 空间复杂度：O(1) 由于旋转操作是 就地 完成的。 var rotate = function(matrix) { let n = matrix.length; // transpose matrix for (let i = 0; i JS 时间复杂度：O(N²)是两重循环的复杂度。 空间复杂度：O(1) 由于旋转操作是 就地 完成的。/** * @param {number[][]} matrix * @return {void} Do not return anything, modify matrix in-place instead. */ var rotate = function(matrix) { let len = matrix[0].length, d = Math.floor(len / 2); while (d--) { let n = len - 2 * d, i = n - 1; while (i--) { let temp = matrix[d][i + d], x = n - 1 + d; matrix[d][i + d] = matrix[x - i][d]; matrix[x - i][d] = matrix[x][x - i]; matrix[x][x - i] = matrix[i + d][x]; matrix[i + d][x] = temp; } } }; JS 主要规律实际上是(x, y) -> (j, n - i - 1) 的循环替换，循环 4次; 实现方法为双层循环，最外层循环的次数为 floor(n / 2)，第二层起始点为外层的值，终止条件为 大于等于(n - i -1) /** * @param {number[][]} matrix * @return {void} Do not return anything, modify matrix in-place instead. */ var rotate = function(matrix) { let len = matrix.length; for (let i = 0; i "},"算法/字母异位词分组.html":{"url":"算法/字母异位词分组.html","title":"字母异位词分组","keywords":"","body":"字母异位词分组 题目 标签 JS JS2 Object.values JS3 Map get set JS4 hash+排序 JS5 indexOf JS 素数 charCodeAt 题目 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 输入: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"], 输出: [ [\"ate\",\"eat\",\"tea\"], [\"nat\",\"tan\"], [\"bat\"] ] 说明： 所有输入均为小写字母。 不考虑答案输出的顺序。 标签 哈希表 字符串 素数算法 JS var groupAnagrams = function(strs) { const hash = {}; const res = []; for (let i = 0; i JS2 Object.values /** * @param {string[]} strs * @return {string[][]} */ var groupAnagrams = function(strs) { let hash = {} for(let i = 0 ; i JS3 Map get set 执行用时 : 212 ms , 在所有 JavaScript 提交中击败了 90.00% 的用户 var groupAnagrams = function(strs) { let arr = new Map(); for (let i = 0; i JS4 hash+排序 var strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]; var groupAnagrams = function(strs) { let hash = new Map(); for (let i = 0; i v[1]) }; groupAnagrams(strs) JS5 indexOf var groupAnagrams = function(strs) { var l = [], res = []; for (var i = 0; i JS 素数 charCodeAt 算术基本定理，又称为正整数的唯一分解定理，即：每个大于1的自然数，要么本身就是质数，要么可以写为2个以上的质数的积，而且这些质因子按大小排列之后，写法仅有一种方式。 利用这个，我们把每个字符串都映射到一个正数上。 用一个数组存储质数 prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103}。 然后每个字符串的字符减去 ' a ' ，然后取到 prime 中对应的质数。把它们累乘。 例如 abc ，就对应 'a' - 'a'， 'b' - 'a'， 'c' - 'a'，即 0, 1, 2，也就是对应素数 2 3 5，然后相乘 2 3 5 = 30，就把 \"abc\" 映射到了 30。 对每一个字母赋一个素数，用这个代表这个单词的每一个字母的素数做乘积，如果乘积一样则认为是异位词。有一点也比较有趣，在这样解法下，哈希表表现比红黑树表现好很多，可以认为是对double计算散列是容易的，因此哈希表的优势较大。 这就可以用大家所说的素数法，将单词中每个字母对应 的素数相乘，就可以得到了该单词的key值，再将key值存入map中。 该map map的键值（double）是用来保存每个单词相对应的值，而int的部分是用来表示该单词在所要返回数组中的索引值。 素数表 int prime[] = { 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101 }; 输入【\"eat\"， \"tea\"， \"nat\"】 先将\"eat\"的值计算出来， 结果是2002，由于map中没有键值为2002的信息，我们先创建一个vector v, 并将 \"eat\"放入到v中，再将v放入res中，这时候v的索引值是0，因为它是第一个被放进去的， map键值为2002的地方放入值0. 再然后计算\"tea\", 它的结果也是2002，map中有键值为2002的信息，且该信息的值为0， 我们可以直接在res索引0 (也就是res[0]) 的位置放入\"tea\". 最后计算\"nat\", 该结果为6106， map中没有键值为6106的信息，我们再创建一个vector v, 并将 \"nat\"放入到v中，再将v放入res中，这时候res中本来存在一个元素，所以该v索引为1， map键值为6106的地方放入值1. var groupAnagrams = function(strs) { let filter = function(number){ for(var i = 2 ,max = Math.ceil(number/2)+1;i{ return sum * [3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103 ][s.charCodeAt(0)-97] },1) result[hash] ? result[hash].push(str) : result[hash] = [str] } return Object.values(result) }; var strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]; groupAnagrams(strs) "},"算法/有效的字母异位词.html":{"url":"算法/有效的字母异位词.html","title":"有效的字母异位词","keywords":"","body":"有效的字母异位词 有效的字母异位词 题目 标签 JS 一行代码解决 JS3 JS4 题目 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 输入: s = \"anagram\", t = \"nagaram\" 输出: true 示例 2: 输入: s = \"rat\", t = \"car\" 输出: false 说明:你可以假设字符串只包含小写字母。 进阶:如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 标签 排序 哈希表 JS /** * @param {string} s * @param {string} t * @return {boolean} */ var isAnagram = function(s, t) { let i = s.length, j = t.length, k = 26; letters = Array(52).fill(0); while (i--) { letters[s.charCodeAt(i) - 97]++; } while (j--) { letters[t.charCodeAt(j) - 71]++; } while (k--) { if (letters[k] !== letters[k + 26]) return false; } return true; }; 一行代码解决 var isAnagram = function(s, t) { return s.split('').sort().join('')==t.split('').sort().join('') }; JS3 var isAnagram = function (s, t) { if (s.length != t.length) return false let sHash = handle(s) let tHash = handle(t) return compare(sHash, tHash) }; function handle(str) { let hash = new Map() for (let i = 0; i JS4 /** * @param {string} s * @param {string} t * @return {boolean} */ var isAnagram = function(s, t) { if (s.length !== t.length) { return false; } const codeMap = {}; for (let i = 0; i "},"算法/找到字符串中所有字母异位词.html":{"url":"算法/找到字符串中所有字母异位词.html","title":"找到字符串中所有字母异位词","keywords":"","body":"找到字符串中所有字母异位词 找到字符串中所有字母异位词 题目 标签 JS JS2 参考大佬写法 JS3 一次遍历记录hash，每次都比较下（记得清空已经遍历过的～） JS4 JS5 超出时间限制，用的双指针 JS6 滑动窗口 题目 给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。 字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。 说明： 字母异位词指字母相同，但排列不同的字符串。 不考虑答案输出的顺序。 示例 1: 输入: s: \"cbaebabacd\" p: \"abc\" 输出: [0, 6] 解释: 起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的字母异位词。 起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的字母异位词。 示例 2: 输入: s: \"abab\" p: \"ab\" 输出: [0, 1, 2] 解释: 起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。 起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的字母异位词。 起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的字母异位词。 标签 哈希表 双指针 滑动窗口 JS var findAnagrams = function(s, p) { var obj={q:0,w:0,e:0,r:0,t:0,y:0,u:0,i:0,o:0,p:0,a:0,s:0,d:0,f:0, g:0,h:0,j:0,k:0,l:0,z:0,x:0,c:0,v:0,b:0,n:0,m:0}, res=[]; for (var i = 0; i JS2 参考大佬写法 /** * @param {string} s * @param {string} p * @return {number[]} */ var findAnagrams = function(s, p) { //参考大佬写法 var map = new Map(); var res = []; var flag = 0; [...\"abcdefghijklmnopqrstuvwxyz\"].forEach((char, i) => map.set(char, 3 ** i)); for (var i = 0; i JS3 一次遍历记录hash，每次都比较下（记得清空已经遍历过的～） var isEqual = function(a, b) { var r = true; for (var k in a) { if (a[k] !== b[k]) { r = false; break; } } return r; }; var findAnagrams = function(s, p) { var tl = p.length; var result = []; let maps = new Array(26); let mapp = new Array(26); for (var p1 of p) { var key = p1.charCodeAt(0) - 97; mapp[key] ? (mapp[key] += 1) : (mapp[key] = 1); } for (var i in s) { var key1 = s[i].charCodeAt(0) - 97; maps[key1] ? (maps[key1] += 1) : (maps[key1] = 1); if (i >= tl) { maps[s[i - tl].charCodeAt(0) - 97] -= 1; } if (isEqual(mapp, maps)) { result.push(i - tl + 1); } } return result; }; JS4 /** * @param {string} s * @param {string} p * @return {number[]} */ var findAnagrams = function(s, p) { let pMap = new Map(); let sMap = new Map(); let start = 0; let end = p.length - 1; let result = []; let newS = s.slice(start, end + 1); const isEctopicWord = (a, b) => { let isEctopicWord = true; a.forEach((value, key) => { if (!b.has(key) && isEctopicWord) { isEctopicWord = false; } else { if (value !== b.get(key) && isEctopicWord) { isEctopicWord = false; } } }); return isEctopicWord; }; // 初始化pMap for (let i = 0; i 1) { sMap.set(s[start - 1], sMap.get(s[start - 1]) - 1); } else { sMap.delete(s[start - 1]); } // 结束位置加1 if (!sMap.has(s[end])) { sMap.set(s[end], 1); } else { sMap.set(s[end], sMap.get(s[end]) + 1); } } return result; }; JS5 超出时间限制，用的双指针 /** * @param {string} s * @param {string} p * @return {number[]} */ var findAnagrams = function(s, p) { // 我的初版, 在数据量特别的大的情况下会超出时间限制 const pLen = p.length; const pArr = p.split(\"\"); const pSort = pArr.sort().join(\"\"); const sLen = s.length; let start = 0; let end = pLen - 1; let result = []; while (end JS6 滑动窗口 var findAnagrams = function(str, pattern) { const map = {}; for (const char of pattern) { map[char] = ~~map[char] + 1; } const currentMap = Object.keys(map).reduce( (pre, key) => Object.assign(pre, { [key]: 0 }), {} ); const result = []; for (const [index, char] of [...str].entries()) { if (index "},"算法/字符串的排列.html":{"url":"算法/字符串的排列.html","title":"字符串的排列","keywords":"","body":"字符串的排列 字符串的排列 题目 标签 JS 滑动窗口 JS2 JS3 JS4 直接在s2中截取s1长度，排序后比较是否相等 JS5 通过双指针和hash解决 JS6 题目 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。 换句话说，第一个字符串的排列之一是第二个字符串的子串。 示例1: 输入: s1 = \"ab\" s2 = \"eidbaooo\" 输出: True 解释: s2 包含 s1 的排列之一 (\"ba\"). 示例2: 输入: s1= \"ab\" s2 = \"eidboaoo\" 输出: False 注意： 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间 标签 双指针 滑动窗口 JS 滑动窗口 const checkInclusion = function(s1, s2) { const l1 = s1.length; const l2 = s2.length; const v1 = new Vector(); const v2 = new Vector(); for (let i = 0; i = l1) { v2.delete(s2[j - l1]); } if (v1.equals(v2)) return true; } return false; }; class Vector { constructor() { this.map = Array.from(Array(26)).map(() => 0); } add(char) { this.map[char.charCodeAt() - 97]++; } delete(char) { this.map[char.charCodeAt() - 97]--; } equals(vector) { return this.map.toString() === vector.map.toString(); } } JS2 /** * @param {string} s1 * @param {string} s2 * @return {boolean} */ const checkInclusion = function(s1, s2) { if (!s1 || !s2) return \"\"; const line1 = new Array(26); const line2 = new Array(26); line1.fill(0); line2.fill(0); const aCharCode = \"a\".charCodeAt(); for (let i = 0; i = s1.length) { --line2[s2[j - s1.length].charCodeAt() - aCharCode]; } ++line2[s2[j].charCodeAt() - aCharCode]; if (line1.toString() === line2.toString()) { return true; } } return false; }; JS3 var checkInclusion = function(s1, s2) { // var map = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0] var map = new Array(26).fill(0), queue = [], l = s1.length, tmp; s1.split('').forEach(function(s) { map[s.charCodeAt() - 97]++; }); for (var i = 0; i -1) { queue.push(s); if (map[mapS] > 0) { map[mapS]--; if (l === queue.length) return true; } else { while (queue[0] !== s) { tmp = queue.shift(); map[tmp.charCodeAt() - 97]++; } queue.shift(); } } else { while (queue.length > 0) { tmp = queue.shift(); map[tmp.charCodeAt() - 97]++; } } } return false; }; JS4 直接在s2中截取s1长度，排序后比较是否相等 var checkInclusion = function(s1, s2) { let len1 = s1.length; let len2 = s2.length; let ss1 = s1.split(\"\").sort().join(\"\"); if (len1 == 0 || len2 = 0) { if (ss1 == s2.substr(i,len1).split(\"\").sort().join(\"\")) { return true } } } return false }; JS5 通过双指针和hash解决 var checkInclusion = function(s1, s2) { var len = s1.length, index = -1, hash = {}, count = len; setHash(); function setHash() { hash = {}; for (var i = 0; i = 1) { hash[letter]--; count--; if (index == -1) { index = i; } if (count == 0) { return true; } } else { // console.log(index, i, hash) // 某个字母多个一个 for (var j = index; j JS6 var checkInclusion = function(s1, s2) { if (s1.length > s2.length) { return false; } let diff = Array(26).fill(0); for (let i = 0; i val === 0)) { return true; } diff[s2[i - s1.length].charCodeAt() - 97]++; diff[s2[i].charCodeAt() - 97]--; } return diff.every(val => val === 0); }; "},"算法/Pow[x,n].html":{"url":"算法/Pow[x,n].html","title":"Pow(x, n)","keywords":"","body":"Pow(x, n) 题目 标签 JS 分治，递归 JS2 JS3 二进制 JS4 JS5 题目 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 输入: 2.00000, 10 输出: 1024.00000 示例 2: 输入: 2.10000, 3 输出: 9.26100 示例 3: 输入: 2.00000, -2 输出: 0.25000 解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 标签 数学 二分查找 JS 分治，递归 /** * @param {number} x * @param {number} n * @return {number} */ var myPow = function(x, n) { if(x === 0) return 0; if (n JS2 /** * @param {number} x * @param {number} n * @return {number} */ var myPow = function(x, n) { if (n === 1) { return x; } if (n === 0) { return 1; } var sign = 1; if (n 0) { if (n >= i) { result *= tmps[i]; n -= i; } i = parseInt(i/2); } return sign === 1 ? result : 1/result; }; JS3 二进制 /** * @param {number} x * @param {number} n * @return {number} */ var myPow = function(x, n) { var res=[x],nabs=Math.abs(n),result=1; var arr=nabs.toString(2).split('').reverse(); for(var i=1; i0){ return result.toFixed(5); } if(n JS4 /** * @param {number} x * @param {number} n * @return {number} */ const myPow = function(x, n) { if (x === 0) return 0; if (n === 0) return 1; if (n === 1) return x; let isOverZero = n >= 0; n = Math.abs(n); let res; if (n % 2 !== 0) { const v1 = myPow(x, (n - 1)/2); res = x * v1 * v1; } else { const v2 = myPow(x, n/2); res = v2 * v2; } if (!isOverZero) { return 1 / res; } return res; }; JS5 // /** // * @param {number} x // * @param {number} n // * @return {number} // */ // var myPow = function(x, n) { // if (n === 0) return 1; // if (n "},"算法/超级次方.html":{"url":"算法/超级次方.html","title":"超级次方","keywords":"","body":"超级次方 题目 标签 JS JS 题目 你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。 示例 1: 输入: a = 2, b = [3] 输出: 8 示例 2: 输入: a = 2, b = [1,0] 输出: 1024 标签 数学 JS 模运算公式 (a + b) % p = (a % p + b % p) % p (a - b) % p = (a % p - b % p) % p (a * b) % p = (a % p * b % p) % p a ^ b % p = ((a % p)^b) % p 例如： a=2， b=[3,1]=3*10+1 因为b的长度可能非常大，所以不可能把b求出来，再算 但b是十进制的 所以，b[i]=b[i]*10+前面的值 b[i]%m = (a^b[i]%m*a^(10*i)%m)%m 因为i可能非常大 所以 a^(10*i) 不可能一次算出来 但可以每次循环时 累乘一次 a^10 这样即使i再大也没有关系了 JS a ^ b % c = (a % c) ^ b % c = ((a % c) ^ (b - t) * (a % c) ^ t) % c 令 t = ~~ (b / 2)：当b为5时，t=2，b-t=3； 当 t = 1时，(a % c) ^ t = a % c; 当 t = 0时，(a % c) ^ t = 1; "},"算法/x的平方根.html":{"url":"算法/x的平方根.html","title":"x的平方根","keywords":"","body":"x的平方根 题目 标签 JS1 JS2 JS3 二分法 JS4 传说中的牛顿迭代法 JS5 牛顿迭代法 JS6 题目 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 输入: 4 输出: 2 示例 2: 输入: 8 输出: 2 说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 标签 数学 二分查找 牛顿迭代法 JS1 var mySqrt = function(x) { if (x === 0 || x === 1) return x let left = 1 let right = x - 1 let m let target let res while(left m) { left = m + 1 res = m } } return Math.floor(res) }; JS2 var mySqrt = function(x) { if (x x) { return i - 1 } } } var mySqrt = function(x) { result = Math.sqrt(x) result = parseInt(result) return result }; JS3 二分法 var mySqrt = function(x) { if(x == 0 || x == 1) return x; var l = 0; var r = x; while (l > 1; if(mid == x/mid) return mid; if(x/mid > mid) l = mid+1; else r= mid-1; } return r; }; JS4 传说中的牛顿迭代法 由 X^2 + C = 0 ==> X = (X + X/C) / 2 不断迭代推出 X var mySqrt = function(x) { if(x == 0 || x == 1) return x; long res = x; while(res > (x/res)){ res = (res + x/res) / 2; } return (int)res; }; JS5 牛顿迭代法 var mySqrt = function(x) { let m = x; let r = x; while (true) { if (m * m === x) { return m; } else if (m * m x) { r = m; if (Math.floor(r) * Math.floor(r) JS6 /** * @param {number} x * @return {number} */ var mySqrt = function(x) { if(x x / r) { r = Math.floor((r + x / r) / 2) } return parseInt(r) }; "},"算法/有效的完全平方数.html":{"url":"算法/有效的完全平方数.html","title":"有效的完全平方数","keywords":"","body":"有效的完全平方数 题目 标签 JS1 JS2 二分查找 JS3 二分 JS4 JS5 JS6 正常判断 JS7 牛顿逼近法 牛顿迭代法 JS8 题目 给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。 说明：不要使用任何内置的库函数，如 sqrt。 示例 1： 输入：16 输出：True 示例 2： 输入：14 输出：False 标签 数学 二分查找 JS1 var isPerfectSquare = function(num) { return (Math.sqrt(num) % 1 == 0) }; JS2 二分查找 var isPerfectSquare = function(num) { var left =1 ,right=num; while(leftnum) right = mid-1; else left=mid+1; } return false }; JS3 二分 var isPerfectSquare = function(num) { var start=0,end=num,middle=parseInt((start+end)/2); while(end>start){ if(middle*middle>num){ end=middle-1; }else{ if(middle*middle JS4 var isPerfectSquare = function (num) { let i = 1; let sum = i; // 一个完全平方数可表示为连续奇数和 while (sum JS5 /** * @param {number} num * @return {boolean} */ var isPerfectSquare = function(num) { if(num === 1) return num; for(var i=1;i>0; return Math.pow(s, 2) === num;*/ }; JS6 正常判断 /** * @param {number} num * @return {boolean} */ /* var isPerfectSquare = function(num) { let sum = 1; let count = 1; while(sum JS7 牛顿逼近法 牛顿迭代法 var isPerfectSquare = function(num) { let r = num while (r*r > num) { r = ~~(r+num/r)/2 } return r*r === num }; JS8 var isPerfectSquare = function(num) { let sum=0; for(let i=1;sum "},"算法/平方数之和.html":{"url":"算法/平方数之和.html","title":"平方数之和","keywords":"","body":"平方数之和 题目 标签 JS1 暴力破解 JS2 JS3 题目 给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c。 示例1: 输入: 5 输出: True 解释: 1 * 1 + 2 * 2 = 5 示例2: 输入: 3 输出: False 标签 数学 JS1 暴力破解 var judgeSquareSum = function(c) { if(c JS2 /** * @param {number} c * @return {boolean} */ var judgeSquareSum = function(c) { var a = Math.ceil(Math.sqrt(c)); var b = 0; while(a >= b){ var temp = a**2 + b**2; if(temp === c) return true; if(temp c) a--; } return false; }; JS3 var judgeSquareSum = function(c) { for(let i=parseInt(Math.sqrt(c));i>-1;i--){ if(Math.sqrt(c-(i*i))%1==0){ return true; } } return false; }; "},"算法/最大子序和.html":{"url":"算法/最大子序和.html","title":"最大子序和","keywords":"","body":"有效的平方数 题目 标签 JS1 动态规划 JS2 动态规划js解决 JS3 动态规划 JS4 动态规划 JS5 枚举 计算出所有可能，找到最大值 JS6 题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 标签 数组 分治算法 动态规划 JS1 动态规划 思路 这道题用动态规划的思路并不难解决，比较难的是后文提出的用分治法求解，但由于其不是最优解法，所以先不列出来 动态规划的是首先对数组进行遍历，当前最大连续子序列和为 sum，结果为 ans 如果 sum > 0，则说明 sum 对结果有增益效果，则 sum 保留并加上当前遍历数字 如果 sum 每次比较 sum 和 ans的大小，将最大值置为ans，遍历结束返回结果 时间复杂度：O(n) /** * @param {number[]} nums * @return {number} */ var maxSubArray = function(nums) { let ans = nums[0]; let sum = 0; for(const num of nums) { if(sum > 0) { sum += num; } else { sum = num; } ans = Math.max(ans, sum); } return ans; }; JS2 动态规划js解决 执行用时 : 64 ms, 在Maximum Subarray的JavaScript提交中击败了100.00% 的用户 val代表当前子序列的值，每次循环val += nums[pos]，即将子序列长度加一，求出这个子序列的值，若果val > max，则将val值赋给max，当前子序列是目前有最大和的子序列，如果此时val let maxSubArray = function(nums) { let max = -1 JS3 动态规划 var maxSubArray = function(nums) { let len = nums.length; if(len === 1){ return nums[0] }else if(len === 2){ return Math.max(nums[1],nums[0]+nums[1],nums[0]) }else{ let result = [ nums[0], Math.max(nums[1],nums[0]+nums[1]) ]; for(let i = 2; i JS4 动态规划 var maxSubArray = function(nums) { let dp = [] dp[0] = nums[0] for (let i = 1; i JS5 枚举 计算出所有可能，找到最大值 var maxSubArray = function(nums) { let max = nums[0] ; let l = nums.length; let total = 0; for(let i = 0 ; i max){ max = total; } } total = 0 } return max }; JS6 var maxSubArray = function(nums) { let res = nums[0]; let sum = 0; for(let i=0;isum+nums[i]?nums[i]:sum+nums[i]; res = res > sum ? res : sum; } return res; }; "},"算法/买卖股票的最佳时机.html":{"url":"算法/买卖股票的最佳时机.html","title":"买卖股票的最佳时机","keywords":"","body":"买卖股票的最佳时机 题目 标签 JS1 JS2 JS3 使用一个变量记录当前最小值 JS4 dp算法 JS5 题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。 注意你不能在买入股票前卖出股票。 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入， 在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 标签 数组 动态规划 JS1 /** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { let ans = 0; let lowestPrice = prices[0]; for (let i = 1; i JS2 第一次解的时候暴力遍历解的，第二次解只循环了一遍，因为只需要交易一次，所以最大利润一定是最大值减去最小值，循环的时候同时找最小值和最大利润。 var minPrice = prices[0]; var maxProfit = 0; for(var i = 1 ; i prices[i]) { minPrice = prices[i]; } else if (prices[i] - minPrice > maxProfit) { maxProfit = prices[i] - minPrice; } } return maxProfit; } JS3 使用一个变量记录当前最小值 var maxProfit = function(prices) { if(prices.length JS4 dp算法 var maxProfit = function(prices) { let dp=[],minestPrice; if(prices.length prices[i]) minestPrice=prices[i]; dp[i] = Math.max(dp[i-1],prices[i]-minestPrice) } return dp[prices.length - 1]; }; JS5 JavaScript 解法思路如下: 用当前位置的值, 减去前面所有数组的最小值 在求最小值的时候 做了优化处理 用minBefore 对象去存储了 前面n 的最小值 最后执行结果 执行用时 : 96 ms, 在Best Time to Buy and Sell Stock的JavaScript提交中击败了96.85% 的用户 内存消耗 : 35.5 MB, 在Best Time to Buy and Sell Stock的JavaScript提交中击败了30.43% 的用户 var maxProfit = function (prices) { if (prices.length "},"算法/买卖股票的最佳时机II.html":{"url":"算法/买卖股票的最佳时机II.html","title":"买卖股票的最佳时机 II","keywords":"","body":"买卖股票的最佳时机 II 买卖股票的最佳时机 II 题目 标签 JS1 贪心算法 JS2 滑动窗口 JS3 JS4 双指针 题目 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 标签 数组 贪心算法 滑动窗口 双指针 JS1 贪心算法 贪心算法，只要当天的比昨天的价格高就可以选择在当天卖出（同一天可以卖出在昨天的再买入今天的） 思路 只要股票价格上涨，上涨的部分就是我的利润，可以理解为上涨期间第一天买入，然后一直持有到上涨最后一天即下跌前一天再卖出 只要股票价格下跌，那我肯定在下跌前一天卖了，而且下跌期间永远不会买入 现实中不存在这样的操作 /** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { let profit = 0; for (let i = 0; i prices[i]) { profit += prices[i + 1] - prices[i]; } } return profit; }; JS2 滑动窗口 滑动窗口法确实慢了 1ms， 主要题目没说明白当天可以卖出去之前的然后再买入当天的 /** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { // 数组为空特例！！ 还有这种没意义的样例！！ if (prices.length == 0) return 0; let i = 0, j = 1, ans = 0; while (j 0) ans += prices[j - 1] - prices[i]; return ans; }; JS3 思路在于当日(i)价格下滑，则取昨日(i-1)卖出的价格差为此次获利。需要注意是在结束的时候需要卖出依旧持有的股票，计算价差获利。 var maxProfit = function(prices) { if (prices.length JS4 双指针 双指针,比最优解麻烦很多,想复杂了. 不过也是时间复杂度O(N),空间复杂度O(3) var maxProfit = function(prices) { if (prices == null) { return -1; } if (prices.length prices[point2 - 1]) { //不会继续上涨 if (prices[point2 + 1] prices[point1] ? prices[point2] - prices[point1] : 0; point1 = point2; } } //当前价格在下跌 if (prices[point2] = prices[point2]) { //买入 point1 = point2; } } point2++; } //最后一个节点 result += prices[point2] > prices[point1] ? prices[point2] - prices[point1] : 0; return result; }; "},"算法/买卖股票的最佳时机III.html":{"url":"算法/买卖股票的最佳时机III.html","title":"买卖股票的最佳时机 III","keywords":"","body":"买卖股票的最佳时机 III 买卖股票的最佳时机 III 题目 标签 JS DP 题目 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [3,3,5,0,0,3,1,4] 输出: 6 解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2: 输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3: 输入: [7,6,4,3,1] 输出: 0 解释: 在这个情况下, 没有交易完成, 所以最大利润为 0。 标签 数组 动态规划 JS DP 这个dp分成四种情况， 使用数组dp1来保存经过一次、两次卖出后能够获得的最大收益，使用数组dp2来保存经过一次、两次购买后能获得的最大收益，递归方程如下: dp2[0][i]=max(-prices[i], i-1>=0?dp2[0][i-1]:-Infinity) ——在第i天第一次购买股票能够获得的最大收益（此时肯定都是负数） dp1[1][i]=max(dp2[0][i-1]+prices[i],dp1[1][i-1])——在第i天第一次卖出股票能够获得的最大收益（max的两个参数分别代表卖出/不卖出能够获得的收益） dp2[1][i]=max(dp1[1][i-1]-prices[i],dp2[1][i-1])——在第i天第二次购买股票能够获得的最大收益。 dp1[2][i]=max(dp2[1][i-1]+prices[i],dp1[2][i-1])——在第i天第二次卖出股票能够获得的最大收益。 /** * @param {number[]} prices * @return {number} */ var maxProfit = function(prices) { if (prices.length === 0) { return 0; } const dp1 = new Array(3).fill(1).map(_ => new Array(prices.length).fill(0)); const dp2 = new Array(2).fill(1).map(_ => new Array(prices.length).fill(-Infinity)); for (let i = 0; i = 0 ? dp2[0][i - 1] : -Infinity); if (i >= 1) { dp1[1][i] = Math.max(dp2[0][i - 1] + prices[i], dp1[1][i - 1]); } if (i >= 2) { dp2[1][i] = Math.max(dp1[1][i - 1] - prices[i], dp2[1][i - 1]); } if (i >= 3) { dp1[2][i] = Math.max(dp2[1][i - 1] + prices[i], dp1[2][i - 1]); } } // console.log(dp1,dp2); return Math.max.apply(null, dp1[2].concat(dp1[1])); }; "},"算法/买卖股票的最佳时机IV.html":{"url":"算法/买卖股票的最佳时机IV.html","title":"买卖股票的最佳时机 IV","keywords":"","body":"买卖股票的最佳时机 IV 买卖股票的最佳时机 IV 题目 标签 JS1 题目 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。 注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: [2,4,1], k = 2 输出: 2 解释: 在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2: 输入: [3,2,6,5,0,3], k = 2 输出: 7 解释: 在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 标签 动态规划 JS1 /** * @param {number} k * @param {number[]} prices * @return {number} */ var maxProfit = function(k, prices) { if (!k) return 0; // 相当于不限次数，能赚钱的都加上 if (k >= prices.length - 1) { let max = 0; for (let i = 1; i 0) max += v; } return max; } // 限制次数 let nBuyNSell = new Array(k).fill(0); let nBuy = new Array(k).fill(Number.POSITIVE_INFINITY); for (let i = 0; i "},"算法/最佳买卖股票时机含冷冻期.html":{"url":"算法/最佳买卖股票时机含冷冻期.html","title":"最佳买卖股票时机含冷冻期","keywords":"","body":"最佳买卖股票时机含冷冻期 最佳买卖股票时机含冷冻期 题目 标签 JS1 JS2 动态规划 题目 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​ 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 输入: [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 标签 动态规划 JS1 var maxProfit = function(prices) { if (prices.length == 0) return 0; var mr = [-prices[0]], //mr[i]表示最后一次操作为买入的最大收益 mc = [0], //卖出 ld = [0]; //冷冻 for (var i = 1; i JS2 动态规划 /** * @param {number[]} prices * @return {number} * 动态规划：dp[i]表示在第i天(0~i)所能获得的最大利润，第i天的状态由前一天是买入还是卖出还是冷冻决定 * (1):前一天卖出，i处于冷冻期：dp[i] = dp[i-1] * (2):某天前买入，i天卖出，dp[i] = findMaxOut(i) * (3):前一天冷冻期，今天买入：dp[i] = dp[i-1] * 状态转移方程式：dp[n] = Math.max(dp[i - 1], findMaxOut(i)) * 两个解法，第一个不是动态规划的动态规划。。O(n^2)，第二种 O(n) */ var maxProfit = function(prices) { let n = prices.length; let dp = new Array(n).fill(0); dp[0] = 0; dp[1] = prices[0] > prices[1] ? 0 : prices[1] - prices[0]; for (let i = 2; i prices[i]) { res = Math.max(res, dp[i - 2] + prices[index] - prices[i]); } } return res; } }; var maxProfit = function(prices) { if (!prices || prices.length "},"算法/买卖股票的最佳时机含手续费.html":{"url":"算法/买卖股票的最佳时机含手续费.html","title":"买卖股票的最佳时机含手续费","keywords":"","body":"买卖股票的最佳时机含手续费 买卖股票的最佳时机含手续费 题目 标签 JS1 DP JS2 贪心算法 JS3 动态规划 题目 给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 示例 1: 输入: prices = [1, 3, 2, 8, 4, 9], fee = 2 输出: 8 解释: 能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8. 注意: 0 . 0 . 0 . 标签 贪心算法 数组 动态规划 JS1 DP var maxProfit = function(prices, fee) { var dp1 = [], //dp1[i]表示i天之前最后操作为买的最大利益 dp2 = []; ////dp2[i]表示i天之前最后操作为卖的最大利益 dp1[0] = -prices[0]; dp2[0] = 0; for (var i = 1; i JS2 贪心算法 var maxProfit = function(prices, fee) { let n = prices.length; if (n min + fee) { //将prices[i]改为min的形式的推理步骤 //gain = prices[next]-prices[i] //gain = prices[next]-(fee+min) //=> prices[i]=fee+min //=> min = prices[i]-fee result += prices[i] - fee - min; min = prices[i] - fee; } } return result; }; JS3 动态规划 var maxProfit = function(prices, fee) { let n = prices.length; if (n "},"算法/一个通用方法团灭6道股票问题.html":{"url":"算法/一个通用方法团灭6道股票问题.html","title":"一个通用方法团灭 6 道股票问题","keywords":"","body":"一个通用方法团灭 6 道股票问题 一个通用方法团灭 6 道股票问题 一、穷举框架 二、状态转移框架 三、秒杀题目 第一题，k = 1 第二题，k = +infinity 第三题，k = +infinity with cooldown 第四题，k = +infinity with fee 第五题，k = 2 第六题，k = any integer 四、最后总结 买卖股票的最佳时机 买卖股票的最佳时机 II 买卖股票的最佳时机 III 买卖股票的最佳时机 IV 最佳买卖股票时机含冷冻期 买卖股票的最佳时机含手续费 很多读者抱怨股票系列问题奇技淫巧太多，如果面试真的遇到这类问题，基本不会想到那些巧妙的办法，怎么办？所以本文拒绝奇技淫巧，而是稳扎稳打，只用一种通用方法解决所用问题，以不变应万变。 这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。 先随便抽出一道题，看看别人的解法： int maxProfit(vector& prices) { if(prices.empty()) return 0; int s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN; for(int i=1;i 能看懂吧？会做了吗？不可能的，你看不懂，这才正常。就算你勉强看懂了，下一个问题你还是做不出来。为什么别人能写出这么诡异却又高效的解法呢？因为这类问题是有框架的，但是人家不会告诉你的，因为一旦告诉你，你五分钟就学会了，该算法题就不再神秘，变得不堪一击了。 本文就来告诉你这个框架，然后带着你一道一道秒杀。 这 6 道股票买卖问题是有共性的，我们通过对第四题（限制最大交易次数为 k）的分析一道一道解决。因为第四题是一个最泛化的形式，其他的问题都是这个形式的简化。 第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。 一、穷举框架 首先，还是一样的思路：如何穷举？这里的穷举思路和上篇文章递归的思想不太一样。 递归其实是符合我们思考的逻辑的，一步步推进，遇到无法解决的就丢给递归，一不小心就做出来了，可读性还很好。缺点就是一旦出错，你也不容易找到错误出现的原因。比如上篇文章的递归解法，肯定还有计算冗余，但确实不容易找到。 而这里，我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。 for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 择优(选择1，选择2...) 比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k > 0 的前提下操作。 很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合： dp[i][k][0 or 1] 0 而且我们可以用自然语言描述出每一个状态的含义，比如说 dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有着股票，至今最多进行 2 次交易。再比如 dp[2][3][0] 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？ 我们想求的最终答案是 dp[n - 1][K][0]，即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 dp[n - 1][K][1]？因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。 记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。 二、状态转移框架 现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。 通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程： dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) max( 选择 rest , 选择 sell ) 解释：今天我没有持有股票，有两种可能： 要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有； 要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。 dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) max( 选择 rest , 选择 buy ) 解释：今天我持有着股票，有两种可能： 要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票； 要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。 这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。 现在，我们已经完成了动态规划中最困难的一步：状态转移方程。如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。不过还差最后一点点，就是定义 base case，即最简单的情况。 dp[-1][k][0] = 0 解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。 dp[-1][k][1] = -infinity 解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。 dp[i][0][0] = 0 解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。 dp[i][0][1] = -infinity 解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。 把上面的状态转移方程总结一下： base case： dp[-1][k][0] = dp[i][0][0] = 0 dp[-1][k][1] = dp[i][0][1] = -infinity 状态转移方程： dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) 读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。 三、秒杀题目 第一题，k = 1 直接套状态转移方程，根据 base case，可以做一些化简： dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) = max(dp[i-1][1][1], -prices[i]) 解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。 现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。 可以进行进一步化简去掉所有 k： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], -prices[i]) 直接写出代码： int n = prices.length; int[][] dp = new int[n][2]; for (int i = 0; i 显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理： for (int i = 0; i 第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1): // k == 1 int maxProfit_k_1(int[] prices) { int n = prices.length; // base case: dp[-1][0] = 0, dp[-1][1] = -infinity int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i 两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。 第二题，k = +infinity 如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架： dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) 我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]) 直接翻译成代码： int maxProfit_k_inf(int[] prices) { int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i 第三题，k = +infinity with cooldown 每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i]) 解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。 翻译成代码： int maxProfit_with_cool(int[] prices) { int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; int dp_pre_0 = 0; // 代表 dp[i-2][0] for (int i = 0; i 第四题，k = +infinity with fee 每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程： dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]) dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee) 解释：相当于买入股票的价格升高了。 在第一个式子里减也是一样的，相当于卖出股票的价格减小了。 直接翻译成代码： int maxProfit_with_fee(int[] prices, int fee) { int n = prices.length; int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE; for (int i = 0; i 第五题，k = 2 k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。 这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。 原始的动态转移方程，没有可化简的地方 dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]) 按照之前的代码，我们可能想当然这样写代码（错误的）： int k = 2; int[][][] dp = new int[n][k + 1][2]; for (int i = 0; i 为什么错误？我这不是照着状态转移方程写的吗？ 还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举： int max_k = 2; int[][][] dp = new int[n][max_k + 1][2]; for (int i = 0; i = 1; k--) { if (i - 1 == -1) { /*处理 base case */ } dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); } } // 穷举了 n × max_k × 2 个状态，正确。 return dp[n - 1][max_k][0]; 如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。 这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况手动列举出来也可以： dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i]) dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i]) dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]) dp[i][1][1] = max(dp[i-1][1][1], -prices[i]) int maxProfit_k_2(int[] prices) { int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE; int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE; for (int price : prices) { dp_i20 = Math.max(dp_i20, dp_i21 + price); dp_i21 = Math.max(dp_i21, dp_i10 - price); dp_i10 = Math.max(dp_i10, dp_i11 + price); dp_i11 = Math.max(dp_i11, -price); } return dp_i20; } 有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会一头雾水，大惊失色，不得不对你肃然起敬。 第六题，k = any integer 有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？ 一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。 直接把之前的代码重用： int maxProfit_k_any(int max_k, int[] prices) { int n = prices.length; if (max_k > n / 2) return maxProfit_k_inf(prices); int[][][] dp = new int[n][max_k + 1][2]; for (int i = 0; i = 1; k--) { if (i - 1 == -1) { /* 处理 base case */ } dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]); dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]); } return dp[n - 1][max_k][0]; } 至此，6 道题目通过一个状态转移方程全部解决。 四、最后总结 本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。 关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？ 具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有。 所以，大家不要被各种高大上的名词吓到，再多的困难问题，奇技淫巧，也不过是基本套路的不断升级组合产生的。只要把住算法的底层原理，即可举一反三，逐个击破。 买卖股票的最佳时机 买卖股票的最佳时机 II 买卖股票的最佳时机 III 买卖股票的最佳时机 IV 最佳买卖股票时机含冷冻期 买卖股票的最佳时机含手续费 "},"算法/股票价格跨度.html":{"url":"算法/股票价格跨度.html","title":"股票价格跨度","keywords":"","body":"股票价格跨度 股票价格跨度 题目 标签 JS 动态规划 JS2 题目 编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。 今天股票价格的跨度被定义为股票价格小于或等于今天价格的最大连续日数（从今天开始往回数，包括今天）。 例如，如果未来7天股票的价格是 [100, 80, 60, 70, 60, 75, 85]，那么股票跨度将是 [1, 1, 1, 2, 1, 4, 6]。 示例： 输入：[\"StockSpanner\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\",\"next\"], [[],[100],[80],[60],[70],[60],[75],[85]] 输出：[null,1,1,1,2,1,4,6] 解释： 首先，初始化 S = StockSpanner()，然后： S.next(100) 被调用并返回 1， S.next(80) 被调用并返回 1， S.next(60) 被调用并返回 1， S.next(70) 被调用并返回 2， S.next(60) 被调用并返回 1， S.next(75) 被调用并返回 4， S.next(85) 被调用并返回 6。 注意 (例如) S.next(75) 返回 4，因为截至今天的最后 4 个价格 (包括今天的价格 75) 小于或等于今天的价格。 提示： 调用 StockSpanner.next(int price) 时，将有 1 。 每个测试用例最多可以调用 10000 次 StockSpanner.next。 在所有测试用例中，最多调用 150000 次 StockSpanner.next。 此问题的总时间限制减少了 50%。 标签 栈 JS 动态规划 动态规划， js, 击败100% 只需要把当前的价格和当前的跨度存下来就可以，当前的跨度为从当前往前走，直到找到大于当前价格的天，将中间这一段的跨度加起来就可以 var StockSpanner = function() { this.data = []; }; /** * @param {number} price * @return {number} */ StockSpanner.prototype.next = function(price) { let base = 1; let offset = this.data.length - 1; while (offset >= 0 && price >= this.data[offset][\"price\"]) { base += this.data[offset][\"offset\"]; offset -= this.data[offset][\"offset\"]; } this.data.push({ price: price, offset: base }); return base; }; JS2 var StockSpanner = function() { this.prePrice = []; this.preLength = []; }; /** * @param {number} price * @return {number} */ StockSpanner.prototype.next = function(price) { this.prePrice.push(price); let len = this.prePrice.length; let ret = 1; while (len - ret - 1 >= 0 && price >= this.prePrice[len - ret - 1]) { ret = ret + this.preLength[len - ret - 1]; } this.preLength.push(ret); return ret; }; /** * Your StockSpanner object will be instantiated and called as such: * var obj = new StockSpanner() * var param_1 = obj.next(price) */ "},"算法/三个无重叠子数组的最大和.html":{"url":"算法/三个无重叠子数组的最大和.html","title":"三个无重叠子数组的最大和","keywords":"","body":"三个无重叠子数组的最大和 三个无重叠子数组的最大和 题目 标签 JS 动态规划 题目 给定数组 nums 由正整数组成，找到三个互不重叠的子数组的最大和。 每个子数组的长度为k，我们要使这3*k个项的和最大化。 返回每个区间起始索引的列表（索引从 0 开始）。如果有多个结果，返回字典序最小的一个。 示例: 输入: [1,2,1,2,6,7,5,1], 2 输出: [0, 3, 5] 解释: 子数组 [1, 2], [2, 6], [7, 5] 对应的起始索引为 [0, 3, 5]。 我们也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。 注意: nums.length的范围在[1, 20000]之间。 nums[i]的范围在[1, 65535]之间。 k的范围在[1, floor(nums.length / 3)]之间。 标签 动态规划 JS 动态规划 状态转移方程 dp[i][n]=max(dp[i-1][n], dp[i-k][n-1]+sumRange(i-k+1, i)); 其中i表示数组下标，n表示第1、2、3个个子数组。sumRange为范围和，这个计算的时间复杂度是O(n)，不过我们可以通过计算前缀和的方式优化到O(1)。这样整个算法的时间复杂度就是O(n)了。 完整代码如下： /** * @param {number[]} nums * @param {number} k * @return {number[]} */ var maxSumOfThreeSubarrays = function(nums, k) { const dp = new Array(nums.length).fill(0).map(_ => new Array(4).fill(0)); // 计算前缀和 const prefixSums = [nums[0]]; for (let i = 1; i = 0 ? dp[i - 1][n] : 0; const prevK = i - k >= 0 ? dp[i - k][n - 1] : 0; const tailSum = i - k >= 0 ? prefixSums[i] - prefixSums[i - k] : prefixSums[i]; dp[i][n] = Math.max(prev1, prevK + tailSum); } } // 根据dp数组找字典序最小的解 const result = []; let n = 3; let currentnow = dp.length - 1; while (result.length = 0 && dp[i - 1][n] === v) { i--; } currentnow = i - k + 1; result.push(currentnow); currentnow--; n--; } return result.reverse(); }; "},"算法/合并区间.html":{"url":"算法/合并区间.html","title":"合并区间","keywords":"","body":"合并区间 合并区间 题目 标签 JS1 reduce JS2 排序，然后比较头尾大小 JS3 JS4 JS5 题目 给出一个区间的集合，请合并所有重叠的区间。 示例 1: 输入: [[1,3],[2,6],[8,10],[15,18]] 输出: [[1,6],[8,10],[15,18]] 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2: 输入: [[1,4],[4,5]] 输出: [[1,5]] 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。 标签 排序 数组 JS1 reduce 先排序，后合并，reduce中acc代码上一次计算的结果，如果上一次能合并的话，acc就是合并后的结果，不能的话acc为上一个数组。最后一项就是reduce的最后结果，因为没有比较，所以直接用res接住返回值 var merge = function(intervals) { if (intervals.length == 0) { return intervals; } intervals.sort((a, b) => a[0] - b[0]); let res = []; res.push( intervals.reduce((acc, cur) => { if (acc[1] >= cur[0]) { if (acc[1] JS2 排序，然后比较头尾大小 /** * @param {number[][]} intervals * @return {number[][]} */ var merge = function(intervals) { if (intervals.length a[0] - b[0]); let result = []; let t = [...intervals[0]]; for (let i = 1; i t[1]) { result.push(t); t = [...intervals[i]]; } else { if (l t[1]) t[1] = r; } } result.push(t); return result; }; JS3 var merge = function(intervals) { if (!intervals.length) return []; intervals = intervals.sort((x, y) => y[0] - x[0] ? y[0] - x[0] : y[1] - y[1] ); let cache = intervals.pop(), space = []; while (intervals.length) { let e = intervals.pop(); if (cache[1] >= e[0]) { cache = [Math.min(cache[0], e[0]), Math.max(cache[1], e[1])]; } else { space.push(cache); cache = e; } } space.push(cache); return space; }; JS4 /** * @param {number[][]} intervals * @return {number[][]} */ var merge = function(intervals) { //排序 try { intervals.sort((a, b) => a[0] - b[0]); var result = []; var min = intervals[0][0]; var max = intervals[0][1]; while (intervals.length > 0) { var i = intervals.shift(); if (max >= i[0]) { max = Math.max(max, i[1]); } else { result.push([min, max]); min = i[0]; max = i[1]; } } result.push([min, max]); return result; } catch (e) { return intervals; } }; JS5 var merge = function(intervals) { return intervals .sort((a, b) => a[0] - b[0]) .reduce((a, b) => { if (a.length === 0) return [b]; let i = a.length - 1; if (a[i][1] >= b[0]) { if (a[i][1] > b[1]) return a; a[i] = [a[i][0], b[1]]; } else { a.push(b); } return a; }, []); }; "},"算法/插入区间.html":{"url":"算法/插入区间.html","title":"插入区间","keywords":"","body":"插入区间 插入区间 题目 标签 JS1 JS2 题目 给出一个无重叠的 ，按照区间起始端点排序的区间列表。 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。 示例 1: 输入: intervals = [[1,3],[6,9]], newInterval = [2,5] 输出: [[1,5],[6,9]] 示例 2: 输入: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] 输出: [[1,2],[3,10],[12,16]] 解释: 这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。 标签 排序 数组 JS1 /** * @param {number[][]} intervals * @param {number[]} newInterval * @return {number[][]} */ function mergeIntervals(a, b) { return [Math.min(a[0], b[0]), Math.max(a[1], b[1])]; } var insert = function(intervals, newInterval) { if (intervals.length === 0) { return [newInterval]; } const res = []; let intervalToBeMerged = newInterval; for (let i = 0; i intervalToBeMerged[1]) { res.push(intervalToBeMerged); res.push(interval); intervalToBeMerged = null; } else if (interval[1] >= intervalToBeMerged[0]) { intervalToBeMerged = mergeIntervals(interval, intervalToBeMerged); } else if (interval[1] JS2 /** * @param {number[][]} intervals * @param {number[]} newInterval * @return {number[][]} */ // intervals = [[1,3],[6,9]], newInterval = [2,5] // 输出: [[1,5],[6,9]] // intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]] // newInterval = [4,8] // 输出: [[1,2],[3,10],[12,16]] var insert = function(intervals, newInterval) { var len = intervals.length; // 假设没有合并,最终的长度为 len + 1 var newLen = intervals.length + 1; var i = 0; for (; i "},"算法/最后一个单词的长度.html":{"url":"算法/最后一个单词的长度.html","title":"最后一个单词的长度","keywords":"","body":"最后一个单词的长度 最后一个单词的长度 题目 标签 JS1 JS2 trim去掉字符串尾部的空格 JS3 JS4 一行 题目 给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指由字母组成，但不包含任何空格的字符串。 示例: 输入: \"Hello World\" 输出: 5 标签 字符串 JS1 思路： 标签：字符串遍历 从字符串末尾开始向前遍历，其中主要有两种情况 第一种情况，以字符串\"Hello World\"为例，从后向前遍历直到遍历到头或者遇到空格为止，即为最后一个单词\"World\"的长度5 第二种情况，以字符串\"Hello World \"为例，需要先将末尾的空格过滤掉，再进行第一种情况的操作，即认为最后一个单词为\"World\"，长度为5 所以完整过程为先从后过滤掉空格找到单词尾部，再从尾部向前遍历，找到单词头部，最后两者相减，即为单词的长度 时间复杂度：O(n)，n为结尾空格和结尾单词总体长度 /** * @param {string} s * @return {number} */ var lengthOfLastWord = function(s) { let end = s.length - 1; while (end >= 0 && s[end] == \" \") end--; if (end = 0 && s[start] != \" \") start--; return end - start; }; JS2 trim去掉字符串尾部的空格 var lengthOfLastWord = function(s) { if (s == \"\") { return 0; } s = s.trim(); if (s.split(\"\").includes(\" \")) { var arr = s.split(\" \"); return arr[arr.length - 1].split(\"\").length; } else { return s.split(\"\").length; } }; JS3 var lengthOfLastWord = function(s) { const word = s.split(' ').filter(x => x).reverse()[0] return word ? word.length : 0 }; JS4 一行 var lengthOfLastWord = function(s) { return s.trim().split(' ').pop().length }; "},"算法/螺旋矩阵.html":{"url":"算法/螺旋矩阵.html","title":"螺旋矩阵","keywords":"","body":"螺旋矩阵 螺旋矩阵 题目 标签 JS1 坐标的规律 JS2 模拟过程 JS3 注意边界 JS4 回溯算法 题目 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。 示例 1: 输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,3,6,9,8,7,4,5] 示例 2: 输入: [ [1, 2, 3, 4], [5, 6, 7, 8], [9,10,11,12] ] 输出: [1,2,3,4,8,12,11,10,9,5,6,7] 标签 数组 回溯算法 JS1 坐标的规律 const spiralOrder = arr => { if (arr.length === 0 || arr[0].length === 0) return [] let m = arr.length, n = arr[0].length if (m === 1) return arr[0] if (n === 1) return arr.map(item => item[0]) let i = 0, j = 0, num = 0, type = 1, res = [] while (res.length = n - 1 && type++ } else if (type % 4 === 2) { i = m - 1 && type++ } else if (type % 4 === 3) { j > 0 && j-- j === 0 && type++ } else if (type % 4 === 0) { i > 0 && i-- if (i === 0) { num++ n === 3 ? type +=2 : type++ } } } return res } JS2 模拟过程 var spiralOrder = function(matrix) { const result = []; const deal = (arr, type) => { if (arr.length == 0 || arr[0].length == 0) return result; let m = (arr[0] && arr[0].length) || 0; let n = (arr && arr.length) || 0; switch (type) { // 横左右 case 1: arr[0].forEach(v => result.push(v)); arr.shift(); return deal(arr, 2); break; // 纵上下 case 2: arr.forEach(v => result.push(v[v.length - 1])); arr.forEach(v => v.pop()); return deal(arr, 3); break; // 横右左 case 3: for (let i = m - 1; i >= 0; i--) { const item = arr[n - 1][i]; result.push(item); } arr.pop(); return deal(arr, 4); break; // 纵下上 case 4: for (let i = n - 1; i >= 0; i--) { const item = arr[i][0]; result.push(item); } arr.forEach(v => v.shift()); return deal(arr, 1); break; default: break; } }; return deal(matrix, 1); }; JS3 注意边界 var spiralOrder = function(matrix) { if (matrix.length == 0 || matrix[0].length == 0) return []; var i = 0, result = [], len = Math.min(matrix.length, matrix[0].length) / 2; while (i i) for (var ii = matrix[0].length - 1 - i; ii >= i; ii--) { result.push(matrix[matrix.length - i - 1][ii]); } if (matrix[0].length - i - 1 > i) for (var ii = matrix.length - 2 - i; ii > i; ii--) { result.push(matrix[ii][i]); } i += 1; } return result; }; JS4 回溯算法 遍历的过程中，假设已经遍历到下标为[i, j]的点，下一个点可能是其上下左右其中的一个。 优先按照当前遍历方向继续前进。 如果当前方向的下一个点已经遍历过了或者超出了范围，则根据\"右下左上\"的顺序继续尝试。 如果每个尝试都失败了，或者我们的结果数组里已经有了m x n个元素，表示遍历结束。 遍历的方向我们用一个数组表示[[0, 1], [1, 0], [0, -1], [-1, 0]]，以根据当前位置以及方向得到下一个可遍历的点坐标。 判断一个点是否合法的方式很简单，刚开始时只要 0 及0 即可。 然后我们在遍历的过程中，更新i和j的上下边界。 例如如果我们尝试向右遍历失败，那么表示我们以及完成了一次向右遍历，当前这一层都被访问过了，所以更新i的下边界。 其它几个方向同理。 代码如下： var spiralOrder = function(matrix) { if (matrix.length === 0) return [] const total = matrix.length * matrix[0].length const result = [] const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]] let direction = 0 let x_min = 0 let x_max = matrix.length - 1 let y_min = 0 let y_max = matrix[0].length - 1 result.push(matrix[0][0]) function back(node) { if (result.length === total) { updateBoundary() return } for (let i = 0; i = x_min && x = y_min && y "},"算法/螺旋矩阵II.html":{"url":"算法/螺旋矩阵II.html","title":"螺旋矩阵 II","keywords":"","body":"螺旋矩阵 II 螺旋矩阵 II 题目 标签 JS1 JS2 JS3 递归 JS4 题目 给定一个正整数 n，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。 示例: 输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ] 标签 数组 JS1 var generateMatrix = function(n) { let res = []; for (let i = 0; i JS2 var generateMatrix = function(n) { let matrix = []; for (let i = 0; i down) break; for (let i = up; i = left; i--) { matrix[down][i] = val++; } if (--down = up; i--) { matrix[i][left] = val++; } if (++left > right) break; } return matrix; }; JS3 递归 /** * @param {number} n * @return {number[][]} */ var generateMatrix = function(n) { let orin = n % 2; let returnList = []; if (orin === 1) { returnList.push([1]); } while (orin { innerList = innerList.map(num => num + addNum); return innerList; }); let top = Array(cur) .fill(1) .map((_, index) => index + 1); let bottom = Array(cur) .fill(1) .map((_, index) => 2 * cur - 1 + index) .reverse(); returnList.forEach((innerList, index) => { innerList.push(cur + 1 + index); innerList.unshift(addNum - index); }); returnList.unshift(top); returnList.push(bottom); orin = cur; } return returnList; }; JS4 const generateMatrix = input => { const matrix = Array(input) .fill() .map(() => Array(input).fill()); const total = input * input; let currentValue = 1; const draw = (all, index) => { if (all === 1) { matrix[index][index] = currentValue; return; } if (all === 0) return; const current = (Math.sqrt(all) - 1) * 4; const width = Math.sqrt(all) - 1; const itertor = Array(width).fill(); for (const key of itertor.keys()) { matrix[index][index + key] = currentValue++; } for (const key of itertor.keys()) { matrix[index + key][index + width] = currentValue++; } for (const key of itertor.keys()) { matrix[index + width][index + width - key] = currentValue++; } for (const key of itertor.keys()) { matrix[index + width - key][index] = currentValue++; } draw(all - current, index + 1); }; draw(total, 0); return matrix; }; "},"算法/第k个排列.html":{"url":"算法/第k个排列.html","title":"第k个排列","keywords":"","body":"第k个排列 第k个排列 题目 标签 JS 找规律 JS2 题目 给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。 按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下： \"123\" \"132\" \"213\" \"231\" \"312\" \"321\" 给定 n 和 k，返回第 k 个排列。 说明： 给定 n 的范围是 [1, 9]。 给定 k 的范围是[1, n!]。 示例 1: 输入: n = 3, k = 3 输出: \"213\" 示例 2: 输入: n = 4, k = 9 输出: \"2314\" 标签 数学 回溯算法 JS 找规律 比如n = 4，那么以1开头的单词有 3 * 2 * 1 个；n = 3，以1开头的单词有 2 * 1个，依次类推，只要得出 k 是当前阶乘的多少倍，那么就获取剩下的当中的第几个单词。 执行用时 :68 ms, 在所有JavaScript提交中击败了100.00%的用户 内存消耗 :33.7 MB, 在所有JavaScript提交中击败了80.28%的用户 /** * @param {number} n * @param {number} k * @return {string} */ var getPermutation = function(n, k) { let m = 1; k = k - 1; for (let i = 2; i JS2 n中每一个数，都有n-1种组合，所以可以不断的循环递减，累积结果，找到答案。 var getPermutation = function(n, k) { let result = '', arr = []; for (let i = 1; i { if (n === 1) return 1; return n * fac(n-1); }; let N = n; while (k > 1) { let count = 1, base = fac(N-1); while (k > count*base) { count++ }; result += arr[count-1]; //注意这里的拼接 arr.splice(count-1, 1); //将本次拼接的数字从arr里删除，因为它已经被“取”走了 k = k - (count-1)*base; //下次循环的k要减掉本次已经积累过的个数 N--; } //这里，当k为1时，说明要拿剩下数字的第一种组合，那就是直接join()起来的数。 return result + arr.join(''); }; "},"算法/路径总和.html":{"url":"算法/路径总和.html","title":"路径总和","keywords":"","body":"路径总和 路径总和 题目 标签 JS1 循环写法 JS2 递归写法 写递归算法的套路(Java) 题目 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ \\ 7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。 标签 树 深度优先搜索 递归 JS1 循环写法 var hasPathSum = function(root, sum) { if (!root) { return false; } let arr = [root]; while (arr.length) { let node = arr.pop(); if (!node.left && !node.right && node.val === sum) { return true; } if (node.left) { node.left.val += node.val; arr.push(node.left); } if (node.right) { node.right.val += node.val; arr.push(node.right); } } return false; }; JS2 递归写法 var hasPathSum = function(root, sum) { if (!root) { return false; } if (!root.left && !root.right && root.val === sum) { return true; } sum -= root.val; return arguments.callee(root.left, sum) || arguments.callee(root.right, sum); }; 写递归算法的套路(Java) /* 看不懂没关系，底下有更详细的分析版本，这里突出体现递归的简洁优美 */ int pathSum(TreeNode root, int sum) { if (root == null) return 0; return count(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum); } int count(TreeNode node, int sum) { if (node == null) return 0; return (node.val == sum) + count(node.left, sum - node.val) + count(node.right, sum - node.val); } 题目看起来很复杂吧，不过代码却极其简洁，这就是递归的魅力。我来简单总结这个问题的解决过程： 首先明确，递归求解树的问题必然是要遍历整棵树的，所以二叉树的遍历框架（分别对左右孩子递归调用函数本身）必然要出现在主函数 pathSum 中。那么对于每个节点，他们应该干什么呢？他们应该看看，自己和脚底下的小弟们包含多少条符合条件的路径。好了，这道题就结束了。 按照前面说的技巧，根据刚才的分析来定义清楚每个递归函数应该做的事： PathSum 函数：给他一个节点和一个目标值，他返回以这个节点为根的树中，和为目标值的路径总数。 count 函数：给他一个节点和一个目标值，他返回以这个节点为根的树中，能凑出几个以该节点为路径开头，和为目标值的路径总数。 /* 有了以上铺垫，详细注释一下代码 */ int pathSum(TreeNode root, int sum) { if (root == null) return 0; int pathImLeading = count(root, sum); // 自己为开头的路径数 int leftPathSum = pathSum(root.left, sum); // 左边路径总数（相信他能算出来） int rightPathSum = pathSum(root.right, sum); // 右边路径总数（相信他能算出来） return leftPathSum + rightPathSum + pathImLeading; } int count(TreeNode node, int sum) { if (node == null) return 0; // 我自己能不能独当一面，作为一条单独的路径呢？ int isMe = (node.val == sum) ? 1 : 0; // 左边的小老弟，你那边能凑几个 sum - node.val 呀？ int leftBrother = count(node.left, sum - node.val); // 右边的小老弟，你那边能凑几个 sum - node.val 呀？ int rightBrother = count(node.right, sum - node.val); return isMe + leftBrother + rightBrother; // 我这能凑这么多个 } 还是那句话，明白每个函数能做的事，并相信他们能够完成。 总结下，PathSum 函数提供的二叉树遍历框架，在遍历中对每个节点调用 count 函数，看出先序遍历了吗（这道题什么序都是一样的）；count 函数也是一个二叉树遍历，用于寻找以该节点开头的目标值路径。 "},"算法/路径总和II.html":{"url":"算法/路径总和II.html","title":"路径总和 II","keywords":"","body":"路径总和 II 路径总和 II 题目 标签 JS 递归 + 回溯 JS2 JS3 题目 给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例: 给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回: [ [5,4,11,2], [5,8,4,5] ] 标签 树 深度优先搜索 JS 递归 + 回溯 var pathSum = function(root, sum) { if(!root) { return [] } if (root.val === sum && !root.left && !root.right) { return [[root.val]] } let ret = [] for(let l of pathSum(root.left, sum - root.val)) { if(l.reduce((r, i) => r + i, 0) + root.val === sum) { l = [root.val, ...l] ret.push(l) } } for(let l of pathSum(root.right, sum - root.val)) { if(l.reduce((r, i) => r + i, 0) + root.val === sum) { l = [root.val, ...l] ret.push(l) } } return ret }; JS2 var pathSum = function(root, sum) { if (root === null) return []; var res = []; function dfs(result, ressum, node) { if (node.left === null && node.right === null) { if (ressum + node.val === sum) { res.push(result.concat([node.val])); } return; } if (node.left !== null) dfs([...result, node.val], ressum + node.val, node.left); if (node.right !== null) dfs([...result, node.val], ressum + node.val, node.right); } dfs([], 0, root); return res; }; JS3 var pathSum = function(root, sum) { let result = []; let tmp = []; const getSum = node => { if (node === null) { return false; } tmp.push(node.val); if ( node.left === null && node.right === null && tmp.reduce((s, item) => s + item, 0) === sum ) { result.push(tmp.slice(0)); } if (getSum(node.left) === undefined) { tmp.pop(); } if (getSum(node.right) === undefined) { tmp.pop(); } }; getSum(root); return result; }; "},"算法/路径总和III.html":{"url":"算法/路径总和III.html","title":"路径总和 III","keywords":"","body":"路径总和 III 路径总和 III 题目 标签 JS JS2 双重递归，对每个节点进行判断 JS3 超过100%的JavaScript解法 JS4 双递归 题目 给定一个二叉树，它的每个结点都存放着一个整数值。 找出路径和等于给定数值的路径总数。 路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。 二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。 示例： root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8 10 / \\ 5 -3 / \\ \\ 3 2 11 / \\ \\ 3 -2 1 返回 3。和等于 8 的路径有: 1. 5 -> 3 2. 5 -> 2 -> 1 3. -3 -> 11 标签 树 JS var pathSum = function(root, sum) { if (root == null) { return 0; } return pathSum(root.left, sum) + pathSum(root.right, sum) + getdfs(root, sum); }; let getdfs = function(node, sum) { let num = 0; if (node == null) { return 0; } if (node.val == sum) { num = 1; } return ( num + getdfs(node.left, sum - node.val) + getdfs(node.right, sum - node.val) ); }; JS2 双重递归，对每个节点进行判断 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @param {number} sum * @return {number} */ var pathSum = function(root, sum) { //双重递归，对每个节点进行判断 var res = []; var count = 0; function dfs(root, num) { if (!root) return; s(root, num); dfs(root.left, num); dfs(root.right, num); } dfs(root, sum); function s(root, num) { if (!root) return; num -= root.val; if (num === 0) { count++; } s(root.left, num); s(root.right, num); } return count; }; JS3 超过100%的JavaScript解法 var pathSum = function(root, sum) { if (!root) return 0; let count = 0; let stack = []; let dfs = function(root, cur) { //当前路径和等于从根节点到此节点的val和 let curSum = cur + root.val; //遍历栈，子路径和等于根到此节点的路径和 - 根到父节点的路径和 if (curSum === sum) count++; for (let i = 0; i JS4 双递归 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @param {number} sum * @return {number} */ var pathSum = function(root, sum) { if(root === null) return 0; var res = 0; return res+= (dfs(root, sum)+pathSum(root.right, sum) + pathSum(root.left, sum)); }; function dfs(root, sum){ if(root === null) return 0; var res = 0; if(root.val === sum) ++res; return res+=(dfs(root.left, sum-root.val)+dfs(root.right, sum-root.val)); } "},"算法/求根到叶子节点数字之和.html":{"url":"算法/求根到叶子节点数字之和.html","title":"求根到叶子节点数字之和","keywords":"","body":"求根到叶子节点数字之和 求根到叶子节点数字之和 题目 标签 JS1 JS2 dfs 题目 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1->2->3 代表数字 123。 计算从根到叶子节点生成的所有数字之和。 说明: 叶子节点是指没有子节点的节点。 示例 1: 输入: [1,2,3] 1 / \\ 2 3 输出: 25 解释: 从根到叶子节点路径 1->2 代表数字 12. 从根到叶子节点路径 1->3 代表数字 13. 因此，数字总和 = 12 + 13 = 25. 示例 2: 输入: [4,9,0,5,1] 4 / \\ 9 0 / \\ 5 1 输出: 1026 解释: 从根到叶子节点路径 4->9->5 代表数字 495. 从根到叶子节点路径 4->9->1 代表数字 491. 从根到叶子节点路径 4->0 代表数字 40. 因此，数字总和 = 495 + 491 + 40 = 1026. 标签 树 深度优先搜索 JS1 /** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } */ /** * @param {TreeNode} root * @return {number} */ var sumNumbers = function(root) { if (root === null) return 0; var res = []; function dfs(sum, node) { if (node.left === null && node.right === null) { res.push(sum * 10 + node.val); return; } if (node.left !== null) dfs(sum * 10 + node.val, node.left); if (node.right !== null) dfs(sum * 10 + node.val, node.right); } dfs(0, root); return res.reduce((a, b) => a + b); }; JS2 dfs var sumNumbers = function(root) { var res = 0; function dfs(node, val) { if (node === null) { return; } if (node.left == null && node.right == null) { res += val * 10 + node.val; return; } if (node.left !== null) { dfs(node.left, val * 10 + node.val); } if (node.right !== null) { dfs(node.right, val * 10 + node.val); } } dfs(root, 0); return res; }; "},"算法/相同的树.html":{"url":"算法/相同的树.html","title":"相同的树","keywords":"","body":"相同的树 相同的树 题目 标签 JS1 前序遍历就完事 JS2 JS3 JS4 题目 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1: 输入: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] 输出: true 示例 2: 输入: 1 1 / \\ 2 2 [1,2], [1,null,2] 输出: false 示例 3: 输入: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] 输出: false 标签 树 深度优先搜索 JS1 前序遍历就完事 执行用时 : 52 ms, 在Same Tree的JavaScript提交中击败了100.00% 的用户 var isSameTree = function(p, q) { let pArr = [], qArr = []; prevOrder(p, pArr); prevOrder(q, qArr); function prevOrder(root, arr) { if (root === null) { arr.push(null); return; } arr.push(root.val); prevOrder(root.left, arr); prevOrder(root.right, arr); } return JSON.stringify(pArr) === JSON.stringify(qArr); }; JS2 var isSameTree = function(p, q) { var left, right; if (p && q) { if (p.val === q.val) { left = isSameTree(p.left, q.left); right = isSameTree(p.right, q.right); } else { return false; } } else if (!p && !q) { return true; } else { return false; } return left && right; }; JS3 var isSameTree = function(p, q) { if (p == null && q == null) return true; if (p != null && q != null && p.val == q.val) { return isSameTree(p.left, q.left) && isSameTree(p.right, q.right); } else { return false; } }; JS4 var isSameTree = function(p, q) { if (p && q) { if (p.val != q.val) return false; return isSameTree(p.left, q.left) && isSameTree(p.right, q.right); } else { if (p == null && q == null) return true; return false; } }; "},"算法/图像渲染.html":{"url":"算法/图像渲染.html","title":"图像渲染","keywords":"","body":"图像渲染 图像渲染 题目 标签 JS1 深度优先 floodfill 算法详解 回溯算法 一、构建框架 二、研究细节 三、处理细节 题目 有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。 为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。 最后返回经过上色渲染后的图像。 示例 1: 输入: image = [[1,1,1],[1,1,0],[1,0,1]] sr = 1, sc = 1, newColor = 2 输出: [[2,2,2],[2,2,0],[2,0,1]] 解析: 在图像的正中间，(坐标(sr,sc)=(1,1)), 在路径上所有符合条件的像素点的颜色都被更改成2。 注意，右下角的像素没有更改为2， 因为它不是在上下左右四个方向上与初始点相连的像素点。 注意: image 和 image[0] 的长度在范围 [1, 50] 内。 给出的初始点将满足 0 和 0 。 image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。 标签 深度优先搜索 JS1 深度优先 /** * @param {number[][]} image * @param {number} sr * @param {number} sc * @param {number} newColor * @return {number[][]} */ var floodFill = function(image, sr, sc, newColor) { //深度优先遍历 if (image[sr][sc] === newColor) return image; var r = image.length; var c = image[0].length; var oldColor = image[sr][sc]; function dfs(x, y) { image[x][y] = newColor; if (x > 0 && image[x - 1][y] === oldColor) dfs(x - 1, y); if (y > 0 && image[x][y - 1] === oldColor) dfs(x, y - 1); if (x floodfill 算法详解 回溯算法 一、构建框架 此题可以抽象成一个二维矩阵（图片其实就是像素点矩阵），然后从某个点开始向四周扩展，直到无法再扩展为止。 矩阵，可以抽象为一幅【图】，这就是一个图的遍历问题，也就类似一个 N 叉树遍历的问题。几行代码就能解决，直接上框架吧： // (x, y) 为坐标位置 void fill(int x, int y) { fill(x - 1, y); // 上 fill(x + 1, y); // 下 fill(x, y - 1); // 左 fill(x, y + 1); // 右 } 这个框架可以解决所有在二维矩阵中遍历的问题，说得高端一点，这就叫深度优先搜索（Depth First Search，简称 DFS），说得简单一点，这就叫四叉树遍历框架。坐标 (x, y) 就是 root，四个方向就是 root 的四个子节点。 int[][] floodFill(int[][] image, int sr, int sc, int newColor) { int origColor = image[sr][sc]; fill(image, sr, sc, origColor, newColor); return image; } void fill(int[][] image, int x, int y, int origColor, int newColor) { // 出界：超出边界索引 if (!inArea(image, x, y)) return; // 碰壁：遇到其他颜色，超出 origColor 区域 if (image[x][y] != origColor) return; image[x][y] = newColor; fill(image, x, y + 1, origColor, newColor); fill(image, x, y - 1, origColor, newColor); fill(image, x - 1, y, origColor, newColor); fill(image, x + 1, y, origColor, newColor); } boolean inArea(int[][] image, int x, int y) { return x >= 0 && x = 0 && y 只要你能够理解这段代码，一定要给你鼓掌，给你 99 分，因为你对【框架思维】的掌控已经炉火纯青，此算法已经 cover 了 99% 的情况，仅有一个细节问题没有解决，就是当 origColor 和 newColor 相同时，会陷入无限递归。 二、研究细节 为什么会陷入无限递归呢，很好理解，因为每个坐标都要搜索上下左右，那么对于一个坐标，一定会被上下左右的坐标搜索。被重复搜索时，必须保证递归函数能够能正确地退出，否则就会陷入死循环。 三、处理细节 如何避免上述问题的发生，最容易想到的就是用一个和 image 一样大小的二维 bool 数组记录走过的地方，一旦发现重复立即 return。 // 出界：超出边界索引 if (!inArea(image, x, y)) return; // 碰壁：遇到其他颜色，超出 origColor 区域 if (image[x][y] != origColor) return; // 不走回头路 if (visited[x][y]) return; visited[x][y] = true; image[x][y] = newColor; 完全 OK，这也是处理「图」的一种常用手段。不过对于此题，不用开数组，我们有一种更好的方法，那就是回溯算法。 前文【回溯算法详解】讲过，这里不再赘述，直接套回溯算法框架： void fill(int[][] image, int x, int y, int origColor, int newColor) { // 出界：超出数组边界 if (!inArea(image, x, y)) return; // 碰壁：遇到其他颜色，超出 origColor 区域 if (image[x][y] != origColor) return; // 已探索过的 origColor 区域 if (image[x][y] == -1) return; // choose：打标记，以免重复 image[x][y] = -1; fill(image, x, y + 1, origColor, newColor); fill(image, x, y - 1, origColor, newColor); fill(image, x - 1, y, origColor, newColor); fill(image, x + 1, y, origColor, newColor); // unchoose：将标记替换为 newColor image[x][y] = newColor; } 这种解决方法是最常用的，相当于使用一个特殊值 -1 代替 visited 数组的作用，达到不走回头路的效果。为什么是 -1，因为题目中说了颜色取值在 0 - 65535 之间，所以 -1 足够特殊，能和颜色区分开。 "},"算法/岛屿的周长.html":{"url":"算法/岛屿的周长.html","title":"岛屿的周长","keywords":"","body":"岛屿的周长 岛屿的周长 题目 标签 JS1 JS2 对任意一个格子来说，只要有重合就算废了一条边儿 JS3 只有周围是0的格子对岛屿的周长有贡献 JS4 遍历，看上下左右是否是0或边界 JS5 JS6 题目 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例 : 输入: [[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] 输出: 16 解释: 它的周长是下面图片中的 16 个黄色的边： 标签 哈希表 JS1 /** * @param {number[][]} grid * @return {number} */ var islandPerimeter = function(grid) { //看示例才读懂题意，输入二维数组中，寻找元素为1的周长和 var count = 0; for (var i = 0; i 0 && grid[i][j - 1] === 1) count -= 2; //上下相邻 if (i > 0 && grid[i - 1][j] === 1) count -= 2; } } } return count; }; JS2 对任意一个格子来说，只要有重合就算废了一条边儿 var islandPerimeter = function(grid) { let lenx = grid.length; let leny = grid[0].length; let sum = 0; for (let i = 0; i = 0 && grid[i - 1][j] === 1; let bottom = i + 1 = 0 && grid[i][j - 1] === 1; let right = j + 1 JS3 只有周围是0的格子对岛屿的周长有贡献 var islandPerimeter = function(grid) { let res = 0; for (let i = 0; i 0) { res = i - 1 >= 0 && grid[i - 1][j] ? res : res + 1; res = j - 1 >= 0 && grid[i][j - 1] ? res : res + 1; res = j + 1 JS4 遍历，看上下左右是否是0或边界 var islandPerimeter = function(grid) { var res = 0; for (var i = 0; i = grid.length || grid[i + 1][ii] == 0) res += 1; if (ii - 1 = grid[0].length || grid[i][ii + 1] == 0) res += 1; } } } return res; }; JS5 var islandPerimeter = function(grid) { let count = 0; // 判断一个方格的左上方有没有岛屿 for (let i = 0; i JS6 var islandPerimeter = function(grid) { const rowLen = grid.length; const colLen = grid[0].length; const initRow = []; let per = 0; let i, j; for (j = 0; j "},"算法/岛屿的最大面积.html":{"url":"算法/岛屿的最大面积.html","title":"岛屿的最大面积","keywords":"","body":"岛屿的最大面积 岛屿的最大面积 题目 标签 JS1 JS2 题目 给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。 找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。) 示例 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] 对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。 示例 2: [[0,0,0,0,0,0,0,0]] 对于上面这个给定的矩阵, 返回 0。 注意: 给定的矩阵grid 的长度和宽度都不超过 50。 标签 深度优先搜索 数组 JS1 var maxAreaOfIsland = function(grid) { let max = 0; let x = grid.length; let y = grid[0].length; for (let i = 0; i max) { max = gg; } } } return max; function sum(i, j, grid) { let num = 0; if (grid[i][j] === 1) { num = 1; grid[i][j] = 0; if (i + 1 = 0 && grid[i - 1][j] === 1) { num += sum(i - 1, j, grid); } if (j + 1 = 0 && grid[i][j - 1] === 1) { num += sum(i, j - 1, grid); } } return num; } }; JS2 var maxAreaOfIsland = function(grid) { let lenY = grid.length; if (lenY.length === 0) return 0; let lenX = grid[0].length; if (lenX.length === 0) return 0; let flag = Array.from({ length: lenY }, item => (item = Array(lenX).fill(0))); let r = 0; let result = 0; let dy = [1, 0, -1, 0]; let dx = [0, 1, 0, -1]; function dfs(y, x) { result = Math.max(r, result); for (let k = 0; k = 0 && newY = 0 && newX "},"算法/边框着色.html":{"url":"算法/边框着色.html","title":"边框着色","keywords":"","body":"边框着色 边框着色 题目 标签 测试用例 java 题目 连通分量的边界是指连通分量中的所有与不在分量中的正方形相邻（四个方向上）的所有正方形，或者在网格的边界上（第一行/列或最后一行/列）的所有正方形。 给出位于 (r0, c0) 的网格块和颜色 color，使用指定颜色 color 为所给网格块的连通分量的边界进行着色，并返回最终的网格 grid 。 示例 1： 输入：grid = [[1,1],[1,2]], r0 = 0, c0 = 0, color = 3 输出：[[3, 3], [3, 2]] 示例 2： 输入：grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3 输出：[[1, 3, 3], [2, 3, 3]] 示例 3： 输入：grid = [[1,1,1],[1,1,1],[1,1,1]], r0 = 1, c0 = 1, color = 2 输出：[[2, 2, 2], [2, 1, 2], [2, 2, 2]] 提示： 1 1 1 0 0 1 标签 深度优先搜索 测试用例 测试用例： [[1,2,1,2,1,2],[2,2,2,2,1,2],[1,2,2,2,1,2]] 1 3 1 1 2 1 2 1 2 1 1 1 1 1 2 2 2 2 2 1 2 -> 1 2 1 1 1 2 1 2 2 2 1 2 1 1 1 1 1 2 DFS 两个判断，1）如果处于边框则变 。 2）如果四面有任意一个和自己不同，则变。 java 题目意思：要染色的边界：1. 处于第一行/列 2.处于最后一行/列 3.四个相邻的元素不能全为grid[0][0] class Solution: def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]: base_color = grid[r0][c0] row, col = len(grid), len(grid[0]) res = copy.deepcopy(grid) def dfs(grid, r, c, row, col, base_color, color, res): if r = row or c = col or grid[r][c] 同样的思路，一位大神更简洁的代码 class Solution: def colorBorder(self, grid: List[List[int]], r0: int, c0: int, color: int) -> List[List[int]]: row, col = len(grid), len(grid[0]) border,visit = set(),set() def dfs(r, c): if not (0 "},"算法/二分查找.html":{"url":"算法/二分查找.html","title":"二分查找","keywords":"","body":"二分查找 二分查找 题目 标签 二分查找细节详解 零、二分查找框架 一、寻找一个数（基本的二分搜索） 二、寻找左侧边界的二分搜索 三、寻找右侧边界的二分查找 四、最后总结 JS1 二分查找 JS2 二分查找 JS 递归版 题目 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。 标签 二分查找 二分查找细节详解 我相信对很多读者朋友来说，编写二分查找的算法代码属于玄学编程，虽然看起来很简单，就是会出错，要么会漏个等号，要么少加个 1。 不要气馁，因为二分查找其实并不简单。看看 Knuth 大佬（发明 KMP 算法的那位）怎么说的： Although the basic idea of binary search is comparatively straightforward, the details can be surprisingly tricky... 这句话可以这样理解：思路很简单，细节是魔鬼。 本文以问答的形式，探究几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。第一个场景就是本题，后两个场景可以解决这道算法题 在排序数组中查找元素的第一个和最后一个位置。 而且，我们就是要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。 零、二分查找框架 int binarySearch(int[] nums, int target) { int left = 0, right = ...; while(...) { int mid = (right + left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] target) { right = ... } } return ...; } 分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。 其中 ... 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。 另外声明一下，计算 mid 时需要技巧防止溢出，即 mid = left + (right - left) / 2。本文暂时忽略这个问题。 一、寻找一个数（基本的二分搜索） 这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。 int binarySearch(int[] nums, int target) { int left = 0; int right = nums.length - 1; // 注意 while(left target) right = mid - 1; // 注意 } return -1; } 为什么 while 循环的条件中是 答：因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。 这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。 我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间，我们不妨称为「搜索区间」。 什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止： if(nums[mid] == target) return mid; 但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。 while(left 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候搜索区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。 while(left 的终止条件是 left == right，写成区间的形式就是 [left, right]，或者带个具体的数字进去 [2, 2]，这时候搜索区间非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。 当然，如果你非要用 while(left //... while(left 为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？ 答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。 刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，如何确定下一步的搜索区间呢？ 当然是 [left, mid - 1] 或者 [mid + 1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。 此算法有什么缺陷？ 答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。 比如说给你有序数组 nums = [1,2,2,2,3]，target = 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。 这样的需求很常见。你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。 我们后续的算法就来讨论这两种二分查找的算法。 二、寻找左侧边界的二分搜索 直接看代码，其中的标记是需要注意的细节： int left_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0; int right = nums.length; // 注意 while (left target) { right = mid; // 注意 } } return left; } 为什么 while(left 答：用相同的方法分析，因为 right = nums.length 而不是 nums.length - 1 。因此每次循环的「搜索区间」是 [left, right) 左闭右开。 while(left 为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？ 答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义： 对于这个数组，算法会返回 1。这个 1 的含义可以这样解读：nums 中小于 2 的元素有 1 个。 比如对于有序数组 nums = [2,3,5,7], target = 1，算法会返回 0，含义是：nums 中小于 1 的元素有 0 个。 再比如说 nums 不变，target = 8，算法会返回 4，含义是：nums 中小于 8 的元素有 4 个。 综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 [0, nums.length]，所以我们简单添加两行代码就能在正确的时候 return -1： while (left 为什么 left = mid + 1，right = mid ？和之前的算法不一样？ 答：这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。 为什么该算法能够搜索左侧边界？ 答：关键在于对于 nums[mid] == target 这种情况的处理： if (nums[mid] == target) right = mid; 可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。 为什么返回 left 而不是 right？ 答：都是一样的，因为 while 终止的条件是 left == right。 三、寻找右侧边界的二分查找 寻找右侧边界和寻找左侧边界的代码差不多，只有两处不同，已标注： int right_bound(int[] nums, int target) { if (nums.length == 0) return -1; int left = 0, right = nums.length; while (left target) { right = mid; } } return left - 1; // 注意 } 为什么这个算法能够找到右侧边界？ 答：类似地，关键点还是这里： if (nums[mid] == target) { left = mid + 1; 当 nums[mid] == target 时，不要立即返回，而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。 为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。 答：首先，while 循环的终止条件是 left == right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回 right - 1 好了。 至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断： if (nums[mid] == target) { left = mid + 1; // 这样想: mid = left - 1 因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target。 至于为什么 left 的更新必须是 left = mid + 1，同左侧边界搜索，就不再赘述。 为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？ 答：类似之前的左侧边界搜索，因为 while 的终止条件是 left == right，就是说 left 的取值范围是 [0, nums.length]，所以可以添加两行代码，正确地返回 -1： while (left 四、最后总结 来梳理一下这些细节差异的因果逻辑： 第一个，最基本的二分查找算法： 因为我们初始化 right = nums.length - 1 所以决定了我们的「搜索区间」是 [left, right] 所以决定了 while (left 第二个，寻找左侧边界的二分查找： 因为我们初始化 right = nums.length 所以决定了我们的「搜索区间」是 [left, right) 所以决定了 while (left 第三个，寻找右侧边界的二分查找： 因为我们初始化 right = nums.length 所以决定了我们的「搜索区间」是 [left, right) 所以决定了 while (left 如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。 通过本文，你学会了： 分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。 注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。 如需要搜索左右边界，只要在 nums[mid] == target 时做修改即可。搜索右侧时需要减一。 可以去先把 在排序数组中查找元素的第一个和最后一个位置 解决了。以后就算遇到其他的二分查找变形，运用这几点技巧，也能保证你写出正确的代码。 JS1 二分查找 var search = function(nums, target) { var left = 0, right = nums.length - 1, mid; while (left nums[mid]) { left = mid + 1; } else { right = mid - 1; } } return -1; }; JS2 二分查找 /** * @param {number[]} nums * @param {number} target * @return {number} */ var search = function(nums, target) { let l = 0 let h = nums.length - 1 while (l target) { h = m - 1 } } return -1 } JS 递归版 var search = function(nums, target) { const binarySearch = (nums, target, low, high) => { if (low > high) { return -1; } let mid = Math.floor((low + high) / 2); if (nums[mid] === target) { return mid; } return nums[mid] > target ? binarySearch(nums, target, low, mid - 1) : binarySearch(nums, target, mid + 1, high); }; return binarySearch(nums, target, 0, nums.length - 1); }; "},"算法/不同路径.html":{"url":"算法/不同路径.html","title":"不同路径","keywords":"","body":"不同路径 不同路径 题目 标签 JS DP JS2 JS3 JS3 动态规划 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 问总共有多少条不同的路径？ 例如，上图是一个7 x 3 的网格。有多少可能的路径？ 说明：m 和 n 的值均不超过 100。 示例 1: 输入: m = 3, n = 2 输出: 3 解释: 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -> 向右 -> 向下 2. 向右 -> 向下 -> 向右 3. 向下 -> 向右 -> 向右 示例 2: 输入: m = 7, n = 3 输出: 28 标签 数组 动态规划 JS DP var uniquePaths = function(m, n) { if (m === 0 || n === 0) return 0; var dp = new Array(n).fill(0).map(function(a) { return new Array(m).fill(0); }); dp[n - 1][m - 1] = 1; for (var i = n - 1; i >= 0; i--) { for (var ii = m - 1; ii >= 0; ii--) { if (i + 1 JS2 var uniquePaths = function(m, n) { const a1 = () => { let a = m - 1, b = m + n - 2; a = Math.min(a, b - a); let s1 = 1, s2 = 1; for (let i = 0; i { let dp = []; for (let i = 0; i JS3 function Factorial(i) { return i JS3 动态规划 还是基础的动态规划题目，类似64.最小路径和 主要考虑 当当前点在左边或者顶边上，到达该点的路径只有一条， 当在网格内部，由于只能向右或者向下走，因此到达该点的路径和就是他左边和上边格子的路径总和 迭代可得最终路径和。 /** * @param {number} m * @param {number} n * @return {number} */ // 执行用时 : 72 ms, 在Unique Paths的JavaScript提交中击败了98.61% 的用户 // 内存消耗 : 34.6 MB, 在Unique Paths的JavaScript提交中击败了45.45% 的用户 var uniquePaths = function (m, n) { let temp = []; for (let i = 0; i "},"算法/不同路径II.html":{"url":"算法/不同路径II.html","title":"不同路径 II","keywords":"","body":"不同路径 II 不同路径 II 题目 标签 JS 动态规划 JS2 DP JS 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：m 和 n 的值均不超过 100。 示例 1: 输入: [ [0,0,0], [0,1,0], [0,0,0] ] 输出: 2 解释: 3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -> 向右 -> 向下 -> 向下 2. 向下 -> 向下 -> 向右 -> 向右 标签 数组 动态规划 JS 动态规划 思路和上题一模一样，只需要增加一个条件判断，注意边上的格子，若其中存在障碍物，该边上的后续格子都无法到达。 /** * @param {number[][]} obstacleGrid * @return {number} */ // 执行用时: 88 ms, 在Unique Paths II的JavaScript提交中击败了89 .23 % 的用户 // 内存消耗: 36.1 MB, 在Unique Paths II的JavaScript提交中击败了13 .56 % 的用户 // 本题主要是有一个障碍物的设定，因此可以直接沿用62的代码，添加上条件判断即可 var uniquePathsWithObstacles = function (obstacleGrid) { let n = obstacleGrid.length, m = obstacleGrid[0].length; let temp = []; for (let i = 0; i JS2 DP var uniquePathsWithObstacles = function(obstacleGrid) { var m = obstacleGrid.length, n = obstacleGrid[0].length, dp = new Array(m).fill(0).map(function(a) { return new Array(n).fill(0); }); if (obstacleGrid[m - 1][n - 1] === 1) return 0; dp[m - 1][n - 1] = 1; for (var i = m - 1; i >= 0; i--) { for (var ii = n - 1; ii >= 0; ii--) { if (obstacleGrid[i][ii] === 1) { continue; } if (i + 1 JS var uniquePathsWithObstacles = function(obstacleGrid) { // 获取终点的坐标 let endX = obstacleGrid.length - 1, endY = obstacleGrid[0].length - 1; let F = (x, y) => { // 如果当前位置的坐标存在负值，说明越界，直接返回0 if (x "},"算法/最小路径和.html":{"url":"算法/最小路径和.html","title":"最小路径和","keywords":"","body":"最小路径和 最小路径和 题目 标签 JS JS2 DP JS3 动态规划 JS4 动态规划 用原数组对象来维护 \"状态数组\" 题目 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 说明：每次只能向下或者向右移动一步。 示例: 输入: [ [1,3,1], [1,5,1], [4,2,1] ] 输出: 7 解释: 因为路径 1→3→1→1→1 的总和最小。 标签 数组 动态规划 JS 我的提交执行用时 已经战胜 86.24 % 的 javascript 提交记录 由题可知，每次只能向右或者向下走，因此[0][n]的上一步必定是向右走，而[0][n]的上一步必定是向下，由此可以先确定第一行和第一列的当前最小路径。 对于中间的其他格子，由于上一步有两种可能性，因此需要分别计算左侧格子和上侧格子的最小路径和，并选出较小的一个，即为当前格的最小路径和。 /** * @param {number[][]} grid * @return {number} */ var minPathSum = function(grid) { let l = grid.length, h = grid[0].length; let temp = []; for (let i = 0; i JS2 DP var minPathSum = function(grid) { if (grid.length === 0 || grid[0].length === 0) return 0; var m = grid.length, n = grid[0].length, dp = new Array(m).fill(0).map(function(a) { return new Array(n).fill(0); }); dp[m - 1][n - 1] = grid[m - 1][n - 1]; for (var i = m - 1; i >= 0; i--) { for (var ii = n - 1; ii >= 0; ii--) { if (i === m - 1 && ii === n - 1) continue; if (i + 1 JS3 动态规划 var minPathSum = function(grid) { let rn = grid.length, cn = grid[0].length; for (let i = 0; i = 0) a = grid[i - 1][j] + grid[i][j]; if (j - 1 >= 0) b = grid[i][j - 1] + grid[i][j]; if (a != Infinity || b != Infinity) { grid[i][j] = a JS4 动态规划 用原数组对象来维护 \"状态数组\" var minPathSum = function (grid) { var m = grid.length var n = grid[0].length for (var i = 0; i "},"算法/斐波那契数.html":{"url":"算法/斐波那契数.html","title":"斐波那契数","keywords":"","body":"斐波那契数 斐波那契数 题目 标签 动态规划套路详解 C++ 步骤一、暴力的递归算法 步骤二、带备忘录的递归解法 步骤三、动态规划 一、暴力解法 二、带备忘录的递归算法 三、动态规划 最后总结 JS1 暴力解决 JS2 JS3 动态规划 JS4 动规划g JS5 题目 斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1. 给定 N，计算 F(N)。 示例 1： 输入：2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1. 示例 2： 输入：3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2. 示例 3： 输入：4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3. 提示： 0 ≤ N ≤ 30 标签 数组 动态规划套路详解 C++ 下面通过对斐波那契数列和 凑零钱问题 详解动态规划。 动态规划算法似乎是一种很高深莫测的算法，你会在一些面试或算法书籍的高级技巧部分看到相关内容，什么状态转移方程，重叠子问题，最优子结构等高大上的词汇也可能让你望而却步。 而且，当你去看用动态规划解决某个问题的代码时，你会觉得这样解决问题竟然如此巧妙，但却难以理解，你可能惊讶于人家是怎么想到这种解法的。 实际上，动态规划是一种常见的「算法设计技巧」，并没有什么高深莫测，至于各种高大上的术语，那是吓唬别人用的，只要你亲自体验几把，这些名词的含义其实显而易见，再简单不过了。 至于为什么最终的解法看起来如此精妙，是因为 动态规划遵循一套固定的流程：递归的暴力解法 -> 带备忘录的递归解法 -> 非递归的动态规划解法。这个过程是层层递进的解决问题的过程，你如果没有前面的铺垫，直接看最终的非递归动态规划解法，当然会觉得牛逼而不可及了。 当然，见的多了，思考多了，是可以一步写出非递归的动态规划解法的。任何技巧都需要练习，我们先遵循这个流程走，算法设计也就这些套路，除此之外，真的没啥高深的。 以下，先通过两个个比较简单的例子：斐波那契和凑零钱问题，揭开动态规划的神秘面纱，描述上述三个流程。后续还会写几篇文章探讨如何使用动态规划技巧解决比较复杂的经典问题。 首先，第一个快被举烂了的例子，斐波那契数列。请读者不要嫌弃这个例子简单，因为简单的例子才能让你把精力充分集中在算法背后的通用思想和技巧上，而不会被那些隐晦的细节问题搞的莫名其妙。后续，困难的例子有的是。 步骤一、暴力的递归算法 // C++ int fib(int N) { if (N == 1 || N == 2) return 1; return fib(N - 1) + fib(N - 2); } // js const fib = N => { if (N == 1 || N == 2) return 1; return fib(N - 1) + fib(N - 2); } 这个不用多说了，学校老师讲递归的时候似乎都是拿这个举例。我们也知道这样写代码虽然简洁易懂，但是十分低效，低效在哪里？假设 n = 20，请画出递归树。 PS：但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。 这个递归树怎么理解？就是说想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18)和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。 递归算法的时间复杂度怎么计算？子问题个数乘以解决一个子问题需要的时间。 子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2n) 解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。 所以，这个算法的时间复杂度为 O(2n)，指数级别，爆炸。 观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(18) 被计算了两次，而且你可以看到，以 f(18) 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 f(18) 这一个节点被重复计算，所以这个算法及其低效。 这就是动态规划问题的第一个性质：重叠子问题。下面，我们想办法解决这个问题。 步骤二、带备忘录的递归解法 明确了问题，其实就已经把问题解决了一半。既然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。 一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。 // C++ int fib(int N) { if (N memo(N + 1, 0); return helper(memo, N); } int helper(vector& memo, int n) { if (n == 1 || n == 2) return 1; if (memo[n] != 0) return memo[n]; // 未被计算过 memo[n] = helper(memo, n - 1) + helper(memo, n - 2); return memo[n]; } // js var fib = function (N) { if (N 现在，画出递归树，你就知道「备忘录」到底做了什么。 实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。 递归算法的时间复杂度怎么算？子问题个数乘以解决一个子问题需要的时间。 子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 f(1), f(2), f(3) ... f(20)f(1),f(2),f(3)...f(20)，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。 解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。 所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。 至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。 啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。 啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1)f(1) 和 f(2)f(2) 开始往上推，直到推到我们想要的答案 f(20)f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。 步骤三、动态规划 有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！ // C++ int fib(int N) { vector dp(N + 1, 0); dp[1] = dp[2] = 1; for (int i = 3; i 画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。 这里，引出「动态转移方程」这个名词，实际上就是描述问题结构的数学形式： 为啥叫「状态转移方程」？为了听起来高端。你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。 你会发现，上面的几种解法中的所有操作，例如 return f(n - 1) + f(n - 2)，dp[i] = dp[i - 1] + dp[i - 2]，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。很容易发现，其实状态转移方程直接代表着暴力解法。 千万不要看不起暴力解，动态规划问题最困难的就是写出状态转移方程，即这个暴力解。优化方法无非是用备忘录或者 DP table，再无奥妙可言。 这个例子的最后，讲一个细节优化。细心的读者会发现，根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)： // C++ int fib(int n) { if (n { if (n 有人会问，动态规划的另一个重要特性「最优子结构」，怎么没有涉及？下面会涉及。斐波那契数列的例子严格来说不算动态规划，以上旨在演示算法设计螺旋上升的过程。当问题中要求求一个最优解或在代码中看到循环和 max、min 等函数时，十有八九，需要动态规划大显身手。 下面，看第二个例子，凑零钱问题 ，有了上面的详细铺垫，这个问题会很快解决。 题目：给你 k 种面值的硬币，面值分别为 c1, c2 ... ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1。 比如说，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 33 枚硬币，即 11 = 5 + 5 + 1 。下面走流程。 一、暴力解法 首先是最困难的一步，写出状态转移方程，这个问题比较好写： 其实，这个方程就用到了「最优子结构」性质：原问题的解由子问题的最优解构成。即 f(11) 由 f(10)，f(9)，f(6) 的最优解转移而来。 记住，要符合「最优子结构」，子问题间必须互相独立。啥叫相互独立？你肯定不想看数学证明，我用一个直观的例子来讲解。 比如说，你的原问题是考出最高的总成绩，那么你的子问题就是要把语文考到最高，数学考到最高...... 为了每门课考到最高，你要把每门课相应的选择题分数拿到最高，填空题分数拿到最高...... 当然，最终就是你每门课都是满分，这就是最高的总成绩。 得到了正确的结果：最高的总成绩就是总分。因为这个过程符合最优子结构，“每门科目考到最高”这些子问题是互相独立，互不干扰的。 但是，如果加一个条件：你的语文成绩和数学成绩会互相制约，此消彼长。这样的话，显然你能考到的最高总成绩就达不到总分了，按刚才那个思路就会得到错误的结果。因为子问题并不独立，语文数学成绩无法同时最优，所以最优子结构被破坏。 回到凑零钱问题，显然子问题之间没有相互制约，而是互相独立的。所以这个状态转移方程是可以得到正确答案的。 之后就没啥难点了，按照方程写暴力递归算法即可。 // C++ int coinChange(vector& coins, int amount) { if (amount == 0) return 0; int ans = INT_MAX; for (int coin : coins) { // 金额不可达 if (amount - coin = coin && dp[i - coin] !== -1) { dp[i] = Math.min(dp[i - coin] + 1, dp[i]); } } if (dp[i] === Number.MAX_VALUE) dp[i] = -1; } return dp[amount]; }; coinChange([1, 2, 5], 11) 画出递归树： 时间复杂度分析：子问题总数 × 每个子问题的时间。子问题总数为递归树节点个数，这个比较难看出来，是 O(n^k)，总之是指数级别的。每个子问题中含有一个 for 循环，复杂度为 O(k)。所以总时间复杂度为 O(k*n^k)，指数级别。 二、带备忘录的递归算法 // C++ int coinChange(vector& coins, int amount) { // 备忘录初始化为 -2 vector memo(amount + 1, -2); return helper(coins, amount, memo); } int helper(vector& coins, int amount, vector& memo) { if (amount == 0) return 0; if (memo[amount] != -2) return memo[amount]; int ans = INT_MAX; for (int coin : coins) { // 金额不可达 if (amount - coin 不画图了，很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 n，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn)。 三、动态规划 // C++ int coinChange(vector& coins, int amount) { vector dp(amount + 1, amount + 1); dp[0] = 0; for (int i = 1; i amount ? -1 : dp[amount]; } 最后总结 如果你不太了解动态规划，还能看到这里，真得给你鼓掌，相信你已经掌握了这个算法的设计技巧。 计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举，穷举所有可能性。算法设计无非就是先思考 “如何穷举”，然后再追求 “如何聪明地穷举”。 列出动态转移方程，就是在解决 “如何穷举” 的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。 备忘录、DP table 就是在追求 “如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门，除此之外，试问，还能玩出啥花活？ JS1 暴力解决 var fib = function(N) { if(N == 0){ return 0 }else if(N == 1){ return 1 }else if(N == 2){ return 1 }else{ let arr = [0,1,1] for(let i = 2 ; i JS2 var fib = function(N) { if(N JS3 动态规划 /** * @param {number} N * @return {number} */ var fib = function(N) { if (N === 0) return 0; if (N === 1) return 1; var a = 0; var b = 1; for (var i = 1; i JS4 动规划g var fib = function(N) { if (N JS5 var fib = function(N) { return ( (Math.sqrt(5) / 5) * (Math.pow((1 + Math.sqrt(5)) / 2, N) - Math.pow((1 - Math.sqrt(5)) / 2, N)) ); }; "},"算法/零钱兑换.html":{"url":"算法/零钱兑换.html","title":"零钱兑换","keywords":"","body":"零钱兑换 - 凑零钱 零钱兑换 - 凑零钱 题目 标签 JS1 DP JS2 DP JS3 DP JS4 DP JS5 DP JS6 DP JS7 贪心算法 题目 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 输入: coins = [1, 2, 5], amount = 11 输出: 3 解释: 11 = 5 + 5 + 1 示例 2: 输入: coins = [2], amount = 3 输出: -1 说明:你可以认为每种硬币的数量是无限的。 标签 动态规划 贪心算法 JS1 DP 画出递归树： var coinChange = function(coins, amount) { if (amount == 0) return 0; var ans = Number.MAX_VALUE; for (var coin of coins) { // 金额不可达 if (amount - coin JS2 DP var coinChange = function(coins, amount) { let dp = [0]; for (let i = 1; i = coin && dp[i - coin] !== -1) { dp[i] = Math.min(dp[i - coin] + 1, dp[i]); } } if (dp[i] === Number.MAX_VALUE) dp[i] = -1; } return dp[amount]; }; JS3 DP var coinChange = (coins, amount) => { // dp[i]表示装满i数量所需要的最少硬币数， // 状态转移方程为d[i] = math.min(dp[i],dp[i-k]+1), // 满足i>=k的条件即可。 let dp = new Array(amount + 1).fill(Number.MAX_SAFE_INTEGER); dp[0] = 0; for (let i = 0; i { if (i - coin >= 0) dp[i] = Math.min(dp[i], dp[i - coin] + 1); }); } return dp[amount] === Number.MAX_SAFE_INTEGER ? -1 : dp[amount]; }; JS4 DP var coinChange = function(coins, amount) { var dp = [0]; for (var i = 1; i = coins[j]) { dp[i] = dp[i] > dp[i - coins[j]] + 1 ? dp[i - coins[j]] + 1 : dp[i]; } } } return dp[amount] > amount ? -1 : dp[amount]; }; coinChange([1, 2, 5], 11) JS5 DP var coinChange = function(coins, amount) { let dp = Array(amount + 1).fill(Number.MAX_SAFE_INTEGER); dp[0] = 0; for (const c of coins) { for (let i = c; i JS6 DP var coinChange = function(coins, amount) { if (amount a - b); var dp = []; //dp[i]表示i金额的最小拿法 for (var i = 0; i JS7 贪心算法 对每个面额(从大到小), 把它的值和total相加后， total需要小于amount, 我们会将当前面额coin添加到结果中，也会将它和total相加 var minCoinChange = function(coins, amount) { var change = [], total = 0; for(var i = coins.length; i >= 0; i--) { // 对每个面额(从大到小) var coin = coins[i]; while(total + coin "},"算法/零钱兑换II.html":{"url":"算法/零钱兑换II.html","title":"零钱兑换 II","keywords":"","body":"零钱兑换 II 零钱兑换 II 题目 标签 JS1 JS2 题目 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 示例 1: 输入: amount = 5, coins = [1, 2, 5] 输出: 4 解释: 有四种方式可以凑成总金额: 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 示例 2: 输入: amount = 3, coins = [2] 输出: 0 解释: 只用面额2的硬币不能凑成总金额3。 示例 3: 输入: amount = 10, coins = [10] 输出: 1 注意: 你可以假设： 0 1 硬币种类不超过 500 种 结果符合 32 位符号整数 标签 动态规划 JS1 var change = function(amount, coins) { let dp = Array(amount + 1).fill(0); dp[0] = 1; coins.forEach((coin, index) => { for (let i = coin; i JS2 var change = function(amount, coins) { let dp = Array(amount + 1).fill(0); dp[0] = 1; for (var i = 0; i "},"算法/N皇后.html":{"url":"算法/N皇后.html","title":"N皇后","keywords":"","body":"N皇后 题目 标签 JS 回溯 JS2 JS3 JS4 JS5 数组判断 JS6 位运算判断 题目 n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。 示例: 输入: 4 输出: [ [\".Q..\", // 解法 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // 解法 2 \"Q...\", \"...Q\", \".Q..\"] ] 解释: 4 皇后问题存在两个不同的解法。 标签 回溯算法 JS 回溯 var solveNQueens = function (n) { const res = []; var backtrack = (n, preBlock = [], r = 0) => { if (r === n) { res.push(preBlock.map(c => '.'.repeat(c) + 'Q' + '.'.repeat(n - c - 1))); return; } for (let c = 0; c j === c || j - c === r - k || j - c === k - r)) { preBlock.push(c); backtrack(n, preBlock, r + 1); preBlock.pop(); } } } backtrack(n) return res; }; JS2 /** * @param {number} n * @return {string[][]} */ const solveNQueens = function(n) { if (0 >= n) return []; const cols = new Set(); const xy_dif = new Set(); const xy_sum = new Set(); const result = []; const dfs = queens => { const y = queens.length; // debugger if (y === n) { result.push(queens); return; } let x = 0; while (x { return res.map(idx => { const arr = new Array(n); arr[idx] = 'Q'; return arr.join('.'); }); }); }; JS3 var solveNQueens = function (n) { let cur = [], t = 1, space = []; cur.length = n + 1; cur.fill(0); const validQueen = function () { for (let i = cur[t]; i 0) { if (t > n) { let lines = []; for (let i = 1; i n) { cur[t] = 0; t--; } else { cur[t]++; let res = validQueen(); cur[t] = res; t = res > 0 ? t + 1 : t - 1; } } return space; }; JS4 /** * @param {number} n * @return {string[][]} */ var solveNQueens = function(n) { const result = []; const col = []; const left = []; const right = []; solution(0, []); return result; function solution(level, plate) { if (level == n) { result.push(plate); return; } for (let position = 0; position JS5 数组判断 function solveNQueens(n) { var answers = [], ld_last = [], //左斜线 \\ ， col-row rd_list = [], //右斜线 / ， row+col col_list = [], //列 queens = [] function isNotUnderAttack(row, col) { return !col_list[col] && !ld_last[col - row] && !rd_list[row + col] } function placeQueen(row, col) { queens.push(col) col_list[col] = true ld_last[col - row] = true rd_list[row + col] = true } function removeQueen(row, col) { queens.pop(col) col_list[col] = false ld_last[col - row] = false rd_list[row + col] = false } function addSolution() { var answer = [] for (let i = 0; i JS6 位运算判断 使用 n 位的二进制存储，以 1100 为例子，表示1、2格子不能放置，3、4格子可放置皇后 function solveNQueens(n) { /* ld 左斜线 \\ 位数为n的二进制数字，1表示已经被占用（不可放置） rd 右斜线 / col 列 | upperlim ��可以放置的位置 n个1 ，例 n=4 --> 1111 */ var answers = [], upperlim = (1 0 , 说明有位置摆放皇后 */ var pos = upperlim & ~(col | ld | rd) while (pos) { /* current 当前摆放皇后的位置，从右往做取第一个 1 ① 取反~，0转1，1转0 ， ~ 0001 = 1110 ② +1，通过二进制加法 把变成 0 的 1 重新转成 1 1110 + 1 = 1111 ③ pos & ，取得第一个 1， 0001 & 0001 = 0001 */ var current = pos & (~pos + 1) pos -= current queens.push(n - 1 - Math.log2(current)) /* 列： col | current （ col + current 也可以 ） 左斜线： ld | current 再 右移 一位 右斜线： rd | current 再 左移 一位 */ backtrack(col | current, upperlim & (ld | current) >> 1, upperlim & (rd | current) "},"算法/N皇后II.html":{"url":"算法/N皇后II.html","title":"N皇后 II","keywords":"","body":"N皇后 II 题目 标签 JS1 回溯 JS2 题目 n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。 示例: 输入: 4 输出: 2 解释: 4 皇后问题存在如下两个不同的解法。 [ [\".Q..\", // 解法 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // 解法 2 \"Q...\", \"...Q\", \".Q..\"] ] 标签 回溯算法 JS1 回溯 var totalNQueens = function (n) { let res = 0; var backtrack = (n, board = [], r = 0) => { if (r === n) { res++ return; } for (let c = 0; c bc === c || c - bc === r - br || c - bc === -(r - br))) { board.push(c); backtrack(n, board, r + 1); board.pop(); } } } backtrack(n) return res; }; JS2 /** * @param {number} n * @return {number} */ var totalNQueens = function(n) { let count = 0; dfs(0, [], [], []); return count; function dfs(level, col, left, right) { if (level === n) { count++; return; } for (let i = 0; i "},"算法/颜色分类.html":{"url":"算法/颜色分类.html","title":"颜色分类","keywords":"","body":"颜色分类 题目 标签 JS1 JS2 冒泡 题目 给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 注意:不能使用代码库中的排序函数来解决这道题。 示例: 输入: [2,0,2,1,1,0] 输出: [0,0,1,1,2,2] 进阶： 一个直观的解决方案是使用计数排序的两趟扫描算法。 首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。 你能想出一个仅使用常数空间的一趟扫描算法吗？ 标签 排序 数组 双指针 JS1 var sortColors = function (nums) { var len = nums.length; for (var i = 0; i JS2 冒泡 var sortColors = function (nums) { for (let i = 0; i nums[j]) { let num num = nums[i] nums[i] = nums[j] nums[j] = num } } } return nums }; "},"算法/子集.html":{"url":"算法/子集.html","title":"子集","keywords":"","body":"子集 题目 标签 JS1 简化问题-从小处入手 JS2 JS3 JS4 JS5 JS6 每个数增加到子集，新子集和旧子集再合并 题目 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例: 输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] 标签 数组 位运算 回溯算法 JS1 简化问题-从小处入手 看到已经有很多人提出了很多种解法了，在此我就做一个小小的补充，以及思考的方法，我觉得知道程序怎么写并不重要，重要的是程序是怎么被设计出来的，程序在没写出来之前，在大脑中又是如何构思的。科学家总是喜欢把美丽的结果呈现在世人的眼前，而抹去推论时的线索和草稿，就好比盖好的大厦会拆除其脚手架，令人惊叹其成就，却无法学到真正思想的瑰宝。   简单来说，这道题其实是一个集合问题，假设有一个集合 [e_1, e_2, ... , e_n] 。那么，其子集无非是 [e_1(选 or 不选), e_2(选 or 不选), ... , e_n(选 or 不选)]。   由于数组的长度可以为无限大，这让我们无从下手。不过，算法毕竟是逐步实现的，我们可以从小规模的问题入手。这时，我们把问题规模缩小一点，减少我们思考的范围。先思考一个元素，那无非就是选和不选，我们假定一开始数组是空的，那么在做完第一次选择之后，应该有两个数组[[], [e1]]。然后，我们再考虑第二个元素，则有[[], [e_1], [e_2], [e_1, e_2]]。发现了吗？这里存在一个规律，[[]] → [[], [e_1]] → [[], [e_1], [e_2], [e_1, e_2]]，每次做选择之后的结果都是在上一步已知的集合上进行扩充得到的，即当前的集合_i = 集合{i-1} \\bigcup 从集合{i-1}扩充后的集合当前的集合 i=集合 i−1⋃从集合 i−1 扩充后的集合。那么，扩充的方式就是对集合{i-1}集合 i−1 中的每个子集加上一个新的元素e_i。 var subsets = function(nums) { let ws = [[]]; for(let i=0; i JS2 var subsets = function (nums) { if (nums.length === 0) { return [[]]; } let [num, ...restNums] = nums; let restSubSets = subsets(restNums); return restSubSets.map(set => [...set, num]).concat(restSubSets); }; JS3 var subsets = function (nums) { var res = [[]]; for (var i = 0; i JS4 /** * @param {number[]} nums * @return {number[][]} */ var subsets = function(nums) { let res = [[]]; for (let i = 0; i { res.push(e.concat(nums[i])) }) } return res; }; JS5 var subsets = function(nums) { let res = []; for(let i=0, len=nums.length; i JS6 每个数增加到子集，新子集和旧子集再合并 var subsets = function (nums) { let res = [[]] for(let i in nums) { for (let j in res) { res.push([...res[j], nums[i]]) } } return res }; "},"算法/单词搜索.html":{"url":"算法/单词搜索.html","title":"单词搜索","keywords":"","body":"单词搜索 题目 标签 JS1 回溯 JS2 JS3 dfs+回溯 JS4 回溯 JS5 dfs 题目 给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 示例: board = [ ['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E'] ] 给定 word = \"ABCCED\", 返回 true. 给定 word = \"SEE\", 返回 true. 给定 word = \"ABCB\", 返回 false. 标签 数组 回溯算法 JS1 回溯 var exist = function (board, word) { //越界处理 board[-1] = [] board.push([]) //寻找首个字母 for (let y = 0; y JS2 var exist = function (board, word) { const find = (i, j, k) => { if (i = (board[0] || []).length || i >= board.length || board[i][j] !== word[k]) return false; if (k === word.length - 1) return true; board[i][j] = null; if ([ [0, 1], [0, -1], [1, 0], [-1, 0] ] .some(([a, b]) => find(i + a, j + b, k + 1))) { return true; } board[i][j] = word[k]; return false; } for (const i of board.keys()) { for (const j of board[i].keys()) { if (find(i, j, 0)) { return true; } } } return false; }; JS3 dfs+回溯 /** * @param {character[][]} board * @param {string} word * @return {boolean} */ function dfs(ans, i, j, word, board) { const rowSize = board[0].length; if (ans.result) { return; } if (word === '') { ans.result = true; return; } if (i board.length - 1 || j > rowSize - 1) { return; } if (board[i][j] !== word[0]) { return; } let v = board[i][j]; board[i][j] = null; const newWord = word.slice(1); dfs(ans, i - 1, j, newWord, board); dfs(ans, i, j - 1, newWord, board); dfs(ans, i, j + 1, newWord, board); dfs(ans, i + 1, j, newWord, board); board[i][j] = v; } var exist = function (board, word) { const ans = { result: false }; for (let i = 0; i JS4 回溯 var exist = function (board, word) { function cp2(arr) { return arr.map(function (a) { return [...a]; }) }; var res = false; var hs = function (board, word, i, j) { if (word.length == 0) { res = true; return; } if (i JS5 dfs var exist = function (board, word) { var m = board.length; if (m = 0 && ni = 0 && nj "},"算法/分治动态规划备忘录的区别.html":{"url":"算法/分治动态规划备忘录的区别.html","title":"分治动态规划备忘录的区别","keywords":"","body":"分治、动态规划、备忘录的区别 分治、动态规划、备忘录的区别 分治 动态规划 备忘录 怎么选择 自底向上与自顶向下 分治 分治算法对问题进行分解时所遵循的原则是将待求解问题分解为若干个规模较小、相互独立且与原问题相同的子问题（不包含公共的子问题） 动态规划 对问题进行分解时所遵循的原则是将待求解问题分解为若干个规模较小、相互关联的与原问题类似的子问题（包含公共的子问题），采用记录表的方法来保存所有已解决问题的答案，而在需要的时候再找出已求得的答案，避免大量的重复计算。与分治法类似，动态规划法 也是把问题一层一层地分解为规模逐渐减小的同类型的子问题。动态规划法与分治法的一个重要的不同点在于，用分治法分解后得到的子问题通常都是相互独立的， 而用动态规划法分解后得到的子问题很多都是重复的。因此，对重复出现的子问题，只是在第一次遇到时才进行计算，然后把计算所得的结果保存起来；当再次遇到该子问题时，就直接引用已保存的结果，而不再重新求解。 备忘录 是动态规划算法的变形，它通过分治思想对原问题进行分解，以存储子问题的解的方式解决冗余计算，并采用自顶向下的递归方式获取问题的最终解。与动态规划算法的不同之处是动态规划算法的递归方式是自底向上递归求解，而备忘录方法的递归方式是自顶向下递归求解 怎么选择 当一个问题的所有子问题都至少要解一次时，使用动态规划算法。 当子问题空间中的部分子问题不需要求解时，使用备忘录方法。 自底向上与自顶向下 自底向上：从初始已知的状态出发，向外拓展，最后到达目标状态。 自顶向下：从最终状态开始，找到可以到达当前状态的状态，如果该状态还没处理，就先处理该状态。 "},"算法/背包问题.html":{"url":"算法/背包问题.html","title":"背包问题","keywords":"","body":"背包问题 背包问题 01背包问题 1.1 问题描述 1.2 问题分析 1.3 各种优化 合并循环 选择物品 使用滚动数组压缩空间 使用一维数组压缩空间 1.4 递归法解01背包 二、完全背包问题 2.1 问题描述： 2.2 问题分析： 2.3 O(nW)优化 三、多重背包问题 3.1 问题描述： 3.2 问题分析： 3.3 使用二进制优化 01背包问题 1.1 问题描述 有${n}$件物品和${1}$个容量为W的背包。每种物品均只有一件，第${i}$件物品的重量为${weights[i]}$，价值为${values[i]}$，求解将哪些物品装入背包可使价值总和最大。 对于一种物品，要么装入背包，要么不装。所以对于一种物品的装入状态只是1或0, 此问题称为01背包问题。 1.2 问题分析 数据：物品个数${n=5}$,物品重量${weights=[2，2，6，5，4]}$,物品价值${values=[6，3，5，4，6]}$,背包总容量${W=10}$。 我们设置一个矩阵${f}$来记录结果，${f(i, j)}$ 表示可选物品为 ${i...n}$ 背包容量为 ${j(0 w v i\\j 0 1 2 3 4 5 6 7 8 9 10 2 6 0 2 3 1 6 5 2 5 4 3 4 6 4 我们先看第一行，物品0的体积为2，价值为6，当容量为0时，什么也放不下，因此第一个格式只能填0，程序表示为${f(0,0) = 0}$或者${f[0][0] = 0}$。 当${j=1}$时，依然放不下${w_0}$，因此依然为0，${f(0, 1) = 0}$。 当${j=2}$时，能放下${w_0}$，于是有 ${f(0, 2)\\ = \\ v_0=6}$。 当${j=3}$时，也能放下${w_0}$，但我们只有一个物品0，因此它的值依然是6，于是一直到${j=10}$时，它的值都是${v_0}$。 w v i\\j 0 1 2 3 4 5 6 7 8 9 10 2 6 0 0 0 6 6 6 6 6 6 6 6 6 2 3 1 6 5 2 5 4 3 4 6 4 根据第一行，我们得到如下方程 当背包容量少于物品価积时，总价值为0，否则为物品的价值 然后我们看第二行，确定确定${f(1,0...10)}$这11个元素的值。当${j=0}$ 时，依然什么也放不下，值为0，但我们发觉它是上方格式的值一样的，${f(1,0)=0}$。 当${j=1}$时，依然什么也放不下，值为0，但我们发觉它是上方格式的值一样的，${f(1,1)=0}$. 当${j=2}$时，它可以选择放入物品1或不放。 如果选择不放物品1，背包里面有物品0，最大价值为6。 如果选择放入物品1，我们要用算出背包放入物品1后还有多少容量，然后根据容量查出它的价值，再加上物品1的价值，即${f(0,j-w_1)+v_1}$ 。由于我们的目标是尽可能装最值钱的物品， 因此放与不放， 我们需要通过比较来决定，于是有 显然${v_1=2，v_0=6}$, 因此这里填${v_0}$。 当${j=3}$时， 情况相同。 当${j=4}$，能同时放下物品0与物品1，我们这个公式的计算结果也合乎我们的预期， 得到${f(1,4)=9}$。 当${j>4}$时， 由于背包只能放物品0与物品1，那么它的最大价值也一直停留在${v_0+v_1=9}$ w v i\\j 0 1 2 3 4 5 6 7 8 9 10 2 6 0 0 0 6 6 6 6 6 6 6 6 6 2 3 1 0 0 6 6 9 9 9 9 9 9 9 6 5 2 5 4 3 4 6 4 我们再看第三行，当${j=0}$时，什么都放不下，${f(2,0)=0}$。当${j=1}$时，依然什么也放不下，${f(2,1)=0}$，当${j=2}$时，虽然放不下${w_2}$，但我们根据上表得知这个容号时，背包能装下的最大价值是6。继续计算下去，其实与上面推导的公式结果是一致的，说明公式是有效的。当${j=8}$时，背包可以是放物品0、1，或者放物品1、2，或者放物品0、2。物品0、1的价值，我们在表中就可以看到是9，至于其他两种情况我们姑且不顾，我们目测就知道是最优值是${6+5=11}$， 恰恰我们的公式也能正确计算出来。当${j=10}$时,刚好三个物品都能装下，它们的总值为14，即${f(2,10)=14}$ 第三行的结果如下： w v i\\j 0 1 2 3 4 5 6 7 8 9 10 2 6 0 0 0 6 6 6 6 6 6 6 6 6 2 3 1 0 0 6 6 9 9 9 9 9 9 9 6 5 2 0 0 6 6 9 9 9 9 11 11 14 5 4 3 4 6 4 整理一下第1，2行的适用方程： 我们根据此方程，继续计算下面各列，于是得到 w v i\\j 0 1 2 3 4 5 6 7 8 9 10 2 6 0 0 0 6 6 6 6 6 6 6 6 6 2 3 1 0 0 6 6 9 9 9 9 9 9 9 6 5 2 0 0 6 6 9 9 9 9 11 11 14 5 4 3 0 0 6 6 9 9 9 10 11 13 14 4 6 4 0 0 6 6 9 9 12 12 15 15 15 至此，我们就可以得到解为15. 我们最后根据0-1背包问题的最优子结构性质，建立计算${f(i,j)}$的递归式： function knapsack(weights, values, W) { var n = weights.length - 1; var f = [[]]; for (var j = 0; j 1.3 各种优化 合并循环 现在方法里面有两个大循环，它们可以合并成一个。 function knapsack(weights, values, W) { var n = weights.length; var f = new Array(n); for (var i = 0; i 然后我们再认真地思考一下，为什么要孤零零地专门处理第一行呢？f[i][j] = j 是不是能适用于下面这一行f[i][j] = Math.max(f[i-1][j], f[i-1][j-weights[i]] + values[i]) 。Math.max可以轻松转换为三元表达式，结构极其相似。而看一下i-1的边界问题，有的书与博客为了解决它，会添加第0行，全部都是0，然后i再往下挪。其实我们也可以添加一个${-1}$行。那么在我们的方程中就不用区分${i==0}$与${0>0}$的情况，方程与其他教科书的一模一样了！ function knapsack(weights, values, W) { var n = weights.length; var f = new Array(n); f[-1] = new Array(W + 1).fill(0); for (var i = 0; i w v i\\j 0 1 2 3 4 5 6 7 8 9 10 X X -1 0 0 0 0 0 0 0 0 0 0 0 2 6 0 0 0 6 6 6 6 6 6 6 6 6 2 3 1 0 0 6 6 9 9 9 9 9 9 9 6 5 2 0 0 6 6 9 9 9 9 11 11 14 5 4 3 0 0 6 6 9 9 9 10 11 13 14 4 6 4 0 0 6 6 9 9 12 12 15 15 15 负一行的出现可以大大减少了在双层循环的分支判定。是一个很好的技巧。 注意，许多旧的教程与网上文章，通过设置二维数组的第一行为0来解决i-1的边界问题（比如下图）。当然也有一些思维转不过来的缘故，他们还在坚持数字以1开始，而我们新世代的IT人已经确立从0开始的编程思想。 选择物品 上面讲解了如何求得最大价值，现在我们看到底选择了哪些物品，这个在现实中更有意义。许多书与博客很少提到这一点，就算给出的代码也不对，估计是在设计状态矩阵就出错了。 仔细观察矩阵，从${f(n-1,W)}$逆着走向${f(0,0)}$，设i=n-1,j=W，如果${f(i,j)}$==${f(i-1,j-w_i)+v_i}$说明包里面有第i件物品，因此我们只要当前行不等于上一行的总价值，就能挑出第i件物品，然后j减去该物品的重量，一直找到j = 0就行了。 function knapsack(weights, values, W) { var n = weights.length; var f = new Array(n); f[-1] = new Array(W + 1).fill(0); var selected = []; for (var i = 0; i = 0; i--) { if (f[i][j] > f[i - 1][j]) { selected.push(i); console.log(\"物品\", i, \"其重量为\", weights[i], \"其价格为\", values[i]); j = j - weights[i]; w += weights[i]; } } console.log(\"背包最大承重为\", W, \" 现在重量为\", w, \" 总价值为\", f[n - 1][W]); return [f[n - 1][W], selected.reverse()]; } var a = knapsack([2, 3, 4, 1], [2, 5, 3, 2], 5); console.log(a); var b = knapsack([2, 2, 6, 5, 4], [6, 3, 5, 4, 6], 10); console.log(b); 使用滚动数组压缩空间 所谓滚动数组，目的在于优化空间，因为目前我们是使用一个${ij}$的二维数组来储存每一步的最优解。在求解的过程中，我们可以发现，当前状态只与前一行的状态有关，那么更之前存储的状态信息已经无用了，可以舍弃的，我们只需要存储当前状态和前一行状态，所以只需使用${2j}$的空间，循环滚动使用，就可以达到跟${i*j}$一样的效果。这是一个非常大的空间优化。 function knapsack(weights, values, W) { var n = weights.length; var lineA = new Array(W + 1).fill(0); var lineB = [], lastLine = 0, currLine; var f = [lineA, lineB]; //case1 在这里使用es6语法预填第一行 for (var i = 0; i = weights[i]) { var a = f[lastLine][j]; var b = f[lastLine][j - weights[i]] + values[i]; f[currLine][j] = Math.max(a, b); //case3 } } lastLine = currLine; //交换行 } return f[currLine][W]; } var a = knapsack([2, 3, 4, 1], [2, 5, 3, 2], 5); console.log(a); var b = knapsack([2, 2, 6, 5, 4], [6, 3, 5, 4, 6], 10); console.log(b); 我们还可以用更hack的方法代替currLine, lastLine function knapsack(weights, values, W) { var n = weights.length; var f = [new Array(W + 1).fill(0), []], now = 1, last; //case1 在这里使用es6语法预填第一行 for (var i = 0; i = weights[i]) { var a = f[1 - now][j]; var b = f[1 - now][j - weights[i]] + values[i]; f[now][j] = Math.max(a, b); //case3 } } last = f[now]; now = 1 - now; // 1 - 0 => 1;1 - 1 => 0; 1 - 0 => 1 .... } return last[W]; } var a = knapsack([2, 3, 4, 1], [2, 5, 3, 2], 5); console.log(a); var b = knapsack([2, 2, 6, 5, 4], [6, 3, 5, 4, 6], 10); console.log(b); 注意，这种解法由于丢弃了之前N行的数据，因此很难解出挑选的物品，只能求最大价值。 使用一维数组压缩空间 观察我们的状态迁移方程: weights为每个物品的重量，values为每个物品的价值，W是背包的容量，i表示要放进第几个物品，j是背包现时的容量（假设我们的背包是魔术般的可放大，从0变到W）。 我们假令i = 0 f中的-1就变成没有意义，因为没有第-1行，而weights[0], values[0]继续有效，${f(0,j)}$也有意义，因为我们全部放到一个一维数组中。于是: 这方程后面多加了一个限制条件，要求是从大到小循环。为什么呢？ 假设有物体${\\cal z}$容量2，价值${v_z}$很大，背包容量为5，如果j的循环顺序不是逆序，那么外层循环跑到物体${\\cal z}$时， 内循环在${j=2}$时 ，${\\cal z}$被放入背包。当${j=4}$时，寻求最大价值，物体z放入背包，${f(4)=max(f(4),f(2)+v_z) }$， 这里毫无疑问后者最大。 但此时${f(2)+v_z}$中的${f(2)}$ 已经装入了一次${\\cal z}$，这样一来${\\cal z}$被装入两次不符合要求， 如果逆序循环j， 这一问题便解决了。 javascript实现： function knapsack(weights, values, W) { var n = weights.length; var f = new Array(W + 1).fill(0); for (var i = 0; i = weights[i]; j--) { f[j] = Math.max(f[j], f[j - weights[i]] + values[i]); } console.log(f.concat()); //调试 } return f[W]; } var b = knapsack([2, 2, 6, 5, 4], [6, 3, 5, 4, 6], 10); console.log(b); 1.4 递归法解01背包 由于这不是动态规则的解法，大家多观察方程就理解了： function knapsack(n, W, weights, values, selected) { if (n == 0 || W == 0) { //当物品数量为0，或者背包容量为0时，最优解为0 return 0; } else { //从当前所剩物品的最后一个物品开始向前，逐个判断是否要添加到背包中 for (var i = n - 1; i >= 0; i--) { //如果当前要判断的物品重量大于背包当前所剩的容量，那么就不选择这个物品 //在这种情况的最优解为f(n-1,C) if (weights[i] > W) { return knapsack(n - 1, W, weights, values, selected); } else { var a = knapsack(n - 1, W, weights, values, selected); //不选择物品i的情况下的最优解 var b = values[i] + knapsack(n - 1, W - weights[i], weights, values, selected); //选择物品i的情况下的最优解 //返回选择物品i和不选择物品i中最优解大的一个 if (a > b) { selected[i] = 0; //这种情况下表示物品i未被选取 return a; } else { selected[i] = 1; //物品i被选取 return b; } } } } } var selected = [], ws = [2, 2, 6, 5, 4], vs = [6, 3, 5, 4, 6]; var b = knapsack(5, 10, ws, vs, selected); console.log(b); //15 selected.forEach(function(el, i) { if (el) { console.log(\"选择了物品\" + i + \" 其重量为\" + ws[i] + \" 其价值为\" + vs[i]); } }); 二、完全背包问题 2.1 问题描述： 有${n}$件物品和${1}$个容量为W的背包。每种物品没有上限，第${i}$件物品的重量为${weights[i]}$，价值为${values[i]}$，求解将哪些物品装入背包可使价值总和最大。 2.2 问题分析： 最简单思路就是把完全背包拆分成01背包，就是把01背包中状态转移方程进行扩展，也就是说01背包只考虑放与不放进去两种情况，而完全背包要考虑 放0、放1、放2...的情况， 这个k当然不是无限的，它受背包的容量与单件物品的重量限制，即${j/weights[i]}$。假设我们只有1种商品，它的重量为20，背包的容量为60，那么它就应该放3个，在遍历时，就0、1、2、3地依次尝试。 程序需要求解${nW}$个状态，每一个状态需要的时间为${O（W/w_i）}$，总的复杂度为${O(nWΣ(W/w_i))}$。 我们再回顾01背包经典解法的核心代码 for (var i = 0; i 现在多了一个k，就意味着多了一重循环 for (var i = 0; i javascript的完整实现 function completeKnapsack(weights, values, W) { var f = [], n = weights.length; f[-1] = []; //初始化边界 for (var i = 0; i 2.3 O(nW)优化 我们再进行优化，改变一下f思路，让${f(i,j)}$表示出在前i种物品中选取若干件物品放入容量为j的背包所得的最大价值。 所以说，对于第i件物品有放或不放两种情况，而放的情况里又分为放1件、2件、......${j/w_i}$件 如果不放, 那么${f(i,j)=f(i-1,j)}$；如果放，那么当前背包中应该出现至少一件第i种物品，所以f(i,j)中至少应该出现一件第i种物品,即${f(i,j)=f(i,j-w_i)+v_i}$，为什么会是${f(i,j-w_i)+v_i}$？ 因为我们要把当前物品i放入包内，因为物品i可以无限使用，所以要用${f(i,j-w_i)}$；如果我们用的是${f(i-1,j-w_i)}$，${f(i-1,j-w_i)}$的意思是说，我们只有一件当前物品i，所以我们在放入物品i的时候需要考虑到第i-1个物品的价值${f(i-1,j-w_i)}$；但是现在我们有无限件当前物品i，我们不用再考虑第i-1个物品了，我们所要考虑的是在当前容量下是否再装入一个物品i，而${(j-w_i)}$的意思是指要确保${f(i,j)}$至少有一件第i件物品，所以要预留c(i)的空间来存放一件第i种物品。总而言之，如果放当前物品i的话，它的状态就是它自己\"i\"，而不是上一个\"i-1\"。 所以说状态转移方程为： 与01背包的相比，只是一点点不同，我们也不需要三重循环了 javascript的完整实现： function unboundedKnapsack(weights, values, W) { var f = [], n = weights.length; f[-1] = []; //初始化边界 for (let i = 0; i 我们可以继续优化此算法，可以用一维数组写 我们用${f(j)}$表示当前可用体积j的价值，我们可以得到和01背包一样的递推式： function unboundedKnapsack(weights, values, W) { var n = weights.length, f = new Array(W + 1).fill(0); for (var i = 0; i tmp ? f[j] : tmp; } } console.log(f); //调试 return f[W]; } var a = unboundedKnapsack([3, 2, 2], [5, 10, 20], 5); //输出40 console.log(a); var b = unboundedKnapsack([2, 3, 4, 7], [1, 3, 5, 9], 10); //输出12 console.log(b); 三、多重背包问题 3.1 问题描述： 有${n}$件物品和${1}$个容量为W的背包。每种物品最多有numbers[i]件可用，第${i}$件物品的重量为${weights[i]}$，价值为${values[i]}$，求解将哪些物品装入背包可使价值总和最大。 3.2 问题分析： 多重背包就是一个进化版完全背包。在我们做完全背包的第一个版本中，就是将它转换成01背包，然后限制k的循环 直接套用01背包的一维数组解法 function knapsack(weights, values, numbers, W){ var n = weights.length; var f= new Array(W+1).fill(0) for(var i = 0; i =weights[i]; j--)//正常的01背包代码 f[j]=Math.max(f[j],f[j-weights[i]]+values[i]); } return f[W]; } var b = knapsack([2,3,1 ],[2,3,4],[1,4,1],6) console.log(b) 3.3 使用二进制优化 其实说白了我们最朴素的多重背包做法是将有数量限制的相同物品看成多个不同的0-1背包。这样的时间复杂度为${O(WΣn(i))}$, W为空间容量 ，n(i)为每种背包的数量限制。如果这样会超时，我们就得考虑更优的拆分方法，由于拆成1太多了，我们考虑拆成二进制数，对于13的数量，我们拆成1，2，4，6（有个6是为了凑数）。 19 我们拆成1，2，4，8，4 （最后的4也是为了凑和为19）。经过这个样的拆分我们可以组合出任意的小于等于n(i)的数目（二进制啊，必然可以）。j极大程度缩减了等效为0-1背包时候的数量。 大概可以使时间复杂度缩减为${O(Wlog(ΣN(i))}$； 定理：一个正整数n可以被分解成1,2,4,…,2^(k-1),n-2^k+1（k是满足n-2^k+1>0的最大整数）的形式，且1～n之内的所有整数均可以唯一表示成1,2,4,…,2^(k-1),n-2^k+1中某几个数的和的形式。 证明如下： （1） 数列1,2,4,…,2^(k-1),n-2^k+1中所有元素的和为n，所以若干元素的和的范围为：[1, n]； （2）如果正整数t2^0+a12^1+…+ak*2^（k-1），其中ak=0或者1，表示t的第ak位二进制数为0或者1. （3）如果t>=2^k,设s=n-2^k+1，则t-s （证毕！） function mKnapsack(weights, values, numbers, W) { var kind = 0; //新的物品种类 var ws = []; //新的物品重量 var vs = []; //新的物品价值 var n = weights.length; /** * 二进制分解 * 100=1+2+4+8+16+32+37，观察可以得出100以内任何一个数都可以由以上7个数选择组合得到， * 所以对物品数目就不是从0都100遍历，而是0，1，2，4，8，16，32，37遍历，时间大大优化。 */ for (let i = 0; i = j) { ws[kind] = j * w; vs[kind] = j * v; num -= j; kind++; } else { ws[kind] = num * w; vs[kind] = num * v; kind++; break; } } } //01背包解法 var f = new Array(W + 1).fill(0); for (let i = 0; i = ws[i]; j--) { f[j] = Math.max(f[j], f[j - ws[i]] + vs[i]); } } return f[W]; } var b = mKnapsack([2, 3, 1], [2, 3, 4], [1, 4, 1], 6); console.log(b); //9 "},"算法/背包问题II.html":{"url":"算法/背包问题II.html","title":"背包问题 II","keywords":"","body":"背包问题 II 背包问题 II 标签 01背包问题 分数背包问题 other 一、 二、 标签 动态规划 贪心算法 01背包问题 背包问题是一个组合优化问题，它可以描述如下：给定一个固定大小、能够携重W的背包，以及一组有价值和重量的物品，找出一个最佳解决方案，使得装入背包的物品总重量不超过W，且总价值最大 下面是一个例子： 物品# 重量 价值 1 2 3 2 3 4 3 4 5 考虑背包能够携带的重量只有5， 对于这个例子，我们可以说最佳解决方案是往背包里装入物品1和物品2，这样，总重量为5, 总价值为7. 动态规划对分数版本无能为力 算法 function knapSack(capacity, weights, values, n) { var i, w, a, b, kS = []; for(i = 0; i b) ? a : b; // {4} max(a,b) } else { kS[i][w] = kS[i-1][w]; //{5} } } } return kS[n][capacity]; //{6} } knapSack(5, [2,3,4], [3,4,5], 3) // 7 解析： {1}: 首先，初始化将用于寻找解决方案的矩阵 kS[n+1][capacity+1] {2}: 忽略矩阵的第一列和第一行，只处理索引不为0的列和行 {3}: 物品i的重量必须小于约束(capacity)才有可能成为解决方案的一部分; 否则，总重量就会超出背包能够携带的重量，这是不可能发生的。发生这种情况时，只要忽略它，用之前的值就可以了(行{5})。 {4}: 当找到可以构成解决方案的物品时，选择价值最大的那个 {6}: 最后，问题的解决方案就在这个二维表格右下角的最后一个格子里 注意： 这个算法只输出背包携带物品架子的最大值，而不列出实际的物品，可以增加下面的附加函数来找出构成解决方案的物品 function findValues(n, capacity, kS, weights, values) { var i = n, k = capacity; console.log(\"解决方案包含以下物品： \")； while (i > 0 && k > 0) { if(kS[i][k] !== kS[i-1][k]) { console.log(`物品${i}, 重量： ${weights[i-1]}, 价值： ${values[i-1]}`); i--; k = k - kS[i][k]; } else { i--; } } } 完整算法： function knapSack(capacity, weights, values, n) { var i, w, a, b, kS = []; for (i = 0; i b ? a : b; //max(a,b) console.log(a + \" can be part of the solution\"); } else { kS[i][w] = kS[i - 1][w]; } } console.log(kS[i].join()); } //extra algorithm to find the items that are part of the solution findValues(n, capacity, kS, values, weights); return kS[n][capacity]; } function findValues(n, capacity, kS, weights, values) { var i = n, k = capacity; console.log(\"Items that are part of the solution:\"); while (i > 0 && k > 0) { if (kS[i][k] !== kS[i - 1][k]) { console.log(`物品${i}, 重量： ${weights[i-1]}, 价值： ${values[i-1]}`); i--; k = k - kS[i][k]; } else { i--; } } } var values = [3, 4, 5], weights = [2, 3, 4], capacity = 5, n = values.length; knapSack(capacity, weights, values, n) // 物品2, 重量： 4, 价值： 3 // 物品1, 重量： 3, 价值： 2 // 总价值7 分数背包问题 求解分数背包问题的算法与动态规划版本稍有不同。 在01背包问题中，只能向背包里装入完整的物品，而分数背包问题中，我们可以装入分数的物品。 我们用前面用过的例子来比较两者的差异，如下图所示 物品# 重量 价值 1 2 3 2 3 4 3 4 5 在动态规划的例子里， 我们考虑背包能够携带的重量只有5. 而在这个例子里，我们可以说最佳解决方案里是往背包里装入物品1和物品2，总重量为5，总价值为7. 如果在分数背包问题中考虑相同的容量，得到的结果是一样的， 因此我们考虑容量为6的情况 在这种情况下，解决方案是装入物品1和物品2，还有25%的物品3， 这样，重量为6的物 物品总价值为8.25。 算法 function knapSack(capacity, values, weights) { var n = values.length, load = 0, i = 0, val = 0; for(i = 0; i 解释 {1}: 总重量少于背包容量， 继续迭代，装入物品 {2}: 如果物品可以完整的装入背包，就将其价值和重量分别计入背包已装入物品的总价值(val)和总重量(load) {3}: 如果物品不能完整的装入背包，计算能够装入部分的比例(r) 如果在01背包问题中考虑同样的容量6，我们就会看到，物品1和物品3组成立解决方案，在这种情况下，对同一个问题应用不同的解决方法，会得到两种不同的结果 other 一、 /** *背包问题算法及个人理解 * * @param {*} weightLimit 背包重量限制 * @param {*} weightArray 物品重量组成的数组 * @param {*} valueArray 物品价值组成的数组。注意顺序要与重量数组对应 * @param {*} account 物品种类（number类型） */ function knapSack(weightLimit, weightArray, valueArray, account) { //ks是保存数据的二维数组，可以看做是矩阵 //初始化一个长度为account+1的二维空数组，每一个子数组都可以看成是选用多少个物品时的情况。 let ks = []; for (let i = 0; i 上述算法有一个前提，即每种物品只有一个。体现在算法上就是a = valueArray[i - 1] + ks[i - 1][w - weightArray[i - 1]];。 当前物品是values[i-1]，那么剩余重量的最优解就是ks[i - 1][w - weightArray[i - 1]]。 那么，如果同一物品不限量呢？ 将这个表达式改成a = valueArray[i - 1] + ks[ i ][w - weightArray[i - 1]]即可。 二、 function completeKnapsack(weights, values, W) { var f = [], n = weights.length; f[-1] = []; //初始化边界 for (var i = 0; i "},"React/React基础/react基础.html":{"url":"React/React基础/react基础.html","title":"React基础","keywords":"","body":"React 基础 reactjs 获取真实dom，并获取dom css 三种方法 方法1： let senderName = ReactDOM.findDOMNode(this.refs['sender-name']); let nleft = senderName.style.left; let ntop = senderName.style.top; let nwidth = senderName.style.width; let nheight = senderName.style.height; console.log(nleft,ntop,nwidth,nheight); 方法2： let rstyle = this.refs['sender-name'].style; let rleft = rstyle.left; let rtop = rstyle.top; let rwidth = rstyle.width; let rheight = rstyle.height; console.log(rleft,rtop,rwidth,rheight); 方法3： let computedStyle=document.defaultView.getComputedStyle(ReactDOM.findDOMNode(this.refs['sender-name']),null); let cleft = computedStyle.left; let ctop = computedStyle.top; console.log(cleft,ctop); "},"React/React基础/React生命周期分析.html":{"url":"React/React基础/React生命周期分析.html","title":"React生命周期分析","keywords":"","body":"React 生命周期分析 V16 生命周期函数用法建议 在 V16 版本中引入了 Fiber 机制。这个机制一定程度上的影响了部分生命周期的调用，并且也引入了新的 2 个 API 来解决问题。 在之前的版本中，如果你拥有一个很复杂的复合组件，然后改动了最上层组件的 state，那么调用栈可能会很长 调用栈过长，再加上中间进行了复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。Fiber 就是为了解决该问题而生。 Fiber 本质上是一个虚拟的堆栈帧，新的调度器会按照优先级自由调度这些帧，从而将之前的同步渲染改成了异步渲染，在不影响体验的情况下去分段计算更新。 对于如何区别优先级，React 有自己的一套逻辑。对于动画这种实时性很高的东西，也就是 16 ms 必须渲染一次保证不卡顿的情况下，React 会每 16 ms（以内） 暂停一下更新，返回来继续渲染动画。 对于异步渲染，现在渲染有两个阶段：reconciliation 和 commit 。前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。 Reconciliation 阶段 componentWillMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate Commit 阶段 componentDidMount componentDidUpdate componentWillUnmount 因为 reconciliation 阶段是可以被打断的，所以 reconciliation 阶段会执行的生命周期函数就可能会出现调用多次的情况，从而引起 Bug。所以对于 reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 以外，其他都应该避免去使用，并且 V16 中也引入了新的 API 来解决这个问题。 getDerivedStateFromProps 用于替换 componentWillReceiveProps ，该函数会在初始化和 update 时被调用 class ExampleComponent extends React.Component { // Initialize state in constructor, // Or with a property initializer. state = {} static getDerivedStateFromProps(nextProps, prevState) { if (prevState.someMirroredValue !== nextProps.someValue) { return { derivedData: computeDerivedState(nextProps), someMirroredValue: nextProps.someValue } } // Return null to indicate no change to state. return null } } getSnapshotBeforeUpdate 用于替换 componentWillUpdate ，该函数会在 update 后 DOM 更新前被调用，用于读取最新的 DOM 数据。 V16 生命周期函数用法建议 class ExampleComponent extends React.Component { // 用于初始化 state constructor() {} // 用于替换 `componentWillReceiveProps` ，该函数会在初始化和 `update` 时被调用 // 因为该函数是静态函数，所以取不到 `this` // 如果需要对比 `prevProps` 需要单独在 `state` 中维护 static getDerivedStateFromProps(nextProps, prevState) {} // 判断是否需要更新组件，多用于组件性能优化 shouldComponentUpdate(nextProps, nextState) {} // 组件挂载后调用 // 可以在该函数中进行请求或者订阅 componentDidMount() {} // 用于获得最新的 DOM 数据 getSnapshotBeforeUpdate() {} // 组件即将销毁 // 可以在此处移除订阅，定时器等等 componentWillUnmount() {} // 组件销毁后调用 componentDidUnMount() {} // 组件更新后调用 componentDidUpdate() {} // 渲染组件函数 render() {} // 以下函数不建议使用 UNSAFE_componentWillMount() {} UNSAFE_componentWillUpdate(nextProps, nextState) {} UNSAFE_componentWillReceiveProps(nextProps) {} } "},"React/React基础/setState.html":{"url":"React/React基础/setState.html","title":"setState","keywords":"","body":"setState setState 在 React 中是经常使用的一个 API，但是它存在一些问题，可能会导致犯错，核心原因就是因为这个 API 是异步的。 首先 setState 的调用并不会马上引起 state 的改变，并且如果你一次调用了多个 setState ，那么结果可能并不如你期待的一样。 handle() { // 初始化 `count` 为 0 console.log(this.state.count) // -> 0 this.setState({ count: this.state.count + 1 }) this.setState({ count: this.state.count + 1 }) this.setState({ count: this.state.count + 1 }) console.log(this.state.count) // -> 0 } 第一，两次的打印都为 0，因为 setState 是个异步 API，只有同步代码运行完毕才会执行。setState 异步的原因我认为在于，setState 可能会导致 DOM 的重绘，如果调用一次就马上去进行重绘，那么调用多次就会造成不必要的性能损失。设计成异步的话，就可以将多次调用放入一个队列中，在恰当的时候统一进行更新过程。 第二，虽然调用了三次 setState ，但是 count 的值还是为 1。因为多次调用会合并为一次，只有当更新结束后 state 才会改变，三次调用等同于如下代码 Object.assign( {}, { count: this.state.count + 1 }, { count: this.state.count + 1 }, { count: this.state.count + 1 } ) 当然也可以通过以下方式来实现调用三次 setState 使得 count 为 3 handle() { this.setState((prevState) => ({ count: prevState.count + 1 })) this.setState((prevState) => ({ count: prevState.count + 1 })) this.setState((prevState) => ({ count: prevState.count + 1 })) } 如果想在每次调用 setState 后获得正确的 state ，可以通过如下代码实现 handle() { this.setState((prevState) => ({ count: prevState.count + 1 }), () => { console.log(this.state) }) } "},"React/React基础/webpack4+babel7+React.html":{"url":"React/React基础/webpack4+babel7+React.html","title":"webpack4+babel7+React","keywords":"","body":"从零开始使用webpack 4, Babel 7创建一个React项目 从零开始使用webpack 4, Babel 7创建一个React项目 你会在本篇学到什么 初始化项目 安装配置webpack 初始化Babel 写React组件 在HTML文件引入bundle webpack dev Server 总结 你会在本篇学到什么 如何安装配置webpack 如何安装配置babel 如何安装react 如何创建两种React Component --- 容器/展示组件 在html文件中引用webpack生成的bundle文件 如何安装使用webpack dev server 初始化项目 首先我们先给项目创建一个文件夹 webpack-react-tutorial： mkdir webpack-react-tutorial && cd webpack-react-tutorial 接着在这个文件夹下创建一个src的子文件夹： mkdir -p src 初始化项目： npm init -y 安装配置webpack npm i webpack --save-devnpm i webpack-cli --save-dev 接着在package.json里添加webpack的指令 \"scripts\": { \"build\": \"webpack --mode production\" } 初始化Babel 为什么要使用Babel? React Component大多是用JS ES6语法来写的，而有些浏览器没办法运行ES6的语法，所以就需要工具来将ES6的代码转化成浏览器可以运行的代码（通常是es5的语法）。 webpack本身是不会做这件事情的，需要靠转换器：loader。 一个webpack loader作用就是把输入进去的文件转化成指定的文件格式输出。其中babel-loader负责将传入的es6文件转化成浏览器可以运行的文件。 babel-loader需要利用Babel，所以需要预先将Babel配置好。 babel preset env：将ES6的代码转成ES5(注意：babel-preset-es2015已经被废弃了) babel preset react: 将JSX语法编译成JS 接着安装这两个依赖： npm i @babel/core babel-loader @babel/preset-env @babel/preset-react --save-dev 不要忘了配置Babel! 首先要在webpack-react-tutorial文件夹里新建一个文件.babelrc，内容为 { \"presets\": [\"@babel/preset-env\", \"@babel/preset-react\"] } 到这个时候，就可以写一小部分webpack的配置文件了。 创建一个新的文件webpack.config.js，内容为 const path = require('path'); module.exports = { entry: './src/index.js', output: { filename: 'bundle.js', path: path.resolve(__dirname, 'dist') } module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: { loader: \"babel-loader\" } } ] } }; 写React组件 这里会写两种React组件：容器、展示组件。如果不了解这两种组件概念的同学可以先了解一下。 简单来说: 容器跟展示组件是React组件的两种模式。 容器组件: 一般比较重数据处理的逻辑会写在这，比如监听外界传入（例如redux） state的变化，或者处理组件内部的state，等等。 展示组件：顾名思义，就是仅仅用来展示的。它一般都是一个纯箭头函数，接受容器组件通过props传来的数据，然后展示我们希望展示的html结构。 在下面的例子中，你会看到它们长啥样。 在本节中，我们来创建只有text input 的超级简单的React表单。 首先先把React库引进来： npm i react react-dom --save-dev 然后创建两个子文件夹来分别放React 容器/展示组件 mkdir -p src/js/components/{container,presentational} 接着我们来写一个容器组件，它有下面的特点 有自己的state 渲染一个html表单 将这个容器组件放在container里 touch src/js/components/container/FormContainer.js 容器组件的代码如下： import React, { Component } from \"react\"; import ReactDOM from \"react-dom\"; class FormContainer extends Component { constructor() { super(); this.state = { title: \"\" }; } render() { return ( ); } } export default FormContainer; 到目前为止，这个组件还没啥用，它只是一个包裹着子展示组件的外壳。 所以我们来定义一下子组件Input吧。 我们知道html input有下列的属性： type class id value required 所有的这些属性都由容器组件通过props传给它，这种组件叫做controlled component。 写一个react组件，最好给它加上Prop Types，这样一来可以做输入的数据类型检测，二来别人用你的组件，可以很快知道这个组件需要什么input。 安装prop-types npm i prop-types --save-dev 接着写这个展示组件 import React from \"react\"; import PropTypes from \"prop-types\"; const Input = ({ label, text, type, id, value, handleChange }) => ( {text} ); Input.propTypes = { label: PropTypes.string.isRequired, text: PropTypes.string.isRequired, type: PropTypes.string.isRequired, id: PropTypes.string.isRequired, value: PropTypes.string.isRequired, handleChange: PropTypes.func.isRequired }; export default Input; 到这一步我们就可以在容器组件里渲染Input这个子组件了 import React, { Component } from \"react\"; import ReactDOM from \"react-dom\"; import Input from \"../presentational/Input\"; class FormContainer extends Component { constructor() { super(); this.state = { seo_title: \"\" }; this.handleChange = this.handleChange.bind(this); } handleChange(event) { this.setState({ [event.target.id]: event.target.value }); } render() { const { seo_title } = this.state; return ( ); } } export default FormContainer; 写好组件之后，就可以用webpack来打包这些代码啦。 由于前面我们已经定义了webpack入口文件是 ./src/index.js，所以我们先创建一个index.js文件，在里面引入React组件 import FormContainer from \"./js/components/container/FormContainer\"; 写好之后，激动人心的时刻到了! 我们终于可以通过运行 npm run build 来生成打包文件，由于我们在配置里定义了输出文件为：dist/bundle.js，所以一切顺利的话， 你现在应该可以看到一个新生成的dist文件，里面有一个bundle.js文件。 在HTML文件引入bundle 为了展示我们的React组件，我们需要让webpack生成一个html文件。上面我们生成的bundle.js就会放在这个html文件的script标签里。 webpack需要两个工具来生成这个html文件：html-webpack-plugin跟html-loader 首先添加这两个依赖： npm i html-webpack-plugin html-loader --save-dev 然后更新webpack的配置文件 const HtmlWebPackPlugin = require(\"html-webpack-plugin\"); module.exports = { module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: { loader: \"babel-loader\" } }, { test: /\\.html$/, use: [ { loader: \"html-loader\" } ] } ] }, plugins: [ new HtmlWebPackPlugin({ title: 'Set Up Project', filename: \"./index.html\" }) ] }; index.html是我们的模板文件，里面定义了React Component需要插入进入的容器create-article-form，不要忘了在FormContainer里用React.render绑定这个。 Getting Started 在./src/js/components/container/FormContainer.js 加上下面的代码： const wrapper = document.getElementById(\"create-article-form\"); wrapper ? ReactDOM.render(, wrapper) : false; 最后，在跑一次构建： npm run build 这时候在dist文件夹里就会看到生成的html文件，由于html-webpack-plugin，bundle文件会被自动注入html里。 在浏览器里打开./dist/index.html，你会看到这个React表单。 webpack dev Server 目前为止，我们来遗留一个问题：每次修改文件的时候，都需要重新跑一次编译 npm run build 这样是很麻烦的，我们想达到的效果是自动重新编译。 达到这个目标很简单，只需要3行配置就可以启动运行一个开发服务器。 启动服务器之后webpack就会在浏览器里启动你的应用，而且当你修改保存代码之后，webpack dev server还会自动刷新浏览器的窗口。 在启动webpack dev server前，需要先安装npm i webpack-dev-server --save-dev 打开package.json 加入start script \"scripts\": { \"start\": \"webpack-dev-server --open --mode development\", \"build\": \"webpack\" } 保存这个文件，最后在跑这个命令 npm start 你会在你的浏览器里看到你的应用。 接下来你可以随意修改一下文件内容，会看到webpack dev server会自动刷新浏览器窗口。 总结 通过上面的学习，我们已经看到如何从零用webpack 与Babel搭建一个React项目，包括 如何安装配置webpack 如何安装配置Babel 如何安装React 如何创建React容器/展示组件 如何在html里插入bundle文件 如何安装和配置webpack dev server "},"React/React基础/React-Router页面传值的三种方法.html":{"url":"React/React基础/React-Router页面传值的三种方法.html","title":"React Router页面传值的三种方法","keywords":"","body":"React Router页面传值的三种方法 React Router页面传值的三种方法 一. props.params 二.query 三.state 本文主要介绍React Router定义路由之后如何传值，有关React和React Router 注：本文示例React Router版本为：3.0.2，使用前请注意检查版本 一. props.params 官方例子使用React router定义路由时，我们可以给指定一个path，然后指定通配符可以携带参数到指定的path： 首先定义路由到UserPage页面: import { Router,Route,hashHistory} from 'react-router'; class App extends React.Component { render() { return ( ) } } 上面指定参数一个参数name 使用： import {Link,hashHistory} from 'react-router'; Link组件实现跳转： 用户 history跳转： hashHistory.push(\"/user/sam\"); 当页面跳转到UserPage页面之后，取出传过来的值： export default class UserPage extends React.Component{ constructor(props){ super(props); } render(){ return(this.props.params.name) } } 上面的方法可以传递一个或多个值，但是每个值的类型都是字符串，没法传递一个对象,如果传递的话可以将json对象转换为字符串，然后传递过去，传递过去之后再将json字符串转换为对象将数据取出来 如：定义路由： 使用： var data = {id:3,name:sam,age:36}; data = JSON.stringify(data); var path = `/user/${data}`; // 1 用户 //2 hashHistory.push(path); 获取数据： var data = JSON.parse(this.props.params.data); var {id,name,age} = data; 通过这种方式跳转到UserPage页面时只能通过传递字符串来传递参数，那么是否有其他方法来优雅地直接传递对象而不仅仅是字符串呢？ 二.query query方式使用很简单，类似于表单中的get方法，传递参数为明文： 首先定义路由： 使用： var data = {id:3,name:sam,age:36}; var path = { pathname:'/user', query:data, } // 1 用户 // 2 hashHistory.push(path); 获取数据： var data = this.props.location.query; var {id,name,age} = data; query方式可以传递任意类型的值，但是页面的URL也是由query的值拼接的，URL很长，那么有没有办法类似于表单post方式传递数据使得传递的数据不以明文传输呢？ 三.state state方式类似于post方式，使用方式和query类似， 首先定义路由： 使用： var data = {id:3,name:sam,age:36}; var path = { pathname:'/user', state:data, } // 1 用户 // 2 hashHistory.push(path); 获取数据： var data = this.props.location.state; var {id,name,age} = data; state方式依然可以传递任意类型的数据，而且可以不以明文方式传输。 可以在实现后对比地址栏的URL来观察三种传值方式URL的区别 "},"React/React进阶/实现react服务器渲染基础方法.html":{"url":"React/React进阶/实现react服务器渲染基础方法.html","title":"实现react服务器渲染基础法","keywords":"","body":"实现react服务器渲染基础方法 实现react服务器渲染基础方法 前言 用到的技术栈 为什么要用服务端渲染 实现 搭建 koa 环境 安装React 配制webpack 代码 从零开始最小实现react服务器渲染详解 前言 最近在写 koa 的时候想到，如果我部分代码提供api，部分代码支持ssr，那我应该如何写呢？（不想拆成 2个服务的情况下） 而且最近写的项目里面也用过一些服务端渲染，如nuxt，自己也搭过next的项目，确实开发体验都非常友好，但是友好归友好，具体又是如何实现的呢，诸位有没有考虑过？ 用到的技术栈 react 16 + webpack3 + koa2 为什么要用服务端渲染 优点 SEO 友好 加快首屏渲染，减少白屏时间 让服务器把有内容的HTML返回给我们，事件的话浏览器再渲染一次来进行挂载 实现 搭建 koa 环境 新建一个 ssr 项目，并在项目中初始化 npm mkdir ssr && cd ssr npm init 下面的代码我们用到了 import jsx 等语法，node环境是不支持的，所以需要配置babel在当前项目中新建文件 app.js跟index.js，然后babel的入口， index.js代码如下 require('babel-core/register')() require('babel-polyfill') require('./app') 我们项目的入口， app.js代码如下 import Koa from 'koa' const app = new Koa() // response app.use((ctx) => { ctx.body = 'Hello Koa' }) app.listen(3000) console.log(\"系统启动，端口：3000\") 根目录下新建一个.babelrc文件 内容是： { \"presets\": [\"react\", \"env\"] } 安装上面所需要的依赖 npm install babel-core babel-polyfill babel-preset-env babel-preset-react nodemon --save-dev npm i koa --save 配置启动脚本 package.json \"scripts\": { \"dev\": \"nodemon index.js\", } 到这里你运行 npm run dev 打开localhost:3000 你就会看到 hello Koa了 安装React cnpm install react react-dom --save 在根目录下新建一个app文件夹，并在文件夹中个新建一个main.js main.js代码如下 import React from 'react' export default class Home extends React.Component { render () { return hello world } } 修改之前server.js import Koa from 'koa' import React from 'react' import { renderToString } from 'react-dom/server' import App from './app/main' const app = new Koa() // response app.use(ctx => { let str = renderToString() ctx.body = str }) app.listen(3000) console.log('系统启动，端口：8080') 这个时候再 npm run dev 你就会看到屏幕上出现hello world 再打开chrome 开发者工具查看我们的请求： 我们的最简单的react组件变成str传了进来 这里我们用到了一个方法： renderToString – 其实就是将组件渲染成字符串 目前为止，我们都还没有给组件加上事件等交互行为，下面那让我们来试一下 修改main.js的代码 import React from 'react' export default class Home extends React.Component { render () { return window.alert(123)}>hello world } } 再刷新一下我们的页面，，咦，是不是没有什么卵用 那是因为后端只能讲组件渲染成一串html的字符串，事件绑定等事情都是需要在浏览器端执行的 那事件我们改怎么绑定上去呢？ 那你肯定就会猜到，既然服务器渲染出来的是一串html，挂载事件的方式是不是在浏览器重新渲染一次就好了呢 配制webpack 在根目录下面新建一个 webpack.config.js 下面是webpack.config.js的内容： var path = require('path') var webpack = require('webpack') module.exports = { entry: { main: './app/index.js' }, output: { filename: '[name].js', path: path.join(__dirname, 'public'), publicPath: '/' }, resolve: { extensions: ['.js', '.jsx'] }, module: { loaders: [ { test: /\\.jsx?$/, loaders: ['babel-loader'], } ] } } 上面的配置将entry设置成了app/index.js文件 那我们就创建一个 下面是app/index.js的代码： import Demo from './main' import ReactDOM from 'react-dom' import React from 'react' ReactDOM.render(, document.getElementById('root')) 因为浏览器渲染需要将根组件挂载到某个dom节点上，所以给我们的react代码设置一个入口 这个时候就有一个问题，就是，document对象node环境下并不存在，那怎么解决的呢？ 不存在？不存在那我就不用就好了，SSR核心就是让请求的url里面返回具体HTML内容，事件什么的并不care，那么我就把根组件直接renderToString 返回出来就好了呗 下面修改我们的服务代码，让代码支持服务器渲染 新增一点依赖 cnpm i --save koa-static koa-views ejs koa-static： 处理静态文件的中间件 koa-views： 配置模板的中间件 ejs：一个模板引擎 修改server.js的代码 import Koa from 'koa' import React from 'react' import { renderToString } from 'react-dom/server' import views from 'koa-views' import path from 'path' import Demo from './app/main' const app = new Koa() // 将/public文件夹设置为静态路径 app.use(require('koa-static')(__dirname + '/public')) // 将ejs设置为我们的模板引擎 app.use(views(path.resolve(__dirname, './views'), { map: { html: 'ejs' } })) // response app.use(async ctx => { let str = renderToString() await ctx.render('index', { root: str }) }) app.listen(3000) console.log('系统启动，端口：8080') 下面新建我们的渲染模板 新建一个views文件夹 里面新建一个index.html： Document 这个 html 里面可以放一些变量，比如这个，就是等下要放renderToString结果的地方 /main.js则是react构建出来的代码 下面直接来测试一下我们的代码 在 package.json里面 新增： \"scripts\": { \"dev\": \"nodemon index.js\", \"build\": \"webpack\" }, 运行 npm run build， 构建出我们的react代码 npm run dev 点击一下代码，是不是会 alert(123) tada 撒花，恭喜你，一个最简单服务器渲染就已经完成 到这里核心的思想就都已经讲完了，总结来说就下面三点： 起一个node服务 把react 根组件 renderToString渲染成字符串一起返回前端 前端再重新render一次 代码 仓库 "},"React/React进阶/React实现Toast（提示）效果.html":{"url":"React/React进阶/React实现Toast（提示）效果.html","title":"React实现Toast（提示）效果","keywords":"","body":"React实现Toast（提示）效果 React实现Toast（提示）效果 效果图 需求 使用方法 组件分析 Notification开发 Notice开发 Toast封装 总结 参考链接 效果图 需求 项目中需要实现app中常见的提示效果Toast。这个效果看似简单，实现起来没有那么容易。首先Toast的使用方法必须十分简单，简单到一行代码搞定： Toast.info('普通的Toast我普通的摇！！', 3000); 随时用随时调用上述方法即可。 再有一点，Toast不用插入到页面中，他不会向其他组件一样一直出现在DOM中。 只有在调用该方法的时候，动态插入到DOM中。 还有，页面可以存在多个提示，多个提示单独存在，互不影响。 所以，实现Toast并不像其他组件那么普通。 使用方法 这次先来看看效果图中的使用代码： import React from 'react' import ListTitle from '../../components/DataDisplay/ListTitle' import Button from '../../components/DataEntry/Button' import Toast from '../../components/Feedback/Toast' import Tools from '../../components/Tools/Tools' const ToastPage = () => { const commonInfo = () => { Toast.info('普通的Toast我普通的摇！！', 3000); }; const commonSuccess = () => { Toast.success('操作成功', 3000, 'fa-check'); }; const commonError = () => { Toast.error('有错误！！', 3000, undefined, false, ()=>{console.log(\"callback\");}); }; const commonToast = () => { Toast.info('欢迎来到本直播间', 3000, undefined, false); }; const successToast = () => { Toast.success('操作成功！', 3000, 'fa-check', false); }; const errorToast = () => { Toast.error('操作失败！', 3000, 'fa-times', false); }; const warningToast = () => { Toast.warning('警告：手机2s后爆炸', 3000, 'fa-exclamation-triangle', false); }; const loadingToast = () => { Toast.show('加载中...', 0, 'fa-circle-o-notch fa-spin', false); const timer = setTimeout(()=>{ Toast.hide(); clearTimeout(timer); }, 3000); }; return ( {Tools.linkTo(\"/index\")}}> Toast 纯文字提示 icon成功提示有蒙版 纯文字报错提示有回调 普通提示 成功提示 失败提示 警告 加载中 ) }; export default ToastPage 可以看到在ToastPage中，render return出来的DOM中没有。 只是在点击Button的回调中直接调用的Toast。 按理说，组件都应该在render时候return出来，Toast是怎么实现在React中动态添加删除DOM的。 组件分析 首先多个提示可以堆叠，不同提示定制化也不同，很显然是个组件，起名为Notice。 然后Notice外面还有个容器组件，用来装载Notice并且，暴露一些方法给Toast，起名Notification。 最后就是Toast组件，负责直接生成不同的Notice，或者销毁Notification。但是其实Toast只是个对象，而不是真正意义的组件。 所以简单的Toast其实是也是分成三部分来完成。 Toast -> Notification -> Notice * n; 接下来就是逐个开发。 Notification开发 为什么要先开发Notification，因为他特别重要，起到承上启下的作用。 首先，Notification是个容器，他自己有state，state中的notices数组就是存放生成Notice关键的数据notice（每个Notice都是不同的，所以notice中比如有一个属性：key）。 然后render的时候，循环notices生成一段DOM节点，放到自己的div中。 同时，其还提供一个向notices中添加notice的方法（add）和根据key，在notices中删除notice的方法（remove）。 最后关键的地方，定义一个reRwrite方法，该方法接受一些参数，动态的向DOM中插入一个div，然后再向这个div中插入Notification，最后返回一个含有几个操作这个Notification的方法的对象。（这就是动态实现插入DOM的关键） Notification的代码： // Notification是Notice父组件，容器 // 是动态插入和删除DOM节点的核心 // 同时也向上暴露给Toast重写改变自己的方法 import React from 'react' import ReactDOM from 'react-dom' import Notice from './Notice' class Notification extends React.Component { constructor (props) { super(props); this.state = { notices: [], // 存储当前有的notices hasMask: true, // 是否显示蒙版 } } add (notice) { // 添加notice // 创造一个不重复的key const {notices} = this.state; const key = notice.key ? notice.key : notice.key = getUuid(); const mask = notice.mask ? notice.mask : false; const temp = notices.filter((item) => item.key === key).length; if(!temp){ // 不存在重复的 添加 notices.push(notice); this.setState({ notices: notices, hasMask: mask }); } } remove (key) { // 根据key删除对应 this.setState(previousState => { return { notices: previousState.notices.filter(notice => notice.key !== key), }; }); } getNoticeDOM () { const _this = this; const {notices} = this.state; let result = []; notices.map((notice)=>{ // 每个Notice onClose的时候 删除掉notices中对应key的notice const closeCallback = () => { _this.remove(notice.key); // 如果有用户传入的onClose 执行 if(notice.onClose) notice.onClose(); }; result.push( ); }); return result; } getMaskDOM () { const {notices, hasMask} = this.state; // notices为空的时候 不显示蒙版 // 始终只有一个蒙版 if(notices.length > 0 && hasMask == true) return ; } render () { const noticesDOM = this.getNoticeDOM(); const maskDOM = this.getMaskDOM(); return ( {maskDOM} {noticesDOM} ) } } // 统计notice总数 防止重复 let noticeNumber = 0; // 生成唯一的id const getUuid = () => { return \"notification-\" + new Date().getTime() + \"-\" + noticeNumber++; }; // Notification增加一个重写方法 // 该方法方便Notification组件动态添加到页面中和重写 Notification.reWrite = function (properties) { const { ...props } = properties || {}; let div; div = document.createElement('div'); document.body.appendChild(div); const notification = ReactDOM.render(, div); return { notice(noticeProps) { notification.add(noticeProps); }, removeNotice(key) { notification.remove(key); }, destroy() { ReactDOM.unmountComponentAtNode(div); document.body.removeChild(div); }, component: notification } }; export default Notification 看了Notification其实谜团就解开了，Notice其实就是根据notices中的notice渲染出来的组件，Toast其实就是调用Notification.reWrite返回结果的集合。 Notice开发 这时候在写Notice就简单了，其props有几个关键的参数duration就是Notice显示几秒，content就是其显示的具体内容，onClose就是该销毁时候执行的回调函数。 这里面控制Notice显示几秒，实际上是用定时器setTimeout实现的，onClose实际上就是在父组件Notification中将自己对应的notice删除。 Notice代码： // Notice是Toast最底层组件 // 每个黑色的小框框其实都是一个Notice // Notice核心就是组件初始化的时候 生成一个定时器 // 根据输入的时间 加载一个动画 然后执行输入的回调 // Notice的显示和隐藏收到父组件Notification的绝对控制 import React from 'react' import classNames from 'classnames' class Notice extends React.Component { static propTypes = { duration: React.PropTypes.number, // Notice显示时间 content: React.PropTypes.any, // Notice显示的内容 onClose: React.PropTypes.func // 显示结束回调 }; static defaultProps = { duration: 3000, }; constructor (props) { super(props); this.state = { shouldClose: false, // 是否开启关闭动画 } } componentDidMount () { if(this.props.duration > 0){ this.closeTimer = setTimeout(() => { this.close(); }, this.props.duration - 300); // 减掉消失动画300毫秒 } } componentWillUnmount () { // 当有意外关闭的时候 清掉定时器 this.clearCloseTimer(); } clearCloseTimer () { if (this.closeTimer) { clearTimeout(this.closeTimer); this.closeTimer = null; } } close () { // 关闭的时候 应该先清掉倒数定时器 // 然后开启过场动画 // 等待动画结束 执行回调 this.clearCloseTimer(); const _this = this; _this.setState({shouldClose: true}); this.timer = setTimeout(()=>{ if(this.props.onClose){ this.props.onClose(); } clearTimeout(_this.timer); }, 300); } render () { const {shouldClose} = this.state; return ( {this.props.content} ) } } export default Notice Toast封装 最后看下Toast就比较简单了。 Toast首先就是要利用Notification.reWrite初始化一个newNotification，并且保持这个Notification为单例。 然后封装一个notice方法，动态的改变这个newNotification。 最后封装几个常用notice方法暴露出去。 Toast代码： import React from 'react' import classNames from 'classnames' import Notification from './Notification' // Toast组件比较特殊 // 因为不会被直接渲染在DOM中 // 而是动态插入页面中 // Toast组件核心就是通过Notification暴露的重写方法 动态改变Notification let newNotification; // 获得一个Notification const getNewNotification = () => { // 单例 保持页面始终只有一个Notification if (!newNotification) { newNotification = Notification.reWrite(); } return newNotification; }; // notice方法实际上就是集合参数 完成对Notification的改变 const notice = (content, type, icon, duration = 3000, onClose, mask = true) => { let notificationInstance = getNewNotification(); notificationInstance.notice({ duration, mask: mask, content: !!icon ? ( {content} ) : ( {content} ), onClose: () => { if (onClose) onClose(); }, }); }; export default { // 无动画 show(content, duration, icon, mask, onClose) { return notice(content, undefined, icon, duration, onClose, mask); }, // 翻转效果 info(content, duration, icon, mask, onClose) { return notice(content, 'info', icon, duration, onClose, mask); }, // 缩放效果 success(content, duration, icon, mask, onClose) { return notice(content, 'success', icon, duration, onClose, mask); }, // 从下方滑入 warning(content, duration, icon, mask, onClose) { return notice(content, 'warning', icon, duration, onClose, mask); }, // 抖动 error(content, duration, icon, mask, onClose) { return notice(content, 'error', icon, duration, onClose, mask); }, // 销毁 hide() { if (newNotification) { newNotification.destroy(); newNotification = null; } }, } 这样Toast，一个在React中动态插入删除DOM的组件完成了。 总结 这里的Toast，Notification和Notice都是参照antd-mobile源码改写的，这种组件暴露方法给别人调用的场景，和动态插入DOM场景平时不多见，借助其源码也是一次学习。 参考链接 项目源码 antd-mobile react-component "},"React/React进阶/React进阶之路.html":{"url":"React/React进阶/React进阶之路.html","title":"React进阶之路","keywords":"","body":"《React进阶之路》 - 笔记 《React进阶之路》 - 笔记 1、简介 2、React PropTypes 定义组件的属性类型和默认属性 3、组件的生命周期 3.1 3.2 React 16.3 生命周期的变化 Fiber 架构 4、事件处理 5、React 16 新特性 5.1 render新的返回类型 5.2 错误处理 5.3 Portals 5.4 自定义DOM属性 5.5 API 的变化 被拆开的 componentWillReceiveProps 5.5.1 getDerivedStateFromProps 5.5.2 componentDidUpdate() 5.5.3 getSnapshotBeforeUpdate() 5.5.4 Ref 6、优化组件 7、React.memo 8、高阶组件（HOC） 8.1 高阶组件的基本形式 8.2 用高阶组件抽取共同逻辑 8.3 高阶组件的高级用法 8.4 链式调用高阶组件 8.5 不要滥用高阶组件 9、render props 模式 9.1 render props 9.2 传递 props 9.3 不局限于 children 9.4 依赖注入 9.5 render props 和高阶组件的比较 9.6 小结 10、 提供者模式 10.1 问题场景 10.2 提供者模式 10.3 如何实现提供者模式 10.4 React v16.3.0 之前的提供者模式 10.5 React v16.3.0 之后的提供者模式 10.6 两种提供者模式实现方式的比较 10.7 小结 11、MVC/MVVM/Flux 11.1 MVC 11.1.1 MVC模式中的3种角色 11.2 MVVM的演变 11.3 MVC的问题 11.4 Flux 12、PureComponent 13、Redux 中间件和异步 13.1 react-redux 1、简介 React 通过引入虚拟DOM、状态、单项数据流等设计理念，形成以组件为核心，用组件搭建UI的开发模式，理顺了UI的开发过程，完美的将数据、组件状态和UI映射到一起，极大地提高了开发大型Web应用的效率 React特点可以归结为以下四点 声明式的视图层 简单的更新流程 灵活的渲染实现 高效的DOM操作 2、React PropTypes 定义组件的属性类型和默认属性 在React 16版本之后, PropTypes 从react包 换到了prop-types包中,所以想要使用PropTypes 需要这样: yarn add prop-types 在需要引入的地方使用: import PropTypes from 'prop-types'; 组件属性类型和PropTypes属性的对应关系 类型 PropTypes对应关系 String PropTypes.string Number PropTypes.number Boolean PropTypes.bool Function PropTypes.func Object PropTypes.object Array PropTypes.array Symbol PropTypes.symbol Element(React元素) PropTypes.element Node(可被渲染的节点：数字、字符串、React元素或由这些类型的数据组成的数组) PropTypes.node 当使用PropTypes.object 或 PropTypes.array 校验属性类型时， 我们只知道这个属性是一个对象或一个数组，至于对象的结构或数组元素的类型是什么样的，依然无从得知， 这种情况下更好的做法是使用 PropTypes.shape 或 PropTypes.arrayOf ， 例如 style: PropTypes.shape({ color: PropTypes.string, fontSize: PropTypes.number }), sequence: PropTypes.arrayOf(PropTypes.number) 表示style是一个对象，对象有color和fontSize两个属性，color是字符串类型，fontSize是数字类型； sequence是一个数组，数组的元素是数字 验证组件实例的属性是否符合要求 Todo.propTypes = { //isRequired 代表该参数是必须的 remove: PropTypes.func.isRequired, //必须而且必须是函数 todo: PropTypes.object, //非必须 可传可不传 title: PropTypes.string.isRequired, }; var data = 123; render( , //此处验证不会通过 document.body ); 组件的属性可以接收任意的值，数字，函数，字符串等 // 可以声明 prop 为指定的 JS 基本类型。默认 // 情况下没有isRequired，这些 prop 都是可传可不传的。 optionalArray: React.PropTypes.array, optionalBool: React.PropTypes.bool, optionalFunc: React.PropTypes.func, optionalNumber: React.PropTypes.number, optionalObject: React.PropTypes.object, optionalString: React.PropTypes.string, optionalSymbol: PropTypes.symbol, // 所有可以被渲染的对象：数字， // 字符串，DOM 元素或包含这些类型的数组。 optionalNode: React.PropTypes.node, // React 元素 optionalElement: React.PropTypes.element, // 用 JS 的 instanceof 操作符声明 prop 为类的实例。 optionalMessage: React.PropTypes.instanceOf(Message), // 用 enum 来限制 prop 只接受指定的值。 可以限制属性值是某个特定值之一 optionalEnum: React.PropTypes.oneOf(['News', 'Photos']), // 指定的多个对象类型中的一个 限制它为列举类型之一的对象 optionalUnion: React.PropTypes.oneOfType([ React.PropTypes.string, React.PropTypes.number, React.PropTypes.instanceOf(Message) ]), // 指定类型组成的数组 一个指定元素类型的数组 optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number), // 指定类型的属性构成的对象 一个指定类型的对象 optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number), // 特定形状参数的对象 一个指定属性及其类型的对象 optionalObjectWithShape: React.PropTypes.shape({ color: React.PropTypes.string, fontSize: React.PropTypes.number }), // 你也可以在任何 PropTypes 属性后面加上 `isRequired` // 后缀，这样如果这个属性父组件没有提供时，会打印警告信息 requiredFunc: PropTypes.func.isRequired, // 任意类型的数据 requiredAny: PropTypes.any.isRequired, // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接 // 使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。 customProp: function(props, propName, componentName) { if (!/matchme/.test(props[propName])) { return new Error('Validation failed!'); } } // 不过你可以提供一个自定义的 `arrayOf` 或 `objectOf` // 验证器，它应该在验证失败时返回一个 Error 对象。 它被用 // 于验证数组或对象的每个值。验证器前两个参数的第一个是数组 // 或对象本身，第二个是它们对应的键。 customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) { if (!/matchme/.test(propValue[key])) { return new Error( 'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); } }) 限制单个子元素 通过PropTypes.element你可以指定只能有一个子元素被作为children传递给一个组件。 import PropTypes from 'prop-types'; class MyComponent extends React.Component { render() { // This must be exactly one element or it will warn. const children = this.props.children; return ( {children} ); } } MyComponent.propTypes = { children: PropTypes.element.isRequired }; 默认prop值 可以定义props的默认值通过分配特殊的defaultProps属性： class Greeting extends React.Component { render() { return ( Hello, {this.props.name} ); } } // 为属性指定默认值 Greeting.defaultProps = { name: 'Stranger' }; // 渲染\"Hello, Stranger\": ReactDOM.render( , document.getElementById('example') ); 如果你在使用像 transform-class-properties 的 Babel 转换器，你也可以在React 组件类中声明 defaultProps 作为静态属性。这个语法还没有最终通过，在浏览器中需要一步编译工作。更多信息，查看类字段提议。 class Greeting extends React.Component { static defaultProps = { name: 'stranger' } render() { return ( Hello, {this.props.name} ) } } 3、组件的生命周期 3.1 挂载阶段 constructor componentWillMount render componentDidMount 更新阶段 componentWillReceiveProps(nextProps) shouldComponentUpdate(nextProps, nextState) componentWillUpdate(nextProps, nextState) render componentDidUpdate(prevProps, prevState) 卸载阶段 componentWillUnmount 3.2 React 16.3 生命周期的变化 Fiber 架构 生命周期函数的更改是因为 16.3 采用了 Fiber 架构，在新的 Fiber 架构中，组件的更新分为了两个阶段： render phase：这个阶段决定究竟哪些组件会被更新。 commit phase：这个阶段是 React 开始执行更新（比如插入，移动，删除节点）。 commit phase 的执行很快，但是真实 DOM 的更新很慢，所以 React 在更新的时候会暂停再恢复组件的更新以免长时间的阻塞浏览器，这就意味着 render phase 可能会被执行多次（因为有可能被打断再重新执行）。 constructor componentWillMount componentWillReceiveProps componentWillUpdate getDerivedStateFromProps shouldComponentUpdate render setState updater functions (the first argument) 这些生命周期都属于 render phase，上面已经说了，render phase 可能被多次执行，所以要避免在 render phase 中的生命周期函数中引入副作用。但是 16.3 之前的生命周期很容易引入副作用，所以 16.3 之后引入新的生命周期来限制开发者引入副作用。 4、事件处理 React中的事件是合成事件，并不是原生的DOM事件。React根据W3C规范定义了一套兼容各个浏览器的事件对象。 在DOM事件中，可以通过处理函数返回false来阻止事件的默认行为，但在React事件中，必须显示地调用事件对象的preventDefault方法来阻止事件的默认行为， 除了这一点外，DOM事件和React事件在使用上并无差别，如果在某些场景下必须使用DOM提供的原生事件，可以通过React事件对象的nativeEvent属性获取 React事件处理函数的写法主要有三种方式 使用箭头函数 使用组件方法 使用bind会创建一个新的函数，因此这种写法依然存在每次render都会创建一个新函数的问题 属性初始化语法（property initializer syntax） 使用 ES7 的property initializers 会自动为class中定义的方法绑定this 5、React 16 新特性 5.1 render新的返回类型 React 16之前， render方法必须返回单个元素，现在，render方法支持两种新的返回类型： 数组(由React元素组成) 和 字符串 定义一个 ListComponent 组件，它的render方法返回数组 import React, { Component } from \"react\"; export default class App extends Component { render() { return [ , ]; } } class ListComponent extends Component { render() { return [ First item, Second item, Third item ]; } } class StringComponent extends Component { render() { return \"Just a strings\"; } } 5.2 错误处理 React 16 之前，组件在运行期间如果执行出错，就会阻塞整个应用的渲染，这时候只能刷新页面才能恢复应用。 React 16 引入了新的错误处理机制，默认情况下，当组件中抛出错误时，这个组件会从组件树中卸载，从而避免整个应用的崩溃。这种方式比起之前的处理方式有所进步，但用户体验依然不够好。 React 16 还提供了一种更加友好的错误处理方式 -- 错误边界（Error Boundaries)， 错误边界是能够捕获子组件的错误并对其做优雅处理的组件。 优雅的处理可以是输出错误日志、显示出错提示等，显然这比直接写在组件要更加友好 定义了 componentDidCatch(error, info) 这个方法的组件将成为一个错误边界，现在我们创建一个组件ErrorBoundary import React, { Component } from \"react\"; const Profile = ({ user }) => name: {user.name}; class ErrorBoundary extends Component { constructor(props) { super(props); this.state = { hasError: false }; } componentDidCatch(err, info) { // 显示错误UI this.setState({ hasError: true }); // 同时输出错误日志 console.log(err, info); } render() { if (this.state.hasError) { return Oops, something went wrong!; } return this.props.children; } } class App extends Component { constructor(props) { super(props); this.state = { user: { name: \"react\" } }; } // 将user置为null，模拟异常 onClick = () => { this.setState({ user: null }); }; render() { return ( 更新 ); } } export default App; 5.3 Portals React 16的Portals特性让我们可以把组件渲染到当前组件树以外的DOM节点上，这个特性典型的应用场景是渲染应用的全局弹框，使用Portals后，任意组件都可以将弹窗组件渲染到根节点上，以方便弹框的显示。 Portals的实现以来ReactDOM的一个新的API: ReactDOM.createPortal(child, container) 第一个参数child是可以被渲染的React节点，例如React元素、由React元素组成的数组、字符串等， container是一个DOM元素，child将被挂载到这个DOM节点 我们创建一个Modal组件，Modal使用 ReactDOM.createPortal() 在DOM根节点上创建一个弹框： import React, { Component } from \"react\"; import ReactDOM from \"react-dom\"; class Modal extends Component { constructor(props) { super(props); // 根节点下创建一个div节点 this.container = document.createElement(\"div\"); document.body.appendChild(this.container); } componentWillUnmount() { document.body.removeChild(this.container); } render() { // 创建的DOM树挂载到this.container指向的div节点下面 return ReactDOM.createPortal( &times; {this.props.children} , this.container ); } } // APP class App extends Component { constructor(props) { super(props); this.state = { showModal: true }; } // 关闭弹框 closeModal = () => { this.setState({ showModal: false }); }; render() { return ( Dashboard {this.state.showModal && ( Modal Dialog )} ); } } export default App; 5.4 自定义DOM属性 React 16 之前会忽略不识别的 HTML和SVG属性，现在React会把不识别的属性传递给DOM元素 例如， React 16 之前，下面的React元素 在浏览器中渲染出的DOM节点为： 而React 16渲染出的DOM节点为： 5.5 API 的变化 被拆开的 componentWillReceiveProps 5.5.1 getDerivedStateFromProps react 16.3 新加入的 API，对标的是之前的 componentWillReceiveProps，在一个组件已经实例化后，re-render 之前被调用。这个新的生命周期具有如下特点： 无副作用 —— 因为是处于 Fiber 的 render 阶段，所以有可能会被多次执行。所以 API 被设计为了静态函数，无法访问到实例的方法，也没有 ref 来操作 DOM，这就避免了实例方法带来副作用的可能性。但是依旧可以从 props 中获得方法触发副作用，所以在执行可能触发副作用的函数前要三思。 只用来更新 state —— 其实看名字也可以知道，这个生命周期唯一的作用就是从 nextProps 和 prevState 中衍生出一个新的 state。 虽然 getDerivedStateFromProps 对标的是 componentWillReceiveProps，但是 componentWillReceiveProps 作为 16.3 之前的“大杂烩“周期，各种脏活累活都能干。在 16.3 之后 componentWillReceiveProps 要通过 getDerivedStateFromProps 与 componentDidUpdate 合力才能替代。之所以要分拆 componentWillReceiveProps，我个人认为有两方面的原因： Fiber 架构导致组件的更新被随时打断再重来，所以 componentWillReceiveProps 可能会被执行多次，但是无法阻止开发者在 componentWillReceiveProps 中引入副作用（事实上 componentWillReceiveProps 是开发者最喜欢引入副作用的生命周期），所以只能将这个 API 拆成在 render phase 中的纯函数 getDerivedStateFromProps 和在 commit phase 中的 componentDidUpdate 来让组件更好预测和维护。 这篇文章 中一针见血得指出： React 团队试图通过框架级别的 API 来约束或者说帮助开发者写出可维护性更佳的 JavaScript 代码 框架最大的特点就是“限制”，通过这么一个限制重重的静态生命周期不让你调用实例方法，就给你 props 和 prevState 让你来 derived state，甚至连这个生命周期的都是一反常态的用一个具体的行为而不是用一个更新过程的时间节点来命名，就是让开发者只做 derived state 这个行为，并且通过返回值来更新 state 可以保证只更新一次 state（以前的 componentWillReceiveProps 是通过 batchUpdate 来保证只更新一次）。 不过官方并不推荐使用 getDerivedStateFromProps，倒不是 getDerivedStateFromProps 这个 API 带来的问题，而是 derived state 带来的问题，之前的 componentWillReceiveProps 也有这个问题。 derived state 会造成不只一个 source of truth，我们都知道，React 的哲学是 view = f(data)，但是当有两个 data 去表征同一个参数造成 view 的修改时就有麻烦了，所以在使用 getDerivedStateFromProps 之前一定要想好是否可以直接使用 props。 getDerivedStateFromProps 作为一个静态函数是不能访问实例属性的，如果需要通过实例方法和 state 或者 props 来计算一个值在 render 周期中使用的 state，那么最好的方法是直接在 render 中计算出这个值然后直接使用，因为这会是一个纯函数的操作。这从侧面反映出来，这次生命周期的升级通过添加限制在一定程度上规范了生命周期的使用。 5.5.2 componentDidUpdate() 那么，之前的副作用在要放在哪里呢？答案就是 componentDidUpdate。 不过这又带来了一个问题，在之前版本的生命周期中，开发者最喜欢使用 componentWillReceiveProps 的一个原因就是 componentWillReceiveProps 不会引起 re-render，而 componentDidUpdate 中 setState，会再次引发一轮的 re-render。 所以我们要尽量避免在 componentDidUpdate 中 setState，而是提前到 getDerivedStateFromProps，将网络操作的副作用放在 componentDidUpdate 中，一方面网络总是有一定延迟的，不管放在哪个生命周期中都会引发 re-render，另一方面是 componentDidUpdate 中 DOM 已经更新。 将通过 props 或 state 计算的衍生数据放在 render 中，一方面符合 render 的纯函数理念，另一方面减少了产生新的 truth of source 的概率。 5.5.3 getSnapshotBeforeUpdate() getSnapshotBeforeUpdate 处于 render phase 和 commit phase 的中间，不过准确的说是处于 commit phase 的阶段，因为它只会被执行一次，在 react 修改 DOM 之前会被紧挨着调用，所以在这个生命周期能够获取这一次更新前的 DOM 的信息。这个生命周期返回的值将作为 componentDidUpdate 的第三个参数。 5.5.4 Ref 在 React16 新版本中，新引入了 React.createRef 与 React.forwardRef 两个 API，有计划移除老的 string ref，使 ref 的使用更加便捷与明确。如果你的应用已经升级到 React16.3+ 版本，那就放心大胆使用 React.createRef 吧，如果暂时没有的话，建议使用 callback ref 来代替 string ref。 详细说明 6、优化组件 当打开一个页面，input 输入框自动获取光标，这会大大提升用户体验。 比如打开一个注册页面，光标自动获取到用户名输入栏。 有人在写这个组件的时候会想到，为 input 绑定一个 id，然后通过 document.getElementById('user-name-input').focus() 来实现。 但我认为这并不是一个很好的方式，我有一个更好的实现方式: class Input extends Component { focus() { this.el.focus(); } render() { return ( { this.el = el; }} /> ); } } ok，一个拥有 focus() 方法的 Input 组件完成了。 在父组件中，我们可以调到子组件的 focus() 方法： class SignInModal extends Component { componentDidMount() { this.InputComponent.focus(); } render() { return ( User name: { this.InputComponent = comp; }} /> ) } } 注意，当您在一个组件上使用 ref 时，它是对组件(而不是底层元素)的引用，因此您可以访问它的方法。 7、React.memo 虽然 PureComponent 可以提高组件渲染性能，但是它也不是没有代价的，它逼迫我们必须把组件实现为 class，不能用纯函数来实现组件。 如果你使用 React v16.6.0 之后的版本，可以使用一个新功能 React.memo 来完美实现 React 组件，上面的 Joke 组件可以这么写： const Joke = React.memo(({ value }) => ( {value || 'loading...' } )); React.memo 既利用了 shouldComponentUpdate，又不要求我们写一个 class，这也体现出 React 逐步向完全函数式编程前进。 React.memo()可以满足创建纯函数而不是一个类的需求。 React.memo()可接受2个参数，第一个参数为纯函数的组件，第二个参数用于对比props控制是否刷新，与shouldComponentUpdate()功能类似。 8、高阶组件（HOC） 在开发 React 组件过程中，很容易发现这样一种现象，某些功能是多个组件通用的，如果每个组件都重复实现这样的逻辑，肯定十分浪费，而且违反了 “不要重复自己”（DRY，Don't Repeat Yourself) 的编码原则，我们肯定想要把这部分共用逻辑提取出来重用。 我们说过，在 React 的世界里，组件是第一公民，首先想到的是当然是把共用逻辑提取为一个 React 组件。不过，有些情况下，这些共用逻辑还没法成为一个独立组件，换句话说，这些共用逻辑单独无法使用，它们只是对其他组件的功能加强。 举个例子，对于很多网站应用，有些模块都需要在用户已经登录的情况下才显示。比如，对于一个电商类网站，“退出登录”按钮、“购物车”这些模块，就只有用户登录之后才显示，对应这些模块的 React 组件如果连“只有在登录时才显示”的功能都重复实现，那就浪费了。 这时候，我们就可以利用 “高阶组件（HoC）” 这种模式来解决问题。 8.1 高阶组件的基本形式 “高阶组件”名为“组件”，其实并不是一个组件，而是一个 函数，只不过这个函数比较特殊，它接受至少一个 React 组件为参数，并且能够返回一个全新的 React 组件作为结果，当然，这个新产生的 React 组件是对作为参数的组件的包装，所以，有机会赋予新组件一些增强的“神力”。 一个最简单的高阶组件是这样的形式： const withDoNothing = (Component) => { const NewComponent = (props) => { return ; }; return NewComponent; }; 上面的函数 withDoNothing 就是一个高阶组件，作为一项业界通用的代码规范，高阶组件的命名一般都带 with 前缀，命名中后面的部分代表这个高阶组件的功能。 就如同 withDoNothing 这个名字所说的一样，这个高阶组件什么都没做，但是从中可以看出高阶组件的基本代码套路。 高阶组件不能去修改作为参数的组件，高阶组件必须是一个纯函数，不应该有任何副作用。 高阶组件返回的结果必须是一个新的 React 组件，这个新的组件的 JSX 部分肯定会包含作为参数的组件。 高阶组件一般需要把传给自己的 props 转手传递给作为参数的组件。 8.2 用高阶组件抽取共同逻辑 接下来，我们对 withDoNothing 进行一些改进，让它实现“只有在登录时才显示”这个功能。 假设我们已经有一个函数 getUserId 能够从 cookies 中读取登录用户的 ID，如果用户未登录，这个 getUserId 就返回空，那么“退出登录按钮“就需要这么写： const LogoutButton = () => { if (getUserId()) { return ...; // 显示”退出登录“的JSX } else { return null; } }; 同样，购物车的代码就是这样： const ShoppintCart = () => { if (getUserId()) { return ...; // 显示”购物车“的JSX } else { return null; } }; 上面两个组件明显有重复的代码，我们可以把重复代码抽取出来，形成 withLogin 这个高阶组件，代码如下： const withLogin = (Component) => { const NewComponent = (props) => { if (getUserId()) { return ; } else { return null; } } return NewComponent; }; 如此一来，我们就只需要这样定义 LogoutButton 和 ShoppintCart： const LogoutButton = withLogin((props) => { return ...; // 显示”退出登录“的JSX }); const ShoppingCart = withLogin(() => { return ...; // 显示”购物车“的JSX }); 你看，我们避免了重复代码，以后如果要修改对用户是否登录的判断逻辑，也只需要修改 withLogin，而不用修改每个 React 组件。 8.3 高阶组件的高级用法 高阶组件只需要返回一个 React 组件即可，没人规定高阶组件只能接受一个 React 组件作为参数，完全可以传入多个 React 组件给高阶组件。 比如，我们可以改进上面的 withLogin，让它接受两个 React 组件，根据用户是否登录选择渲染合适的组件。 const withLoginAndLogout = (ComponentForLogin, ComponentForLogout) => { const NewComponent = (props) => { if (getUserId()) { return ; } else { return ; } } return NewComponent; }; 有了上面的 withLoginAndLogout，就可以产生根据用户登录状态显示不同的内容。 const TopButtons = withLoginAndLogout( LogoutButton, LoginButton ); 8.4 链式调用高阶组件 高阶组件最巧妙的一点，是可以链式调用。 假设，你有三个高阶组件分别是 withOne、withTwo 和 withThree，那么，如果要赋予一个组件 X 某个高阶组件的超能力，那么，你要做的就是挨个使用高阶组件包装，代码如下： const X1 = withOne(X); const X2 = withTwo(X1); const X3 = withThree(X2); const SuperX = X3; //最终的SuperX具备三个高阶组件的超能力 很自然，我们可以避免使用中间变量 X1 和 X2，直接连续调用高阶组件，如下： const SuperX = withThree(withTwo(withOne(X))); 对于 X 而言，它被高阶组件包装了，至于被一个高阶组件包装，还是被 N 个高阶组件包装，没有什么差别。而高阶组件本身就是一个纯函数，纯函数是可以组合使用的，所以，我们其实可以把多个高阶组件组合为一个高阶组件，然后用这一个高阶组件去包装X，代码如下： const hoc = compose(withThree, withTwo, withOne); const SuperX = hoc(X); 在上面代码中使用的 compose，是函数式编程中很基础的一种方法，作用就是把多个函数组合为一个函数，在很多开源的代码库中都可以看到，下面是一个参考实现： export default function compose(...funcs) { if (funcs.length === 0) { return arg => arg } if (funcs.length === 1) { return funcs[0] } return funcs.reduce((a, b) => (...args) => a(b(...args))) } React 组件可以当做积木一样组合使用，现在有了 compose，我们就可以把高阶组件也当做积木一样组合，进一步重用代码。 假如一个应用中多个组件都需要同样的多个高阶组件包装，那就可以用 compose 组合这些高阶组件为一个高阶组件，这样在使用多个高阶组件的地方实际上就只需要使用一个高阶组件了。 8.5 不要滥用高阶组件 高阶组件虽然可以用一种可重用的方式扩充现有 React 组件的功能，但高阶组件并不是绝对完美的。 首先，高阶组件不得不处理 displayName，不然 debug 会很痛苦。当 React 渲染出错的时候，靠组件的 displayName 静态属性来判断出错的组件类，而高阶组件总是创造一个新的 React 组件类，所以，每个高阶组件都需要处理一下 displayName。 如果要做一个最简单的什么增强功能都没有的高阶组件，也必须要写下面这样的代码： const withExample = (Component) => { const NewComponent = (props) => { return ; } NewComponent.displayName = `withExample(${Component.displayName || Component.name || 'Component'})`; return NewCompoennt; }; 每个高阶组件都这么写，就会非常的麻烦。 对于 React 生命周期函数，高阶组件不用怎么特殊处理，但是，如果内层组件包含定制的静态函数，这些静态函数的调用在 React 生命周期之外，那么高阶组件就必须要在新产生的组件中增加这些静态函数的支持，这更加麻烦。 其次，高阶组件支持嵌套调用，这是它的优势。但是如果真的一大长串高阶组件被应用的话，当组件出错，你看到的会是一个超深的 stack trace，十分痛苦。 最后，使用高阶组件，一定要非常小心，要避免重复产生 React 组件，比如，下面的代码是有问题的： const Example = () => { const EnhancedFoo = withExample(Foo); return } 像上面这样写，每一次渲染 Example，都会用高阶组件产生一个新的组件，虽然都叫做 EnhancedFoo，但是对 React 来说是一个全新的东西，在重新渲染的时候不会重用之前的虚拟 DOM，会造成极大的浪费。 正确的写法是下面这样，自始至终只有一个 EnhancedFoo 组件类被创建： const EnhancedFoo = withExample(Foo); const Example = () => { return } 总之，高阶组件是重用代码的一种方式，但并不是唯一方式，在下一小节，我们会介绍一种更加精妙的方式。 9、render props 模式 9.1 render props 所谓 render props，指的是让 React 组件的 props 支持函数这种模式。因为作为 props 传入的函数往往被用来渲染一部分界面，所以这种模式被称为 render props。 一个最简单的 render props 组件 RenderAll，代码如下： const RenderAll = (props) => { return( {props.children(props)} ); }; 这个 RenderAll 预期子组件是一个函数，它所做的事情就是把子组件当做函数调用，调用参数就是传入的 props，然后把返回结果渲染出来，除此之外什么事情都没有做。 使用 RenderAll 的代码如下： {() => hello world} 可以看到，RenderAll 的子组件，也就是夹在 RenderAll 标签之间的部分，其实是一个函数。这个函数渲染出 hello world，这就是上面使用 RenderAll 渲染出来的结果。 当然，这个 RenderAll 没做任何实际工作，接下来我们看 render props 真正强悍的使用方法。 9.2 传递 props 和高阶组件一样，render props 可以做很多的定制功能，我们还是以根据是否登录状态来显示一些界面元素为例，来实现一个 render props。 下面是实现 render props 的 Login 组件，可以看到，render props 和高阶组件的第一个区别，就是 render props 是真正的 React 组件，而不是一个返回 React 组件的函数。 const Login = (props) => { const userName = getUserName(); if (userName) { const allProps = {userName, ...props}; return ( {props.children(allProps)} ); } else { return null; } }; 当用户处于登录状态，getUserName 返回当前用户名，否则返回空，然后我们根据这个结果决定是否渲染 props.children 返回的结果。 当然，render props 完全可以决定哪些 props 可以传递给 props.children，在 Login 中，我们把 userName 作为增加的 props 传递给下去，这样就是 Login 的增强功能。 一个使用上面 Login 的 JSX 代码示例如下： {({userName}) => Hello {userName}} 对于名为“程墨Morgan”的用户登录，上面的 JSX 会产生 Hello 程墨Morgan。 9.3 不局限于 children 在上面的例子中，作为 render 方法的 props 就是 children，在我写的《深入浅出React和Redux》中，将这种模式称为“以函数为子组件（function as child）”的模式，这可以算是 render props 的一种具体形式，也就利用 children 这个 props 来作为函数传递。 实际上，render props 这个模式不必局限于 children 这一个 props，任何一个 props 都可以作为函数，也可以利用多个 props 来作为函数。 我们来扩展 Login，不光在用户登录时显示一些东西，也可以定制用户没有登录时显示的东西，我们把这个组件叫做 Auth，对应代码如下： const Auth = (props) => { const userName = getUserName(); if (userName) { const allProps = {userName, ...props}; return ( {props.login(allProps)} ); } else { {props.nologin(props)} } }; 使用 Auth 的话，可以分别通过 login 和 nologin 两个 props 来指定用户登录或者没登录时显示什么，用法如下： Hello {userName}} nologin={() => Please login} /> 9.4 依赖注入 render props 其实就是 React 世界中的 “依赖注入”（Dependency Injection)。 所谓依赖注入，指的是解决这样一个问题：逻辑 A 依赖于逻辑 B，如果让 A 直接依赖于 B，当然可行，但是 A 就没法做得通用了。依赖注入就是把 B 的逻辑以函数形式传递给 A，A 和 B 之间只需要对这个函数接口达成一致就行，如此一来，再来一个逻辑 C，也可以用一样的方法重用逻辑 A。 在上面的代码示例中，Login 和 Auth 组件就是上面所说的逻辑 A，而传递给组件的函数类型 props，就是逻辑 B 和 C。 9.5 render props 和高阶组件的比较 我们来比对一下这两种重用 React 组件逻辑的模式。 首先，render props 模式的应用，就是做一个 React 组件，而高阶组件，虽然名为“组件”，其实只是一个产生 React 组件的函数。 render props 不像上一小节中介绍的高阶组件有那么多毛病，如果说 render props 有什么缺点，那就是 render props 不能像高阶组件那样链式调用，当然，这并不是一个致命缺点。 render props 相对于高阶组件还有一个显著优势，就是对于新增的 props 更加灵活。还是以登录状态为例，假如我们扩展 withLogin 的功能，让它给被包裹的组件传递用户名这个 props，代码如下： const withLogin = (Component) => { const NewComponent = (props) => { const userName= getUserName(); if (userName) { return ; } else { return null; } } return NewComponent; }; 这就要求被 withLogin 包住的组件要接受 userName 这个props。可是，假如有一个现成的 React 组件不接受 userName，却接受名为 name 的 props 作为用户名，这就麻烦了。我们就不能直接用 withLogin 包住这个 React 组件，还要再造一个组件来做 userName 到 name 的映射，十分费事。 对于应用 render props 的 Login，就不存在这个问题，接受 name 不接受 userName 是吗？这样写就好了： { (props) => { const {userName} = props; return } } 所以，当需要重用 React 组件的逻辑时，建议首先看这个功能是否可以抽象为一个简单的组件；如果行不通的话，考虑是否可以应用 render props 模式；再不行的话，才考虑应用高阶组件模式。 这并不表示高阶组件无用武之地，在后续章节，我们会对 render props 和高阶组件分别讲解具体的实例。 9.6 小结 在这一小节中，我们介绍了 render props 这种模式，也将 render props 和高阶组件两种模式进行了比较。 读者应该要明白: render props 的形式； render props 其实就是“依赖注入”； 如何利用 render props 实现共享组件之间的逻辑。 10、 提供者模式 介绍 React 中的 “提供者模式”（Provider Pattern） 10.1 问题场景 在 React 中，props 是组件之间通讯的主要手段，但是，有一种场景单纯靠 props 来通讯是不恰当的，那就是两个组件之间间隔着多层其他组件，下面是一个简单的组件树示例图： 在上图中，组件 A 需要传递信息给组件 X，如果通过 props 的话，那么从顶部的组件 A 开始，要把 props 传递给组件 B，然后组件 B 传递给组件 D，最后组件 D 再传递给组件 X。 其实组件 B 和组件 D 完全用不上这些 props，但是又被迫传递这些 props，这明显不合理，要知道组件树的结构会变化的，将来如果组件 B 和组件 D 之间再插入一层新的组件，这个组件也需要传递这个 props，这就麻烦无比。 可见，对于跨级的信息传递，我们需要一个更好的方法。 在 React 中，解决这个问题应用的就是“提供者模式”。 10.2 提供者模式 虽然这个模式叫做“提供者模式”，但是其实有两个角色，一个叫“提供者”（Provider），另一个叫“消费者”（Consumer），这两个角色都是 React 组件。其中“提供者”在组件树上居于比较靠上的位置，“消费者”处于靠下的位置。在上面的组件树中，组件 A 可以作为提供者，组件 X 就是消费者。 既然名为“提供者”，它可以提供一些信息，而且这些信息在它之下的所有组件，无论隔了多少层，都可以直接访问到，而不需要通过 props 层层传递。 避免 props 逐级传递，即是提供者的用途。 10.3 如何实现提供者模式 实现提供者模式，需要 React 的 Context 功能，可以说，提供者模式只不过是让 Context 功能更好用一些而已。 所谓 Context 功能，就是能够创造一个“上下文”，在这个上下文笼罩之下的所有组件都可以访问同样的数据。 在 React v16.3.0 之前，React 虽然提供了 Context 功能，但是官方文档上都建议尽量不要使用，因为对应的 API 他们并不满意，觉得迟早要废弃掉。即使如此，依然有很多库和应用使用 Context 功能，可见对这个需求的呼声有多大。 当 React 发布 v16.3.0 时，终于提供了“正式版本”的 Context 功能 API，和之前的有很大不同，当然，这也带来一些问题，我在后面会介绍。 提供者模式的一个典型用例就是实现 “样式主题”（Theme），由顶层的提供者确定一个主题，下面的样式就可以直接使用对应主题里的样式。这样，当需要切换样式时，只需要修改提供者就行，其他组件不用修改。 为了方便比对，这里我会介绍提供者模式用不同 Context API 的实现方法。不过，你如果完全不在意老版本 React 如何实现的，可以略过下面一段。 10.4 React v16.3.0 之前的提供者模式 在 React v16.3.0 之前，要实现提供者，就要实现一个 React 组件，不过这个组件要做两个特殊处理。 需要实现 getChildContext 方法，用于返回“上下文”的数据； 需要定义 childContextTypes 属性，声明“上下文”的结构。 下面就是一个实现“提供者”的例子，组件名为 ThemeProvider： class ThemeProvider extends React.Component { getChildContext() { return { theme: this.props.value }; } render() { return ( {this.props.children} ); } } ThemeProvider.childContextTypes = { theme: PropTypes.object }; 在上面的例子中，getChildContext 只是简单返回名为 value 的 props 值，但是，因为 getChildContext 是一个函数，它可以有更加复杂的操作，比如可以从 state 或者其他数据源获得数据。 对于 ThemeProvider，我们创造了一个上下文，这个上下文就是一个对象，结构是这样： { theme: { //一个对象 } } 接下来，我们来做两个消费（也就是使用）这个“上下文”的组件，第一个是 Subject，代表标题；第二个是 Paragraph，代表章节。 我们把 Subject 实现为一个类，代码如下： class Subject extends React.Component { render() { const {mainColor} = this.context.theme; return ( {this.props.children} ); } } Subject.contextTypes = { theme: PropTypes.object } 在 Subject 的 render 函数中，可以通过 this.context 访问到“上下文”数据，因为 ThemeProvider 提供的“上下文”包含 theme 字段，所以可以直接访问 this.context.theme。 千万不要忘了 Subject 必须增加 contextTypes 属性，必须和 ThemeProvider 的 childContextTypes 属性一致，不然，this.context 就不会得到任何值。 读者可能会问了，为什么这么麻烦呢？为什么要求“提供者”用 childContextTypes 定义一次上下文结构，又要求“消费者”再用 contextTypes 再重复定义一次呢？这不是很浪费吗？ React 这么要求，是考虑到“上下文”可能会嵌套，就是一个“提供者”套着另一个“提供者”，这时候，底层的消费者组件到底消费哪一个“提供者”呢？通过这种显示的方式指定。 不过，实话实说，这样的 API 设计的确麻烦了一点，难怪 React 官方在最初就不建议使用。 上面的 Subject 是一个类，其实也可以把消费者实现为一个纯函数组件，只不过访问“上下文”的方式有些不同，我们用纯函数的方式实现另一个消费者 Paragraph，代码如下： const Paragraph = (props, context) => { const {textColor} = context.theme; return ( {props.children} ); }; Paragraph.contextTypes = { theme: PropTypes.object }; 从上面的代码可以看到，因为 Paragraph 是一个函数形式，所以不可能访问 this.context，但是函数的第二个参数其实就是 context。 当然，也不要忘了设定 Paragraph 的 contextTypes，不然参数 context 也不会是上下文。 最后，我们看如何结合”提供者“和”消费者“。 我们做一个组件来使用 Subject 和 Paragraph，这个组件不需要帮助传递任何 props，代码如下： const Page = () => ( 这是标题 这是正文 ); 上面的组件 Page 使用了 Subject 和 Paragraph，现在我们想要定制样式主题，只需要在 Page 或者任何需要应用这个主题的组件外面包上 ThemeProvider，对应的 JSX 代码如下： 最后，看到的效果如下： 当我们需要改变一个样式主题的时候，改变传给 ThemeProvider的 value 值就搞定了。 10.5 React v16.3.0 之后的提供者模式 到了 React v16.3.0 的时候，新的 Context API 出来了，这套 API 毫不掩饰自己就是“提供者模式”的实现，命名上就带 “Provider” 和 “Consumer”。 还是上面的样式主题的例子，首先，要用新提供的 createContext 函数创造一个“上下文”对象。 const ThemeContext = React.createContext(); 这个“上下文”对象 ThemeContext 有两个属性，分别就是——对，你没猜错——Provider 和 Consumer。 const ThemeProvider = ThemeContext.Provider; const ThemeConsumer = ThemeContext.Consumer; 创造“提供者”极大简化了，都不需要我们创造一个 React 组件类。 使用“消费者”也同样简单，而且应用了上一节我们介绍的 render props 模式，比如，Subject 的代码如下: class Subject extends React.Component { render() { return ( { (theme) => ( {this.props.children} ) } ); } } 上面的 ThemeConsumer 其实就是一个应用了 render props 模式的组件，它要求子组件是一个函数，会把“上下文”的数据作为参数传递给这个函数，而这个函数里就可以通过参数访问“上下文”对象。 在新的 API 里，不需要设定组件的 childContextTypes 或者 contextTypes 属性，这省了不少事。 可以注意到，Subject 没有自己的状态，没必要实现为类，我们用纯函数的形式实现 Paragraph，代码如下： const Paragraph = (props, context) => { return ( { (theme) => ( {props.children} ) } ); }; 实现 Page 的方式并没有变化，而应用 ThemeProvider 的代码和之前也完全一样: 10.6 两种提供者模式实现方式的比较 通过上面的代码，可以很清楚地看到，新的 Context API 更简洁，但是，也并不是十全十美。 在老版 Context API 中，“上下文”只是一个概念，并不对应一个代码，两个组件之间达成一个协议，就诞生了“上下文”。 在新版 Context API 中，需要一个“上下文”对象（上面的例子中就是 ThemeContext)，使用“提供者”的代码和“消费者”的代码往往分布在不同的代码文件中，那么，这个 ThemeContext 对象放在哪个代码文件中呢？ 最好是放在一个独立的文件中，这么一来，就多出一个代码文件，而且所有和这个“上下文”相关的代码，都要依赖于这个“上下文”代码文件，虽然这没什么大不了的，但是的确多了一层依赖关系。 为了避免依赖关系复杂，每个应用都不要滥用“上下文”，应该限制“上下文”的使用个数。 不管怎么说，新版本的 Context API 才是未来，在 React v17 中，可能就会删除对老版 Context API 的支持，所以，现在大家都应该使用第二种实现方式。 10.7 小结 这一小节我们介绍了“提供者模式”，读者应该能够理解： 提供者模式解决的问题； React 的 Context 功能对这种模式有很直接的支持； 提供者模式中 render props 的应用。 在接下来关于 Redux 和 Mobx 的介绍中，可以看到“提供者模式”更广泛的应用。 11、MVC/MVVM/Flux 11.1 MVC MVC是一种架构设计模式，它通过关注数据界面分离，来鼓励改进应用程序结构。 具体的说，MVC强制将业务数据(Model) 与用户界面(View)隔离，用控制器(Controller)管理逻辑和用户输入 11.1.1 MVC模式中的3种角色 在MVC模式中，主要涉及3种角色--Model、View和Controller Model Model负责保存应用数据，和后端交互同步应用数据，或校验数据 Model不涉及应用数据，也不涉及表示层，而是代表应用程序可能需要的独特形式的数据，当Model改变时，它会通知它的观察者（如视图）做出相应的反应 总的来说，Model主要与业务数据有关，与应用内交互状态无关 View View是Model的可视化表示，表示当前状态的视图，前端View负责构建和维护DOM元素。View对应用程序中的Model和Controller的了解是有限的，更新Model的实际任务都是在Controller上 用户可以与View交互，包括读取和编辑Model，在Model中获取或设置属性值 一个View通常对应一个Model，并在Model更改时进行通知，是View本身能够进行相应的更新，但在实际应用开发中，还会面临多个View对应多个Model的情况 Controller 负责连接View和Model， Model的任何改变会应用到View中，View的操作和通过Controller应用到Model中 总的来说，Controller管理了应用程序中的Model和View之间的逻辑和协调 11.2 MVVM的演变 MVVM出现于2005年，最大的变化在于VM(ViewModel)代替了C(Controller), 其关键“改进”是数据绑定（DataBinding）,也就是说，View的数据状态发生变化可以直接影响VM,反之亦然 11.3 MVC的问题 致命缺点： 在项目越来越大、逻辑越来越复杂的时候，混乱的数据流动方式 11.4 Flux Flux的核心思想： 数据和逻辑永远单向流动 不足： 冗余代码太多， 虽然Flux源码中几乎只有dispatcher的现实，但是在每个应用中都需要手动创建一个dispatcher的示例，这还是让很多开发者觉得烦恼 12、PureComponent 可以用shouldComponentUpdate模拟PureComponent,下面两个组件的功能一样 class Demo1 extends Component { shouldComponentUpdate(nextProps, nextState) { const { props, state } = this; function shallowCompare(a, b) { return a === b || Object.keys(a).every(k => a[k] === b[k]); } return shallowCompare(nextProps, props) && shallowCompare(nextState, state) } } class Demo2 extends PureComponent {} 13、Redux 中间件和异步 Redux 中间件提供的是位于action被派发之后，到达reducer之前的扩展点，因此我们可以利用Redux中间件来完成日志记录、调用异步接口或者路由等。 Redux 本身提供了applyMiddleware 方法用来接入中间件。创建store的实例的代码如下 const store = createStore( reducer, preloadedState, applyMiddleware(middleware) ) // 或者 const store = creatSore( reducer, applyMiddleware(middleware) ) 13.1 react-redux 容器组件： 所谓容器组件，实际上是指数据状态和逻辑的容器。他并不负责展示，而是只能维护内部状态，进行数据分发和处理派发action。因此，容器组件对Redux是感知的，可以使用Redux的API，比如dispatch等。 展示组件： 与容器组件相反，展示组件只负责接收相应的数据，完成页面展示，它本身并不维护数据和状态。实际上，为了渲染页面，展示组件所需要的所有数据都又容器组件通过props层层传递下来。 展示组件 容器组件 目的 展示页面内容 处理数据和逻辑 是否感知Redux 不感知 感知 数据来源 从props获取 从Redux state订阅获取 改变数据 通过回调props派发action 直接派发action 由谁编写 开发者 由react-redux库生产 "},"React/React进阶/Ref.html":{"url":"React/React进阶/Ref.html","title":"Ref","keywords":"","body":"React ref 的前世今生 React ref 的前世今生 ref 的三驾马车 string ref 之殇 createRef vs callback ref 穿云箭 React.forwardRef ref 的三驾马车 在 React v16.3 之前，ref 通过字符串（string ref）或者回调函数（callback ref）的形式进行获取，在 v16.3 中，经 0017-new-create-ref 提案引入了新的 React.createRef API。 注意：本文以下代码示例以及源码均基于或来源于 React v16.3.2 release 版本。 // string ref class MyComponent extends React.Component { componentDidMount() { this.refs.myRef.focus(); } render() { return ; } } // callback ref class MyComponent extends React.Component { componentDidMount() { this.myRef.focus(); } render() { return { this.myRef = ele; }} />; } } // React.createRef class MyComponent extends React.Component { constructor(props) { super(props); this.myRef = React.createRef(); } componentDidMount() { this.myRef.current.focus(); } render() { return ; } } string ref 之殇 在 React.createRef 出现之前，string ref 就已被诟病已久，React 官方文档直接提出 string ref 将会在未来版本被移出，建议用户使用 callback ref 来代替，为何需要这么做呢？主要原因集中于以下几点： ref 定义为 string 时，需要 React 追踪当前正在渲染的组件，在 reconciliation 阶段，React Element 创建和更新的过程中，ref 会被封装为一个闭包函数，等待 commit 阶段被执行，这会对 React 的性能产生一些影响。 function coerceRef( returnFiber: Fiber, current: Fiber | null, element: ReactElement, ) { ... const stringRef = '' + element.ref; // 从 fiber 中得到实例 let inst = ownerFiber.stateNode; // ref 闭包函数 const ref = function(value) { const refs = inst.refs === emptyObject ? (inst.refs = {}) : inst.refs; if (value === null) { delete refs[stringRef]; } else { refs[stringRef] = value; } }; ref._stringRef = stringRef; return ref; ... } 当使用 render callback 模式时，使用 string ref 会造成 ref 挂载位置产生歧义。 class MyComponent extends Component { renderRow = (index) => { // string ref 会挂载在 DataTable this 上 return ; // callback ref 会挂载在 MyComponent this 上 return this['input-' + index] = input} />; } render() { return } } string ref 无法被组合，例如一个第三方库的父组件已经给子组件传递了 ref，那么我们就无法再在子组件上添加 ref 了，而 callback ref 可完美解决此问题。 /** string ref **/ class Parent extends React.Component { componentDidMount() { // 可获取到 this.refs.childRef console.log(this.refs); } render() { const { children } = this.props; return React.cloneElement(children, { ref: 'childRef', }); } } class App extends React.Component { componentDidMount() { // this.refs.child 无法获取到 console.log(this.refs); } render() { return ( ); } } /** callback ref **/ class Parent extends React.Component { componentDidMount() { // 可以获取到 child ref console.log(this.childRef); } render() { const { children } = this.props; return React.cloneElement(children, { ref: (child) => { this.childRef = child; children.ref && children.ref(child); } }); } } class App extends React.Component { componentDidMount() { // 可以获取到 child ref console.log(this.child); } render() { return ( { this.child = child; }} /> ); } } 在根组件上使用无法生效。 ReactDOM.render(, document.getElementById('main')); 对于静态类型较不友好，当使用 string ref 时，必须显式声明 refs 的类型，无法完成自动推导 编译器无法将 string ref 与其 refs 上对应的属性进行混淆，而使用 callback ref，可被混淆。 /** string ref，无法混淆 */ this.refs.myRef /** callback ref, 可以混淆 */ this.myRef { this.myRef = dom; }}> this.r { this.r = e; }}> createRef vs callback ref 对比新的 createRef 与 callback ref，并没有压倒性的优势，只是希望成为一个便捷的特性，在性能上会会有微小的优势，callback ref 采用了组件 render 过程中在闭包函数中分配 ref 的模式，而 createRef 则采用了 object ref。 createRef 显得更加直观，类似于 string ref，避免了 callback ref 的一些理解问题，对于 callback ref 我们通常会使用内联函数的形式，那么每次渲染都会重新创建，由于 react 会清理旧的 ref 然后设置新的（见下图，commitDetachRef -> commitAttachRef），因此更新期间会调用两次，第一次为 null，如果在 callback 中带有业务逻辑的话，可能会出错，当然可以通过将 callback 定义成类成员函数并进行绑定的方式避免。 class App extends React.Component { state = { a: 1, }; componentDidMount() { this.setState({ a: 2, }); } render() { return ( { // 输出 3 次 // // null // console.log(dom); }}> ); } } class App extends React.Component { state = { a: 1, }; constructor(props) { super(props); this.refCallback = this.refCallback.bind(this); } componentDidMount() { this.setState({ a: 2, }); } refCallback(dom) { // 只输出 1 次 // console.log(dom); } render() { return ( ); } } 不过不得不承认，createRef 在能力上仍逊色于 callback ref，例如上一节提到的组合问题，createRef 也是无能为力的。在 React v16.3 中，string ref/callback ref 与 createRef 的处理略有差别，让我们来看一下 ref 整个构建流程。 // markRef 前会进行新旧 ref 的引用比较 if (current.ref !== workInProgress.ref) { markRef(workInProgress); } // effectTag 基于位操作，其中有 ref 的变更标志位 function markRef(workInProgress: Fiber) { workInProgress.effectTag |= Ref; } // effectTag 与 Ref 的 & 操作表示当前 fiber 有 ref 变更 if (effectTag & Ref) { commitAttachRef(nextEffect); } function commitAttachRef(finishedWork: Fiber) { const ref = finishedWork.ref; if (ref !== null) { const instance = finishedWork.stateNode; let instanceToUse; switch (finishedWork.tag) { // 当前 Host 环境为 DOM 环境，HostComponent 即为 DOM 元素，需要借助实例获取原生 DOM 元素 case HostComponent: instanceToUse = getPublicInstance(instance); break; // 对于 ClassComponent 等而言，直接返回实例即可 default: instanceToUse = instance; } // string ref 与 callback 都会去执行 ref 闭包函数 // createRef 会直接挂在 object ref 的 current 上 if (typeof ref === 'function') { ref(instanceToUse); } else { ref.current = instanceToUse; } } } 以上会涉及 react fiber 的一些概念与细节，比如：fiber 对象含义，fiber tree 构建更新过程，effectTag 的含义与收集过程等等，如果读者对上述细节不熟悉，可暂时跳过此段内容，不影响对于 ref 的掌握与理解。 穿云箭 React.forwardRef 除了 createRef 以外，React16 还另外提供了一个关于 ref 的 API React.forwardRef，主要用于穿过父元素直接获取子元素的 ref。在提到 forwardRef 的使用场景之前，我们先来回顾一下，HOC（higher-order component）在 ref 使用上的问题，HOC 的 ref 是无法通过 props 进行传递的，因此无法直接获取被包裹组件（WrappedComponent），需要进行中转。 function HOCProps(WrappedComponent) { class HOCComponent extends React.Component { constructor(props) { super(props); this.setWrappedInstance = this.setWrappedInstance.bind(this); } getWrappedInstance() { return this.wrappedInstance; } // 实现 ref 的访问 setWrappedInstance(ref) { this.wrappedInstance = ref; } render() { return ; } } return HOCComponent; } const App = HOCProps(Wrap); { // 只能获取到 HOCComponent console.log(dom); // 通过中转后可以获取到 WrappedComponent console.log(dom.getWrappedInstance()); }} /> 在拥有 forwardRef 之后，就不需要再通过 getWrappedInstance 了，利用 forwardRef 能直接穿透 HOCComponent 获取到 WrappedComponent。 function HOCProps(WrappedComponent) { class HOCComponent extends React.Component { render() { const { forwardedRef, ...rest } = this.props; return ; } } return React.forwardRef((props, ref) => { return ; }); } const App = HOCProps(Wrap); { // 可以直接获取 WrappedComponent console.log(dom); }} /> React.forwardRef 的原理其实非常简单，forwardRef 会生成 react 内部一种较为特殊的 Component。当进行创建更新操作时，会将 forwardRef 组件上的 props 与 ref 直接传递给提前注入的 render 函数，来生成 children。 const nextChildren = render(workInProgress.pendingProps, workInProgress.ref); React refs 到此就全部介绍完了，在 React16 新版本中，新引入了 React.createRef 与 React.forwardRef 两个 API，有计划移除老的 string ref，使 ref 的使用更加便捷与明确。如果你的应用已经升级到 React16.3+ 版本，那就放心大胆使用 React.createRef 吧，如果暂时没有的话，建议使用 callback ref 来代替 string ref。 "},"React/React进阶/setState.html":{"url":"React/React进阶/setState.html","title":"setState","keywords":"","body":"你真的理解setState吗？ 你真的理解setState吗？ setState真的是异步的吗 ？ 一、合成事件中的setState 二、生命周期函数中的setState 三、原生事件中的setState 四、setTimeout中的setState 五、setState中的批量更新 最后看个🌰 总结 : setState Promise 面试官：“react中setState是同步的还是异步？”我：“异步的，setState不能立马拿到结果。” 面试官：“那什么场景下是异步的，可不可能是同步，什么场景下又是同步的？”我：“......” setState真的是异步的吗 ？ 这两天自己简单的看了下setState的部分实现代码（源码版本是16.4.1）。 看之前，为了方便理解和简化流程，我们默认react内部代码执行到performWork、performWorkOnRoot、performSyncWork、performAsyncWork这四个方法的时候，就是react去update更新并且作用到UI上。 一、合成事件中的setState 首先得了解一下什么是合成事件，react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在jsx中常见的onClick、onChange这些都是合成事件。 class App extends Component { state = { val: 0 } increment = () => { this.setState({ val: this.state.val + 1 }) console.log(this.state.val) // 输出的是更新前的val --> 0 } render() { return ( {`Counter is: ${this.state.val}`} ) } } 合成事件中的setState写法比较常见，点击事件里去改变this.state.val的状态值，在increment事件中打个断点可以看到调用栈，这里我贴一张自己画的流程图： 合成事件中setState的调用栈 从 dispatchInteractiveEvent 到 callCallBack 为止，都是对合成事件的处理和执行，从 setState 到 requestWork 是调用 this.setState 的逻辑，这边主要看下 requestWork 这个函数（从 dispatchEvent 到 requestWork 的调用栈是属于 interactiveUpdates$1 的 try 代码块，下文会提到）。 function requestWork(root, expirationTime) { addRootToSchedule(root, expirationTime); if (isRendering) { // Prevent reentrancy. Remaining work will be scheduled at the end of // the currently rendering batch. return; } if (isBatchingUpdates) { // Flush work at the end of the batch. if (isUnbatchingUpdates) { // ...unless we're inside unbatchedUpdates, in which case we should // flush it now. nextFlushedRoot = root; nextFlushedExpirationTime = Sync; performWorkOnRoot(root, Sync, false); } return; } // TODO: Get rid of Sync and use current time? if (expirationTime === Sync) { performSyncWork(); } else { scheduleCallbackWithExpiration(expirationTime); } } 在requestWork中有三个if分支，三个分支中有两个方法 performWorkOnRoot 和performSyncWork，就是我们默认的update函数，但是在合成事件中，走的是第二个if分支，第二个分支中有两个标识 isBatchingUpdates 和 isUnbatchingUpdates 两个初始值都为false，但是在 interactiveUpdates$1 中会把 isBatchingUpdates 设为 true ，下面就是 interactiveUpdates$1 的代码： function interactiveUpdates$1(fn, a, b) { if (isBatchingInteractiveUpdates) { return fn(a, b); } // If there are any pending interactive updates, synchronously flush them. // This needs to happen before we read any handlers, because the effect of // the previous event may influence which handlers are called during // this event. if (!isBatchingUpdates && !isRendering && lowestPendingInteractiveExpirationTime !== NoWork) { // Synchronously flush pending interactive updates. performWork(lowestPendingInteractiveExpirationTime, false, null); lowestPendingInteractiveExpirationTime = NoWork; } var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates; var previousIsBatchingUpdates = isBatchingUpdates; isBatchingInteractiveUpdates = true; isBatchingUpdates = true; // 把requestWork中的isBatchingUpdates标识改为true try { return fn(a, b); } finally { isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates; isBatchingUpdates = previousIsBatchingUpdates; if (!isBatchingUpdates && !isRendering) { performSyncWork(); } } } 在这个方法中把 isBatchingUpdates 设为了 true , 导致在 requestWork 方法中， isBatchingUpdates 为 true ，但是 isUnbatchingUpdates 是 false，而被直接return了。 那return完的逻辑回到哪里呢，最终正是回到了 interactiveUpdates 这个方法，仔细看一眼，这个方法里面有个 try finally 语法，前端这个其实是用的比较少的，简单的说就是会先执行 try代码块中的语句，然后再执行 finally 中的代码，而 fn(a, b) 是在try代码块中，刚才说到在 requestWork 中被return掉的也就是这个fn（上文提到的 从dispatchEvent到 requestWork 的一整个调用栈）。 所以当你在increment中调用 setState 之后去 console.log 的时候，是属于try代码块中的执行，但是由于是合成事件，try 代码块执行完 state 并没有更新，所以你输入的结果是更新前的 state 值，这就导致了所谓的\"异步\"，但是当你的 try 代码块执行完的时候（也就是你的increment合成事件），这个时候会去执行 finally 里的代码，在 finally 中执行了 performSyncWork 方法，这个时候才会去更新你的 state并且渲染到UI上。 二、生命周期函数中的setState class App extends Component { state = { val: 0 } componentDidMount() { this.setState({ val: this.state.val + 1 }) console.log(this.state.val) // 输出的还是更新前的值 --> 0 } render() { return ( {`Counter is: ${this.state.val}`} ) } } 钩子函数中setState的调用栈： 其实还是和合成事件一样，当componentDidmount执行的时候，react内部并没有更新，执行完componentDidmount后才去commitUpdateQueue更新。这就导致你在componentDidmount中setState完去console.log拿的结果还是更新前的值。 三、原生事件中的setState class App extends Component { state = { val: 0 } changeValue = () => { this.setState({ val: this.state.val + 1 }) console.log(this.state.val) // 输出的是更新后的值 --> 1 } componentDidMount() { document.body.addEventListener('click', this.changeValue, false) } render() { return ( {`Counter is: ${this.state.val}`} ) } } 原生事件是指非react合成事件，原生自带的事件监听 addEventListener ，或者也可以用原生js、jq直接 document.querySelector().onclick 这种绑定事件的形式都属于原生事件。 原生事件中setState的调用栈 原生事件的调用栈就比较简单了，因为没有走合成事件的那一大堆，直接触发click事件，到requestWork ,在 requestWork 里由于 expirationTime === Sync 的原因，直接走了 performSyncWork 去更新，并不像合成事件或钩子函数中被return，所以当你在原生事件中setState后，能同步拿到更新后的state值。 四、setTimeout中的setState class App extends Component { state = { val: 0 } componentDidMount() { setTimeout(_ => { this.setState({ val: this.state.val + 1 }) console.log(this.state.val) // 输出更新后的值 --> 1 }, 0) } render() { return ( {`Counter is: ${this.state.val}`} ) } } 在 setTimeout 中去 setState 并不算是一个单独的场景，它是随着你外层去决定的，因为你可以在合成事件中 setTimeout，可以在钩子函数中 setTimeout，也可以在原生事件setTimeout，但是不管是哪个场景下，基于event loop的模型下，setTimeout 中里去 setState 总能拿到最新的state值。 举个栗子，比如之前的合成事件，由于 setTimeout(_ => { this.setState()}, 0)是在 try 代码块中,当你 try 代码块执行到setTimeout的时候，把它丢到列队里，并没有去执行，而是先执行的 finally 代码块，等 finally 执行完了，isBatchingUpdates又变为了 false，导致最后去执行队列里的 setState 时候， requestWork 走的是和原生事件一样的 expirationTime === Sync if分支，所以表现就会和原生事件一样，可以同步拿到最新的state值。 五、setState中的批量更新 class App extends Component { state = { val: 0 } batchUpdates = () => { this.setState({ val: this.state.val + 1 }) this.setState({ val: this.state.val + 1 }) this.setState({ val: this.state.val + 1 }) } render() { return ( {`Counter is ${this.state.val}`} // 1 ) } } 上面的结果最终是1，在setState的时候react内部会创建一个updateQueue，通过firstUpdate、lastUpdate、lastUpdate.next去维护一个更新的队列，在最终的performWork中，相同的key会被覆盖，只会对最后一次的setState进行更新，下面是部分实现代码： function createUpdateQueue(baseState) { var queue = { expirationTime: NoWork, baseState: baseState, firstUpdate: null, lastUpdate: null, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null }; return queue; } function appendUpdateToQueue(queue, update, expirationTime) { // Append the update to the end of the list. if (queue.lastUpdate === null) { // Queue is empty queue.firstUpdate = queue.lastUpdate = update; } else { queue.lastUpdate.next = update; queue.lastUpdate = update; } if (queue.expirationTime === NoWork || queue.expirationTime > expirationTime) { // The incoming update has the earliest expiration of any update in the // queue. Update the queue's expiration time. queue.expirationTime = expirationTime; } } 最后看个🌰 class App extends React.Component { state = { val: 0 } componentDidMount() { this.setState({ val: this.state.val + 1 }) console.log(this.state.val) this.setState({ val: this.state.val + 1 }) console.log(this.state.val) setTimeout(_ => { this.setState({ val: this.state.val + 1 }) console.log(this.state.val); this.setState({ val: this.state.val + 1 }) console.log(this.state.val) }, 0) } render() { return {this.state.val} } } 结合上面分析的，钩子函数中的 setState 无法立马拿到更新后的值，所以前两次都是输出0，当执行到setTimeout里的时候，前面两个state的值已经被更新，由于 setState 批量更新的策略， this.state.val 只对最后一次的生效，为1，而在 setTimmout 中setState 是可以同步拿到更新结果，所以 setTimeout 中的两次输出2，3，最终结果就为0, 0, 2, 3。 总结 : setState 只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout 中都是同步的。 setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。 setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。 setState Promise setStateAsync(state) { return new Promise((resolve) => { this.setState(state, resolve) }) } "},"React/React进阶/React-Hooks.html":{"url":"React/React进阶/React-Hooks.html","title":"React Hooks","keywords":"","body":"一篇看懂 React Hooks 一篇看懂 React Hooks 什么是 React Hooks React Hooks 的特点 利用 useState 创建 Redux 利用 useEffect 代替一些生命周期 React Hooks 将带来什么变化 Hooks 带来的约定 状态与 UI 的界限会越来越清晰 React Hooks 实践 DOM 副作用修改 / 监听 修改页面 title 监听页面大小变化，网络是否断开 动态注入 css 组件辅助 获取组件宽高 拿到组件 onChange 抛出的值 做动画 在某个时间段内获取 0-1 之间的值 弹性动画 Tween 动画 发请求 通用 Http 封装 Request Service 填表单 Hooks 思维的表单组件 模拟生命周期 componentDidMount componentWillUnmount componentDidUpdate Force Update isMounted 存数据 全局 Store 封装原有库 RenderProps to Hooks Hooks to RenderProps 封装原本对 setState 增强的库 总结 将之前对 React Hooks 的总结整理在一篇文章，带你从认识到使用 React Hooks。 什么是 React Hooks React Hooks 是 React 16.7.0-alpha 版本推出的新特性，想尝试的同学安装此版本即可。 React Hooks 要解决的问题是状态共享，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。 这个状态指的是状态逻辑，所以称为状态逻辑复用会更恰当，因为只共享数据处理逻辑，不会共享数据本身。 不久前精读分享过的一篇 Epitath 源码 - renderProps 新用法 就是解决 JSX 嵌套问题，有了 React Hooks 之后，这个问题就被官方正式解决了。 为了更快理解 React Hooks 是什么，先看笔者引用的下面一段 renderProps 代码： function App() { return ( {({ on, toggle }) => ( Open Modal )} ) } 恰巧，React Hooks 解决的也是这个问题： function App() { const [open, setOpen] = useState(false); return ( <> setOpen(true)}> Open Modal setOpen(false)} onCancel={() => setOpen(false)} /> ); } 可以看到，React Hooks 就像一个内置的打平 renderProps 库，我们可以随时创建一个值，与修改这个值的方法。看上去像 function 形式的 setState，其实这等价于依赖注入，与使用 setState 相比，这个组件是没有状态的。 React Hooks 的特点 React Hooks 带来的好处不仅是 “更 FP，更新粒度更细，代码更清晰”，还有如下三个特性： 多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。 Hooks 可以引用其他 Hooks。 更容易将组件的 UI 与状态分离。 第二点展开说一下：Hooks 可以引用其他 Hooks，我们可以这么做： import { useState, useEffect } from \"react\"; // 底层 Hooks, 返回布尔值：是否在线 function useFriendStatusBoolean(friendID) { const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) { setIsOnline(status.isOnline); } useEffect(() => { ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () => { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); }; }); return isOnline; } // 上层 Hooks，根据在线状态返回字符串：Loading... or Online or Offline function useFriendStatusString(props) { const isOnline = useFriendStatusBoolean(props.friend.id); if (isOnline === null) { return \"Loading...\"; } return isOnline ? \"Online\" : \"Offline\"; } // 使用了底层 Hooks 的 UI function FriendListItem(props) { const isOnline = useFriendStatusBoolean(props.friend.id); return ( {props.friend.name} ); } // 使用了上层 Hooks 的 UI function FriendListStatus(props) { const statu = useFriendStatusString(props.friend.id); return {statu}; } 这个例子中，有两个 Hooks：useFriendStatusBoolean 与 useFriendStatusString, useFriendStatusString 是利用 useFriendStatusBoolean 生成的新 Hook，这两个 Hook 可以给不同的 UI：FriendListItem、FriendListStatus 使用，而因为两个 Hooks 数据是联动的，因此两个 UI 的状态也是联动的。 顺带一提，这个例子也可以用来理解 对 React Hooks 的一些思考 一文的那句话：“有状态的组件没有渲染，有渲染的组件没有状态”： useFriendStatusBoolean 与 useFriendStatusString 是有状态的组件（使用 useState），没有渲染（返回非 UI 的值），这样就可以作为 Custom Hooks 被任何 UI 组件调用。 FriendListItem 与 FriendListStatus 是有渲染的组件（返回了 JSX），没有状态（没有使用 useState），这就是一个纯函数 UI 组件， 利用 useState 创建 Redux Redux 的精髓就是 Reducer，而利用 React Hooks 可以轻松创建一个 Redux 机制： // 这就是 Redux function useReducer(reducer, initialState) { const [state, setState] = useState(initialState); function dispatch(action) { const nextState = reducer(state, action); setState(nextState); } return [state, dispatch]; } 这个自定义 Hook 的 value 部分当作 redux 的 state，setValue 部分当作 redux 的 dispatch，合起来就是一个 redux。而 react-redux 的 connect 部分做的事情与 Hook 调用一样： // 一个 Action function useTodos() { const [todos, dispatch] = useReducer(todosReducer, []); function handleAddClick(text) { dispatch({ type: \"add\", text }); } return [todos, { handleAddClick }]; } // 绑定 Todos 的 UI function TodosUI() { const [todos, actions] = useTodos(); return ( <> {todos.map((todo, index) => ( {todo.text} ))} Add Todo ); } useReducer 已经作为一个内置 Hooks 了，在这里可以查阅所有 内置 Hooks。 不过这里需要注意的是，每次 useReducer 或者自己的 Custom Hooks 都不会持久化数据，所以比如我们创建两个 App，App1 与 App2: function App1() { const [todos, actions] = useTodos(); return todo count: {todos.length}; } function App2() { const [todos, actions] = useTodos(); return todo count: {todos.length}; } function All() { return ( <> ); } 这两个实例同时渲染时，并不是共享一个 todos 列表，而是分别存在两个独立 todos 列表。也就是 React Hooks 只提供状态处理方法，不会持久化状态。 如果要真正实现一个 Redux 功能，也就是全局维持一个状态，任何组件 useReducer 都会访问到同一份数据，可以和 useContext 一起使用。 大体思路是利用 useContext 共享一份数据，作为 Custom Hooks 的数据源。具体实现可以参考 redux-react-hook。 利用 useEffect 代替一些生命周期 在 useState 位置附近，可以使用 useEffect 处理副作用： useEffect(() => { const subscription = props.source.subscribe(); return () => { // Clean up the subscription subscription.unsubscribe(); }; }); useEffect 的代码既会在初始化时候执行，也会在后续每次 rerender 时执行，而返回值在析构时执行。这个更多带来的是便利，对比一下 React 版 G2 调用流程： class Component extends React.PureComponent { private chart: G2.Chart = null; private rootDomRef: React.ReactInstance = null; componentDidMount() { this.rootDom = ReactDOM.findDOMNode(this.rootDomRef) as HTMLDivElement; this.chart = new G2.Chart({ container: document.getElementById(\"chart\"), forceFit: true, height: 300 }); this.freshChart(this.props); } componentWillReceiveProps(nextProps: Props) { this.freshChart(nextProps); } componentWillUnmount() { this.chart.destroy(); } freshChart(props: Props) { // do something this.chart.render(); } render() { return (this.rootDomRef = ref)} />; } } 用 React Hooks 可以这么做： function App() { const ref = React.useRef(null); let chart: G2.Chart = null; React.useEffect(() => { if (!chart) { chart = new G2.Chart({ container: ReactDOM.findDOMNode(ref.current) as HTMLDivElement, width: 500, height: 500 }); } // do something chart.render(); return () => chart.destroy(); }); return ; } 可以看到将细碎的代码片段结合成了一个完整的代码块，更维护。 现在介绍了 useState useContext useEffect useRef 等常用 hooks，更多可以查阅：内置 Hooks，相信不久的未来，这些 API 又会成为一套新的前端规范。 React Hooks 将带来什么变化 Hooks 带来的约定 Hook 函数必须以 \"use\" 命名开头，因为这样才方便 eslint 做检查，防止用 condition 判断包裹 useHook 语句。 为什么不能用 condition 包裹 useHook 语句，详情可以见 官方文档，这里简单介绍一下。 React Hooks 并不是通过 Proxy 或者 getters 实现的（具体可以看这篇文章 React hooks: not magic, just arrays），而是通过数组实现的，每次 useState 都会改变下标，如果 useState 被包裹在 condition 中，那每次执行的下标就可能对不上，导致 useState 导出的 setter 更新错数据。 虽然有 eslint-plugin-react-hooks 插件保驾护航，但这第一次将 “约定优先” 理念引入了 React 框架中，带来了前所未有的代码命名和顺序限制（函数命名遭到官方限制，JS 自由主义者也许会暴跳如雷），但带来的便利也是前所未有的（没有比 React Hooks 更好的状态共享方案了，约定带来提效，自由的代价就是回到 renderProps or HOC，各团队可以自行评估）。 笔者认为，React Hooks 的诞生，也许来自于这个灵感：“不如通过增加一些约定，彻底解决状态共享问题吧！” React 约定大于配置脚手架 nextjs umi 以及笔者的 pri 都通过有 “约定路由” 的功能，大大降低了路由配置复杂度，那么 React Hooks 就像代码级别的约定，大大降低了代码复杂度。 状态与 UI 的界限会越来越清晰 因为 React Hooks 的特性，如果一个 Hook 不产生 UI，那么它可以永远被其他 Hook 封装，虽然允许有副作用，但是被包裹在 useEffect 里，总体来说还是挺函数式的。而 Hooks 要集中在 UI 函数顶部写，也很容易养成书写无状态 UI 组件的好习惯，践行 “状态与 UI 分开” 这个理念会更容易。 不过这个理念稍微有点蹩脚的地方，那就是 “状态” 到底是什么。 function App() { const [count, setCount] = useCount(); return {count}; } 我们知道 useCount 算是无状态的，因为 React Hooks 本质就是 renderProps 或者 HOC 的另一种写法，换成 renderProps 就好理解了： {(count, setCount) => }; function App(props) { return {props.count}; } 可以看到 App 组件是无状态的，输出完全由输入（Props）决定。 那么有状态无 UI 的组件就是 useCount 了： function useCount() { const [count, setCount] = useState(0); return [count, setCount]; } 有状态的地方应该指 useState(0) 这句，不过这句和无状态 UI 组件 App 的 useCount() 很像，既然 React 把 useCount 成为自定义 Hook，那么 useState 就是官方 Hook，具有一样的定义，因此可以认为 useCount 是无状态的，useState 也是一层 renderProps，最终的状态其实是 useState 这个 React 内置的组件。 我们看 renderProps 嵌套的表达： {(count, setCount) => ( {\" \"} {/**虽然是透传，但给 count 做了去重，不可谓没有作用 */} {(count, setCount) => } )} 能确定的是，App 一定有 UI，而上面两层父级组件一定没有 UI。为了最佳实践，我们尽量避免 App 自己维护状态，而其父级的 RenderProps 组件可以维护状态（也可以不维护状态，做个二传手）。因此可以考虑在 “有状态的组件没有渲染，有渲染的组件没有状态” 这句话后面加一句：没渲染的组件也可以没状态。 React Hooks 实践 通过上面的理解，你已经对 React Hooks 有了基本理解，也许你也看了 React Hooks 基本实现剖析（就是数组），但理解实现原理就可以用好了吗？学的是知识，而用的是技能，看别人的用法就像刷抖音一样（哇，饭还可以这样吃？），你总会有新的收获。 首先，站在使用角度，要理解 React Hooks 的特点是 “非常方便的 Connect 一切”，所以无论是数据流、Network，或者是定时器都可以监听，有一点 RXJS 的意味，也就是你可以利用 React Hooks，将 React 组件打造成：任何事物的变化都是输入源，当这些源变化时会重新触发 React 组件的 render，你只需要挑选组件绑定哪些数据源（use 哪些 Hooks），然后只管写 render 函数就行了！ DOM 副作用修改 / 监听 做一个网页，总有一些看上去和组件关系不大的麻烦事，比如修改页面标题（切换页面记得改成默认标题）、监听页面大小变化（组件销毁记得取消监听）、断网时提示（一层层装饰器要堆成小山了）。而 React Hooks 特别擅长做这些事，造这种轮子，大小皆宜。 由于 React Hooks 降低了高阶组件使用成本，那么一套生命周期才能完成的 “杂耍” 将变得非常简单。 下面举几个例子： 修改页面 title 效果：在组件里调用 useDocumentTitle 函数即可设置页面标题，且切换页面时，页面标题重置为默认标题 “前端精读”。 useDocumentTitle(\"个人中心\"); 实现：直接用 document.title 赋值，不能再简单。在销毁时再次给一个默认标题即可，这个简单的函数可以抽象在项目工具函数里，每个页面组件都需要调用。 function useDocumentTitle(title) { useEffect( () => { document.title = title; return () => (document.title = \"前端精读\"); }, [title] ); } 在线 Demo 监听页面大小变化，网络是否断开 效果：在组件调用 useWindowSize 时，可以拿到页面大小，并且在浏览器缩放时自动触发组件更新。 const windowSize = useWindowSize(); return 页面高度：{windowSize.innerWidth}; 实现：和标题思路基本一致，这次从 window.innerHeight 等 API 直接拿到页面宽高即可，注意此时可以用 window.addEventListener('resize') 监听页面大小变化，此时调用 setValue 将会触发调用自身的 UI 组件 rerender，就是这么简单！ 最后注意在销毁时，removeEventListener 注销监听。 function getSize() { return { innerHeight: window.innerHeight, innerWidth: window.innerWidth, outerHeight: window.outerHeight, outerWidth: window.outerWidth }; } function useWindowSize() { let [windowSize, setWindowSize] = useState(getSize()); function handleResize() { setWindowSize(getSize()); } useEffect(() => { window.addEventListener(\"resize\", handleResize); return () => { window.removeEventListener(\"resize\", handleResize); }; }, []); return windowSize; } 在线 Demo 动态注入 css 效果：在页面注入一段 class，并且当组件销毁时，移除这个 class。 const className = useCss({ color: \"red\" }); return Text.; 实现：可以看到，Hooks 方便的地方是在组件销毁时移除副作用，所以我们可以安心的利用 Hooks 做一些副作用。注入 css 自然不必说了，而销毁 css 只要找到注入的那段引用进行销毁即可，具体可以看这个 代码片段。 DOM 副作用修改 / 监听场景有一些现成的库了，从名字上就能看出来用法：document-visibility、network-status、online-status、window-scroll-position、window-size、document-title。 组件辅助 Hooks 还可以增强组件能力，比如拿到并监听组件运行时宽高等。 获取组件宽高 效果：通过调用 useComponentSize 拿到某个组件 ref 实例的宽高，并且在宽高变化时，rerender 并拿到最新的宽高。 const ref = useRef(null); let componentSize = useComponentSize(ref); return ( <> {componentSize.width} ); 实现：和 DOM 监听类似，这次换成了利用 ResizeObserver 对组件 ref 进行监听，同时在组件销毁时，销毁监听。 其本质还是监听一些副作用，但通过 ref 的传递，我们可以对组件粒度进行监听和操作了。 useLayoutEffect(() => { handleResize(); let resizeObserver = new ResizeObserver(() => handleResize()); resizeObserver.observe(ref.current); return () => { resizeObserver.disconnect(ref.current); resizeObserver = null; }; }, []); 在线 Demo，对应组件 component-size。 拿到组件 onChange 抛出的值 效果：通过 useInputValue() 拿到 Input 框当前用户输入的值，而不是手动监听 onChange 再腾一个 otherInputValue 和一个回调函数把这一堆逻辑写在无关的地方。 let name = useInputValue(\"Jamie\"); // name = { value: 'Jamie', onChange: [Function] } return ; 可以看到，这样不仅没有占用组件自己的 state，也不需要手写 onChange 回调函数进行处理，这些处理都压缩成了一行 use hook。 实现：读到这里应该大致可以猜到了，利用 useState 存储组件的值，并抛出 value 与 onChange，监听 onChange 并通过 setValue 修改 value, 就可以在每次 onChange 时触发调用组件的 rerender 了。 function useInputValue(initialValue) { let [value, setValue] = useState(initialValue); let onChange = useCallback(function(event) { setValue(event.currentTarget.value); }, []); return { value, onChange }; } 这里要注意的是，我们对组件增强时，组件的回调一般不需要销毁监听，而且仅需监听一次，这与 DOM 监听不同，因此大部分场景，我们需要利用 useCallback 包裹，并传一个空数组，来保证永远只监听一次，而且不需要在组件销毁时注销这个 callback。 在线 Demo，对应组件 input-value。 做动画 利用 React Hooks 做动画，一般是拿到一些具有弹性变化的值，我们可以将值赋给进度条之类的组件，这样其进度变化就符合某种动画曲线。 在某个时间段内获取 0-1 之间的值 这个是动画最基本的概念，某个时间内拿到一个线性增长的值。 效果：通过 useRaf(t) 拿到 t 毫秒内不断刷新的 0-1 之间的数字，期间组件会不断刷新，但刷新频率由 requestAnimationFrame 控制（不会卡顿 UI）。 const value = useRaf(1000); 实现：写起来比较冗长，这里简单描述一下。利用 requestAnimationFrame 在给定时间内给出 0-1 之间的值，那每次刷新时，只要判断当前刷新的时间点占总时间的比例是多少，然后做分母，分子是 1 即可。 在线 Demo，对应组件 use-raf。 弹性动画 效果：通过 useSpring 拿到动画值，组件以固定频率刷新，而这个动画值以弹性函数进行增减。 实际调用方式一般是，先通过 useState 拿到一个值，再通过动画函数包住这个值，这样组件就会从原本的刷新一次，变成刷新 N 次，拿到的值也随着动画函数的规则变化，最后这个值会稳定到最终的输入值（如例子中的 50）。 const [target, setTarget] = useState(50); const value = useSpring(target); return setTarget(100)}>{value}; 实现：为了实现动画效果，需要依赖 rebound 库，它可以实现将一个目标值拆解为符合弹性动画函数过程的功能，那我们需要利用 React Hooks 做的就是在第一次接收到目标值是，调用 spring.setEndValue 来触发动画事件，并在 useEffect 里做一次性监听，再值变时重新 setValue 即可。 最神奇的 setTarget 联动 useSpring 重新计算弹性动画部分，是通过 useEffect 第二个参数实现的： useEffect( () => { if (spring) { spring.setEndValue(targetValue); } }, [targetValue] ); 也就是当目标值变化后，才会进行新的一轮 rerender，所以 useSpring 并不需要监听调用处的 setTarget，它只需要监听 target 的变化即可，而巧妙利用 useEffect 的第二个参数可以事半功倍。 在线 Demo Tween 动画 明白了弹性动画原理，Tween 动画就更简单了。 效果：通过 useTween 拿到一个从 0 变化到 1 的值，这个值的动画曲线是 tween。可以看到，由于取值范围是固定的，所以我们不需要给初始值了。 const value = useTween(); 实现：通过 useRaf 拿到一个线性增长的值（区间也是 0 ～ 1），再通过 easing 库将其映射到 0 ～ 1 到值即可。这里用到了 hook 调用 hook 的联动（通过 useRaf 驱动 useTween），还可以在其他地方举一反三。 const fn: Easing = easing[easingName]; const t = useRaf(ms, delay); return fn(t); 发请求 利用 Hooks，可以将任意请求 Promise 封装为带有标准状态的对象：loading、error、result。 通用 Http 封装 效果：通过 useAsync 将一个 Promise 拆解为 loading、error、result 三个对象。 const { loading, error, result } = useAsync(fetchUser, [id]); 实现：在 Promise 的初期设置 loading，结束后设置 result，如果出错则设置 error，这里可以将请求对象包装成 useAsyncState 来处理，这里就不放出来了。 export function useAsync(asyncFunction) { const asyncState = useAsyncState(options); useEffect(() => { const promise = asyncFunction(); asyncState.setLoading(); promise.then( result => asyncState.setResult(result);, error => asyncState.setError(error); ); }, params); } 具体代码可以参考 react-async-hook，这个功能建议仅了解原理，具体实现因为有一些边界情况需要考虑，比如组件 isMounted 后才能相应请求结果。 Request Service 业务层一般会抽象一个 request service 做统一取数的抽象（比如统一 url，或者可以统一换 socket 实现等等）。假如以前比较 low 的做法是： async componentDidMount() { // setState: 改 isLoading state try { const data = await fetchUser() // setState: 改 isLoading、error、data } catch (error) { // setState: 改 isLoading、error } } 后来把请求放在 redux 里，通过 connect 注入的方式会稍微有些改观： @Connect(...) class App extends React.PureComponent { public componentDidMount() { this.props.fetchUser() } public render() { // this.props.userData.isLoading | error | data } } 最后会发现还是 Hooks 简洁明了： function App() { const { isLoading, error, data } = useFetchUser(); } 而 useFetchUser 利用上面封装的 useAsync 可以很容易编写： const fetchUser = id => fetch(`xxx`).then(result => { if (result.status !== 200) { throw new Error(\"bad status = \" + result.status); } return result.json(); }); function useFetchUser(id) { const asyncFetchUser = useAsync(fetchUser, id); return asyncUser; } 填表单 React Hooks 特别适合做表单，尤其是 antd form 如果支持 Hooks 版，那用起来会方便许多： function App() { const { getFieldDecorator } = useAntdForm(); return ( {getFieldDecorator(\"userName\", { rules: [{ required: true, message: \"Please input your username!\" }] })( } placeholder=\"Username\" /> )} Log in Or register now! ); } 不过虽然如此，getFieldDecorator 还是基于 RenderProps 思路的，彻底的 Hooks 思路是利用之前说的 组件辅助方式，提供一个组件方法集，用解构方式传给组件。 Hooks 思维的表单组件 效果：通过 useFormState 拿到表单值，并且提供一系列 组件辅助 方法控制组件状态。 const [formState, { text, password }] = useFormState(); return ( ); 上面可以通过 formState 随时拿到表单值，和一些校验信息，通过 password(\"pwd\") 传给 input 组件，让这个组件达到受控状态，且输入类型是 password 类型，表单 key 是 pwd。而且可以看到使用的 form 是原生标签，这种表单增强是相当解耦的。 实现：仔细观察一下结构，不难发现，我们只要结合 组件辅助 小节说的 “拿到组件 onChange 抛出的值” 一节的思路，就能轻松理解 text、password 是如何作用于 input 组件，并拿到其输入状态。 往简单的来说，只要把这些状态 Merge 起来，通过 useReducer 聚合到 formState 就可以实现了。 为了简化，我们只考虑对 input 的增强，源码仅需 30 几行： export function useFormState(initialState) { const [state, setState] = useReducer(stateReducer, initialState || {}); const createPropsGetter = type => (name, ownValue) => { const hasOwnValue = !!ownValue; const hasValueInState = state[name] !== undefined; function setInitialValue() { let value = \"\"; setState({ [name]: value }); } const inputProps = { name, // 给 input 添加 type: text or password get value() { if (!hasValueInState) { setInitialValue(); // 给初始化值 } return hasValueInState ? state[name] : \"\"; // 赋值 }, onChange(e) { let { value } = e.target; setState({ [name]: value }); // 修改对应 Key 的值 } }; return inputProps; }; const inputPropsCreators = [\"text\", \"password\"].reduce( (methods, type) => ({ ...methods, [type]: createPropsGetter(type) }), {} ); return [ { values: state }, // formState inputPropsCreators ]; } 上面 30 行代码实现了对 input 标签类型的设置，监听 value onChange，最终聚合到大的 values 作为 formState 返回。读到这里应该发现对 React Hooks 的应用都是万变不离其宗的，特别是对组件信息的获取，通过解构方式来做，Hooks 内部再做一下聚合，就完成表单组件基本功能了。 实际上一个完整的轮子还需要考虑 checkbox radio 的兼容，以及校验问题，这些思路大同小异，具体源码可以看 react-use-form-state。 模拟生命周期 有的时候 React15 的 API 还是挺有用的，利用 React Hooks 几乎可以模拟出全套。 componentDidMount 效果：通过 useMount 拿到 mount 周期才执行的回调函数。 useMount(() => { // quite similar to `componentDidMount` }); 实现：componentDidMount 等价于 useEffect 的回调（仅执行一次时），因此直接把回调函数抛出来即可。 useEffect(() => void fn(), []); componentWillUnmount 效果：通过 useUnmount 拿到 unmount 周期才执行的回调函数。 useUnmount(() => { // quite similar to `componentWillUnmount` }); 实现：componentWillUnmount 等价于 useEffect 的回调函数返回值（仅执行一次时），因此直接把回调函数返回值抛出来即可。 useEffect(() => fn, []); componentDidUpdate 效果：通过 useUpdate 拿到 didUpdate 周期才执行的回调函数。 useUpdate(() => { // quite similar to `componentDidUpdate` }); 实现：componentDidUpdate 等价于 useMount 的逻辑每次执行，除了初始化第一次。因此采用 mouting flag（判断初始状态）+ 不加限制参数确保每次 rerender 都会执行即可。 const mounting = useRef(true); useEffect(() => { if (mounting.current) { mounting.current = false; } else { fn(); } }); Force Update 效果：这个最有意思了，我希望拿到一个函数 update，每次调用就强制刷新当前组件。 const update = useUpdate(); 实现：我们知道 useState 下标为 1 的项是用来更新数据的，而且就算数据没有变化，调用了也会刷新组件，所以我们可以把返回一个没有修改数值的 setValue，这样它的功能就仅剩下刷新组件了。 const useUpdate = () => useState(0)[1]; 对于 getSnapshotBeforeUpdate, getDerivedStateFromError, componentDidCatch 目前 Hooks 是无法模拟的。 isMounted 很久以前 React 是提供过这个 API 的，后来移除了，原因是可以通过 componentWillMount 和 componentWillUnmount 推导。自从有了 React Hooks，支持 isMount 简直是分分钟的事。 效果：通过 useIsMounted 拿到 isMounted 状态。 const isMounted = useIsMounted(); 实现：看到这里的话，应该已经很熟悉这个套路了，useEffect 第一次调用时赋值为 true，组件销毁时返回 false，注意这里可以加第二个参数为空数组来优化性能。 const [isMount, setIsMount] = useState(false); useEffect(() => { if (!isMount) { setIsMount(true); } return () => setIsMount(false); }, []); return isMount; 在线 Demo 存数据 上一篇提到过 React Hooks 内置的 useReducer 可以模拟 Redux 的 reducer 行为，那唯一需要补充的就是将数据持久化。我们考虑最小实现，也就是全局 Store + Provider 部分。 全局 Store 效果：通过 createStore 创建一个全局 Store，再通过 StoreProvider 将 store 注入到子组件的 context 中，最终通过两个 Hooks 进行获取与操作：useStore 与 useAction： const store = createStore({ user: { name: \"小明\", setName: (state, payload) => { state.name = payload; } } }); const App = () => ( ); function YourApp() { const userName = useStore(state => state.user.name); const setName = userAction(dispatch => dispatch.user.setName); } 实现：这个例子的实现可以单独拎出一篇文章了，所以笔者从存数据的角度剖析一下 StoreProvider 的实现。 对，Hooks 并不解决 Provider 的问题，所以全局状态必须有 Provider，但这个 Provider 可以利用 React 内置的 createContext 简单搞定： const StoreContext = createContext(); const StoreProvider = ({ children, store }) => ( {children} ); 剩下就是 useStore 怎么取到持久化 Store 的问题了，这里利用 useContext 和刚才创建的 Context 对象： const store = useContext(StoreContext); return store; 更多源码可以参考 easy-peasy，这个库基于 redux 编写，提供了一套 Hooks API。 封装原有库 是不是 React Hooks 出现后，所有的库都要重写一次？当然不是，我们看看其他库如何做改造。 RenderProps to Hooks 这里拿 react-powerplug 举例。 比如有一个 renderProps 库，希望改造成 Hooks 的用法： import { Toggle } from 'react-powerplug' function App() { return ( {({ on, toggle }) => ( )} ) } ↓ ↓ ↓ ↓ ↓ ↓ import { useToggle } from 'react-powerhooks' function App() { const [on, toggle] = useToggle() return } 效果：假如我是 react-powerplug 的维护者，怎么样最小成本支持 React Hook? 说实话这个没办法一步做到，但可以通过两步实现。 export function Toggle() { // 这是 Toggle 的源码 // balabalabala.. } const App = wrap(() => { // 第一步：包 wrap const [on, toggle] = useRenderProps(Toggle); // 第二步：包 useRenderProps }); 实现：首先解释一下为什么要包两层，首先 Hooks 必须遵循 React 的规范，我们必须写一个 useRenderProps 函数以符合 Hooks 的格式，那问题是如何拿到 Toggle 给 render 的 on 与 toggle？正常方式应该拿不到，所以退而求其次，将 useRenderProps 拿到的 Toggle 传给 wrap，让 wrap 构造 RenderProps 执行环境拿到 on 与 toggle 后，调用 useRenderProps 内部的 setArgs 函数，让 const [on, toggle] = useRenderProps(Toggle) 实现曲线救国。 const wrappers = []; // 全局存储 wrappers export const useRenderProps = (WrapperComponent, wrapperProps) => { const [args, setArgs] = useState([]); const ref = useRef({}); if (!ref.current.initialized) { wrappers.push({ WrapperComponent, wrapperProps, setArgs }); } useEffect(() => { ref.current.initialized = true; }, []); return args; // 通过下面 wrap 调用 setArgs 获取值。 }; 由于 useRenderProps 会先于 wrap 执行，所以 wrappers 会先拿到 Toggle，wrap 执行时直接调用 wrappers.pop() 即可拿到 Toggle 对象。然后构造出 RenderProps 的执行环境即可： export const wrap = FunctionComponent => props => { const element = FunctionComponent(props); const ref = useRef({ wrapper: wrappers.pop() }); // 拿到 useRenderProps 提供的 Toggle const { WrapperComponent, wrapperProps } = ref.current.wrapper; return createElement(WrapperComponent, wrapperProps, (...args) => { // WrapperComponent => Toggle，这一步是在构造 RenderProps 执行环境 if (!ref.current.processed) { ref.current.wrapper.setArgs(args); // 拿到 on、toggle 后，通过 setArgs 传给上面的 args。 ref.current.processed = true; } else { ref.current.processed = false; } return element; }); }; 以上实现方案参考 react-hooks-render-props，有需求要可以拿过来直接用，不过实现思路可以参考，作者的脑洞挺大。 Hooks to RenderProps 好吧，如果希望 Hooks 支持 RenderProps，那一定是希望同时支持这两套语法。 效果：一套代码同时支持 Hooks 和 RenderProps。 实现：其实 Hooks 封装为 RenderProps 最方便，因此我们使用 Hooks 写核心的代码，假设我们写一个最简单的 Toggle： const useToggle = initialValue => { const [on, setOn] = useState(initialValue); return { on, toggle: () => setOn(!on) }; }; 在线 Demo 然后通过 render-props 这个库可以轻松封装出 RenderProps 组件： const Toggle = ({ initialValue, children, render = children }) => renderProps(render, useToggle(initialValue)); 在线 Demo 其实 renderProps 这个组件的第二个参数，在 Class 形式 React 组件时，接收的是 this.state，现在我们改成 useToggle 返回的对象，也可以理解为 state，利用 Hooks 机制驱动 Toggle 组件 rerender，从而让子组件 rerender。 封装原本对 setState 增强的库 Hooks 也特别适合封装原本就作用于 setState 的库，比如 immer。 useState 虽然不是 setState，但却可以理解为控制高阶组件的 setState，我们完全可以封装一个自定义的 useState，然后内置对 setState 的优化。 比如 immer 的语法是通过 produce 包装，将 mutable 代码通过 Proxy 代理为 immutable： const nextState = produce(baseState, draftState => { draftState.push({ todo: \"Tweet about it\" }); draftState[1].done = true; }); 那这个 produce 就可以通过封装一个 useImmer 来隐藏掉： function useImmer(initialValue) { const [val, updateValue] = React.useState(initialValue); return [ val, updater => { updateValue(produce(updater)); } ]; } 使用方式： const [value, setValue] = useImmer({ a: 1 }); value(obj => (obj.a = 2)); // immutable 总结 把 React Hooks 当作更便捷的 RenderProps 去用吧，虽然写法看上去是内部维护了一个状态，但其实等价于注入、Connect、HOC、或者 renderProps，那么如此一来，使用 renderProps 的门槛会大大降低，因为 Hooks 用起来实在是太方便了，我们可以抽象大量 Custom Hooks，让代码更加 FP，同时也不会增加嵌套层级。 "},"React/React进阶/React-HOC.html":{"url":"React/React进阶/React-HOC.html","title":"React HOC","keywords":"","body":"React高阶组件 React高阶组件 1. 什么是高阶组件？ 2. 解决什么问题？ 3. 高阶组件总共分为两大类 4. 代理方式 4.1 代理方式之 操纵prop 4.2 代理方式之 抽取状态 4.3 代理方式之 包装组件 4.4 代理方式的生命周期函数的过程类似于堆栈调用 5. 继承方式 5.1 继承方式之 操纵生命周期（渲染劫持） 5.2 继承方式之 操纵prop 6. 彩蛋recompose库 1. 什么是高阶组件？ 高阶组件是一种用于复用组件逻辑的高级技术，它并不是 React API 的一部分，而是从 React 演化而来的一种模式。具体地说，高阶组件就是一个接收一个组件并返回另外一个新组件的函数！ 输入的组件可以是一个组件的实例，也可以是一个组件类，还可以是一个无状态组件的函数。 2. 解决什么问题？ 随着项目越来越复杂，开发过程中，多个组件需要某个功能，而且这个功能和页面并没有关系，所以也不能简单的抽取成一个新的组件，但是如果让同样的逻辑在各个组件里各自实现，无疑会导致重复的代码。比如页面有三种弹窗一个有title，一个没有，一个又有右上角关闭按钮，除此之外别无它样，你总不能整好几个弹窗组件吧，这里除了tilte,关闭按钮其他的就可以做为上面说的基本材料。 3. 高阶组件总共分为两大类 代理方式 操纵 prop 访问 ref(不推荐) 抽取状态 包装组件 继承方式 操纵生命周期 操纵prop 4. 代理方式 4.1 代理方式之 操纵prop 删除prop import React from 'react' function HocRemoveProp(WrappedComponent) { return class WrappingComponent extends React.Component { render() { const { user, ...otherProps } = this.props return } } } export default HocRemoveProp 增加prop接下来我把简化了写法，把匿名函数去掉，同时换成箭头函数 import React from 'react' class HocAddProp = (WrappedComponent, uid) => class extends React.Component { render () { const newProps = { uid } return } } export default HocAddProp 上面HocRemoveProp高阶组件中，所做的事情和输入组件WrappedComponent功能一样，只是忽略了名为user的prop。也就是说，如果WrappedComponent能处理名为user的prop,这个高阶组件返回的组件则完全无视这个prop。 const { user, ...otherProps } = this.props; 这是一个利用es6语法技巧，经过上面的语句，otherProps里面就有this.props中所有的字段除了user. 假如我们现在不希望某个组件接收user的prop,那么我们就不要直接使用这个组件，而是把这个组件作为参数传递给HocRemoveProp，然后我们把这个函数的返回结果当作组件来使用 两个高阶组件的使用方法： const newComponent = HocRemoveProp(SampleComponent); const newComponent = HocAddProp(SampleComponent,'1111111'); 也可以利用decorator语法糖这样使用 import React, { Component } from 'React'; @HocRemoveProp class SampleComponent extends Component { render() {} } export default SampleComponent; 4.2 代理方式之 抽取状态 将所有的状态的管理交给外面的容器组件，这个模式就是 抽取状态，外面的容器就是这个高阶组件。 const HocContainer = (WrappedComponent) => { class extends React.Component { constructor(props) { super(props) this.state = { name: '' } } onNameChange = (event) => { this.setState({ name: event.target.value }) } render () { const newProps = { name: { value: this.state.name, onChange: this.onNameChange } } return } } } @HocContainer class SampleComponent extends React.Component { render() { return } } 这样当我们使用这个以及被包裹的input组件(SampleComponent)时候，它的值就被放在了HocContainer高阶组件中，当很多这样的input组件都用这个HocContainer高阶组件时，那么它们的值都将保存在这个 HocContainer 高阶组件中 4.3 代理方式之 包装组件 const HocStyleComponent = (WrappedComponent, style) =>{ class extends React.Component { render() { return ( ) } } } 这样使用 import HocStyleComponent from './HocStyleComponent' const colorStyle = {color: '#ff5555'} const newComponent = HocStyleComponent(SampleComponent, colorStyle) 4.4 代理方式的生命周期函数的过程类似于堆栈调用 didmount -> HOC didmount -> (HOCs dismount) -> (HOCs will unmount) -> Hoc will unmount -> unmount 5. 继承方式 在说继承方式之前先看一个例子 const MyContainer = (WrappedComponent) => { class extends WrappedComponent { render() { return super.render() } } } 这个例子很简单，相当于把WrappedComponent组件的render方法，通过super.render()方法吐到了MyContainer中，可以顺序调用。 继承方式的生命周期的过程类似于队列调用： didmount -> HOC didmount -> (HOCs didmount) -> will unmount -> HOC will unmount -> (HOCs will unmount) -> 代理方式下 WrappedComponent 会经历一个完整的生命周期，产生的新组件和参数组件是两个不同的组件，一次渲染，两个组件都会经历各自的生命周期。 在继承方式下，产生的新组件和参数组件合二为一， super.render只是生命周期中的函数，变成一个生命周期。 5.1 继承方式之 操纵生命周期（渲染劫持） 首先创建一个高阶，在创建一个使用高阶组件，也就是输入组件，最后我在改变这个输入组件 props import * as React from 'react' const HocComponent = (WrappedComponent) =>{ class MyContainer extends WrappedComponent { render() { if (this.props.time && this.state.success) { return super.render() } return 倒计时完成了... } } } 这个高阶组件会直接读取输入组件中的props,state,然后控制了输入组件的render展示 只有在props.time和state.success同时为真的时候才会展示 import * as React from 'react'; import HocComponent from './HocComponent' @HocComponent class DemoComponent extends React.Component { constructor(props) { super(props); this.state = { success: true, }; } render() { return 我是一个组件 } } export default DemoComponent; 然后调用，递减time数值直到变为0最后页面的效果就是，当然他不是循环的。先展示”我是一个组件“，我设置了两秒，之后展示”倒计时完成“ 由此可以看出高阶组件也可以控制state 但是最好要限制这样做，可能会让WrappedComponent组件内部状态变得一团糟。建议可以通过重新命名state，以防止混淆。 5.2 继承方式之 操纵prop const HOCPropsComponent = (WrappedComponent) => { class extends WrappedComponent { render() { const elementsTree = super.render() let newProps = { color: (elementsTree && elementsTree.type === 'div') ? '#fff' : '#ff5555' } const props = Object.assign({}, elementsTree.props, newProps) const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children) } } } 这样就传入了新的props React.cloneElement( element, [props], [...children]) 参数：TYPE（ReactElement），[PROPS（object）]，[CHILDREN（ReactElement） 克隆并返回一个新的 ReactElement ，新返回的元素会保留有旧元素的 props、ref、key，也会集成新的 props。 6. 彩蛋recompose库 recompose是一个很流行的库，它提供了很多很有用的高阶组件（小工具），而且也可以优雅的组合它们。 Step1 扁平props我们有这样一个组件 const Profile = ({user}) => ( Username: {user.username} Age: {user.age} ) 如果想要改变组件接口来接收单个 prop 而不是整个用户对象，可以用 recompose 提供的高阶组件 flattenProp 来实现 const Profile = ({username, age}) => ( Username: {username} Age: {age} ) const ProfileWithFlattenUser = flattenProp('user')(Profile) 现在我们希望同时使用多个高阶组件：一个用于扁平化处理用户prop,另外一个用于重命名用户对象的单个 prop。此时 recompose 库提供的 compose 函数就派上用场了。 const enhance = compose( flattenProp('user'), renameProp('username', 'name') ) 然后按照以下方式将它应用于原有组件： const EnhancedProfile = enhance(Profile) 还可以将 compose 函数用在我们自己的高阶组件上，甚至结合使用都可以： const enhance = compose( flattenProp('user'), renameProp('username', 'name'), withInnerWidth ) Step2 提取输入表单的State 我们将从 Recompose 库中使用 withStateHandlers 高阶组件。它将允许我们从组件状态与组件本身隔离开来。 我们将使用它作为电子邮件，密码和确认密码字段添加表单状态，以及上述的时间处理程序。 import { withStateHandlers, compose } from 'recompose' const initialState = { email: {value: ''}, password: {value: ''}, confirmPassword: {value: ''} } const onChangeEmail = props => event => ({email: {value: event.target.value, isDirty: true }) const onChangePassword = props => event => ({ password: { value: event.target.value, isDirty: true } }) const onChangeConfirmPassword = props => event => ({ confirmPassword: { value: event.target.value, isDirty: true } }) const withTextFieldState => withStateHandlers(initialState, { onChangeEmail, onChangePassword, onChangeConfirmPassword }) export default widthTextFieldState withStateHandlers它接受初始状态和包含状态处理程序的对象。调用时，每个状态处理程序将返回新的状态。 "},"React/React进阶/HOC.html":{"url":"React/React进阶/HOC.html","title":"React-HOC","keywords":"","body":"什么是高阶组件 高阶组件就是一个函数，传给它一个组件，它返回一个新的组件。 const NewComponent = higherOrderComponent(OldComponent) 重要的事情再重复一次，高阶组件是一个函数（而不是组件），它接受一个组件作为参数，返回一个新的组件。这个新的组件会使用你传给它的组件作为子组件，我们看看一个很简单的高阶组件： import React, { Component } from 'react' export default (WrappedComponent) => { class NewComponent extends Component { // 可以做很多自定义逻辑 render () { return } } return NewComponent } 现在看来好像什么用都没有，它就是简单的构建了一个新的组件类 NewComponent，然后把传进入去的 WrappedComponent 渲染出来。但是我们可以给 NewCompoent 做一些数据启动工作： import React, { Component } from 'react' export default (WrappedComponent, name) => { class NewComponent extends Component { constructor () { super() this.state = { data: null } } componentWillMount () { let data = localStorage.getItem(name) this.setState({ data }) } render () { return } } return NewComponent } 现在 NewComponent 会根据第二个参数 name 在挂载阶段从 LocalStorage 加载数据，并且 setState 到自己的 state.data 中，而渲染的时候将 state.data 通过 props.data 传给 WrappedComponent。 这个高阶组件有什么用呢？假设上面的代码是在 src/wrapWithLoadData.js 文件中的，我们可以在别的地方这么用它： import wrapWithLoadData from './wrapWithLoadData' class InputWithUserName extends Component { render () { return } } InputWithUserName = wrapWithLoadData(InputWithUserName, 'username') export default InputWithUserName 假如 InputWithUserName 的功能需求是挂载的时候从 LocalStorage 里面加载 username 字段作为 的 value 值，现在有了 wrapWithLoadData，我们可以很容易地做到这件事情。 只需要定义一个非常简单的 InputWithUserName，它会把 props.data 作为 的 value 值。然把这个组件和 'username' 传给 wrapWithLoadData，wrapWithLoadData 会返回一个新的组件，我们用这个新的组件覆盖原来的 InputWithUserName，然后再导出去模块。 别人用这个组件的时候实际是用了被加工过的组件： import InputWithUserName from './InputWithUserName' class Index extends Component { render () { return ( 用户名： ) } } 根据 wrapWithLoadData 的代码我们可以知道，这个新的组件挂载的时候会先去 LocalStorage 加载数据，渲染的时候再通过 props.data 传给真正的 InputWithUserName。 如果现在我们需要另外一个文本输入框组件，它也需要 LocalStorage 加载 'content' 字段的数据。我们只需要定义一个新的 TextareaWithContent： import wrapWithLoadData from './wrapWithLoadData' class TextareaWithContent extends Component { render () { return } } TextareaWithContent = wrapWithLoadData(TextareaWithContent, 'content') export default TextareaWithContent 写起来非常轻松，我们根本不需要重复写从 LocalStorage 加载数据字段的逻辑，直接用 wrapWithLoadData 包装一下就可以了。 我们来回顾一下到底发生了什么事情，对于 InputWithUserName 和 TextareaWithContent 这两个组件来说，它们的需求有着这么一个相同的逻辑：“挂载阶段从 LocalStorage 中加载特定字段数据”。 如果按照之前的做法，我们需要给它们两个都加上 componentWillMount 生命周期，然后在里面调用 LocalStorage。要是有第三个组件也有这样的加载逻辑，我又得写一遍这样的逻辑。但有了 wrapWithLoadData 高阶组件，我们把这样的逻辑用一个组件包裹了起来，并且通过给高阶组件传入 name 来达到不同字段的数据加载。充分复用了逻辑代码。 到这里，高阶组件的作用其实不言而喻，其实就是为了组件之间的代码复用。组件可能有着某些相同的逻辑，把这些逻辑抽离出来，放到高阶组件中进行复用。高阶组件内部的包装组件和被包装组件之间通过 props 传递数据。 高阶组件的灵活性 代码复用的方法、形式有很多种，你可以用类继承来做到代码复用，也可以分离模块的方式。但是高阶组件这种方式很有意思，也很灵活。学过设计模式的同学其实应该能反应过来，它其实就是设计模式里面的装饰者模式。它通过组合的方式达到很高的灵活程度。 假设现在我们需求变化了，现在要的是通过 Ajax 加载数据而不是从 LocalStorage 加载数据。我们只需要新建一个 wrapWithAjaxData 高阶组件： import React, { Component } from 'react' export default (WrappedComponent, name) => { class NewComponent extends Component { constructor () { super() this.state = { data: null } } componentWillMount () { ajax.get('/data/' + name, (data) => { this.setState({ data }) }) } render () { return } } return NewComponent } 其实就是改了一下 wrapWithLoadData 的 componentWillMount 中的逻辑，改成了从服务器加载数据。现在只需要把 InputWithUserName 稍微改一下： import wrapWithAjaxData from './wrapWithAjaxData' class InputWithUserName extends Component { render () { return } } InputWithUserName = wrapWithAjaxData(InputWithUserName, 'username') export default InputWithUserName 只要改一下包装的高阶组件就可以达到需要的效果。而且我们并没有改动 InputWithUserName 组件内部的任何逻辑，也没有改动 Index 的任何逻辑，只是改动了中间的高阶组件函数。 （以下内容为选读内容，有兴趣的同学可以继续往下读，否则也可以直接跳到文末的总结部分。） 多层高阶组件（选读） 假如现在需求有变化了：我们需要先从 LocalStorage 中加载数据，再用这个数据去服务器取数据。我们改一下（或者新建一个）wrapWithAjaxData 高阶组件，修改其中的 componentWillMount： ... componentWillMount () { ajax.get('/data/' + this.props.data, (data) => { this.setState({ data }) }) } ... 它会用传进来的 props.data 去服务器取数据。这时候修改 InputWithUserName： import wrapWithLoadData from './wrapWithLoadData' import wrapWithAjaxData from './wrapWithAjaxData' class InputWithUserName extends Component { render () { return } } InputWithUserName = wrapWithAjaxData(InputWithUserName) InputWithUserName = wrapWithLoadData(InputWithUserName, 'username') export default InputWithUserName 大家可以看到，我们给 InputWithUserName 应用了两种高阶组件：先用 wrapWithAjaxData 包裹 InputWithUserName，再用 wrapWithLoadData 包含上次包裹的结果。它们的关系就如下图的三个圆圈： 实际上最终得到的组件会先去 LocalStorage 取数据，然后通过 props.data 传给下一层组件，下一层用这个 props.data 通过 Ajax 去服务端取数据，然后再通过 props.data 把数据传给下一层，也就是 InputWithUserName。大家可以体会一下下图尖头代表的组件之间的数据流向： 用高阶组件改造评论功能（选读） 大家对这种在挂载阶段从 LocalStorage 加载数据的模式都很熟悉，在上一阶段的实战中，CommentInput 和 CommentApp 都用了这种方式加载、保存数据。实际上我们可以构建一个高阶组件把它们的相同的逻辑抽离出来，构建一个高阶组件 wrapWithLoadData： export default (WrappedComponent, name) => { class LocalStorageActions extends Component { constructor () { super() this.state = { data: null } } componentWillMount () { let data = localStorage.getItem(name) try { // 尝试把它解析成 JSON 对象 this.setState({ data: JSON.parse(data) }) } catch (e) { // 如果出错了就当普通字符串读取 this.setState({ data }) } } saveData (data) { try { // 尝试把它解析成 JSON 字符串 localStorage.setItem(name, JSON.stringify(data)) } catch (e) { // 如果出错了就当普通字符串保存 localStorage.setItem(name, `${data}`) } } render () { return ( ) } } return LocalStorageActions } CommentApp 可以这样使用： class CommentApp extends Component { static propTypes = { data: PropTypes.any, saveData: PropTypes.func.isRequired } constructor (props) { super(props) this.state = { comments: props.data } } handleSubmitComment (comment) { if (!comment) return if (!comment.username) return alert('请输入用户名') if (!comment.content) return alert('请输入评论内容') const comments = this.state.comments comments.push(comment) this.setState({ comments }) this.props.saveData(comments) } handleDeleteComment (index) { const comments = this.state.comments comments.splice(index, 1) this.setState({ comments }) this.props.saveData(comments) } render() { return ( ) } } CommentApp = wrapWithLoadData(CommentApp, 'comments') export default CommentApp 同样地可以在 CommentInput 中使用 wrapWithLoadData，这里就不贴代码了。有兴趣的同学可以查看高阶组件重构的 CommentApp 版本。 总结 高阶组件就是一个函数，传给它一个组件，它返回一个新的组件。新的组件使用传入的组件作为子组件。 高阶组件的作用是用于代码复用，可以把组件之间可复用的代码、逻辑抽离到高阶组件当中。新的组件和传入的组件通过 props 传递信息。 高阶组件有助于提高我们代码的灵活性，逻辑的复用性。灵活和熟练地掌握高阶组件的用法需要经验的积累还有长时间的思考和练习，如果你觉得本章节的内容无法完全消化和掌握也没有关系，可以先简单了解高阶组件的定义、形式和作用即可。 "},"React/React进阶/React事件处理机制.html":{"url":"React/React进阶/React事件处理机制.html","title":"React事件处理机制","keywords":"","body":"React 事件处理机制 React在处理事件和HTML中JS处理事件不同,本文介绍React中的事件处理机制。React中不通过返回false来阻止事件的默认行为,必须明确使用preventDefault. function ActionLink() { function handleClick(e) { e.preventDefault(); console.log('The link was clicked.'); } return ( Click me ); } 用ES6 class构建组件的时候，处理事件,需要注意的是，利用bind来绑定callback反馈。因为我们没有使用handleClick()来绑定到onClick上，仅仅使用{this.handleClick}.所以需要在constructor中来绑定this class Toggle extends React.Component { constructor(props) { super(props); this.state = {isToggleOn: true}; // This binding is necessary to make `this` work in the callback this.handleClick = this.handleClick.bind(this); } handleClick() { this.setState(prevState => ({ isToggleOn: !prevState.isToggleOn })); } render() { return ( {this.state.isToggleOn ? 'ON' : 'OFF'} ); } } 当然我们还可以用另外两种方法来绕过此绑定行为,但是依旧推荐在constructer绑定。 class LoggingButton extends React.Component { // This syntax ensures `this` is bound within handleClick. // Warning: this is *experimental* syntax. handleClick = () => { console.log('this is:', this); } render() { return ( Click me ); } } class LoggingButton extends React.Component { handleClick() { console.log('this is:', this); } render() { // This syntax ensures `this` is bound within handleClick return ( this.handleClick(e)}> Click me ); } } "},"React/React进阶/React事件机制.html":{"url":"React/React进阶/React事件机制.html","title":"React事件机制","keywords":"","body":"React事件机制 React事件机制 React事件系统 1.事件注册 2、事件存储 3、事件执行 3.1 事件分发 3.2生成合成事件 3.3批量处理回调函数 Jquery事件机制 主要包含事件注册、触发以及回调函数的存储，最后会讲述一下Jquery事件机制与React事件机制的相同之处。 React事件机制不是原生的那一套，React组件上声明的事件没有绑定在React组件对应的原生DOM节点上，而是绑定在document节点上，触发的事件是对原生事件的包装。 React事件系统 React内部事件系统实现可以分为两个阶段：事件注册、事件触发，涉及的主要类如下： ReactEventListener：负责事件注册和事件分发。React将DOM事件全都注册到document节点上，事件分发主要调用dispatchEvent进行，从事件触发组件开始，向父元素遍历。 ReactEventEmitter：负责每个组件上事件的执行。 EventPluginHub：负责回调函数的存储 JSX中声明一个React事件，比如： render() { return ( 点击 ) } 用户点击button按钮触发click事件后，DOM将event传给ReactEventListener，它将事件分发到当前组件及以上的父组件。然后ReactEventEmitter对每个组件进行事件的执行，先构造React合成事件，然后以队列的方式调用JSX中声明的callback。 备注：以下代码逻辑大部分写在注释里面 1.事件注册 要从组件创建和更新的入口方法说起，ReactDOMComponent在进行组件加载时入口方法为mountComponent、更新时入口方法为updateComponent，这两个方法都会调用_updateDOMProperties方法，对JSX中声明的组件属性进行处理，源码如下： ReactDOMComponent.Mixin = { /** * lastProp则表示上一次的属性 * nextProp表示要创建或者更新的属性 */ _updateDOMProperties: function (lastProps, nextProps, transaction) { ... // 如果是props这个对象直接声明的属性，不是从原型链中继承来的，则处理它 else if (registrationNameModules.hasOwnProperty(propKey)) { // 对于mountComponent，lastProp为null。updateComponent二者都不为null。 unmountComponent则nextProp为null if (nextProp) { // mountComponent和updateComponent中，enqueuePutListener注册事件 enqueuePutListener(this, propKey, nextProp, transaction); } else if (lastProp) { // unmountComponent中，删除注册的listener，防止内存泄漏 deleteListener(this, propKey); } } } } _updateDOMProperties中调用enqueuePutListener注册事件，下面来看enqueuePutListener，它负责两件事：在document上注册JSX中声明的事件；采用事务队列的方式存储注册事件，源码如下： /** * inst: React Component对象 * registrationName: React合成事件名，如onClick * listener: React事件回调方法，如onClick=callback中的callback * transaction: mountComponent或updateComponent所处的事务流，React都是基于事务流的 */ function enqueuePutListener(inst, registrationName, listener, transaction) { if (transaction instanceof ReactServerRenderingTransaction) { return; } var containerInfo = inst._hostContainerInfo; var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE; // 找到document var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument; // 注册事件，将事件注册到document上 listenTo(registrationName, doc); // 存储事件,放入事务队列中 transaction.getReactMountReady().enqueue(putListener, { inst: inst, registrationName: registrationName, listener: listener }); } 上面调用listenTo方法来注册事件，接下来看listenTo方法 ，源码如下： //ReactBrowserEventEmitter.js listenTo: function (registrationName, contentDocumentHandle) { ... if (...) { //注册冒泡事件 ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(...); } else if (...) { //注册捕获事件 ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(...); } ... } listenTo解决了不同浏览器间捕获和冒泡不兼容的问题，事件回调方法在冒泡阶段被触发，如果我们想让它在捕获阶段触发，需要在事件名加上capture，比如冒泡阶段触发，点击事件写成onClick，在捕获阶段触发需要写成onCaptureClick。 接下来主要看trapBubbledEvent方法，源码如下： //ReactEventListener.js var ReactEventListener = { ... trapBubbledEvent: function (topLevelType, handlerBaseName, element) { ... return EventListener.listen( element, //绑定到的DOM节点，即document handlerBaseName, //事件类型 ReactEventListener.dispatchEvent.bind(null, topLevelType) //callback，document上的原生事件触发后的回调函数，不包含任何的事物处理，只起到事件分发的作用 ); }, trapCapturedEvent: function (topLevelType, handlerBaseName, element) { var handler = ReactEventListener.dispatchEvent.bind(null, topLevelType); return EventListener.capture(element, handlerBaseName, handler); } //在listen方法中，终于发现了熟悉的addEventListener这个原生事件注册方法 listen: function listen(target, eventType, callback) { if (target.addEventListener) { // 将原生事件添加到target这个dom上,也就是document上。 // 这就是只有document这个DOM节点上有原生事件的原因 target.addEventListener(eventType, callback, false); return { // 删除事件,这个由React自己回调,不需要调用者来销毁。但仅仅对于React合成事件才行 remove: function remove() { target.removeEventListener(eventType, callback, false); } }; } else if (target.attachEvent) { // attach和detach的方式 target.attachEvent('on' + eventType, callback); return { remove: function remove() { target.detachEvent('on' + eventType, callback); } }; } }, //事件分发，document不管注册的是什么事件，都执行统一的回调函数 handleTopLevelImpl dispatchEvent: function (topLevelType, nativeEvent) { ... ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping); ... } } function handleTopLevelImpl(bookKeeping) { ... ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent)); ... } 事件注册说完了， 接下来说事件存储 2、事件存储 事件存储由EventPluginHub负责，它的入口在上面讲到的enqueuePutListener中的putListener方法，源码如下： /** * EventPluginHub用来存储React事件, 将listener存储到`listenerBank[registrationName][key]` * * @param {object} inst: 事件源 * @param {string} 事件属性，比如onClick * @param {function} callback */ // putListener: function (inst, registrationName, listener) { // 用来标识注册了事件,比如onClick的React对象。key的格式为'.nodeId', 只用知道它可以标示哪个React对象就可以了 var key = getDictionaryKey(inst); var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {}); // 将listener事件回调方法存入listenerBank[registrationName][key]中,比如listenerBank['onclick'][nodeId] // 所有React组件对象定义的所有React事件都会存储在listenerBank中 bankForRegistrationName[key] = listener; }, var getDictionaryKey = function (inst) { return '.' + inst._rootNodeID; }; React中的所有事件的回调函数均存储在listenerBank对象里，根据事件类型、component对象的_rootNodeID为两个key，来存储对应的回调函数。比如nodeId组件上注册的onClick事件最后存储在listenerBank.onclick[nodeId]中。 事件注册完后，就可以依据事件委托进行事件执行，接下来说事件执行。 3、事件执行 注册事件中已经提到，几乎所有的事件都注册在document上，document上的事件回调函数只有一个： ReactEventListener.dispatchEvent，进行相关的分发。 3.1 事件分发 源码如下 var ReactEventListener = { // topLevelType：事件名 // nativeEvent: 用户触发click等事件时，浏览器传递的原生事件 dispatchEvent: function (topLevelType, nativeEvent) { ... // 放入批处理队列中,React事件流也是一个消息队列的方式 ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping); ... } } //handleTopLevelImpl才是事件分发的真正执行者，它是事件分发的核心，体现了React事件分发的特点 function handleTopLevelImpl(bookKeeping) { //根据原生的事件对象，找到事件触发的dom元素以及该dom对应的component对象 var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent); var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget); // 执行事件回调前,先由当前组件向上遍历它的所有父组件。得到ancestors这个数组。 // 因为事件回调中可能会改变Virtual DOM结构,所以要先遍历好组件层级 var ancestor = targetInst; do { bookKeeping.ancestors.push(ancestor); ancestor = ancestor && findParent(ancestor); } while (ancestor); // 从当前组件向父组件遍历,依次执行注册的回调方法. 我们遍历构造ancestors数组时,是从当前组件向父组件回溯的,故此处事件回调也是这个顺序 // 这个顺序就是冒泡的顺序,并且我们发现不能通过stopPropagation来阻止'冒泡'。 for (var i = 0; i 从上面的事件分发中可见，React自身实现了一套冒泡机制。从触发事件的对象开始，向父元素回溯，依次调用它们注册的事件callback。 上面的代码提到批量处理回调函数时要把事件传进去，react中的事件对象不是原生的事件对象，而是经过处理后的对象，接下来看一下如何生成合成事件。 3.2生成合成事件 生成合成事件，源码如下： // EventPluginHub.js var EventPluginHub = { extractEvents: function (...) { var events; // EventPluginHub可以存储React合成事件的callback,也存储了一些plugin,这些plugin在EventPluginHub初始化时注册的 var plugins = EventPluginRegistry.plugins; for (var i = 0; i 上面提到系统启动过程中注入(injection)过来plugins，代码如下： // react-dom模块的入口文件ReactDOM.js: var ReactDefaultInjection = require('./ReactDefaultInjection'); ReactDefaultInjection.inject(); ... // ReactDefaultInjection.js module.exports = { inject: inject }; function inject() { ... ReactInjection.EventPluginHub.injectEventPluginsByName({ SimpleEventPlugin: SimpleEventPlugin, EnterLeaveEventPlugin: EnterLeaveEventPlugin, ChangeEventPlugin: ChangeEventPlugin, SelectEventPlugin: SelectEventPlugin, BeforeInputEventPlugin: BeforeInputEventPlugin }); ... } 默认情况下，react注入了五种事件plugin，针对不同的事件，得到不同的合成事件，下面看一下最常见的 SimpleEventPlugin 如何生成它对应的React合成事件，代码如下： // 根据不同事件类型,比如click,focus构造不同的合成事件SyntheticEvent, 如SyntheticKeyboardEvent SyntheticFocusEvent extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) { var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType]; if (!dispatchConfig) { return null; } var EventConstructor; // 根据事件类型，采用不同的SyntheticEvent来构造不同的合成事件 switch (topLevelType) { ... // 仅以blur和focus为例 case 'topBlur': case 'topFocus': EventConstructor = SyntheticFocusEvent; break; ... } // 从event对象池中取出合成事件对象 var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget); //用于从EventPluginHub中获取回调函数 EventPropagators.accumulateTwoPhaseDispatches(event); return event; }, 上面提到调用EventPropagators.accumulateTwoPhaseDispatches(event)从EventPluginHub中获取回调函数，如何获取具体的回调函数，如下： // EventPropagators.js function accumulateTwoPhaseDispatches(events) { forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle); } function accumulateTwoPhaseDispatchesSingle(event) { if (event && event.dispatchConfig.phasedRegistrationNames) { EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event); } } function accumulateDirectionalDispatches(inst, phase, event) { var listener = listenerAtPhase(inst, event, phase); if (listener) { event._dispatchListeners = accumulateInto(event._dispatchListeners, listener); event._dispatchInstances = accumulateInto(event._dispatchInstances, inst); } } var getListener = EventPluginHub.getListener; function listenerAtPhase(inst, event, propagationPhase) { var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase]; return getListener(inst, registrationName); } // EventPluginHub.js getListener: function (inst, registrationName) { var bankForRegistrationName = listenerBank[registrationName]; var key = getDictionaryKey(inst); return bankForRegistrationName && bankForRegistrationName[key]; }, 3.3批量处理回调函数 回调函数拿到了，继续3.1中的采用队列的方式处理回调函数，react会进行批量处理具体的回调函数，回调函数的执行为两步，源码如下： function runEventQueueInBatch(events) { // 第一步：将events事件放入队列中 EventPluginHub.enqueueEvents(events); // 第二部：处理队列中的事件,包括之前未处理完的。先入先处理原则 EventPluginHub.processEventQueue(false); } 第一步源码如下： var eventQueue = null; var EventPluginHub = { enqueueEvents: function (events) { if (events) { eventQueue = accumulateInto(eventQueue, events); } }, processEventQueue: function (simulated) { var processingEventQueue = eventQueue; ... forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated); ... }, } function accumulateInto(current, next) { if (current == null) { return next; } // 将next添加到current中,返回一个包含他们两个的新数组 // 如果next是数组,current不是数组,采用push方法,否则采用concat方法 // 如果next不是数组,则返回一个current和next构成的新数组 if (Array.isArray(current)) { if (Array.isArray(next)) { current.push.apply(current, next); return current; } current.push(next); return current; } if (Array.isArray(next)) { return [current].concat(next); } return [current, next]; } 第二步事件执行的入口方法为executeDispatchesAndReleaseTopLevel，代码如下： var executeDispatchesAndReleaseTopLevel = function (e) { return executeDispatchesAndRelease(e, false); }; var executeDispatchesAndRelease = function (event, simulated) { if (event) { //进行事件分发 EventPluginUtils.executeDispatchesInOrder(event, simulated); if (!event.isPersistent()) { // 处理完,则release掉event对象,采用对象池方式,减少GC // React帮我们处理了合成事件的回收机制，不需要我们关心。但要注意，如果使用了DOM原生事件，则要自己回收 event.constructor.release(event); } } }; // EventPluginUtils.js // 事件处理的核心 function executeDispatchesInOrder(event, simulated) { var dispatchListeners = event._dispatchListeners; var dispatchInstances = event._dispatchInstances; if (Array.isArray(dispatchListeners)) { // 如果有多个listener,则遍历执行数组中event for (var i = 0; i Jquery事件机制 Jquery事件机制中也会调用原生的注册事件和删除事件，回调函数存储跟React的回调函数存储类似，可以阅读代码，感受一下事件机制的相通之处，源码如下： jQuery.fn.extend( { on: function (types, selector, data, fn) { // on 又依托于全局的 on 函数 return on(this, types, selector, data, fn); } } ); //on函数 function on( elem, types, selector, data, fn, one ) { var origFn, type; // 支持 object 的情况 if ( typeof types === \"object\" ) { // ( types-Object, selector, data ) if ( typeof selector !== \"string\" ) { // ( types-Object, data ) data = data || selector; selector = undefined; } // 一次执行 object 的每一个 for ( type in types ) { on( elem, type, selector, data, types[ type ], one ); } return elem; } // 参数为两个的情况 if ( data == null && fn == null ) { // ( types, fn ) fn = selector; data = selector = undefined; } else if ( fn == null ) { if ( typeof selector === \"string\" ) { // ( types, selector, fn ) fn = data; data = undefined; } else { // ( types, data, fn ) fn = data; data = selector; selector = undefined; } } if ( fn === false ) { // returnFalse 是一个返回 false 的函数 fn = returnFalse; } else if ( !fn ) { return elem; } if ( one === 1 ) { origFn = fn; fn = function( event ) { // Can use an empty set, since event contains the info jQuery().off( event ); return origFn.apply( this, arguments ); }; // Use same guid so caller can remove using origFn fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ ); } return elem.each( function() { // 关键 jQuery.event.add( this, types, fn, data, selector ); } ); } //off函数 jQuery.fn.off = function (types, selector, fn) { var handleObj, type; if (types && types.preventDefault && types.handleObj) { // ( event ) dispatched jQuery.Event handleObj = types.handleObj; jQuery(types.delegateTarget).off( handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler ); return this; } if (typeof types === \"object\") { // ( types-object [, selector] ) for (type in types) { this.off(type, selector, types[type]); } return this; } if (selector === false || typeof selector === \"function\") { // ( types [, fn] ) fn = selector; selector = undefined; } if (fn === false) { fn = returnFalse; } return this.each(function() { // 关键 jQuery.event.remove(this, types, fn, selector); }); } "},"React/源码分析/React-Object实现React对象.html":{"url":"React/源码分析/React-Object实现React对象.html","title":"React Object实现React对象","keywords":"","body":"React Object实现React对象 React Object实现React对象 不使用ES6 声明Prop的检查类型以及默认Props值 设定初始化状态 自动绑定 代码混合器 不使用JSX 不使用ES6 通常情况下，定义一个React组件可以使用ES6规范中的class关键字： class Greeting extends React.Component { render() { return Hello, {this.props.name}; } } 如果不使用ES6语法，可以直接使用 React.createClass 来实现相同的功能： var Greeting = React.createClass({ render: function() { return Hello, {this.props.name}; } }); 声明Prop的检查类型以及默认Props值 class Greeting extends React.Component { // ... } Greeting.propTypes = { name: React.PropTypes.string }; Greeting.defaultProps = { name: 'Mary' }; 在使用 React.createClass 时，可以通过设定传入的对象的一个属性值—— propTypes 来指定参数类型，通过 getDefaultProps() 方法来设定每个参数的默认值： var Greeting = React.createClass({ propTypes: { name: PropTypes.string }, getDefaultProps: function() { return { name: 'Mary' }; }, // ... }); 设定初始化状态 在ES6的 class 结构中，我们可以在构造函数中设定初始化状态： class Counter extends React.Component { constructor(props) { super(props); this.state = {count: props.initialCount}; } // ... } 在使用 React.createClass 时，可以为传入的对象参数添加一个 getInitialState 方法并返回一个初始状态值： var Counter = React.createClass({ getInitialState: function() { return {count: this.props.initialCount}; }, // ... }); 自动绑定 当使用ES6的 class 关键字声明一个React组件时，类中的方法遵循与常规的方法一样的定义。这就意味着在类中申明的方法在执行时并不会自动属于当前实例，必须在构造函数中显示的使用.bind(this)方法绑定到当前实例： class SayHello extends React.Component { constructor(props) { super(props); this.state = {message: 'Hello!'}; // 必须，否在在handleClick中this将指向调用对象 this.handleClick = this.handleClick.bind(this); } handleClick() { alert(this.state.message); } render() { return ( Say hello ); } } 在使用 React.createClass 时不必绑定所有的方法： var SayHello = React.createClass({ getInitialState: function() { return {message: 'Hello!'}; }, handleClick: function() { alert(this.state.message); }, render: function() { return ( Say hello ); } }); 以上的特性意味着使用ES6编写代码每一个方法都会额外增加一些样板式代码，但是对于大型应用来说代码结构更清晰。 如果十分排斥样板式代码，可以启用Babal的 类属性功能（ Class Properties ），利用双箭头来创建方法： class SayHello extends React.Component { constructor(props) { super(props); this.state = {message: 'Hello!'}; } handleClick = () => { alert(this.state.message); } render() { return ( Say hello ); } } 需要注意的是，目前这个功能还是实验性的，双箭头的表达式很有可能会调整。该提议不一定会被委员会接纳。 如果非常想要尝试这种写法，你可以有这几种实现方式： 在构造函数中绑定方法。 使用箭头来定义方法。 使用 React.createClass 。 代码混合器 注意：ES6在目前的方案中并不支持代码混合功能，因此在使用ES6编写React代码时并不能实现相关功能。官方也收到许多在使用混合器时遇到的问题，强烈建议不要在新的代码中使用混合器功能。以下的内容仅供参考。 某些时候2个不同的组件需要共享一些相同的方法或者功能。这种情况我们称为 横切关联（ cross-cutting concerns）。 React.createClass 可以通过继承来实现组件间公用相同方法。 一个通用的案例是一个组件需要定期更新自己的状态，只要使用setInterval()就可以实现。但是当您不再需要它来节省内存时，取消定时器是很重要的。React提供了生命周期方法来通知创建和销毁事件。下面的代码创建了一个肩带的混合器，混合器的作用是当组件被销毁之前，可以清除已有的定时器： // 定义一个混合器 var SetIntervalMixin = { //组件将要被渲染时调用 componentWillMount: function() { this.intervals = []; }, // 设置定时器方法 setInterval: function() { this.intervals.push(setInterval.apply(null, arguments)); }, //组件将要被卸载时调用 componentWillUnmount: function() { this.intervals.forEach(clearInterval); } }; var TickTock = React.createClass({ mixins: [SetIntervalMixin], // 设定混合器 getInitialState: function() { return {seconds: 0}; }, componentDidMount: function() { this.setInterval(this.tick, 1000); // 调用混合器中的setInterval 方法 }, tick: function() { this.setState({seconds: this.state.seconds + 1}); }, render: function() { return ( React has been running for {this.state.seconds} seconds. ); } }); ReactDOM.render( , document.getElementById('example') ); 如果组件使用了多个混合器并且很多混合器定义了相同的生命周期方法，比如同时定义了componentWillUnmount方法当组件卸载时注销某些资源。所有混合器的生命周期方法都会被调用，React会按照混合器设定的顺序来执行。 不使用JSX 对于React来说JSX并不是必须要使用的表达式。当在环境中不想在家额外的编译工具时尤其适用。 每一个JSX的元素都仅仅是React.createElement(component, props, ...children)的语法糖，所以任何使用JSX表达式实现的内容都可以直接用JavaScript来实现。 例如下面使用JSX编码的例子： class Hello extends React.Component { render() { return Hello {this.props.toWhat}; } } ReactDOM.render( , document.getElementById('root') ); 如果我们不想使用JSX，可以将其修改为： class Hello extends React.Component { render() { return React.createElement('div', null, `Hello ${this.props.toWhat}`); } } ReactDOM.render( React.createElement(Hello, {toWhat: 'World'}, null), document.getElementById('root') ); 组件被编译成一段字符串、由 React.Component创建的子类或者一个普通无状态的组件。 如果对编码时每次都要键入长长React.createElement感到痛苦，一个常见的模式是分配一个别名： const e = React.createElement; ReactDOM.render( e('div', null, 'Hello World'), document.getElementById('root') ); "},"React/源码分析/从零开始实现一个React（一）：JSX和虚拟DOM.html":{"url":"React/源码分析/从零开始实现一个React（一）：JSX和虚拟DOM.html","title":"从零开始实现一个React（一）：JSX和虚拟DOM","keywords":"","body":"从零开始实现一个React（一）：JSX和虚拟DOM 从零开始实现一个React（一）：JSX和虚拟DOM 前言 关于jsx 准备工作 React.createElement和虚拟DOM ReactDOM.render 渲染和更新 后话 前言 从零开始实现一个React，从API层面实现React的大部分功能，在这个过程中去探索为什么有虚拟DOM、diff、为什么setState这样设计等问题。 提起React，总是免不了和Vue做一番对比 Vue的API设计非常简洁，但是其实现方式却让人感觉是“魔法”，开发者虽然能马上上手，但其原理却很难说清楚。 相比之下React的设计哲学非常简单，虽然有很多需要自己处理的细节问题，但它没有引入任何新的概念，相对更加的干净和简单。 关于jsx const title = Hello, world!; 这段代码并不是合法的js代码，它是一种被称为jsx的语法扩展，通过它我们就可以很方便的在js代码中书写html片段。 本质上，jsx是语法糖，上面这段代码会被babel转换成如下代码 const title = React.createElement( 'h1', { className: 'title' }, 'Hello, world!' ); babel官网提供的在线转译测试jsx转换后的代码，这里有一个稍微复杂一点的例子 准备工作 在代码打包工具上选择了最近火热的零配置打包工具parcel,需要先安装parcel： npm install -g parcel-bundler 接下来新建index.js和index.html，在index.html中引入index.js。 注意一下babel的配置 .babelrc { \"presets\": [\"env\"], \"plugins\": [ [\"transform-react-jsx\", { \"pragma\": \"React.createElement\" }] ] } 这个transform-react-jsx就是将jsx转换成js的babel插件，它有一个pragma项，可以定义jsx转换方法的名称，你也可以将它改成h（这是很多类React框架使用的名称）或别的。 准备工作完成后，我们可以用命令parcel index.html将它跑起来了。 React.createElement和虚拟DOM 前文提到，jsx片段会被转译成用React.createElement方法包裹的代码。所以第一步，我们来实现这个React.createElement方法 从jsx转译结果来看，createElement方法的参数是这样： createElement( tag, attrs, child1, child2, child3 ); 第一个参数是DOM节点的标签名，它的值可能是div，h1，span等等 第二个参数是一个对象，里面包含了所有的属性，可能包含了className，id等等 从第三个参数开始，就是它的子节点 我们对createElement的实现非常简单，只需要返回一个对象来保存它的信息就行了。 function createElement( tag, attrs, ...children ) { return { tag, attrs, children } } 函数的参数 ...children使用了ES6的rest参数，它的作用是将后面child1,child2等参数合并成一个数组children。 现在我们来试试调用它 // 将上文定义的createElement方法放到对象React中 const React = { createElement } const element = ( helloworld! ); console.log( element ); 打开调试工具，我们可以看到输出的对象和我们预想的一致 我们的createElement方法返回的对象记录了这个DOM节点所有的信息，换言之，通过它我们就可以生成真正的DOM，这个记录信息的对象我们称之为虚拟DOM。 ReactDOM.render 接下来是ReactDOM.render方法，我们再来看这段代码 ReactDOM.render( Hello, world!, document.getElementById('root') ); 经过转换，这段代码变成了这样 ReactDOM.render( React.createElement( 'h1', null, 'Hello, world!' ), document.getElementById('root') ); 所以render的第一个参数实际上接受的是createElement返回的对象，也就是虚拟DOM而第二个参数则是挂载的目标DOM 总而言之，render方法的作用就是将虚拟DOM渲染成真实的DOM，下面是它的实现： function render( vnode, container ) { // 当vnode为字符串时，渲染结果是一段文本 if ( typeof vnode === 'string' ) { const textNode = document.createTextNode( vnode ); return container.appendChild( textNode ); } const dom = document.createElement( vnode.tag ); if ( vnode.attrs ) { Object.keys( vnode.attrs ).forEach( key => { const value = vnode.attrs[ key ]; setAttribute( dom, key, value ); // 设置属性 } ); } vnode.children.forEach( child => render( child, dom ) ); // 递归渲染子节点 return container.appendChild( dom ); // 将渲染结果挂载到真正的DOM上 } 设置属性需要考虑一些特殊情况，我们单独将其拿出来作为一个方法setAttribute function setAttribute( dom, name, value ) { // 如果属性名是className，则改回class if ( name === 'className' ) name = 'class'; // 如果属性名是onXXX，则是一个事件监听方法 if ( /on\\w+/.test( name ) ) { name = name.toLowerCase(); dom[ name ] = value || ''; // 如果属性名是style，则更新style对象 } else if ( name === 'style' ) { if ( !value || typeof value === 'string' ) { dom.style.cssText = value || ''; } else if ( value && typeof value === 'object' ) { for ( let name in value ) { // 可以通过style={ width: 20 }这种形式来设置样式，可以省略掉单位px dom.style[ name ] = typeof value[ name ] === 'number' ? value[ name ] + 'px' : value[ name ]; } } // 普通属性则直接更新属性 } else { if ( name in dom ) { dom[ name ] = value || ''; } if ( value ) { dom.setAttribute( name, value ); } else { dom.removeAttribute( name ); } } } 这里其实还有个小问题：当多次调用render函数时，不会清除原来的内容。所以我们将其附加到ReactDOM对象上时，先清除一下挂载目标DOM的内容： const ReactDOM = { render: ( vnode, container ) => { container.innerHTML = ''; return render( vnode, container ); } } 渲染和更新 到这里我们已经实现了React最为基础的功能，可以用它来做一些事了。 我们先在index.html中添加一个根节点 我们先来试试官方文档中的Hello,World ReactDOM.render( Hello, world!, document.getElementById('root') ); 可以看到结果： 试试渲染一段动态的代码，这个例子也来自官方文档 function tick() { const element = ( Hello, world! It is {new Date().toLocaleTimeString()}. ); ReactDOM.render( element, document.getElementById( 'root' ) ); } setInterval( tick, 1000 ); 后话 这篇文章中，实现了React非常基础的功能，也了解了jsx和虚拟DOM，下一篇文章实现非常重要的组件功能。 "},"React/源码分析/从零开始实现一个React（二）：组件和生命周期.html":{"url":"React/源码分析/从零开始实现一个React（二）：组件和生命周期.html","title":"从零开始实现一个React（二）：组件和生命周期","keywords":"","body":"从零开始实现一个React（二）：组件和生命周期 从零开始实现一个React（二）：组件和生命周期 组件 createElement的变化 组件基类React.Component Component 1. 先定义一个Component类： 2. state & props 3. setState 4. render 组件渲染和生命周期 渲染组件 渲染函数定义组件渲染函数定义组件 渲染类定义组件 后话 组件 React定义组件的方式可以分为两种：函数 和 类，函数定义可以看做是类定义的一种简单形式。 createElement的变化 React.createElement的实现： function createElement( tag, attrs, ...children ) { return { tag, attrs, children } } 这种实现我们前面暂时只用来渲染原生DOM元素，而对于组件，createElement得到的参数略有不同：如果JSX片段中的某个元素是组件，那么createElement的第一个参数tag将会是一个方法，而不是字符串。 区分组件和原生DOM的工作，是babel-plugin-transform-react-jsx帮我们做的 例如在处理时，createElement方法的第一个参数tag，实际上就是我们定义Welcome的方法： function Welcome( props ) { return Hello, {props.name}; } 我们不需要对createElement做修改，只需要知道如果渲染的是组件，tag的值将是一个函数 组件基类React.Component 通过类的方式定义组件，我们需要继承React.Component： class Welcome extends React.Component { render() { return Hello, {this.props.name}; } } 所以我们就需要先来实现React.Component这个类 Component React.Component包含了一些预先定义好的变量和方法，我们来一步一步地实现它： 1. 先定义一个Component类： class Component {} 2. state & props 通过继承React.Component定义的组件有自己的私有状态state，可以通过this.state获取到。同时也能通过this.props来获取传入的数据。 所以在构造函数中，我们需要初始化state和props // React.Component class Component { constructor( props = {} ) { this.state = {}; this.props = props; } } 3. setState 组件内部的state和渲染结果相关，当state改变时通常会触发渲染，为了让React知道我们改变了state，我们只能通过setState方法去修改数据。我们可以通过Object.assign来做一个简单的实现。 在每次更新state后，我们需要调用renderComponent方法来重新渲染组件，renderComponent方法的实现后文会讲到。 import { renderComponent } from '../react-dom/render' class Component { constructor( props = {} ) { // ... } setState( stateChange ) { // 将修改合并到state Object.assign( this.state, stateChange ); renderComponent( this ); } } 你可能听说过React的setState是异步的，同时它有很多优化手段，这里我们暂时不去管它，在以后会有一篇文章专门来讲setState方法。 4. render 上一篇文章中实现的render方法只支持渲染原生DOM元素，我们需要修改ReactDOM.render方法，让其支持渲染组件。 修改之前我们先来回顾一下上一篇文章中我们对ReactDOM.render的实现： function render( vnode, container ) { return container.appendChild( _render( vnode ) ); } function _render( vnode ) { if ( vnode === undefined || vnode === null || typeof vnode === 'boolean' ) vnode = ''; if ( typeof vnode === 'number' ) vnode = String( vnode ); if ( typeof vnode === 'string' ) { let textNode = document.createTextNode( vnode ); return textNode; } const dom = document.createElement( vnode.tag ); if ( vnode.attrs ) { Object.keys( vnode.attrs ).forEach( key => { const value = vnode.attrs[ key ]; setAttribute( dom, key, value ); } ); } vnode.children.forEach( child => render( child, dom ) ); // 递归渲染子节点 return dom; } 我们需要在其中加一段用来渲染组件的代码： function _render( vnode, container ) { // ... if ( typeof vnode.tag === 'function' ) { const component = createComponent( vnode.tag, vnode.attrs ); setComponentProps( component, vnode.attrs ); return component.base; } // ... } 组件渲染和生命周期 在上面的方法中用到了createComponent和setComponentProps两个方法，组件的生命周期方法也会在这里面实现。 生命周期方法是一些在特殊时机执行的函数，例如componentDidMount方法会在组件挂载后执行 createComponent方法用来创建组件实例，并且将函数定义组件扩展为类定义组件进行处理，以免其他地方需要区分不同定义方式。 // 创建组件 function createComponent( component, props ) { let inst; // 如果是类定义组件，则直接返回实例 if ( component.prototype && component.prototype.render ) { inst = new component( props ); // 如果是函数定义组件，则将其扩展为类定义组件 } else { inst = new Component( props ); inst.constructor = component; inst.render = function() { return this.constructor( props ); } } return inst; } setComponentProps方法用来更新props，在其中可以实现componentWillMount，componentWillReceiveProps两个生命周期方法 // set props function setComponentProps( component, props ) { if ( !component.base ) { if ( component.componentWillMount ) component.componentWillMount(); } else if ( component.componentWillReceiveProps ) { component.componentWillReceiveProps( props ); } component.props = props; renderComponent( component ); } renderComponent方法用来渲染组件，setState方法中会直接调用这个方法进行重新渲染，在这个方法里可以实现componentWillUpdate，componentDidUpdate，componentDidMount几个生命周期方法。 export function renderComponent( component ) { let base; const renderer = component.render(); if ( component.base && component.componentWillUpdate ) { component.componentWillUpdate(); } base = _render( renderer ); if ( component.base ) { if ( component.componentDidUpdate ) component.componentDidUpdate(); } else if ( component.componentDidMount ) { component.componentDidMount(); } if ( component.base && component.base.parentNode ) { component.base.parentNode.replaceChild( base, component.base ); } component.base = base; base._component = component; } 渲染组件 渲染函数定义组件渲染函数定义组件 渲染前文提到的Welcome组件： const element = ; ReactDOM.render( element, document.getElementById( 'root' ) ); 在浏览器中可以看到结果： 试试更复杂的例子，将多个组件组合起来： function App() { return ( ); } ReactDOM.render( , document.getElementById( 'root' ) ); 在浏览器中可以看到结果： 渲染类定义组件 我们来试一试将刚才函数定义组件改成类定义： class Welcome extends React.Component { render() { return Hello, {this.props.name}; } } class App extends React.Component { render() { return ( ); } } ReactDOM.render( , document.getElementById( 'root' ) ); 运行起来结果和函数定义组件完全一致： 再来尝试一个能体现出类定义组件区别的例子，实现一个计数器Counter，每点击一次就会加1。 并且组件中还增加了两个生命周期函数： class Counter extends React.Component { constructor( props ) { super( props ); this.state = { num: 0 } } componentWillUpdate() { console.log( 'update' ); } componentWillMount() { console.log( 'mount' ); } onClick() { this.setState( { num: this.state.num + 1 } ); } render() { return ( this.onClick() }> number: {this.state.num} add ); } } ReactDOM.render( , document.getElementById( 'root' ) ); 可以看到结果： mount只在挂载时输出了一次，后面每次更新时会输出update 后话 至此我们已经从API层面实现了React的核心功能。但是我们目前的做法是每次更新都重新渲染整个组件甚至是整个应用，这样的做法在页面复杂时将会暴露出性能上的问题，DOM操作非常昂贵 "},"React/源码分析/从零开始实现一个React（三）：diff算法.html":{"url":"React/源码分析/从零开始实现一个React（三）：diff算法.html","title":"从零开始实现一个React（三）：diff算法","keywords":"","body":"从零开始实现一个React（三）：diff算法 从零开始实现一个React（三）：diff算法 前言 对比策略 实现 实现diff 对比文本节点 对比非文本DOM节点 对比属性 对比子节点 对比组件 渲染 后话 前言 在上一篇文章，我们已经实现了React的组件功能，从功能的角度来说已经实现了React的核心功能了。 但是我们的实现方式有很大的问题：每次更新都重新渲染整个应用或者整个组件，DOM操作十分昂贵，这样性能损耗非常大。 为了减少DOM更新，我们需要找渲染前后真正变化的部分，只更新这一部分DOM。而对比变化，找出需要更新部分的算法我们称之为diff算法。 对比策略 在前面两篇文章后，我们实现了一个render方法，它能将虚拟DOM渲染成真正的DOM，我们现在就需要改进它，让它不要再傻乎乎地重新渲染整个DOM树，而是找出真正变化的部分。 这部分很多类React框架实现方式都不太一样，有的框架会选择保存上次渲染的虚拟DOM，然后对比虚拟DOM前后的变化，得到一系列更新的数据，然后再将这些更新应用到真正的DOM上。 但也有一些框架会选择直接对比虚拟DOM和真实DOM，这样就不需要额外保存上一次渲染的虚拟DOM，并且能够一边对比一边更新，这也是我们选择的方式。 不管是DOM还是虚拟DOM，它们的结构都是一棵树，完全对比两棵树变化的算法时间复杂度是O(n^3)，但是考虑到我们很少会跨层级移动DOM，所以我们只需要对比同一层级的变化。 只需要对比同一颜色框内的节点 总而言之，我们的diff算法有两个原则： 对比当前真实的DOM和虚拟DOM，在对比过程中直接更新真实DOM 只对比同一层级的变化 实现 实现diff 我们需要实现一个diff方法，它的作用是对比真实DOM和虚拟DOM，最后返回更新后的DOM /** * @param {HTMLElement} dom 真实DOM * @param {vnode} vnode 虚拟DOM * @returns {HTMLElement} 更新后的DOM */ function diff( dom, vnode ) { // ... } 接下来就要实现这个方法。在这之前先来回忆一下我们虚拟DOM的结构:虚拟DOM的结构可以分为三种，分别表示文本、原生DOM节点以及组件。 // 原生DOM节点的vnode { tag: 'div', attrs: { className: 'container' }, children: [] } // 文本节点的vnode \"hello,world\" // 组件的vnode { tag: ComponentConstrucotr, attrs: { className: 'container' }, children: [] } 对比文本节点 首先考虑最简单的文本节点，如果当前的DOM就是文本节点，则直接更新内容，否则就新建一个文本节点，并移除掉原来的DOM。 // diff text node if ( typeof vnode === 'string' ) { // 如果当前的DOM就是文本节点，则直接更新内容 if ( dom && dom.nodeType === 3 ) { // nodeType: https://developer.mozilla.org/zh-CN/docs/Web/API/Node/nodeType if ( dom.textContent !== vnode ) { dom.textContent = vnode; } // 如果DOM不是文本节点，则新建一个文本节点DOM，并移除掉原来的 } else { out = document.createTextNode( vnode ); if ( dom && dom.parentNode ) { dom.parentNode.replaceChild( out, dom ); } } return out; } 文本节点十分简单，它没有属性，也没有子元素，所以这一步结束后就可以直接返回结果了。 对比非文本DOM节点 如果vnode表示的是一个非文本的DOM节点，那就要分两种情况了： 情况一：如果真实DOM不存在，表示此节点是新增的，或者新旧两个节点的类型不一样，那么就新建一个DOM元素，并将原来的子节点（如果有的话）移动到新建的DOM节点下。 if ( !dom || dom.nodeName.toLowerCase() !== vnode.tag.toLowerCase() ) { out = document.createElement( vnode.tag ); if ( dom ) { [ ...dom.childNodes ].map( out.appendChild ); // 将原来的子节点移到新节点下 if ( dom.parentNode ) { dom.parentNode.replaceChild( out, dom ); // 移除掉原来的DOM对象 } } } 情况二：如果真实DOM存在，并且和虚拟DOM是同一类型的，那我们暂时不需要做别的，只需要等待后面对比属性和对比子节点。 对比属性 实际上diff算法不仅仅是找出节点类型的变化，它还要找出来节点的属性以及事件监听的变化。我们将对比属性单独拿出来作为一个方法： function diffAttributes( dom, vnode ) { const old = {}; // 当前DOM的属性 const attrs = vnode.attrs; // 虚拟DOM的属性 for ( let i = 0 ; i setAttribute方法的实现参见第一篇文章 对比子节点 节点本身对比完成了，接下来就是对比它的子节点。这里会面临一个问题，前面我们实现的不同diff方法，都是明确知道哪一个真实DOM和虚拟DOM对比，但是子节点是一个数组，它们可能改变了顺序，或者数量有所变化，我们很难确定要和虚拟DOM对比的是哪一个。为了简化逻辑，我们可以让用户提供一些线索：给节点设一个key值，重新渲染时对比key值相同的节点。 // diff方法 if ( vnode.children && vnode.children.length > 0 || ( out.childNodes && out.childNodes.length > 0 ) ) { diffChildren( out, vnode.children ); } function diffChildren( dom, vchildren ) { const domChildren = dom.childNodes; const children = []; const keyed = {}; // 将有key的节点和没有key的节点分开 if ( domChildren.length > 0 ) { for ( let i = 0; i 0 ) { let min = 0; let childrenLen = children.length; for ( let i = 0; i 对比组件 如果vnode是一个组件，我们也单独拿出来作为一个方法: function diffComponent( dom, vnode ) { let c = dom && dom._component; let oldDom = dom; // 如果组件类型没有变化，则重新set props if ( c && c.constructor === vnode.tag ) { setComponentProps( c, vnode.attrs ); dom = c.base; // 如果组件类型变化，则移除掉原来组件，并渲染新的组件 } else { if ( c ) { unmountComponent( c ); oldDom = null; } c = createComponent( vnode.tag, vnode.attrs ); setComponentProps( c, vnode.attrs ); dom = c.base; if ( oldDom && dom !== oldDom ) { oldDom._component = null; removeNode( oldDom ); } } return dom; } 下面是相关的工具方法的实现，和上一篇文章的实现相比，只需要修改renderComponent方法的两个地方。 function renderComponent( component ) { // ... // base = base = _render( renderer ); // 将_render改成diff base = diff( component.base, renderer ); // ... // 去掉这部分 // if ( component.base && component.base.parentNode ) { // component.base.parentNode.replaceChild( base, component.base ); // } // ... } 完整diff实现看这个文件 渲染 现在我们实现了diff方法，我们尝试渲染上一篇文章中定义的Counter组件，来感受一下有无diff方法的不同。 class Counter extends React.Component { constructor( props ) { super( props ); this.state = { num: 1 } } onClick() { this.setState( { num: this.state.num + 1 } ); } render() { return ( count: { this.state.num } this.onClick()}>add ); } } 不使用diff 使用上一篇文章的实现，从chrome的调试工具中可以看到，闪烁的部分是每次更新的部分，每次点击按钮，都会重新渲染整个组件。 使用diff 而实现了diff方法后，每次点击按钮，都只会重新渲染变化的部分。 后话 在这篇文章中我们实现了diff算法，通过它做到了每次只更新需要更新的部分，极大地减少了DOM操作。React实现远比这个要复杂，特别是在React 16之后还引入了Fiber架构，但是主要的思想是一致的。 实现diff算法可以说性能有了很大的提升，但是在别的地方仍然后很多改进的空间：每次调用setState后会立即调用renderComponent重新渲染组件，但现实情况是，我们可能会在极短的时间内多次调用setState。 假设我们在上文的Counter组件中写出了这种代码 onClick() { for ( let i = 0; i 那以目前的实现，每次点击都会渲染100次组件，对性能肯定有很大的影响。 下一篇文章我们就要来改进setState方法 "},"React/源码分析/从零开始实现一个React（四）：异步的setState.html":{"url":"React/源码分析/从零开始实现一个React（四）：异步的setState.html","title":"从零开始实现一个React（四）：异步的setState","keywords":"","body":"从零开始实现一个React（四）：异步的setState 从零开始实现一个React（四）：异步的setState 前言 真正的React是怎么做的 合并setState setState队列 清空队列 延迟执行 别的延迟执行方法 试试效果 后话 前言 在上一篇文章中，我们实现了diff算法，性能有非常大的改进。但是文章末尾也指出了一个问题：按照目前的实现，每次调用setState都会触发更新，如果组件内执行这样一段代码： for ( let i = 0; i 那么执行这段代码会导致这个组件被重新渲染100次，这对性能是一个非常大的负担。 真正的React是怎么做的 React显然也遇到了这样的问题，所以针对setState做了一些特别的优化：React会将多个setState的调用合并成一个来执行，这意味着当调用setState时，state并不会立即更新，举个栗子： class App extends Component { constructor() { super(); this.state = { num: 0 } } componentDidMount() { for ( let i = 0; i { this.state.num } ); } } 我们定义了一个App组件，在组件挂载后，会循环100次，每次让this.state.num增加1，我们用真正的React来渲染这个组件，看看结果： 组件渲染的结果是1，并且在控制台中输出了100次0，说明每个循环中，拿到的state仍然是更新之前的。 这是React的优化手段，但是显然它也会在导致一些不符合直觉的问题（就如上面这个例子），所以针对这种情况，React给出了一种解决方案：setState接收的参数还可以是一个函数，在这个函数中可以拿先前的状态，并通过这个函数的返回值得到下一个状态。 我们可以通过这种方式来修正App组件： componentDidMount() { for ( let i = 0; i { console.log( prevState.num ); return { num: prevState.num + 1 } } ); } } 这种用法是不是很像数组的reduce方法？ 现在来看看App组件的渲染结果： 现在终于能得到我们想要的结果了。 所以，这篇文章的目标也明确了，我们要实现以下两个功能： 异步更新state，将短时间内的多个setState合并成一个 为了解决异步更新导致的问题，增加另一种形式的setState：接受一个函数作为参数，在函数中可以得到前一个状态并返回下一个状态 合并setState 回顾一下第二篇文章中对setState的实现： setState( stateChange ) { Object.assign( this.state, stateChange ); renderComponent( this ); } 这种实现，每次调用setState都会更新state并马上渲染一次。 setState队列 为了合并setState，我们需要一个队列来保存每次setState的数据，然后在一段时间后，清空这个队列并渲染组件。 队列是一种数据结构，它的特点是“先进先出”，可以通过js数组的push和shift方法模拟然后需要定义一个”入队“的方法，用来将更新添加进队列。 const queue = []; function enqueueSetState( stateChange, component ) { queue.push( { stateChange, component } ); } 然后修改组件的setState方法，不再直接更新state和渲染组件，而是添加进更新队列。 setState( stateChange ) { enqueueSetState( stateChange, this ); } 现在队列是有了，怎么清空队列并渲染组件呢？ 清空队列 我们定义一个flush方法，它的作用就是清空队列 function flush() { let item; // 遍历 while( item = setStateQueue.shift() ) { const { stateChange, component } = item; // 如果没有prevState，则将当前的state作为初始的prevState if ( !component.prevState ) { component.prevState = Object.assign( {}, component.state ); } // 如果stateChange是一个方法，也就是setState的第二种形式 if ( typeof stateChange === 'function' ) { Object.assign( component.state, stateChange( component.prevState, component.props ) ); } else { // 如果stateChange是一个对象，则直接合并到setState中 Object.assign( component.state, stateChange ); } component.prevState = component.state; } } 这只是实现了state的更新，我们还没有渲染组件。渲染组件不能在遍历队列时进行，因为同一个组件可能会多次添加到队列中，我们需要另一个队列保存所有组件，不同之处是，这个队列内不会有重复的组件。 我们在enqueueSetState时，就可以做这件事 const queue = []; const renderQueue = []; function enqueueSetState( stateChange, component ) { queue.push( { stateChange, component } ); // 如果renderQueue里没有当前组件，则添加到队列中 if ( !renderQueue.some( item => item === component ) ) { renderQueue.push( component ); } } 在flush方法中，我们还需要遍历renderQueue，来渲染每一个组件 function flush() { let item, component; while( item = queue.shift() ) { // ... } // 渲染每一个组件 while( component = renderQueue.shift() ) { renderComponent( component ); } } 延迟执行 现在还有一件最重要的事情：什么时候执行flush方法。 我们需要合并一段时间内所有的setState，也就是在一段时间后才执行flush方法来清空队列，关键是这个“一段时间“怎么决定。 一个比较好的做法是利用js的事件队列机制。 先来看这样一段代码： setTimeout( () => { console.log( 2 ); }, 0 ); Promise.resolve().then( () => console.log( 1 ) ); console.log( 3 ); 你可以打开浏览器的调试工具运行一下，它们打印的结果是： 3 1 2 我们可以利用事件队列，让flush在所有同步任务后执行 function enqueueSetState( stateChange, component ) { // 如果queue的长度是0，也就是在上次flush执行之后第一次往队列里添加 if ( queue.length === 0 ) { defer( flush ); } queue.push( { stateChange, component } ); if ( !renderQueue.some( item => item === component ) ) { renderQueue.push( component ); } } 定义defer方法，利用刚才题目中出现的Promise.resolve function defer( fn ) { return Promise.resolve().then( fn ); } 这样在一次“事件循环“中，最多只会执行一次flush了，在这个“事件循环”中，所有的setState都会被合并，并只渲染一次组件。 别的延迟执行方法 除了用Promise.resolve().then( fn )，我们也可以用上文中提到的setTimeout( fn, 0 )，setTimeout的时间也可以是别的值，例如16毫秒。 16毫秒的间隔在一秒内大概可以执行60次，也就是60帧，人眼每秒只能捕获60幅画面 另外也可以用requestAnimationFrame或者requestIdleCallback function defer( fn ) { return requestAnimationFrame( fn ); } 试试效果 就试试渲染上文中用React渲染的那两个例子： class App extends Component { constructor() { super(); this.state = { num: 0 } } componentDidMount() { for ( let i = 0; i { this.state.num } ); } } 效果和React完全一样 同样，用第二种方式调用setState： componentDidMount() { for ( let i = 0; i { console.log( prevState.num ); return { num: prevState.num + 1 } } ); } } 结果也完全一样： 后话 在这篇文章中，我们又实现了一个很重要的优化：合并短时间内的多次setState，异步更新state。 "},"React/源码分析/85行代码实现一个React.html":{"url":"React/源码分析/85行代码实现一个React.html","title":"85行代码实现一个React","keywords":"","body":"85行代码实现一个React 85行代码实现一个React 1.第一个commit: initial commit 2.第二个commit:实现最简单的React渲染字符的功能（第一版）著作权归原作者所有。 3.第三个commit:添加函数组件的功能，能够实现函数组件（第二版） 4.第四个commit: 主要实现向React中添加子组件的效果（第三版） 5.第四个commit：类组件的实现（第四版） 6.第五个commit：React函数组件带参数的实现（第五版） 7.第六个commit：类组件属性的传递（第六版） 8.第七个commit：类组件添加事件属性（第七版） 9.第八个commit：实现类组件的动态渲染（数据的变化能够同步到页面上）（第八版） 完整代码 85行代码分18次commit, 每个commit实现一个小目标,每个小目标实现一个相对完整的功能。最后由这些功能组合成自己的React.js框架。著作权归原作者所有。 1.第一个commit: initial commit 是在github上建立仓库时自动生成的。然后在README.md中说明了一下仓库的用途。用于实现一个基础的React.js框架著作权归原作者所有。 2.第二个commit:实现最简单的React渲染字符的功能（第一版）著作权归原作者所有。 这个commit主要实现了用React输出一个helloworld到HTML页面中。期待引用了我们的React.js后直接通过下述方式实现著作权归原作者所有。 const helloWorld = React.createElement('div', null, `Hello World`); ReactDOM.render(helloWorld, document.getElementById('root')); 此时我们React.js中的代码如下： function createElement(parentEle, props, childEle) { let parentElement = document.createElement(parentEle); parentElement.innerHTML = childEle; return parentElement; } function render(insertEle, rootEle) { rootEle.appendChild(insertEle); } React = { createElement } ReactDOM = { render } 3.第三个commit:添加函数组件的功能，能够实现函数组件（第二版） 主要实现能够在React创建组件时，实现能够传递函数定义的组件，后期还会扩展向函数组件中传递参数著作权归原作者所有。 const Hello = function () { return React.createElement('div', null, `Hello Version2.0`); }; const helloWorld = React.createElement(Hello, null, null); ReactDOM.render(helloWorld, document.getElementById('root')); 此时我们的React.js中的代码如下： function createElement(parentEle, props, childEle) { if(typeof parentEle === 'function') { return parentEle(); } else { let parentElement = document.createElement(parentEle); parentElement.innerHTML = childEle; return parentElement; } } function render(insertEle, rootEle) { rootEle.appendChild(insertEle); } React = { createElement } ReactDOM = { render } 4.第四个commit: 主要实现向React中添加子组件的效果（第三版） 实现能够在React.js中添加子组件的效果，如下代码实现添加多个helloworld字符和div片段等。著作权归原作者所有。 const HelloVersion3 = function () { return React.createElement('div', null, `版本3.0`); }; const helloWorld1 = React.createElement(HelloVersion3, null, null); const helloWorld2 = React.createElement(HelloVersion3, null, null); const divEle = React.createElement('div', null, `我被一个div标签包裹`); const parent = React.createElement('div', null, helloWorld1, helloWorld2, divEle, `我是文本内容哦` ); ReactDOM.render(parent, document.getElementById('root')); 具体的React.js实现代码如下所示： function createElement(parentEle, props, ...childEles) { if(typeof parentEle === 'function') { return parentEle(); } else { let parentElement = document.createElement(parentEle); childEles.forEach(child => { if(typeof child === 'string') { parentElement.innerHTML += child; } else if(typeof child === 'object') { parentElement.appendChild(child); } }); return parentElement; } } function render(insertEle, rootEle) { rootEle.appendChild(insertEle); } React = { createElement } ReactDOM = { render } 5.第四个commit：类组件的实现（第四版） 主要是实现采用和React中最常用的使用class来定义组件的方式，如下代码所示：著作权归原作者所有。 class Hello { render() { return React.createElement('div', null, `版本四，类组件的实现`); } } const helloWorld = React.createElement(Hello, null, null); ReactDOM.render(helloWorld, document.getElementById('root')); React.js代码如下： function createElement(parentEle, props, ...childEles) { if (typeof parentEle === 'function' && /^\\s*class\\s+/.test(parentEle.toString())) { let component = new parentEle(); return component.render(); }else if (typeof parentEle === 'function'){ return parentEle(); }else { let parentElement = document.createElement(parentEle); childEles.forEach(child => { if(typeof child === 'string') { parentElement.innerHTML += child; } else if(typeof child === 'object') { parentElement.appendChild(child); } }); return parentElement; } } function render(insertEle, rootEle) { rootEle.appendChild(insertEle); } React = { createElement } ReactDOM = { render } 6.第五个commit：React函数组件带参数的实现（第五版） 这个比较简单，其实原理就是向普通函数中传递参数后使用是一个道理，要实现的效果如下代码：著作权归原作者所有。 const Hello = ({name}) => { return React.createElement('div', null, `这是 ${name}`); }; const helloWorld = React.createElement(Hello, {name: '版本五'}, null); ReactDOM.render(helloWorld, document.getElementById('root')); React.js代码如下： function createElement(parentEle, props, ...childEles) { if (typeof parentEle === 'function' && /^\\s*class\\s+/.test(parentEle.toString())) { let component = new parentEle(); return component.render(); } else if (typeof parentEle === 'function') { return parentEle(props); } else { let parentElement = document.createElement(parentEle); childEles.forEach(child => { if (typeof child === 'string') { parentElement.innerHTML += child; } else if (typeof child === 'object') { parentElement.appendChild(child); } }); return parentElement; } } function render(insertEle, rootEle) { rootEle.appendChild(insertEle); } React = { createElement } ReactDOM = { render } 7.第六个commit：类组件属性的传递（第六版） 这个commit主要用来解决如何向内组件中传递参数的问题，实现如下代码效果 class Hello extends React.Component { constructor(props) { super(props); } render() { return React.createElement('div', null, `Hello ${this.props.name}`); } } const helloWorld = React.createElement(Hello, {name: '文字'}, null); ReactDOM.render(helloWorld, document.getElementById('root')); React.js代码如下所示： class Component { constructor(props) { this.props = props; } } function createElement(parentEle, props, ...childEles) { if (typeof parentEle === 'function' && /^\\s*class\\s+/.test(parentEle.toString())) { // 当为类组件时 let component = new parentEle(props); return component.render(); } else if (typeof parentEle === 'function') { // 当为函数组件时 return parentEle(props); } else { // 当为html标签组件时 let parentElement = document.createElement(parentEle); childEles.forEach(child => { if (typeof child === 'string') { parentElement.innerHTML += child; } else if (typeof child === 'object') { parentElement.appendChild(child); } }); return parentElement; } } function render(insertEle, rootEle) { rootEle.appendChild(insertEle); } React = { createElement, Component } ReactDOM = { render } 8.第七个commit：类组件添加事件属性（第七版） 主要实现能够绑定click事件的功能，需要实现的效果代码如下： class MyButton extends React.Component { constructor(props) { super(props); } render() { return React.createElement('button', {onclick: this.props.onClick}, `Click me`); } } const myBtn = React.createElement(MyButton, {onClick: () => alert('点击事件触发')}, null); ReactDOM.render(myBtn, document.getElementById('root')); React.js代码如下： class Component { constructor(props) { this.props = props; } } function createElement(parentEle, props, ...childEles) { if (typeof parentEle === 'function' && /^\\s*class\\s+/.test(parentEle.toString())) { // 当为类组件时 let component = new parentEle(props); return component.render(); } else if (typeof parentEle === 'function') { // 当为函数组件时 return parentEle(props); } else { // 当为html标签组件时 let parentElement = document.createElement(parentEle); Object.keys(props).forEach(key => { switch(key) { case 'onclick': parentElement.addEventListener('click', props[key]); break; default: break; } }); childEles.forEach(child => { if(typeof child === 'string') { parentElement.innerHTML += child; } else if(typeof child === 'object') { parentElement.appendChild(child); } }); return parentElement; } } function render(insertEle, rootEle) { rootEle.appendChild(insertEle); } React = { createElement, Component } ReactDOM = { render } 9.第八个commit：实现类组件的动态渲染（数据的变化能够同步到页面上）（第八版） 到这一步已经可以使用上述的功能完成一个小的应用了，我们来试一下，实现一个简单的计数器的应用。技术器的代码如下： class Counter extends React.Component { constructor(props) { super(props); this.state = {value: 0}; } onPlusClick() { this.setState({value: this.state.value + 1}); } onMinusClick() { this.setState({value: this.state.value - 1}); } render() { return React.createElement('div', null, React.createElement('div', null, `The Famous Dan Abramov's Counter`), React.createElement('div', null, `${this.state.value}`), React.createElement('button', {onClick: this.onPlusClick.bind(this)}, '+'), React.createElement('button', {onClick: this.onMinusClick.bind(this)}, '-') ); } } let myCounter = React.createElement(Counter,null,null); ReactDOM.render(myCounter, document.getElementById('root')); React.js代码如下： let rootElement, rootReactElement; // React基础组件库 class Component { constructor(props) { this.props = props; } setState(state) { this.state = state; reRender(); } } // React.createElement function createElement(parentEle, props, ...childEles) { if (typeof parentEle === 'function' && /^\\s*class\\s+/.test(parentEle.toString())) { // 当为类组件时 let component = new parentEle(props); return component; } else if (typeof parentEle === 'function') { // 当为函数组件时 return parentEle(props); } else { // 当为html标签组件时 let parentElement = document.createElement(parentEle); Object.keys(props || {}).forEach(key => { switch (key) { case 'onclick': parentElement.addEventListener('click', props[key]); break; case 'onClick': parentElement.addEventListener('click', props[key]); break; default: break; } }); childEles.forEach(child => { if (typeof child === 'string') { parentElement.innerHTML += child; } else if (typeof child === 'object') { parentElement.appendChild(child); } }); return parentElement; } } function render(insertEle, rootEle) { rootElement = rootEle; rootReactElement = insertEle; rootEle.appendChild(insertEle.render()); } function reRender() { while (rootElement.hasChildNodes()) { rootElement.removeChild(rootElement.lastChild); } ReactDOM.render(rootReactElement, rootElement); } React = { createElement, Component } ReactDOM = { render } 完整代码 // 防止局部变量污染全局，只暴露全局的方法 (() => { let rootElement, rootReactElement; const REACT_CLASS = 'REACT_CLASS'; // React基础组件库 class Component { constructor(props) { this.props = props; } setState(state) { // this.state = state; 导致年龄和姓名丢失 this.state = Object.assign({}, this.state, state); reRender(); } } // React.createElement function createElement(parentEle, props, ...childEles) { if (typeof parentEle === 'function' && /^\\s*class\\s+/.test(parentEle.toString())) { // （1）当为类组件时 let component = new parentEle(props); component.type = REACT_CLASS; return component; } else if (typeof parentEle === 'function') { // （2）当为函数组件时 return parentEle(props); } else { // （3）当为html标签组件时 let parentElement = document.createElement(parentEle); Object.keys(props || {}).forEach(key => { if(/^on.*$/.test(key)) { eventName = key.slice(2).toLowerCase(); parentElement.addEventListener(eventName, props[key]); } else if(key ==='className') { parentElement.setAttribute('class', props[key]); } else if(key ==='style') { Object.keys(props[key]).forEach(attr => parentElement.style[attr] = props[key][attr] ); } else if (key === 'ref'){ props[key](parentElement); } else { // 添加其他如href等属性直接添加进来 parentElement.setAttribute(key, props[key]); } }); childEles.forEach(child => { if(typeof child === 'string') { // (1)当子元素是一个字符时 parentElement.innerHTML += child; } else if (Array.isArray(child)) { // (2)当子元素是一个数组中包含多个Node节点时 child.forEach((childItem) => parentElement.appendChild(childItem)); } else if(child !== null && typeof child === 'object' && child.type === 'REACT_CLASS') { parentElement.appendChild(child.render()); } else if(child !== null && typeof child === 'object') { // (3)当子元素是一个Node节点是直接附加到父节点 parentElement.appendChild(child); } }); return parentElement; } } function render(insertEle, rootEle) { rootElement = rootEle; rootReactElement = insertEle; let currentEle = rootReactElement.type === 'REACT_CLASS' ? rootReactElement.render() : rootReactElement; rootEle.appendChild(currentEle); } function reRender() { while(rootElement.hasChildNodes()) { rootElement.removeChild(rootElement.lastChild); } ReactDOM.render(rootReactElement, rootElement); } window.React = { createElement, Component } window.ReactDOM = { render } })(); "},"React/源码分析/40行代码内实现一个React.html":{"url":"React/源码分析/40行代码内实现一个React.html","title":"40行代码内实现一个React","keywords":"","body":"40 行代码内实现一个 React.js 40 行代码内实现一个 React.js 1. 前言 2. 一切从点赞说起 3. 实现可复用性 3.1 结构复用 3.2 生成 DOM 元素并且添加事件 4. 为什么不暴力一点？ 4.1 状态改变 -> 构建新的 DOM 元素 4.2 重新插入新的 DOM 元素 5. 抽象出 Component 类 6. 总结 7. 实现代码 1. 前言 50 行代码内，不依赖任何第三方的库，用纯 JavaScript 实现一个 React.js 。 2. 一切从点赞说起 假设现在我们需要实现一个点赞、取消点赞的功能。 HTML: 点赞 ? 为了现实当中的实际情况，所以这里特易把这个 button 的 HTML 结构搞得稍微复杂一些。有了这个 HTML 结构，现在就给它加入一些 JavaScript 的行为： const button = document.querySelector('.like-btn'); const buttonText = button.querySelector('.like-text'); let isLiked = false; button.addEventListener('click', function () { isLiked = !isLiked if (isLiked) { buttonText.innerHTML = '取消' } else { buttonText.innerHTML = '点赞' } }, false) 3. 实现可复用性 3.1 结构复用 现在我们来重新编写这个点赞功能。这次我们先写一个类，这个类有 render 方法，这个方法里面直接返回一个表示 HTML 结构的字符串： class LikeButton { render () { return ` 赞 ? ` } } 然后可以用这个类来构建不同的点赞功能的实例，然后把它们插到页面中。 const wrapper = document.querySelector('.wrapper') const likeButton1 = new LikeButton() wrapper.innerHTML = likeButton1.render() const likeButton2 = new LikeButton() wrapper.innerHTML += likeButton2.render() 这里非常暴力地使用了 innerHTML ，把两个按钮粗鲁地插入了 wrapper 当中。虽然你可能会对这种实现方式非常不满意，但我们还是勉强了实现了结构的复用。我们后面再来优化它。 3.2 生成 DOM 元素并且添加事件 你一定会发现，现在的按钮是死的，你点击它它根本不会有什么反应。因为根本没有往上面添加事件。但是问题来了，LikeButton 类里面是虽然说有一个 button，但是这玩意根本就是在字符串里面的。你怎么能往一个字符串里面添加事件呢？DOM 事件的 API 只有 DOM 结构才能用。 我们需要 DOM 结构，准确地来说：我们需要这个点赞功能的 HTML 字符串代表的 DOM 结构。假设我们现在有一个函数 createDOMFromString ，你往这个函数传入 HTML 字符串，但是它会把相应的 DOM 元素返回给你。这个问题就可以额解决了。 // ::String => ::Document const createDOMFromString = (domString) => { // TODO } 先不用管这个函数应该怎么实现，先知道它是干嘛的。拿来用就好，这时候用它来改写一下 LikeButton 类： class LikeButton { render () { this.el = createDOMFromString(` 点赞 ? `) this.el.addEventListener('click', () => console.log('click'), false) return this.el } } 现在 render() 返回的不是一个 html 字符串了，而是一个由这个 html 字符串所生成的 DOM。在返回 DOM 元素之前会先给这个 DOM 元素上添加事件在返回。 因为现在 render 返回的是 DOM 元素，所以不能用 innerHTML 暴力地插入 wrapper。而是要用 DOM API 插进去。 const wrapper = document.querySelector('.wrapper') const likeButton1 = new LikeButton() wrapper.appendChild(likeButton1.render()) const likeButton2 = new LikeButton() wrapper.appendChild(likeButton2.render()) 现在你点击这两个按钮，每个按钮都会在控制台打印 click，说明事件绑定成功了。但是按钮上的文本还是没有发生改变，只要稍微改动一下 LikeButton 的代码就可以完成完整的功能： class LikeButton { constructor () { this.state = { isLiked: false } } changeLikeText () { const likeText = this.el.querySelector('.like-text') this.state.isLiked = !this.state.isLiked if (this.state.isLiked) { likeText.innerHTML = '取消' } else { likeText.innerHTML = '点赞' } } render () { this.el = createDOMFromString(` 点赞 ? `) this.el.addEventListener('click', this.changeLikeText.bind(this), false) return this.el } } 这里的代码稍微长了一些，但是还是很好理解。只不过是在给 LikeButton 类添加了构造函数，这个构造函数会给每一个 LikeButton 的实例添加一个对象 state，state 里面保存了每个按钮自己是否点赞的状态。还改写了原来的事件绑定函数：原来只打印 click，现在点击的按钮的时候会调用 changeLikeText 方法，这个方法会根据 this.state 的状态改变点赞按钮的文本。 如果你现在还能跟得上文章的思路，那么你留意下，现在的代码已经和 React.js 的组件代码有点类似了。但其实我们根本没有讲 React.js 的任何内容，我们一心一意只想怎么做好“组件化”。 现在这个组件的可复用性已经很不错了，只要实例化一下然后插入到 DOM 里面去就好了。 4. 为什么不暴力一点？ 仔细留意一下 changeLikeText 函数，这个函数包含了 DOM 操作，现在看起来比较简单，那是因为现在只有 isLiked 一个状态。但想一下，因为你的数据状态改变了你就需要去更新页面的内容，所以如果你的组件包含了很多状态，那么你的组件基本全部都是 DOM 操作。一个组件包含很多状态的情况非常常见，所以这里还有优化的空间：如何尽量减少这种手动 DOM 操作？ 4.1 状态改变 -> 构建新的 DOM 元素 这里要提出的一种解决方案：一旦状态发生改变，就重新调用 render 方法，构建一个新的 DOM 元素。这样做的好处是什么呢？好处就是你可以在 render 方法里面使用最新的 this.state 来构造不同 HTML 结构的字符串，并且通过这个字符串构造不同的 DOM 元素。页面就更新了！听起来有点绕，看看代码怎么写： class LikeButton { constructor () { this.state = { isLiked: false } } setState (state) { this.state = state this.el = this.render() } changeLikeText () { this.setState({ isLiked: !this.state.isLiked }) } render () { this.el = createDOMFromString(` ${this.state.isLiked ? '取消' : '点赞'} ? `) this.el.addEventListener('click', this.changeLikeText.bind(this), false) return this.el } } 其实只是改了几个小地方： render 函数里面的 HTML 字符串会根据 this.state 不同而不同（这里是用了 ES6 的字符串特性，做这种事情很方便）。 新增一个 setState 函数，这个函数接受一个对象作为参数；它会设置实例的 state，然后重新调用一下 render 方法。 当用户点击按钮的时候， changeLikeText 会构建新的 state 对象，这个新的 state ，传入 setState 函数当中。 这样的结果就是，用户每次点击，changeLikeText 都会调用改变组件状态然后调用 setState ；setState 会调用 render 方法重新构建新的 DOM 元素；render 方法会根据 state 的不同构建不同的 DOM 元素。 也就是说，你只要调用 setState，组件就会重新渲染。我们顺利地消除了没必要的 DOM 操作。 4.2 重新插入新的 DOM 元素 上面的改进不会有什么效果，因为你仔细看一下就会发现，其实重新渲染的 DOM 元素并没有插入到页面当中。所以这个组件之外，你需要知道这个组件发生了改变，并且把新的 DOM 元素更新到页面当中。 重新修改一下 setState 方法： ... setState (state) { const oldEl = this.el this.state = state this.el = this.render() if (this.onStateChange) this.onStateChange(oldEl, this.el) } ... 使用这个组件的时候： const likeButton = new LikeButton() wrapper.appendChild(likeButton.render()) // 第一次插入 DOM 元素 component.onStateChange = (oldEl, newEl) => { wrapper.insertBefore(newEl, oldEl) // 插入新的元素 wrapper.removeChild(oldEl) // 删除旧的元素 } 这里每次 setState 都会调用 onStateChange 方法，而这个方法是实例化以后时候被设置的，所以你可以自定义 onStateChange 的行为。这里做的事是，每当 setState 的时候，就会把插入新的 DOM 元素，然后删除旧的元素，页面就更新了。这里已经做到了进一步的优化了：现在不需要再手动更新页面了。 非一般的暴力。不过没有关系，这种暴力行为可以被 Virtual-DOM 的 diff 策略规避掉，但这不是本文章所讨论的范围。 这个版本的点赞功能很不错，我可以继续往上面加功能，而且还不需要手动操作DOM。但是有一个不好的地方，如果我要重新另外做一个新组件，譬如说评论组件，那么里面的这些 setState 方法要重新写一遍，其实这些东西都可以抽出来。 5. 抽象出 Component 类 为了让代码更灵活，可以写更多的组件，我把这种模式抽象出来，放到一个 Component 类当中： class Component { constructor (props = {}) { this.props = props } setState (state) { const oldEl = this.el this.state = state this.el = this.renderDOM() if (this.onStateChange) this.onStateChange(oldEl, this.el) } renderDOM () { this.el = createDOMFromString(this.render()) if (this.onClick) { this.el.addEventListener('click', this.onClick.bind(this), false) } return this.el } } 还有一个额外的 mount 的方法，其实就是把组件的 DOM 元素插入页面，并且在 setState 的时候更新页面： const mount = (wrapper, component) => { wrapper.appendChild(component.renderDOM()) component.onStateChange = (oldEl, newEl) => { wrapper.insertBefore(newEl, oldEl) wrapper.removeChild(oldEl) } } 这样的话我们重新写点赞组件就会变成： class LikeButton extends Component { constructor (props) { super(props) this.state = { isLiked: false } } onClick () { this.setState({ isLiked: !this.state.isLiked }) } render () { return ` ${this.props.word || ''} ${this.state.isLiked ? '取消' : '点赞'} ? ` } } mount(wrapper, new LikeButton({ word: 'hello' })) 有没有发现你写的代码已经和 React.js 的组件写法很相似了？而且还是可以正常运作的代码，而且我们从头到尾都是用纯的 JavaScript，没有依赖任何第三方库。（注意这里加入了上面没有提到过点 props，可以给组件传入配置属性，跟 React.js 一样）。 只要有了上面那个 Component 类和 mount 方法加起来不足40行代码就可以做到组件化。如果我们需要写另外一个组件，只需要像上面那样，简单地继承一下 Component 类就好了： class RedBlueButton extends Component { constructor (props) { super(props) this.state = { color: 'red' } } onClick () { this.setState({ color: 'blue' }) } render () { return ` ${this.state.color} ` } } 还有一个神秘的 createDOMFromString，其实它更简单： const createDOMFromString = (domString) => { const div = document.createElement('div') div.innerHTML = domString return div } 6. 总结 这个 40 行不到的代码其实是一个残废而且智障版的 React.js，没有 JSX ，没有组件嵌套等等。它只是 React.js 组件化表现形式的一种实现而已。它根本没有触碰到 React.js 的精髓。 React.js 的最最精髓的地方可能就在于它的 Virtual DOM 算法，而它的 setState 、props 等等都只不过是一种形式 7. 实现代码 Reactjs in 40 .like-btn { font-size: 50px; } /* Component */ class Component { constructor (props = {}) { this.props = props } setState (state) { const oldEl = this.el this.state = state this.el = this.renderDOM() if (this.onStateChange) this.onStateChange(oldEl, this.el) } renderDOM () { this.el = createDOMFromString(this.render()) if (this.onClick) { this.el.addEventListener('click', this.onClick.bind(this), false) } return this.el } } const createDOMFromString = (domString) => { const div = document.createElement('div') div.innerHTML = domString return div } const mount = (component, wrapper) => { wrapper.appendChild(component.renderDOM()) component.onStateChange = (oldEl, newEl) => { wrapper.insertBefore(newEl, oldEl) wrapper.removeChild(oldEl) } } /* ========================================= */ class LikeButton extends Component { constructor (props) { super(props) this.state = { isLiked: false } } onClick () { this.setState({ isLiked: !this.state.isLiked }) } render () { return ` ${this.state.isLiked ? '取消' : '点赞'} 👍 ` } } class RedBlueButton extends Component { constructor (props) { super(props) this.state = { color: 'red' } } onClick () { this.setState({ color: 'blue' }) } render () { return ` ${this.state.color} ` } } const wrapper = document.querySelector('.wrapper') mount(new LikeButton({ bgColor: 'red' }), wrapper) mount(new LikeButton(), wrapper) mount(new RedBlueButton(), wrapper) ` "},"React/源码分析/简易版react.html":{"url":"React/源码分析/简易版react.html","title":"简易版react","keywords":"","body":"简易版react 简易版react 实现一个“react” vdom jsx component state/props 组件通讯 实现一个“react” 实现一个组件（component），它能够监听数据的变化，动态地维护视图，处理UI与用户的交互。 我们先创造一个对象component： var component = {} 我们给这个component设置一些本地数据data： var component = { data: { name: 'Jack' } } OK，有了数据，我们赋予它操作数据的能力，给它加一个setData方法： var component = { data: { name: 'Jack' }, setData: function (key, val) { var _t = this _t.data[key] = val } } 好啦，现在它既有数据又有操作数据的方法，接着我们给它一个render方法，让它渲染一段html到页面中，当然，它得先有个根元素作为根节点，我们也给它一个root的属性，指向一个节点： var component = { root: document.getElementById('root'), data: { name: 'Jack' }, setData: function (key, val) { var _t = this _t.data[key] = val }, render: function () { var _t = this var template = `hello, world!` _t.root.innerHTML = template } } OK，我们直接调用render函数来看看效果： var component = { root: document.getElementById('root'), data: { name: 'Jack' }, setData: function (key, val) { var _t = this _t.data[key] = val }, render: function () { var _t = this var template = `hello, world!` _t.root.innerHTML = template } } component.render() // 调用render 对应页面效果如下： index hello, world! 不过，我们是希望这个component能够根据我们的数据来渲染页面，实现模板引擎的效果。这里我们需要思考一下，怎么样才能把数据映射到字符串模板中去？我们可以在模板里面用一些变量限制符（variables controls）来特殊标识一个变量，比如在需要插入变量name的地方，我们用{name}来表示，那么原来的模板就变成var template = hello, {name}!，然后我们再用正则替换的方式，去寻找这些特殊标识，然后对应替换成变量的值。所以我们来使用正则改进一下： var component = { root: document.getElementById('root'), data: { name: 'Jack' }, setData: function (key, val) { var _t = this _t.data[key] = val }, render: function () { var _t = this var template = `hello, {name}!` var html = template.replace(/\\{.*\\}/g, function (res) { // 正则替换 var key = res.substr(1, res.length - 2) // 除去花括号，拿到key return _t.data[key] // 返回key在data中对应的val }) _t.root.innerHTML = html // 注意，这里是html，不是template了 } } component.render() 可以看到，我们只是简单粗暴地使用正则来替换相对于的字符串而已，实际上这里你完全可以使用现成的 js模板引擎 来帮助实现，会更加强大专业。 现在我们调用render就可以看到hello, Jack!了。OK，为了使我们修改数据的同时，视图也自动更新，我们需要在setData的时候同时调用render以更新视图。 var component = { ... setData: function (key, val) { var _t = this _t.data[key] = val _t.render() // 修改完数据之后，调用render更新视图 } ... } 现在我们试试，调用setData来改变数据： var component = { ... } component.render() setTimeout(function () { component.setData('name', 'React') }, 2000) 棒！现在这个“react”算是开发完成了！ 不过，还有点小问题我们可以改进的： 默认调用一次render来启动component，感觉不是很好，体现不出启动的含义； 现在所有的业务都写在了component体外，我们还是希望能够汇聚一点，把属于component本身的业务都包揽进去。 我们还是希望它能够有个比较正式的启动方式，我们给它一个start方法（这逼装的给满分）： var component = { root: document.getElementById('root'), data: { name: 'Jack' }, setData: function (key, val) { var _t = this _t.data[key] = val _t.render() }, render: function () { var _t = this var template = `hello, {name}!` var html = template.replace(/\\{.*\\}/g, function (res) { var key = res.substr(1, res.length - 2) return _t.data[key] }) root.innerHTML = html }, start: function () { var _t = this _t.render() } } component.start() // 注意，这里不再是执行render，而是执行start了 那么，什么时候开始执行业务？至少要等我的dom ready吧！那dom什么时候ready？至少要render之后吧！ok，那么我们先来给component加一个ready方法，顺手把之前写的setTimeout给搬进去： var component = { root: document.getElementById('root'), data: { name: 'Jack' }, setData: function (key, val) { var _t = this _t.data[key] = val _t.render() }, render: function () { var _t = this var template = `hello, {name}!` var html = template.replace(/\\{.*\\}/g, function (res) { var key = res.substr(1, res.length - 2) return _t.data[key] }) root.innerHTML = html }, start: function () { var _t = this _t.render() _t.ready() // 注意这里，在render之后，就可以执行ready了 }, ready: function () { var _t = this setTimeout(function () { _t.setData('name', 'React') }, 2000) } } component.start() ok，现在看起来舒服多了。 这里我们稍微停顿一下，我们可以看到，这个component在运作的时候，ready的含义明显与其他方法有区别，如果我们不需要任何业务实现的话，那ready本身是没有也不需要任何内容的。它仅仅表示的是这时候组件已经渲染到页面上了，你处在一个可以安全的进行dom操作的阶段 ，而如果你愿意，你设置可以多设置几个这样子的方法，比如beforeReady等等，只需要在start中，把它的调用放在_t.ready()之前即可，当然，举例的这个方法没有太大意义就是了。这样的设计我们称为 生命周期 ，这些方法我们称为 生命周期函数 ，react提供了几个非常关键且实用的生命周期函数，使得我们能够更加合理地设计我们的component，初步学习我们只需要了解与ready相对应的componentDidMount就可以了，下面会演示到。 那么，假设我们需要给dom加事件，应该怎么做？ 理论上来说，最好的做法是能够把模板转换为实实在在的dom对象，然后通过js给这些对象添加事件；另一种方法简单粗暴，那就是我直接在模板元素的行间写事件绑定，然后等整个html插入root之后，这些行内属性会自动生效。 这还用想吗？我们直接写行间： var component = { ... render: function () { var _t = this var template = `hello, {name}!` var html = template.replace(/\\{.*\\}/g, function (res) { var key = res.substr(1, res.length - 2) return _t.data[key] }) root.innerHTML = html }, changeName: function () { var _t = this _t.setData('name', '山里育') } ... } component.start() 这里剧透一下，react在这一步采用的是 jsx 的做法，这是一种对dom的抽象，原理是把用html标签表示的闭合元素转换为js对象，也就是说，你看到的代码中的hello, Jack其实在编译之后并不是html片段，而是一个js对象，然后自然而然地，写在行内的属性也就相对应变成了该对象的属性，这里我们不必对实现方式太过深入理解。 不信？在jsx中直接console.log(hello, Jack)试试？ 我们直接在onclick里执行_react_.changeName()是没有作用的，而且还会报错，因为component不是全局可以访问的，所以我们要把component挂在window下，暴露到全局： var component = window._react_ = { // 注意，在这里把_react_挂在window下 root: document.getElementById('root'), data: { name: 'Jack' }, setData: function (key, val) { var _t = this _t.data[key] = val _t.render() }, render: function () { var _t = this var template = `hello, {name}!` var html = template.replace(/\\{.*\\}/g, function (res) { var key = res.substr(1, res.length - 2) return _t.data[key] }) root.innerHTML = html }, start: function () { var _t = this _t.render() _t.ready() }, ready: function () { var _t = this setTimeout(function () { _t.setData('name', 'React') }, 2000) }, changeName: function () { var _t = this _t.setData('name', '山里育') } } component.start() 熟悉react或者vue的童鞋肯定会觉得熟悉，我们可以一一对应一下（看注释）： var component = window._react_ = { root: document.getElementById('root'), data: { // react -> getInitialState; vue -> data name: 'Jack' }, setData: function (key, val) { // react -> setState; vue -> 劫持对象的getter和setter var _t = this _t.data[key] = val _t.render() }, render: function () { // react -> render; vue -> var _t = this var template = `hello, {name}!` var html = template.replace(/\\{.*\\}/g, function (res) { var key = res.substr(1, res.length - 2) return _t.data[key] }) root.innerHTML = html }, start: function () { // react -> React.createClass; vue -> new Vue var _t = this _t.render() _t.ready() }, ready: function () { // react -> componentDidMount; vue -> ready(1.x)\\mounted(2.x) var _t = this setTimeout(function () { _t.setData('name', 'React') }, 2000) }, changeName: function () { // react -> changeName; vue -> methods.changeName var _t = this _t.setData('name', '山里育') } } component.start() 不过，我们的react并不能真正投入生产，因为render方法使用全局刷新dom的方式，对性能消耗太大。我们知道dom操作是很昂贵的。相比之下，我们传统的针对某个元素进行修改的方式反倒是性能更优。 vdom vdom即virtual dom，其实vdom就是为了填上面这个坑才被创造出来的。我们知道，如果每次有点小改动就全局刷新dom，那性能的消耗就太大了，没办法愉快工作下去。但是，如果在渲染之前，我们能够通过对比，计算出需要修改的部分，有针对性地去更新这一部分dom，那就可以避免这样的性能消耗了。 vdom就是帮我们干这事的！ vdom保存着真实dom树的所有信息，并保持同步。我们在render的时候不是直接渲染dom，而是渲染vdom，这时的vdom会通过一系列的算法比对（diff），得到最终需要修改的部分dom，然后再作用到真实的dom上： 我们家react：render -> dom 别人家react：render -> vdom -> (diff) -> dom 我们可以尝试猜一下vdom（的一个单元）大概是什么样的结构： var vdom = { tagName: 'H1', className: '', innerHTML: 'hello, Jack!', onClick: function () { // do something... }, children: [ // 子元素 ] ... } 所以vdom其实就是一个普通的对象，不是什么神奇的东西，真正有讲究的是diff算法，这关系到vdom的准确度和更新效率，我们在这里就不作深入探讨了。 jsx 完成了一个简单的react之后，我们来真正写react的时候就容易理解多了： // App.jsx import React from 'react' import ReactDOM from 'react-dom' var App = React.createClass({ getInitialState: function() { return { name: 'world' } }, componentDidMount: function() { var _t = this if (_t.isMounted()) { setTimeout(function() { _t.setState({ name: 'Jack' }) }, 2000) } }, render: function() { var _t = this return ( hello, {_t.state.name}! ) }, changeName: function() { var _t = this _t.setState({ name: 'React' }) } }) ReactDOM.render(, document.getElementById('root')) 上面的代码是react的实现，功能跟我们刚刚自己写的component是等效的（不要脸）。而且我们也可以看到，其实整个结构和工作流程也是跟我们的“React”很相近（真不要脸）。唯一差别比较大的，那就是直接在javascript中写html的方式了，这可能是大部分初学者都比较难接受的一点。 这种js和html混编的方式，就叫做jsx。 jsx使你可以在js中方便地组织你的html，想想，如果我们的html都要像之前我们写的那样，变成字符串的方式来写，那感觉很糟糕，连换行都不自在，因为你总会感觉你的思路在html和js之间来回切换，你总要考虑这里的换行有没有问题，那里的字符有没有歧义，需不需要转义等等的问题，强制把html给parse为js中的字符串，既不方便书写，又难以维护。所以为了消除这种麻烦，react干脆就把html当作一个可辨别的js代码片段来使用。其原理很简单，只是经过babel处理后，把js中的html标签内容变成js对象就可以了。 所以，如果我们把所有标签都当成一个js对象来看，那就很好理解了，一个hello, Jack!在js中应该就相当于（以下是真实例子拷贝）： { $$typeof: Symbol(react.element), _owner: null, _self: null, _source: null, _store: Object, key: null, props:{ children: \"hello, Jack!\", onClick: _t.changeName // 这是我自己补的 }, ref:null, type:\"h1\", __proto__:Object } 当然，以上应该说是一个组件的调用，真实的组件本身应该是lazy的，或者是functional的，你可以试试直接console.log(App)（以下依旧为真实例子拷贝）： function App(props) { _classCallCheck(this, App); var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props)); _this.state = { … } } 是不是验证了之前说的，jsx中的html片段其实是编译成js可识别的对象（函数）。 component component顾名思义，就是组件的意思。组件化 的目的是实现代码复用，这跟 模块化 很相似。简单来说，我们可以认为组件化，就是把一个个独立的代码块进行封装，然后在需要使用的时候，再一个个组装起来，构建最终的页面。 打个比方，我们的首页一般会有一个导航栏，这个导航栏就是一个功能完整并且相对独立的模块，我们可以把它拆出来，封装成组件，然后在代码中引用。这样的话，除了首页以外的其他页面，也都可以引用这个组件，这样我们就不必为每个页面都写一个导航栏，也不必在导航栏有变动的时候，去把所有页面都修改一遍，而只需要修改导航栏这个组件就可以了。 假设我们有一个页面index，这个页面上有一个logo、一个导航栏、一个新闻列表的板块，还有一个页脚，那么我们可以这么来写： logo nav item item item copy right 在react中，我们可以很容易地实现组件化，实现上面需求只需要这么写： // App.jsx import React from 'react' import ReactDOM from 'react-dom' var Logo = React.createClass({ render: function() { return logo } }) var Nav = React.createClass({ render: function() { return index about product } }) var NewsItem = React.createClass({ render: function() { return item } }) var Footer = React.createClass({ render: function() { return copy right } }) var App = React.createClass({ render: function() { return } }) ReactDOM.render(, document.getElementById('root')) 这样，我们就实现了对页面的拆分，彼此隔离的组件大大缓解了我们在一个作用域里书写大片的代码而引起污染的情况，使得调试变得更加方便。 看过react文档的小伙伴可能会说，咦？怎么是createClass的方式，而不是直接extends React.Component？其实官方提供了好几种声明一个组件的方式，并不限于以上两种，后者也是借助于es2015（es6）的class来实现的，在这里，我们为了让重点更加集中，就不使用class的方式了，有兴趣的小伙伴可以自行了解。 为了实现代码的跨页面复用，我们还可以把以上的组件分别封装到独立的文件当中，然后使用es6提供的import方式来引入： // App.jsx import React from 'react' import ReactDOM from 'react-dom' import Logo from './components/Logo' import Nav from './components/Nav' import NewsItem from './components/NewsItem' import Footer from './components/Footer' var App = React.createClass({ render: function() { return } }) ReactDOM.render(, document.getElementById('root')) 注意，为了使组件能够被import，在编写组件的时候，你需要对应地把它export出来： // Logo.jsx import React from 'react' var Logo = React.createClass({ render: function() { return logo } }) export default Logo 这里我们要强调一点，import和export是es6的语法，与react本身没有关系，不管你用不用es6，react都是能正常运作的，只不过我们借助于es6，能提高我们的编程体验以及更好地实现组件化的工程。 state/props 讲到component，就不得不讲 state 和 props 这两个属性，state是一个组件的本地数据，也就是它的私有数据，可以理解为local model，而props则是组件由外部接收的属性。 有点混乱，我们简单区别一下，假设我们有一个时钟组件clock，它平时都是自己运行，那么它可以自己管理自己的时间，所以它的time就可以由state来管理；除了显示时间之外，它还需要展示自己所在的城市，我们希望它的城市可以订制，也就是地点是需要“被告知”的，所以它的city就需要由props传入。 var Clock = React.createClass({ getInitialState: function() { return { time: new Date().toString() } }, render: function() { var _t = this return {_t.props.city}: {_t.state.time} }, componentDidMount: function() { var _t = this var timer = setInterval(function () { if (_t.isMounted()) { _t.setState({ time: new Date().toString() }) } else { clearInterval(timer) } }, 1000) } }) 我们可以在App组件里这样调用： var App = React.createClass({ render: function() { return } }) 这里为了突出可订制的性质，我特地放了两个时钟，标识了两个地点。虽然这个例子还是有点奇怪，但是我们以理解为主，不要去纠结这些细节，因为我一时也没想到什么比较好的例子。 一般来说，如果你能确定一个数据它只属于组件自己，完全不需要外部来管理，那么它就可以放在state中，如果这个数据（属性）可能来自外部，或者它需要被外部定制，或者它可能需要参考外界因素，或者它需要跟外部相互作用，那么它应该由props传入。 留意我们以上Clock组件中，出现了一个isMounted方法，这个方法是干嘛用的呢？ isMounted是判断当前组件是否挂载的状态，也就是说，如果isMounted()返回的是true那么说明这个组件目前是挂载在页面上的，正常运作；如果返回false，说明这个组件已经被卸载了，那么你不应该再对它做任何操作，比如setState而引起组件重新渲染。 组件被卸载的情况是很常见的，假设页面上有三个列表，那么这三个列表就是三个组件，而我们一次只显示一个列表，点击tab可以切换显示不同列表，那么我们切换列表实际就是对列表组件的加载和卸载过程，这时候，如果一个列表已经被卸载，那么对它的一切操作都应该被停止。 另一种情况是使用了router来实现SPA的时候，这也是很常见的，更应该用好isMounted，不然页面切换的时候很有可能会报错。 还有一点就是，state是可以由组件自己自由操作的，但是传入的props，需要依靠外部才能更新，换句话说，props对接收的组件来说，是只读不可写的！ 那如果我们确实需要更新自己的props该怎么办？我们需要以某种方式来通知外界，让外界来更新状态，这就涉及到组件之间的通讯了。 组件通讯 很多时候，我们的组件都不可避免的要跟组件外的环境，或者其他的组件互相作用，我们称为 组件之间的通讯 。 组件之间的通讯分为：父组件与子组件之间通讯、子组件与子组件之间通讯，以及跨了好几代的通讯（不好意思我不知道怎么一本正经地描述这种关系）。 最后一种通讯其实可以通过第一种来一步步传递实现，也可以借助于redux这样的插件来实现，后者已经超出了题纲，我们不作展开。 来个典型点的例子，假设我们要写一个模拟alert的弹窗组件，也就是web开发中非常非常常见的 模态弹窗 ，我们来分析一下需求： 窗口的状态（激活/关闭） 激活窗口的方法 关闭窗口的方法 可订制的弹窗内容 "},"React/源码分析/200行代码实现简版react.html":{"url":"React/源码分析/200行代码实现简版react.html","title":"200行代码实现简版react","keywords":"","body":"200行代码实现简版react 200行代码实现简版react 1. 基本概念 Component（组件） instance（组件实例） element jsx dom 2 虚拟dom与diff算法 3 生命周期与diff算法 4 实现 4.1 实现createElement 4.2 实现render 4.3 实现instantiate 4.4 区分类组件与函数式组件 4.5 实现reconcile(diff算法) 4.6 整体代码 5 fiber架构 1. 基本概念 Component(组件)、instance(组件实例)、 element、jsx、dom Component（组件） Component就是我们经常实现的组件，可以是类组件（class component）或者函数式组件（functional component），而类组件又可以分为普通类组件(React.Component)以及纯类组件（React.PureComponent），总之这两类都属于类组件，只不过PureComponent基于shouldComponentUpdate做了一些优化，这里不展开说。函数式组件则用来简化一些简单组件的实现，用起来就是写一个函数，入参是组件属性props，出参与类组件的render方法返回值一样，是react element（注意这里已经出现了接下来要介绍的element哦）。 下面我们分别按三种方式实现下Welcome组件： // Component class Welcome extends React.Component { render() { return Hello, {this.props.name}; } } // PureComponent class Welcome extends React.PureComponent { render() { return Hello, {this.props.name}; } } // functional component function Welcome(props) { return Hello, {props.name}; } instance（组件实例） 熟悉面向对象编程的人肯定知道类和实例的关系，这里也是一样的，组件实例其实就是一个组件类实例化的结果，概念虽然简单，但是在react这里却容易弄不明白，为什么这么说呢？因为大家在react的使用过程中并不会自己去实例化一个组件实例，这个过程其实是react内部帮我们完成的，因此我们真正接触组件实例的机会并不多。我们更多接触到的是下面要介绍的element，因为我们通常写的jsx其实就是element的一种表示方式而已(后面详细介绍)。虽然组件实例用的不多，但是偶尔也会用到，其实就是ref。ref可以指向一个dom节点或者一个类组件(class component)的实例，但是不能用于函数式组件，因为函数式组件不能实例化。这里简单介绍下ref，我们只需要知道ref可以指向一个组件实例即可，更加详细的介绍大家可以看react官方文档Refs and the DOM。 element 前面已经提到了element，即类组件的render方法以及函数式组件的返回值均为element。 那么这里的element到底是什么呢？其实很简单，就是一个纯对象（plain object），而且这个纯对象包含两个属性：type:(string|ReactClass)和props:Object，注意element并不是组件实例，而是一个纯对象。虽然element不是组件实例，但是又跟组件实例有关系，element是对组件实例或者dom节点的描述。如果type是string类型，则表示dom节点，如果type是function或者class类型，则表示组件实例。比如下面两个element分别描述了一个dom节点和一个组件实例： // 描述dom节点 { type: 'button', props: { className: 'button button-blue', children: { type: 'b', props: { children: 'OK!' } } } } function Button(props){ // ... } // 描述组件实例 { type: Button, props: { color: 'blue', children: 'OK!' } } jsx 只要弄明白了element，那么jsx就不难理解了，jsx只是换了一种写法，方便我们来创建element而已，想想如果没有jsx那么我们开发效率肯定会大幅降低，而且代码肯定非常不利于维护。比如我们看下面这个jsx的例子： const foo = Hello!; 其实说白了就是定义了一个dom节点div，并且该节点的属性集合是{id: 'foo'}，children是Hello!，就这点信息量而已，因此完全跟下面这种纯对象的表示是等价的 { type: 'div', props: { id: 'foo', children: 'Hello!' } } 那么React是如何将jsx语法转换为纯对象的呢？其实就是利用Babel编译生成的，我们只要在使用jsx的代码里加上个编译指示(pragma)即可，可以参考这里Babel如何编译jsx。比如我们将编译指示设置为指向createElement函数：/** @jsx createElement */，那么前面那段jsx代码就会编译为： var foo = createElement('div', {id:\"foo\"}, 'Hello!'); 可以看出，jsx的编译过程其实就是从、>这种标签式写法到函数调用式写法的一种转化而已。有了这个前提，我们只需要简单实现下createElement函数不就可以构造出element了嘛，我们后面自己实现简版react也会用到这个函数： function createElement(type, props, ...children) { props = Object.assign({}, props); props.children = [].concat(...children) .filter(child => child != null && child !== false) .map(child => child instanceof Object ? child : createTextElement(child)); return {type, props}; } dom dom我们这里也简单介绍下，作为一个前端研发人员，想必大家对这个概念应该再熟悉不过了。我们可以这样创建一个dom节点div： const divDomNode = window.document.createElement('div'); 其实所有dom节点都是HTMLElement类的实例，我们可以验证下： window.document.createElement('div') instanceof window.HTMLElement; // 输出 true 关于HTMLElementAPI可以参考这里：HTMLElement介绍。因此，dom节点是HTMLElement类的实例；同样的，在react里面，组件实例是组件类的实例，而element又是对组件实例和dom节点的描述，现在这些概念之间的关系大家应该都清楚了吧。介绍完了这几个基本概念，我们画个图来描述下这几个概念之间的关系： 2 虚拟dom与diff算法 相信使用过react的同学都多少了解过这两个概念：虚拟dom以及diff算法。这里的虚拟dom其实就是前面介绍的element，为什么说是虚拟dom呢，前面咱们已经介绍过了，element只是dom节点或者组件实例的一种纯对象描述而已，并不是真正的dom节点，因此是虚拟dom。react给我们提供了声明式的组件写法，当组件的props或者state变化时组件自动更新。整个页面其实可以对应到一棵dom节点树，每次组件props或者state变更首先会反映到虚拟dom树，然后最终反应到页面dom节点树的渲染。 那么虚拟dom跟diff算法又有什么关系呢？之所以有diff算法其实是为了提升渲染效率，试想下，如果每次组件的state或者props变化后都把所有相关dom节点删掉再重新创建，那效率肯定非常低，所以在react内部存在两棵虚拟dom树，分别表示现状以及下一个状态，setState调用后就会触发diff算法的执行，而好的diff算法肯定是尽可能复用已有的dom节点，避免重新创建的开销。我用下图来表示虚拟dom和diff算法的关系： react组件最初渲染到页面后先生成第1帧虚拟dom，这时current指针指向该第一帧。setState调用后会生成第2帧虚拟dom，这时next指针指向第二帧，接下来diff算法通过比较第2帧和第1帧的异同来将更新应用到真正的dom树以完成页面更新。 这里再次强调一下setState后具体怎么生成虚拟dom，因为这点很重要，而且容易忽略。前面刚刚已经介绍过什么是虚拟dom了，就是element树而已。那element树是怎么来的呢？其实就是render方法返回的嘛，下面的流程图再加深下印象： 其实react官方对diff算法有另外一个称呼，大家肯定会在react相关资料中看到，叫Reconciliation，我个人认为这个词有点晦涩难懂，不过后来又重新翻看了下词典，发现跟diff算法一个意思 可以看到reconcile有消除分歧、核对的意思，在react语境下就是对比虚拟dom异同的意思，其实就是说的diff算法。这里强调下，我们后面实现部实现reconcile函数，就是实现diff算法。 3 生命周期与diff算法 生命周期与diff算法又有什么关系呢？这里我们以componentDidMount、componentWillUnmount、ComponentWillUpdate以及componentDidUpdate为例说明下二者的关系。我们知道，setState调用后会接着调用render生成新的虚拟dom树，而这个虚拟dom树与上一帧可能会产生如下区别： 新增了某个组件； 删除了某个组件； 更新了某个组件的部分属性。 因此，我们在实现diff算法的过程会在相应的时间节点调用这些生命周期函数。 这里需要重点说明下前面提到的第1帧，我们知道每个react应用的入口都是： ReactDOM.render( Hello, world!, document.getElementById('root') ); ReactDom.render也会生成一棵虚拟dom树，但是这棵虚拟dom树是开天辟地生成的第一帧，没有前一帧用来做diff，因此这棵虚拟dom树对应的所有组件都只会调用挂载期的生命周期函数，比如componentDidMount、componentWillUnmount。 4 实现 // 声明编译指示 /** @jsx DiyReact.createElement */ // 导入我们下面要实现的API const DiyReact = importFromBelow(); // 业务代码 const randomLikes = () => Math.ceil(Math.random() * 100); const stories = [ {name: \"React\", url: \"https://reactjs.org/\", likes: randomLikes()}, {name: \"Node\", url: \"https://nodejs.org/en/\", likes: randomLikes()}, {name: \"Webpack\", url: \"https://webpack.js.org/\", likes: randomLikes()} ]; const ItemRender = props => { const {name, url} = props; return ( {name} ); }; class App extends DiyReact.Component { render() { return ( DiyReact Stories {this.props.stories.map(story => { return ; })} ); } componentWillMount() { console.log('execute componentWillMount'); } componentDidMount() { console.log('execute componentDidMount'); } componentWillUnmount() { console.log('execute componentWillUnmount'); } } class Story extends DiyReact.Component { constructor(props) { super(props); this.state = {likes: Math.ceil(Math.random() * 100)}; } like() { this.setState({ likes: this.state.likes + 1 }); } render() { const {name, url} = this.props; const {likes} = this.state; const likesElement = ; return ( this.like()}>{likes}❤️ ); } // shouldcomponentUpdate() { // return true; // } componentWillUpdate() { console.log('execute componentWillUpdate'); } componentDidUpdate() { console.log('execute componentDidUpdate'); } } // 将组件渲染到根dom节点 DiyReact.render(, document.getElementById(\"root\")); 我们在这段业务代码里面使用了render、createElement以及Component三个API，因此后面的任务就是实现这三个API并包装到一个函数importFromBelow 4.1 实现createElement createElement函数的功能跟jsx是紧密相关的，前面介绍jsx的部分已经介绍过了，其实就是把类似html的标签式写法转化为纯对象element，具体实现如下： function createElement(type, props, ...children) { props = Object.assign({}, props); props.children = [].concat(...children) .filter(child => child != null && child !== false) .map(child => child instanceof Object ? child : createTextElement(child)); return {type, props}; } 4.2 实现render 注意这个render相当于ReactDOM.render，不是组件的render方法，组件的render方法在后面Component实现部分。 // rootInstance用来缓存一帧虚拟dom let rootInstance = null; function render(element, parentDom) { // prevInstance指向前一帧 const prevInstance = rootInstance; // element参数指向新生成的虚拟dom树 const nextInstance = reconcile(parentDom, prevInstance, element); // 调用完reconcile算法(即diff算法)后将rooInstance指向最新一帧 rootInstance = nextInstance; } render函数实现很简单，只是进行了两帧虚拟dom的对比(reconcile)，然后将rootInstance指向新的虚拟dom。细心点会发现，新的虚拟dom为element，即最开始介绍的element，而reconcile后的虚拟dom是instance，不过这个instance并不是组件实例，这点看后面instantiate的实现。总之render方法其实就是调用了reconcile方法进行了两帧虚拟dom的对比而已。 4.3 实现instantiate 那么前面的instance到底跟element有什么不同呢？其实instance指示简单的是把element重新包了一层，并把对应的dom也给包了进来，这也不难理解，毕竟我们调用reconcile进行diff比较的时候需要把跟新应用到真实的dom上，因此需要跟dom关联起来，下面实现的instantiate函数就干这个事的。注意由于element包括dom类型和Component类型(由type字段判断，不明白的话可以回过头看一下第一节的element相关介绍)，因此需要分情况处理： dom类型的element.type为string类型，对应的instance结构为{element, dom, childInstances}。 Component类型的element.type为ReactClass类型，对应的instance结构为{dom, element, childInstance, publicInstance}，注意这里的publicInstance就是前面介绍的组件实例。 function instantiate(element) { const {type, props = {}} = element; const isDomElement = typeof type === 'string'; if (isDomElement) { // 创建dom const isTextElement = type === TEXT_ELEMENT; const dom = isTextElement ? document.createTextNode('') : document.createElement(type); // 设置dom的事件、数据属性 updateDomProperties(dom, [], element.props); const children = props.children || []; const childInstances = children.map(instantiate); const childDoms = childInstances.map(childInstance => childInstance.dom); childDoms.forEach(childDom => dom.appendChild(childDom)); const instance = {element, dom, childInstances}; return instance; } else { const instance = {}; const publicInstance = createPublicInstance(element, instance); const childElement = publicInstance.render(); const childInstance = instantiate(childElement); Object.assign(instance, {dom: childInstance.dom, element, childInstance, publicInstance}); return instance; } } 需要注意，由于dom节点和组件实例都可能有孩子节点，因此instantiate函数中有递归实例化的逻辑。 4.4 区分类组件与函数式组件 前面我们提到过，组件包括类组件（class component）与函数式组件（functional component）。我在平时的业务中经常用到这两类组件，如果一个组件仅用来渲染，我一般会使用函数式组件，毕竟代码逻辑简单清晰易懂。那么React内部是如何区分出来这两种组件的呢？这个问题说简单也简单，说复杂也复杂。为什么这么说呢，是因为React内部实现方式确实比较简单，但是这种简单的实现方式却是经过各种考量后确定下来的实现方式。蛋总(Dan)有一篇文章详细分析了下React内部如何区分二者，强烈推荐大家阅读，这里我直接拿过来用，文章链接见这里How Does React Tell a Class from a Function?。其实很简答，我们实现类组件肯定需要继承自类React.Component，因此首先给React.Component打个标记，然后在实例化组件时判断element.type的原型链上是否有该标记即可。 // 打标记 Component.prototype.isReactComponent = {}; // 区分组件类型 const type = element.type; const isDomElement = typeof type === 'string'; const isClassElement = !!(type.prototype && type.prototype.isReactComponent); 这里我们升级下前面的实例化函数instantiate以区分出函数式组件与类组件： function instantiate(element) { const {type, props = {}} = element; const isDomElement = typeof type === 'string'; const isClassElement = !!(type.prototype && type.prototype.isReactComponent); if (isDomElement) { // 创建dom const isTextElement = type === TEXT_ELEMENT; const dom = isTextElement ? document.createTextNode('') : document.createElement(type); // 设置dom的事件、数据属性 updateDomProperties(dom, [], element.props); const children = props.children || []; const childInstances = children.map(instantiate); const childDoms = childInstances.map(childInstance => childInstance.dom); childDoms.forEach(childDom => dom.appendChild(childDom)); const instance = {element, dom, childInstances}; return instance; } else if (isClassElement) { const instance = {}; const publicInstance = createPublicInstance(element, instance); const childElement = publicInstance.render(); const childInstance = instantiate(childElement); Object.assign(instance, {dom: childInstance.dom, element, childInstance, publicInstance}); return instance; } else { const childElement = type(element.props); const childInstance = instantiate(childElement); const instance = { dom: childInstance.dom, element, childInstance }; return instance; } } 可以看到，如果是函数式组件，我们没有实例化该组件，而是直接调用了该函数获取虚拟dom。 4.5 实现reconcile(diff算法) 重点来了，reconcile是react的核心，显然如何将新设置的state快速的渲染出来非常重要，因此react会尽量复用已有节点，而不是每次都动态创建所有相关节点。但是react强大的地方还不仅限于此，react16将reconcile算法由之前的stack架构升级成了fiber架构，更近一步做的性能优化。fiber相关的内容下一节再介绍，这里为了简单易懂，仍然使用类似stack架构的算法来实现，对于fiber现在只需要知道其调度原理即可，当然后面有时间可以再实现一版基于fiber架构的。 首先看一下整个reconcile算法的处理流程： 可以看到，我们会根据不同的情况做不同的处理： 如果是新增instance，那么需要实例化一个instance并且appendChild； 如果是不是新增instance，而是删除instance，那么需要removeChild； 如果既不是新增也不是删除instance，那么需要看instance的type是否变化，如果有变化，那节点就无法复用了，也需要实例化instance，然后replaceChild； 如果type没变化就可以复用已有节点了，这种情况下要判断是原生dom节点还是我们自定义实现的react节点，两种情况下处理方式不同。 大流程了解后，我们只需要在对的时间点执行生命周期函数即可，下面看具体实现： function reconcile(parentDom, instance, element) { if (instance === null) { const newInstance = instantiate(element); // componentWillMount newInstance.publicInstance && newInstance.publicInstance.componentWillMount && newInstance.publicInstance.componentWillMount(); parentDom.appendChild(newInstance.dom); // componentDidMount newInstance.publicInstance && newInstance.publicInstance.componentDidMount && newInstance.publicInstance.componentDidMount(); return newInstance; } else if (element === null) { // componentWillUnmount instance.publicInstance && instance.publicInstance.componentWillUnmount && instance.publicInstance.componentWillUnmount(); parentDom.removeChild(instance.dom); return null; } else if (instance.element.type !== element.type) { const newInstance = instantiate(element); // componentDidMount newInstance.publicInstance && newInstance.publicInstance.componentDidMount && newInstance.publicInstance.componentDidMount(); parentDom.replaceChild(newInstance.dom, instance.dom); return newInstance; } else if (typeof element.type === 'string') { updateDomProperties(instance.dom, instance.element.props, element.props); instance.childInstances = reconcileChildren(instance, element); instance.element = element; return instance; } else { if (instance.publicInstance && instance.publicInstance.shouldcomponentUpdate) { if (!instance.publicInstance.shouldcomponentUpdate()) { return; } } // componentWillUpdate instance.publicInstance && instance.publicInstance.componentWillUpdate && instance.publicInstance.componentWillUpdate(); instance.publicInstance.props = element.props; const newChildElement = instance.publicInstance.render(); const oldChildInstance = instance.childInstance; const newChildInstance = reconcile(parentDom, oldChildInstance, newChildElement); // componentDidUpdate instance.publicInstance && instance.publicInstance.componentDidUpdate && instance.publicInstance.componentDidUpdate(); instance.dom = newChildInstance.dom; instance.childInstance = newChildInstance; instance.element = element; return instance; } } function reconcileChildren(instance, element) { const {dom, childInstances} = instance; const newChildElements = element.props.children || []; const count = Math.max(childInstances.length, newChildElements.length); const newChildInstances = []; for (let i = 0; i instance !== null); } 看完reconcile算法后肯定有人会好奇，为什么这种算法叫做stack算法，这里简单解释一下。从前面的实现可以看到，每次组件的state更新都会触发reconcile的执行，而reconcile的执行也是一个递归过程，而且一开始直到递归执行完所有节点才停止，因此称为stack算法。由于是个递归过程，因此该diff算法一旦开始就必须执行完，因此可能会阻塞线程，又由于js是单线程的，因此这时就可能会影响用户的输入或者ui的渲染帧频，降低用户体验。不过react16中升级为了fiber架构，这一问题得到了解决。 4.6 整体代码 把前面实现的所有这些代码组合起来就是完整的简版react，不到200行代码，so easy～！完整代码见DiyReact。 5 fiber架构 react16升级了reconcile算法架构，从stack升级为fiber架构，前面我们已经提到过stack架构的缺点，那就是使用递归实现，一旦开始就无法暂停，只能一口气执行完毕，由于js是单线程的，这就有可能阻塞用户输入或者ui渲染，会降低用户体验。 而fiber架构则不一样。底层是基于requestIdleCallback来调度diff算法的执行，关于requestIdleCallback的介绍可以参考我之前写的一篇关于js事件循环的文章javascript事件循环（浏览器端、node端）。requestIdlecallback的特点顾名思义就是利用空闲时间来完成任务。注意这里的空闲时间就是相对于那些优先级更高的任务(比如用户输入、ui渲染)来说的。 "},"React/源码分析/实现Didact.html":{"url":"React/源码分析/实现Didact.html","title":"实现Didact","keywords":"","body":"创建自己的React 创建自己的React 1.(Didact):创建你自己的react 1.1 引言 2.渲染dom元素 2.1 什么是DOM 2.2 Didact元素 2.3 渲染dom元素 2.4 渲染DOM文本节点 2.5 总结 3.JSX和创建元素 3.1 JSX 3.2总结 4.虚拟DOM和调和过程 4.1 虚拟DOM和调和过程 4.2 实例(instance) 4.3 重构 4.4 复用dom节点 4.5 子元素的调和 4.6 删除Dom节点 4.7 总结 5.组件和状态(state) 5.1 回顾 5.2 组件类 1.(Didact):创建你自己的react 老的react架构写起 1.1 引言 如果不考虑性能，调试，平台兼容性等等，react的主要3，4个特性重写并不难。事实上，它们很简单，甚至只要不足200行代码 用不到200行代码写一个有一样的API,能跑的React。因为这个库的说教性(didactic)特点，我们打算就称之为Didact 用Didact写的应用如下： const stories = [ { name: \"Didact introduction\", url: \"http://bit.ly/2pX7HNn\" }, { name: \"Rendering DOM elements \", url: \"http://bit.ly/2qCOejH\" }, { name: \"Element creation and JSX\", url: \"http://bit.ly/2qGbw8S\" }, { name: \"Instances and reconciliation\", url: \"http://bit.ly/2q4A746\" }, { name: \"Components and state\", url: \"http://bit.ly/2rE16nh\" } ]; class App extends Didact.Component { render() { return ( Didact Stories {this.props.stories.map(story => { return ; })} ); } } class Story extends Didact.Component { constructor(props) { super(props); this.state = { likes: Math.ceil(Math.random() * 100) }; } like() { this.setState({ likes: this.state.likes + 1 }); } render() { const { name, url } = this.props; const { likes } = this.state; const likesElement = ; return ( this.like()}>{likes}❤️ {name} ); } } Didact.render(, document.getElementById(\"root\")); 效果如下: 我们将会从下面几点来一步步添加Didact的功能： 渲染dom元素 JSX和创建元素 虚拟DOM和调和过程 组件和状态(state)) Fiber:增量调和 这个系列暂时不讲的地方： Functional components Context（上下文） 生命周期方法 ref属性 通过key的调和过程（这里只讲根据子节点原顺序的调和） 其他渲染引擎 （只支持DOM） 旧浏览器支持 2.渲染dom元素 2.1 什么是DOM 开始之前，让我们回想一下，我们经常使用的DOM API // Get an element by id const domRoot = document.getElementById(\"root\"); // Create a new element given a tag name const domInput = document.createElement(\"input\"); // Set properties domInput[\"type\"] = \"text\"; domInput[\"value\"] = \"Hi world\"; domInput[\"className\"] = \"my-class\"; // Listen to events domInput.addEventListener(\"change\", e => alert(e.target.value)); // Create a text node const domText = document.createTextNode(\"\"); // Set text node content domText[\"nodeValue\"] = \"Foo\"; // Append an element domRoot.appendChild(domInput); // Append a text node (same as previous) domRoot.appendChild(domText); 注意到我们设置元素的属性而不是特性属性和特性的区别，只有合法的属性才可以设置。 2.2 Didact元素 我们用js对象来描述渲染过程，这些js对象我们称之为Didact元素.这些元素有2个属性，type和props。type可以是一个字符串或者方法。在后面讲到组件之前，我们先用字符串。props是一个可以为空的对象（不过不能为null）。props可能有children属性,这个children属性是一个Didact元素的数组。 我们将多次使用Didact元素，目前我们先称之为元素。不要和html元素混淆，在变量命名的时候，我们称它们为DOM元素或者dom(preact就是这么做的) 一个元素就像下面这样： const element = { type: \"div\", props: { id: \"container\", children: [ { type: \"input\", props: { value: \"foo\", type: \"text\" } }, { type: \"a\", props: { href: \"/bar\" } }, { type: \"span\", props: {} } ] } }; 对应描述下面的dom： Didact元素和react元素很像，但是不像react那样，你可能使用JSX或者createElement，创建元素就和创建js对象一样.Didatc我们也这么做，不过在后面章节我们再加上create元素的代码 2.3 渲染dom元素 下一步是渲染一个元素以及它的children到dom里。我们将写一个render方法(对应于react的ReactDOM.render)，它接受一个元素和一个dom 容器。然后根据元素的定义生成dom树,附加到容器里。 function render(element, parentDom) { const { type, props } = element; const dom = document.createElement(type); const childElements = props.children || []; childElements.forEach(childElement => render(childElement, dom)); parentDom.appendChild(dom); } 我们仍然没有对其添加属性和事件监听。现在让我们使用object.keys来遍历props属性，设置对应的值： function render(element, parentDom) { const { type, props } = element; const dom = document.createElement(type); const isListener = name => name.startsWith(\"on\"); Object.keys(props).filter(isListener).forEach(name => { const eventType = name.toLowerCase().substring(2); dom.addEventListener(eventType, props[name]); }); const isAttribute = name => !isListener(name) && name != \"children\"; Object.keys(props).filter(isAttribute).forEach(name => { dom[name] = props[name]; }); const childElements = props.children || []; childElements.forEach(childElement => render(childElement, dom)); parentDom.appendChild(dom); } 2.4 渲染DOM文本节点 现在render函数不支持的就是文本节点，首先我们定义文本元素什么样子，比如，在react中描述 Foo： const reactElement = { type: \"span\", props: { children: [\"Foo\"] } }; 注意到子节点，只是一个字符串，并不是其他元素对象。这就让我们的Didact元素定义不合适了：children元素应该是一个数组，数组里的元素都有type和props属性。如果我们遵守这个规则，后面将减少不必要的if判断.所以，Didact文本元素应该有一个“TEXT ELEMENT”的类型，并且有在对应的节点有文本的值。比如： const textElement = { type: \"span\", props: { children: [ { type: \"TEXT ELEMENT\", props: { nodeValue: \"Foo\" } } ] } }; 现在我们来定义文本元素应该如何渲染。不同的是，文本元素不使用createElement方法，而用createTextNode代替。节点值就和其他属性一样被设置上去。 function render(element, parentDom) { const { type, props } = element; // Create DOM element const isTextElement = type === \"TEXT ELEMENT\"; const dom = isTextElement ? document.createTextNode(\"\") : document.createElement(type); // Add event listeners const isListener = name => name.startsWith(\"on\"); Object.keys(props).filter(isListener).forEach(name => { const eventType = name.toLowerCase().substring(2); dom.addEventListener(eventType, props[name]); }); // Set properties const isAttribute = name => !isListener(name) && name != \"children\"; Object.keys(props).filter(isAttribute).forEach(name => { dom[name] = props[name]; }); // Render children const childElements = props.children || []; childElements.forEach(childElement => render(childElement, dom)); // Append to parent parentDom.appendChild(dom); } 2.5 总结 我们现在创建了一个可以渲染元素以及子元素的render方法。后面我们需要实现如何创建元素。我们将在下节讲到如何使JSX和Didact很好地融合。 3.JSX和创建元素 3.1 JSX 我们之前讲到了Didact元素,讲到如何渲染到DOM，用一种很繁琐的方式.这一节我们来看看如何使用JSX简化创建元素的过程。 JSX提供了一些创建元素的语法糖，不用使用下面的代码： const element = { type: \"div\", props: { id: \"container\", children: [ { type: \"input\", props: { value: \"foo\", type: \"text\" } }, { type: \"a\", props: { href: \"/bar\", children: [{ type: \"TEXT ELEMENT\", props: { nodeValue: \"bar\" } }] } }, { type: \"span\", props: { onClick: e => alert(\"Hi\"), children: [{ type: \"TEXT ELEMENT\", props: { nodeValue: \"click me\" } }] } } ] } }; 我们现在可以这么写： const element = ( bar alert(\"Hi\")}>click me ); 要让浏览器理解它，上面的代码必须使用预处理工具处理。比如babel。babel会把上面的代码转成下面这样： const element = createElement( \"div\", { id: \"container\" }, createElement(\"input\", { value: \"foo\", type: \"text\" }), createElement( \"a\", { href: \"/bar\" }, \"bar\" ), createElement( \"span\", { onClick: e => alert(\"Hi\") }, \"click me\" ) ); 支持JSX我们只要在Didact里添加一个createElement方法。其他事的交给预处理器去做。这个方法的第一个参数是元素的类型type,第二个是含有props属性的对象，剩下的参数都是子节点children。createElement方法需要创建一个对象，并把第二个参数上所有的值赋给它，把第二个参数后面的所有参数放到一个数组，并设置到children属性上，最后返回一个有type和props的对象。用代码实现很容易： function createElement(type, config, ...args) { const props = Object.assign({}, config); const hasChildren = args.length > 0; props.children = hasChildren ? [].concat(...args) : []; return { type, props }; } 同样，这个方法对文本元素不适用。文本的子元素是作为字符串传给createElement方法的。但是我们的Didact需要文本元素一样有type和props属性。所以我们要把不是didact元素的参数都转成一个’文本元素’ const TEXT_ELEMENT = \"TEXT ELEMENT\"; function createElement(type, config, ...args) { const props = Object.assign({}, config); const hasChildren = args.length > 0; const rawChildren = hasChildren ? [].concat(...args) : []; props.children = rawChildren .filter(c => c != null && c !== false) .map(c => c instanceof Object ? c : createTextElement(c)); return { type, props }; } function createTextElement(value) { return createElement(TEXT_ELEMENT, { nodeValue: value }); } 我同样从children列表里过滤了null，undefined,false参数。我们不需要把它们加到props.children上因为我们根本不会去渲染它们。 3.2总结 到这里我们并没有为Didact加特殊的功能.但是我们有了更好的开发体验，因为我们可以使用JSX来定义元素。我已经更新了codepen上的代码。因为codepen用babel转译JSX,所以以/* @jsx createElement /开头的注释都是为了让babel知道使用哪个函数。 下面我们将介绍Didact用来更新dom的虚拟dom和所谓的调和算法. 4.虚拟DOM和调和过程 到目前为止，我们基于JSX的描述方式实现了dom元素的创建机制。这里开始，我们专注于怎么更新DOM. 在下面介绍setState之前，我们之前更新DOM的方式只有再次调用render()方法，传入不同的元素。比如：我们要渲染一个时钟组件，代码是这样的： const rootDom = document.getElementById(\"root\"); function tick() { const time = new Date().toLocaleTimeString(); const clockElement = {time}; render(clockElement, rootDom); } tick(); setInterval(tick, 1000); 我们现在的render方法还做不到这个。它不会为每个tick更新之前同一个的div,相反它会新添一个新的div.第一种解决办法是每一次更新,替换掉div.在render方法的最下面，我们检查父元素是否有子元素，如果有，我们就用新元素生产的dom替换它： function render(element, parentDom) { // ... // Create dom from element // ... // Append or replace dom if (!parentDom.lastChild) { parentDom.appendChild(dom); } else { parentDom.replaceChild(dom, parentDom.lastChild); } } 在这个小列子里，这个办法很有效。但在复杂情况下，这种重复创建所有子节点的方式并不可取。所以我们需要一种方式，来对比当前和之前的元素树之间的区别。最后只更新不同的地方。 4.1 虚拟DOM和调和过程 React把这种diff过程称之为调和过程，我们现在也这么称呼它。首先我们要保存之前的渲染树，从而可以和新的树对比。换句话说，我们将实现自己的DOM,虚拟dom. 这种虚拟dom的‘节点’应该是什么样的呢？首先考虑使用我们的Didact元素。它们已经有一个props.children属性，我们可以根据它来创建树。但是这依然有两个问题,一个是为了是调和过程容易些，我们必须为每个虚拟dom保存一个对真实dom的引用，并且我们更希望元素都不可变(imumutable).第二个问问题是后面我们要支持组件，组件有自己的状态(state),我们的元素还不能处理那种。 4.2 实例(instance) 所以我们要介绍一个新的名词：实例。实例代表的已经渲染到DOM中的元素。它其实是一个有着，element``,dom,chilInstances属性的JS普通对象。childInstances是有着该元素所以子元素实例的数组。 注意我们这里提到的实例, 他指的是React调用继承于React.component的那些类的构造函数所获得的‘公共实例’(public instances)。我们会在以后把公共实例加上。 每一个DOM节点都有一个相应的实例。调和算法的一个目标就是尽量避免创建和删除实例。创建删除实例意味着我们在修改DOM，所以重复利用实例就是越少地修改dom树。 4.3 重构 我们来重写render方法，保留同样健壮的调和算法，但添加一个实例化方法来根据给定的元素生成一个实例（包括其子元素） let rootInstance = null; function render(element, container) { const prevInstance = rootInstance; const nextInstance = reconcile(container, prevInstance, element); rootInstance = nextInstance; } function reconcile(parentDom, instance, element) { if (instance == null) { const newInstance = instantiate(element); parentDom.appendChild(newInstance.dom); return newInstance; } else { const newInstance = instantiate(element); parentDom.replaceChild(newInstance.dom, instance.dom); return newInstance; } } function instantiate(element) { const { type, props } = element; // Create DOM element const isTextElement = type === \"TEXT ELEMENT\"; const dom = isTextElement ? document.createTextNode(\"\") : document.createElement(type); // Add event listeners const isListener = name => name.startsWith(\"on\"); Object.keys(props).filter(isListener).forEach(name => { const eventType = name.toLowerCase().substring(2); dom.addEventListener(eventType, props[name]); }); // Set properties const isAttribute = name => !isListener(name) && name != \"children\"; Object.keys(props).filter(isAttribute).forEach(name => { dom[name] = props[name]; }); // Instantiate and append children const childElements = props.children || []; const childInstances = childElements.map(instantiate); const childDoms = childInstances.map(childInstance => childInstance.dom); childDoms.forEach(childDom => dom.appendChild(childDom)); const instance = { dom, element, childInstances }; return instance; } 这段代码和之前一样，不过我们对上一次调用render方法保存了实例，我们也把调和方法和实例化方法分开了。 为了复用dom节点而不需要重新创建dom节点，我们需要一种更新dom属性（className,style,onClick等等）的方法。所以，我们将把目前用来设置属性的那部分代码抽出来，作为一个更新属性的更通用的方法。 function instantiate(element) { const { type, props } = element; // Create DOM element const isTextElement = type === \"TEXT ELEMENT\"; const dom = isTextElement ? document.createTextNode(\"\") : document.createElement(type); updateDomProperties(dom, [], props); // Instantiate and append children const childElements = props.children || []; const childInstances = childElements.map(instantiate); const childDoms = childInstances.map(childInstance => childInstance.dom); childDoms.forEach(childDom => dom.appendChild(childDom)); const instance = { dom, element, childInstances }; return instance; } function updateDomProperties(dom, prevProps, nextProps) { const isEvent = name => name.startsWith(\"on\"); const isAttribute = name => !isEvent(name) && name != \"children\"; // Remove event listeners Object.keys(prevProps).filter(isEvent).forEach(name => { const eventType = name.toLowerCase().substring(2); dom.removeEventListener(eventType, prevProps[name]); }); // Remove attributes Object.keys(prevProps).filter(isAttribute).forEach(name => { dom[name] = null; }); // Set attributes Object.keys(nextProps).filter(isAttribute).forEach(name => { dom[name] = nextProps[name]; }); // Add event listeners Object.keys(nextProps).filter(isEvent).forEach(name => { const eventType = name.toLowerCase().substring(2); dom.addEventListener(eventType, nextProps[name]); }); } updateDomProperties 方法删除所有旧属性，然后添加上新的属性。如果属性没有变，它还是照做一遍删除添加属性。所以这个方法会做很多无谓的更新，为了简单，目前我们先这样写。 4.4 复用dom节点 我们说过调和算法会尽量复用dom节点.现在我们为调和(reconcile)方法添加一个校验，检查是否之前渲染的元素和现在渲染的元素有一样的类型(type)，如果类型一致，我们将重用它(更新旧元素的属性来匹配新元素) function reconcile(parentDom, instance, element) { if (instance == null) { // Create instance const newInstance = instantiate(element); parentDom.appendChild(newInstance.dom); return newInstance; } else if (instance.element.type === element.type) { // Update instance updateDomProperties(instance.dom, instance.element.props, element.props); instance.element = element; return instance; } else { // Replace instance const newInstance = instantiate(element); parentDom.replaceChild(newInstance.dom, instance.dom); return newInstance; } } 4.5 子元素的调和 现在调和算法少了重要的一步，忽略了子元素。子元素调和是react的关键。它需要元素上一个额外的key属性来匹配之前和现在渲染树上的子元素.我们将实现一个该算法的简单版。这个算法只会匹配子元素数组同一位置的子元素。它的弊端就是当两次渲染时改变了子元素的排序，我们将不能复用dom节点。 实现这个简单版，我们将匹配之前的子实例 instance.childInstances 和元素子元素 element.props.children，并一个个的递归调用调和方法（reconcile）。我们也保存所有reconcile返回的实例来更新childInstances。 function reconcile(parentDom, instance, element) { if (instance == null) { // Create instance const newInstance = instantiate(element); parentDom.appendChild(newInstance.dom); return newInstance; } else if (instance.element.type === element.type) { // Update instance updateDomProperties(instance.dom, instance.element.props, element.props); instance.childInstances = reconcileChildren(instance, element); instance.element = element; return instance; } else { // Replace instance const newInstance = instantiate(element); parentDom.replaceChild(newInstance.dom, instance.dom); return newInstance; } } function reconcileChildren(instance, element) { const dom = instance.dom; const childInstances = instance.childInstances; const nextChildElements = element.props.children || []; const newChildInstances = []; const count = Math.max(childInstances.length, nextChildElements.length); for (let i = 0; i 4.6 删除Dom节点 如果nextChildElements数组比childInstances数组长度长，reconcileChildren将为所有子元素调用reconcile方法，并传入一个undefined实例。这没什么问题，因为我们的reconcile方法里if (instance == null)语句已经处理了并创建新的实例。但是另一种情况呢？如果childInstances数组比nextChildElements数组长呢，因为element是undefined,这将导致element.type报错。 这是我们并没有考虑到的，如果我们是从dom中删除一个元素情况。所以，我们要做两件事，在reconcile方法中检查element == null的情况并在reconcileChildren方法里过滤下childInstances function reconcile(parentDom, instance, element) { if (instance == null) { // Create instance const newInstance = instantiate(element); parentDom.appendChild(newInstance.dom); return newInstance; } else if (element == null) { // Remove instance parentDom.removeChild(instance.dom); return null; } else if (instance.element.type === element.type) { // Update instance updateDomProperties(instance.dom, instance.element.props, element.props); instance.childInstances = reconcileChildren(instance, element); instance.element = element; return instance; } else { // Replace instance const newInstance = instantiate(element); parentDom.replaceChild(newInstance.dom, instance.dom); return newInstance; } } function reconcileChildren(instance, element) { const dom = instance.dom; const childInstances = instance.childInstances; const nextChildElements = element.props.children || []; const newChildInstances = []; const count = Math.max(childInstances.length, nextChildElements.length); for (let i = 0; i instance != null); } 4.7 总结 这一章我们增强了Didact使其支持更新dom.我们也通过重用dom节点避免大范围dom树的变更，使didact性能更好。另外也使管理一些dom内部的状态更方便，比如滚动位置和焦点。 这里我更新了codepen,在每个状态改变时调用render方法，你可以在devtools里查看我们是否重建dom节点。 因为我们是在根节点调用render方法，调和算法是作用在整个树上。下面我们将介绍组件，组件将允许我们只把调和算法作用于其子树上。 5.组件和状态(state) 5.1 回顾 我们上一章的代码有几个问题： 每一次变更触发整个虚拟树的调和算法 状态是全局的 当状态变更时，我们需要显示地调用render方法 组件解决了这些问题，我们可以： 为jsx定义我们自己的‘标签’ 生命周期的钩子（我们这章不讲这个） 5.2 组件类 首先我们要提供一个供组件继承的Component的基类。我们还需要提供一个含props参数的构造方法，一个setState方法，setState接收一个partialState参数来更新组件状态： class Component { constructor(props) { this.props = props; this.state = this.state || {}; } setState(partialState) { this.state = Object.assign({}, this.state, partialState); } } 我们的应用里将和其他元素类型(div或者span)一样继承这个类再这样使用：。注意到我们的createElement方法不需要改变任何东西，createElement会把组件类作为元素的type，并正常的处理props属性。我们真正需要的是一个根据所给元素来创建组件实例(我们称之为公共实例)的方法。 function createPublicInstance(element, internalInstance) { const { type, props } = element; const publicInstance = new type(props); publicInstance.__internalInstance = internalInstance; return publicInstance; } 除了创建公共实例外，我们保留了对触发组件实例化的内部实例(从虚拟dom)引用，我们需要当公共实例状态发生变化时，能够只更新该实例的子树。 class Component { constructor(props) { this.props = props; this.state = this.state || {}; } setState(partialState) { this.state = Object.assign({}, this.state, partialState); updateInstance(this.__internalInstance); } } function updateInstance(internalInstance) { const parentDom = internalInstance.dom.parentNode; const element = internalInstance.element; reconcile(parentDom, internalInstance, element); } 我们也需要更新实例化方法。对组件而言，我们需要创建公共实例，然后调用组件的render方法来获取之后要再次传给实例化方法的子元素： function instantiate(element) { const { type, props } = element; const isDomElement = typeof type === \"string\"; if (isDomElement) { // Instantiate DOM element const isTextElement = type === TEXT_ELEMENT; const dom = isTextElement ? document.createTextNode(\"\") : document.createElement(type); updateDomProperties(dom, [], props); const childElements = props.children || []; const childInstances = childElements.map(instantiate); const childDoms = childInstances.map(childInstance => childInstance.dom); childDoms.forEach(childDom => dom.appendChild(childDom)); const instance = { dom, element, childInstances }; return instance; } else { // Instantiate component element const instance = {}; const publicInstance = createPublicInstance(element, instance); const childElement = publicInstance.render(); const childInstance = instantiate(childElement); const dom = childInstance.dom; Object.assign(instance, { dom, element, childInstance, publicInstance }); return instance; } } 组件的内部实例和dom元素的内部实例不同，组件内部实例只能有一个子元素(从render函数返回)，所以组件内部只有childInstance属性，而dom元素有childInstances数组。另外，组件内部实例需要有对公共实例的引用，这样在调和期间，才可以调用render方法。 唯一缺失的是处理组件实例调和，所以我们将为调和算法添加一些处理。如果组件实例只能有一个子元素，我们就不需要处理子元素的调和，我们只需要更新公共实例的props属性，重新渲染子元素并调和算法它： function reconcile(parentDom, instance, element) { if (instance == null) { // Create instance const newInstance = instantiate(element); parentDom.appendChild(newInstance.dom); return newInstance; } else if (element == null) { // Remove instance parentDom.removeChild(instance.dom); return null; } else if (instance.element.type !== element.type) { // Replace instance const newInstance = instantiate(element); parentDom.replaceChild(newInstance.dom, instance.dom); return newInstance; } else if (typeof element.type === \"string\") { // Update dom instance updateDomProperties(instance.dom, instance.element.props, element.props); instance.childInstances = reconcileChildren(instance, element); instance.element = element; return instance; } else { //Update composite instance instance.publicInstance.props = element.props; const childElement = instance.publicInstance.render(); const oldChildInstance = instance.childInstance; const childInstance = reconcile(parentDom, oldChildInstance, childElement); instance.dom = childInstance.dom; instance.childInstance = childInstance; instance.element = element; return instance; } } 这就是全部代码了，我们现在支持组件，我更新了codepen,我们的应用代码就像下面这样： const stories = [ { name: \"Didact introduction\", url: \"http://bit.ly/2pX7HNn\" }, { name: \"Rendering DOM elements \", url: \"http://bit.ly/2qCOejH\" }, { name: \"Element creation and JSX\", url: \"http://bit.ly/2qGbw8S\" }, { name: \"Instances and reconciliation\", url: \"http://bit.ly/2q4A746\" }, { name: \"Components and state\", url: \"http://bit.ly/2rE16nh\" } ]; class App extends Didact.Component { render() { return ( Didact Stories {this.props.stories.map(story => { return ; })} ); } } class Story extends Didact.Component { constructor(props) { super(props); this.state = { likes: Math.ceil(Math.random() * 100) }; } like() { this.setState({ likes: this.state.likes + 1 }); } render() { const { name, url } = this.props; const { likes } = this.state; const likesElement = ; return ( this.like()}>{likes}❤️ {name} ); } } Didact.render(, document.getElementById(\"root\")); 使用组件使我们可以创建自己的’JSX标签’，封装组件状态，并且只在子树上进行调和算法 最后的codepen使用这个系列的所有代码。 "},"React/源码分析/实现一个简易版的React.html":{"url":"React/源码分析/实现一个简易版的React.html","title":"实现一个简易版的React","keywords":"","body":"React 源码分析，实现一个简易版的React React 源码分析，实现一个简易版的React 写在前面 实现一个 hello React！的渲染 虚拟 dom 实现一个简单的更新机制 文本节点的 receiveComponent 自定义元素的 receiveComponent 基本元素的 receiveComponent diff 实现 _patch 的实现 end 写在前面 基于 React v15包括： React 的几种组件以及首次渲染实现 React 更新机制的实现以及 React diff 算法 React 的核心主要有一下几点。 虚拟 dom 对象（Virtual DOM） 虚拟 dom 差异化算法（diff algorithm） 单向数据流 组件声明周期 事件处理 实现一个 hello React！的渲染 看如下代码： // js React.render('hello React！',document.getElementById(\"root\")) // html // 生成代码 hello React! 针对上面代码的具体实现 /** * component 类 * 文本类型 * @param {*} text 文本内容 */ function ReactDOMTextComponent(text) { // 存下当前的字符串 this._currentElement = \"\" + text; // 用来标识当前component this._rootNodeID = null; } /** * component 类 装载方法,生成 dom 结构 * @param {number} rootID 元素id * @return {string} 返回dom */ ReactDOMTextComponent.prototype.mountComponent = function(rootID) { this._rootNodeID = rootID; return ( '' + this._currentElement + \"\" ); }; /** * 根据元素类型实例化一个具体的component * @param {*} node ReactElement * @return {*} 返回一个具体的component实例 */ function instantiateReactComponent(node) { //文本节点的情况 if (typeof node === \"string\" || typeof node === \"number\") { return new ReactDOMTextComponent(node); } } const React = { nextReactRootIndex: 0, /** * 接收一个React元素，和一个dom节点 * @param {*} element React元素 * @param {*} container 负责装载的dom */ render: function(element, container) { // 实例化组件 var componentInstance = instantiateReactComponent(element); // 组件完成dom装载 var markup = componentInstance.mountComponent(React.nextReactRootIndex++); // 将装载好的 dom 放入 container 中 $(container).html(markup); $(document).trigger(\"mountReady\"); } }; 这里代码分为三个部分： React.render 作为入口接受一个 React 元素和游览器中的 dom 负责调用渲染,nextReactRootIndex 为每个 component 的唯一标识 引入 component 类的概念，ReactDOMTextComponent 是一个 component 类定义。ReactDOMTextComponent 针对于文本节点进行处理。并且在 ReactDOMTextComponent 的原型上实现了 mountComponent 方法，用于对组件的渲染，返回组件的 dom 结构。当然 component 还具有更新和删除操作，这里将在后续讲解。 instantiateReactComponent 用来根据 element 的类型（现在只有一种 string 类型），返回一个 component 的实例。其实就是个类工厂。 在这里我们把逻辑分为几个部分，渲染逻辑则由 component 内部定义，React.render 负责调度整个流程，在调用 instantiateReactComponent 生成一个对应 component 类型的实例对象，再调用对象的 mountComponent 返回 dom，最后再写到 container 节点中 虚拟 dom 虚拟 dom 无疑是 React 的核心概念，在代码中我们会使用 React.createElement 来创建一个虚拟 dom 元素。 虚拟 dom 分为两种一种是游览器自带的基本元素比如 div，还有一种是自定义元素（文本节点不算虚拟 dom） 虚拟节点的使用方式 // 绑定事件监听方法 function sayHello(){ alert('hello!') } var element = React.createElement('div',{id:'jason',onclick:hello},'click me') React.render(element,document.getElementById(\"root\")) // 最终生成的html click me 我们使用 React.createElement 来创建一个虚拟 dom 元素，以下是简易实现 /** * ReactElement 就是虚拟节点的概念 * @param {*} key 虚拟节点的唯一标识，后期可以进行优化 * @param {*} type 虚拟节点类型，type可能是字符串（'div', 'span'），也可能是一个function，function时为一个自定义组件 * @param {*} props 虚拟节点的属性 */ function ReactElement(type, key, props) { this.type = type; this.key = key; this.props = props; } const React = { nextReactRootIndex: 0, /** * @param {*} type 元素的 component 类型 * @param {*} config 元素配置 * @param {*} children 元素的子元素 */ createElement: function(type, config, children) { var props = {}; var propName; config = config || {}; var key = config.key || null; for (propName in config) { if (config.hasOwnProperty(propName) && propName !== \"key\") { props[propName] = config[propName]; } } var childrenLength = arguments.length - 2; if (childrenLength === 1) { props.children = Array.isArray(children) ? children : [children]; } else if (childrenLength > 1) { var childArray = []; for (var i = 0; i createElement 方法对传入的参数做了一些处理，最终会返回一个 ReactElement 虚拟元素实例，key 的定义可以提高更新时的效率 有了虚拟元素实例，我们需要改造一下 instantiateReactComponent 方法 /** * 根据元素类型实例化一个具体的component * @param {*} node ReactElement * @return {*} 返回一个具体的component实例 */ function instantiateReactComponent(node) { //文本节点的情况 if (typeof node === \"string\" || typeof node === \"number\") { return new ReactDOMTextComponent(node); } //浏览器默认节点的情况 if (typeof node === \"object\" && typeof node.type === \"string\") { //注意这里，使用了一种新的component return new ReactDOMComponent(node); } } 我们增加了一个判断，这样当 render 的不是文本而是浏览器的基本元素时。我们使用另外一种 component 来处理它渲染时应该返回的内容。这里就体现了工厂方法 instantiateReactComponent 的好处了，不管来了什么类型的 node，都可以负责生产出一个负责渲染的 component 实例。这样 render 完全不需要做任何修改，只需要再做一种对应的 component 类型（这里是 ReactDOMComponent）就行了。 ReactDOMComponent的具体实现 /** * component 类 * react 基础标签类型，类似与html中的（'div','span' 等） * @param {*} element 基础元素 */ function ReactDOMComponent(element) { // 存下当前的element对象引用 this._currentElement = element; this._rootNodeID = null; } /** * component 类 装载方法 * @param {*} rootID 元素id * @param {string} 返回dom */ ReactDOMComponent.prototype.mountComponent = function(rootID) { this._rootNodeID = rootID; var props = this._currentElement.props; // 外层标签 var tagOpen = \"\"; // 加上reactid标识 tagOpen += \" data-reactid=\" + this._rootNodeID; // 拼接标签属性 for (var propKey in props) { // 属性为绑定事件 if (/^on[A-Za-z]/.test(propKey)) { var eventType = propKey.replace(\"on\", \"\"); // 对当前节点添加事件代理 $(document).delegate( '[data-reactid=\"' + this._rootNodeID + '\"]', eventType + \".\" + this._rootNodeID, props[propKey] ); } // 对于props 上的children和事件属性不做处理 if ( props[propKey] && propKey != \"children\" && !/^on[A-Za-z]/.test(propKey) ) { tagOpen += \" \" + propKey + \"=\" + props[propKey]; } } // 渲染子节点dom var content = \"\"; var children = props.children || []; var childrenInstances = []; // 保存子节点component 实例 var that = this; children.forEach((child, key) => { var childComponentInstance = instantiateReactComponent(child); // 为子节点添加标记 childComponentInstance._mountIndex = key; childrenInstances.push(childComponentInstance); var curRootId = that._rootNodeID + \".\" + key; // 得到子节点的渲染内容 var childMarkup = childComponentInstance.mountComponent(curRootId); // 拼接在一起 content += \" \" + childMarkup; }); // 保存component 实例 this._renderedChildren = childrenInstances; // 拼出整个html内容 return tagOpen + \">\" + content + tagClose; }; 对于虚拟 dom 的渲染逻辑，本质上还是个递归渲染的东西，reactElement 会递归渲染自己的子节点。可以看到我们通过 instantiateReactComponent 屏蔽了子节点的差异，只需要使用不同的 component 类，这样都能保证通过 mountComponent 最终拿到渲染后的内容。 另外这边的事件也要说下，可以在传递 props 的时候传入{onClick:function(){}}这样的参数，这样就会在当前元素上添加事件，代理到 document。由于 React 本身全是在写 js，所以监听的函数的传递变得特别简单。 这里很多东西没有考虑，这里为了保持简单就不再扩展了，另外 React 的事件处理其实很复杂，实现了一套标准的 w3c 事件。这里偷懒直接使用 jQuery 的事件代理到 document 上了。 自定义元素的实现 随着前端技术的发展浏览器的那些基本元素已经满足不了我们的需求了，如果你对 web components 有一定的了解，就会知道人们一直在尝试扩展一些自己的标记。 React 通过虚拟 dom 做到了类似的功能，还记得我们上面 node.type 只是个简单的字符串，如果是个类呢？如果这个类恰好还有自己的生命周期管理，那扩展性就很高了。 在 React 中使用自定义元素 var CompositeComponent = React.createClass({ getInitialState: function() { return { count: 0 }; }, componentWillMount: function() { console.log(\"声明周期: \" + \"componentWillMount\"); }, componentDidMount: function() { console.log(\"声明周期: \" + \"componentDidMount\"); }, onChange: function(e) { var count = ++this.state.count; this.setState({ count: count }); }, render: function() { const count = this.state.count; var h3 = React.createElement( \"h3\", { onclick: this.onChange.bind(this), class: \"h3\" }, `click me ${count}` ); var children = [h3]; return React.createElement(\"div\", null, children); } }); var CompositeElement = React.createElement(CompositeComponent); var root = document.getElementById(\"container\"); React.render(CompositeElement, root); React.createElement接受的不再是字符串，而是一个 class。 React.createClass 生成一个自定义标记类，带有基本的生命周期： getInitialState 获取最初的属性值 this.state componentWillmount 在组件准备渲染时调用 componentDidMount 在组件渲染完成后调用 React.createClass 的实现 /** * 所有自定义组件的超类 * @function render所有自定义组件都有该方法 */ function ReactClass() {} ReactClass.prototype.render = function() {}; /** * 更新 * @param {*} newState 新状态 */ ReactClass.prototype.setState = function(newState) { // 拿到ReactCompositeComponent的实例 this._reactInternalInstance.receiveComponent(null, newState); }; const React = { nextReactRootIndex: 0, /** * 创建 ReactClass * @param {*} spec 传入的对象 */ createClass: function(spec) { var Constructor = function(props) { this.props = props; this.state = this.getInitialState ? this.getInitialState() : null; }; Constructor.prototype = new ReactClass(); Constructor.prototype.constructor = Constructor; Object.assign(Constructor.prototype, spec); return Constructor; }, /** * 自己上文的createElement方法 */ /** * 自己上文的render方法 */ }; 这里 createClass 生成了一个继承 ReactClass 的子类，在构造函数里调用 this.getInitialState 获得最初的 state。 为了演示方便,我们这边的 ReactClass 相当简单，实际上原始的代码处理了很多东西，比如类的 mixin 的组合继承支持,比如 componentDidMount 等可以定义多次，需要合并调用等等，有兴趣的去翻源码吧，不是本文的主要目的，这里就不详细展开了。 看看我们上面的两种类型就知道，我们是时候为自定义元素也提供一个 component 类了，在那个类里我们会实例化 ReactClass，并且管理生命周期，还有父子组件依赖。 首先改造 instantiateReactComponent /** * 根据元素类型实例化一个具体的component * @param {*} node ReactElement * @return {*} 返回一个具体的component实例 */ function instantiateReactComponent(node) { // 文本节点的情况 if (typeof node === \"string\" || typeof node === \"number\") { return new ReactDOMTextComponent(node); } //浏览器默认节点的情况 if (typeof node === \"object\" && typeof node.type === \"string\") { // 注意这里，使用了一种新的component return new ReactDOMComponent(node); } // 自定义的元素节点 if (typeof node === \"object\" && typeof node.type === \"function\") { // 注意这里，使用新的component,专门针对自定义元素 return new ReactCompositeComponent(node); } } 这里我们添加了一个判断，处理自定义类型的 component ReactCompositeComponent 的具体实现如下 /** * component 类 * 复合组件类型 * @param {*} element 元素 */ function ReactCompositeComponent(element) { // 存放元素element对象 this._currentElement = element; // 存放唯一标识 this._rootNodeID = null; // 存放对应的ReactClass的实例 this._instance = null; } /** * component 类 装载方法 * @param {*} rootID 元素id * @param {string} 返回dom */ ReactCompositeComponent.prototype.mountComponent = function(rootID) { this._rootNodeID = rootID; // 当前元素属性 var publicProps = this._currentElement.props; // 对应的ReactClass var ReactClass = this._currentElement.type; var inst = new ReactClass(publicProps); this._instance = inst; // 保留对当前 component的引用 inst._reactInternalInstance = this; if (inst.componentWillMount) { // 生命周期 inst.componentWillMount(); //这里在原始的 reactjs 其实还有一层处理，就是 componentWillMount 调用 setstate，不会触发 rerender 而是自动提前合并，这里为了保持简单，就略去了 } // 调用 ReactClass 实例的render 方法，返回一个element或者文本节点 var renderedElement = this._instance.render(); var renderedComponentInstance = instantiateReactComponent(renderedElement); this._renderedComponent = renderedComponentInstance; //存起来留作后用 var renderedMarkup = renderedComponentInstance.mountComponent( this._rootNodeID ); // dom 装载到html 后调用生命周期 $(document).on(\"mountReady\", function() { inst.componentDidMount && inst.componentDidMount(); }); return renderedMarkup; }; 自定义元素本身不负责具体的内容，他更多的是负责生命周期。具体的内容是由它的 render 方法返回的虚拟节点来负责渲染的。 本质上也是递归的去渲染内容的过程。同时因为这种递归的特性，父组件的 componentWillMount 一定在某个子组件的 componentWillMount 之前调用，而父组件的 componentDidMount 肯定在子组件之后，因为监听 mountReady 事件，肯定是子组件先监听的。 需要注意的是自定义元素并不会处理我们 createElement 时传入的子节点，它只会处理自己 render 返回的节点作为自己的子节点。不过我们在 render 时可以使用 this.props.children 拿到那些传入的子节点，可以自己处理。其实有点类似 web components 里面的 shadow dom 的作用。 初始化渲染的大致流程如下: 实现一个简单的更新机制 一般在 React 中我们需要更新时都是调用的 setState 方法。所以本文的更新就基于 setState 实现。看下面的调用方式: /** * ReactCompositeComponent组件 */ var CompositeComponent = React.createClass({ getInitialState: function() { return { count: 0 }; }, componentWillMount: function() { console.log(\"声明周期: \" + \"componentWillMount\"); }, componentDidMount: function() { console.log(\"声明周期: \" + \"componentDidMount\"); }, onChange: function(e) { var count = ++this.state.count; this.setState({ count: count }); }, render: function() { const count = this.state.count; var h3 = React.createElement( \"h3\", { onclick: this.onChange.bind(this), class: \"h3\" }, `click me ${count}` ); var children = [h3]; return React.createElement(\"div\", null, children); } }); var CompositeElement = React.createElement(CompositeComponent); var root = document.getElementById(\"root\"); React.render(CompositeElement, root); // 生成html click me 0 // 点击click me 计数会递增 点击文字就会调用 setState 走更新流程，我们回顾一下 ReactClass，看一下 setState 的实现 /** * 更新 * @param {*} newState 新状态 */ ReactClass.prototype.setState = function(newState) { // 拿到ReactCompositeComponent的实例 // 在装载的时候保存 // 代码：this._reactInternalInstance = this this._reactInternalInstance.receiveComponent(null, newState); }; 可以看到 setState 主要调用了对应的 component 的 receiveComponent 来实现更新。所有的挂载，更新都应该交给对应的 component 来管理。所以就像所有的 component 都实现了 mountComponent 来处理第一次渲染，所有的 component 类都应该实现 receiveComponent 用来处理自己的更新。 文本节点的 receiveComponent 文本节点的更新比较简单，拿到新的文本进行比较，不同则直接替换整个节点 /** * component 类 更新 * @param {*} newText */ ReactDOMTextComponent.prototype.receiveComponent = function(nextText) { var nextStringText = \"\" + nextText; // 跟以前保存的字符串比较 if (nextStringText !== this._currentElement) { this._currentElement = nextStringText; // 替换整个节点 $('[data-reactid=\"' + this._rootNodeID + '\"]').html(this._currentElement); } }; 自定义元素的 receiveComponent 先来看自定义元素的 receiveComponent 的实现 /** * component 类 更新 * @param {*} nextElement * @param {*} newState */ ReactCompositeComponent.prototype.receiveComponent = function( nextElement, newState ) { // 如果接受了新的element，则直接使用最新的element this._currentElement = nextElement || this._currentElement; var inst = this._instance; // 合并state var nextState = Object.assign(inst.state, newState); var nextProps = this._currentElement.props; // 更新state inst.state = nextState; // 生命周期方法 if ( inst.shouldComponentUpdate && inst.shouldComponentUpdate(nextProps, nextState) === false ) { // 如果实例的 shouldComponentUpdate 返回 false，则不需要继续往下执行更新 return; } // 生命周期方法 if (inst.componentWillUpdate) inst.componentWillUpdate(nextProps, nextState); // 获取老的element var prevComponentInstance = this._renderedComponent; var prevRenderedElement = prevComponentInstance._currentElement; // 通过重新render 获取新的element var nextRenderedElement = this._instance.render(); // 比较新旧元素 if (_shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) { // 两种元素为相同，需要更新，执行字节点更新 prevComponentInstance.receiveComponent(nextRenderedElement); // 生命周期方法 inst.componentDidUpdate && inst.componentDidUpdate(); } else { // 两种元素的类型不同，直接重新装载dom var thisID = this._rootNodeID; this._renderedComponent = this._instantiateReactComponent( nextRenderedElement ); var nextMarkup = _renderedComponent.mountComponent(thisID); // 替换整个节点 $('[data-reactid=\"' + this._rootNodeID + '\"]').replaceWith(nextMarkup); } }; /** * 通过比较两个元素，判断是否需要更新 * @param {*} preElement 旧的元素 * @param {*} nextElement 新的元素 * @return {boolean} */ function _shouldUpdateReactComponent(prevElement, nextElement) { if (prevElement != null && nextElement != null) { var prevType = typeof prevElement; var nextType = typeof nextElement; if (prevType === \"string\" || prevType === \"number\") { // 文本节点比较是否为相同类型节点 return nextType === \"string\" || nextType === \"number\"; } else { // 通过type 和 key 判断是否为同类型节点和同一个节点 return ( nextType === \"object\" && prevElement.type === nextElement.type && prevElement.key === nextElement.key ); } } return false; } 上述代码的大致流程是: 合并 state 更新 state 然后看业务代码中是否实现生命周期方法 shouldComponentUpdate 有则调用，如果返回值为 false 则停止往下执行 然后是生命周期方法 componentWillUpdate 然后通过拿到新 state 的 instance 调用 render 方法拿到新的 element 和之旧的 element 进行比较 如果要更新就继续调用对应的 component 类对应的 receiveComponent 就好啦，其实就是直接当甩手掌柜，事情直接丢给手下去办了。当然还有种情况是，两次生成的 element 差别太大，就不是一个类型的，那好办直接重新生成一份新的代码重新渲染一次就 o 了 _shouldUpdateReactComponent 是一个全局方法，这个是一种 React 的优化机制。用来决定是直接全部替换，还是使用很细微的改动。当两次 render 出来的子节点 key 不同，直接全部重新渲染一遍，替换就好了。否则，我们就得来个递归的更新，保证最小化的更新机制，这样可以不会有太大的闪烁。 在这里本质上还是递归调用 receiveComponent 的过程。 基本元素的 receiveComponent 基础元素的更新包括两方面 属性的更新，包括对特殊属性比如事件的处理 子节点的更新 子节点的更新比较复杂，是提升效率的关键，所以需要处理以下问题： diff - 拿新的子节点树跟以前老的子节点树对比，找出他们之间的差别。 patch - 所有差别找出后，再一次性的去更新。 下面是基础元素更新的基本结构 /** * component 类 更新 * @param {*} nextElement */ ReactDOMComponent.prototype.receiveComponent = function(nextElement) { var lastProps = this._currentElement.props; var nextProps = nextElement.props; this._currentElement = nextElement; // 处理当前节点的属性 this._updateDOMProperties(lastProps, nextProps); // 处理当前节点的子节点变动 this._updateDOMChildren(nextElement.props.children); }; 先看看，更新属性怎么变更： /** * 更新属性 * @param {*} lastProps * @param {*} nextProps */ ReactDOMComponent.prototype._updateDOMProperties = function( lastProps, nextProps ) { // 当老属性不在新属性的集合里时，需要删除属性 var propKey; for (propKey in lastProps) { if ( nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) ) { // 新属性中有，且不再老属性的原型中 continue; } if (/^on[A-Za-z]/.test(propKey)) { var eventType = propKey.replace(\"on\", \"\"); // 特殊事件，需要去掉事件监听 $(document).undelegate( '[data-reactid=\"' + this._rootNodeID + '\"]', eventType, lastProps[propKey] ); continue; } // 删除不需要的属性 $('[data-reactid=\"' + this._rootNodeID + '\"]').removeAttr(propKey); } // 对于新的事件，需要写到dom上 for (propKey in nextProps) { if (/^on[A-Za-z]/.test(propKey)) { var eventType = propKey.replace(\"on\", \"\"); // 删除老的事件绑定 lastProps[propKey] && $(document).undelegate( '[data-reactid=\"' + this._rootNodeID + '\"]', eventType, lastProps[propKey] ); // 针对当前的节点添加事件代理,以_rootNodeID为命名空间 $(document).delegate( '[data-reactid=\"' + this._rootNodeID + '\"]', eventType + \".\" + this._rootNodeID, nextProps[propKey] ); continue; } if (propKey == \"children\") continue; // 添加新的属性，重写同名属性 $('[data-reactid=\"' + this._rootNodeID + '\"]').prop( propKey, nextProps[propKey] ); } }; 属性的变更并不是特别复杂，主要就是找到以前老的不用的属性直接去掉，新的属性赋值，并且注意其中特殊的事件属性做出特殊处理就行了。 子节点更新，也是最复杂的部分： // 全局的更新深度标识 var updateDepth = 0; // 全局的更新队列，所有的差异都存在这里 var diffQueue = []; ReactDOMComponent.prototype._updateDOMChildren = function( nextChildrenElements ) { updateDepth++; // _diff用来递归找出差别,组装差异对象,添加到更新队列diffQueue。 this._diff(diffQueue, nextChildrenElements); updateDepth--; if (updateDepth == 0) { // 在需要的时候调用patch，执行具体的dom操作 this._patch(diffQueue); diffQueue = []; } }; 就像我们之前说的一样，更新子节点包含两个部分，一个是递归的分析差异，把差异添加到队列中。然后在合适的时机调用_patch 把差异应用到 dom 上。那么什么是合适的时机，updateDepth 又是干嘛的？这里需要注意的是，_diff 内部也会递归调用子节点的 receiveComponent 于是当某个子节点也是浏览器普通节点，就也会走_updateDOMChildren 这一步。所以这里使用了 updateDepth 来记录递归的过程，只有等递归回来 updateDepth 为 0 时，代表整个差异已经分析完毕，可以开始使用 patch 来处理差异队列了。 diff 实现 // 差异更新的几种类型 var UPDATE_TYPES = { MOVE_EXISTING: 1, REMOVE_NODE: 2, INSERT_MARKUP: 3 }; /** * 生成子节点 elements 的 component 集合 * @param {object} prevChildren 前一个 component 集合 * @param {Array} nextChildrenElements 新传入的子节点element数组 * @return {object} 返回一个映射 */ function generateComponentChildren(prevChildren, nextChildrenElements) { var nextChildren = {}; nextChildrenElements = nextChildrenElements || []; $.each(nextChildrenElements, function(index, element) { var name = element.key ? element.key : index; var prevChild = prevChildren && prevChildren[name]; var prevElement = prevChild && prevChild._currentElement; var nextElement = element; // 调用_shouldUpdateReactComponent判断是否是更新 if (_shouldUpdateReactComponent(prevElement, nextElement)) { // 更新的话直接递归调用子节点的receiveComponent就好了 prevChild.receiveComponent(nextElement); // 然后继续使用老的component nextChildren[name] = prevChild; } else { // 对于没有老的，那就重新新增一个，重新生成一个component var nextChildInstance = instantiateReactComponent(nextElement, null); // 使用新的component nextChildren[name] = nextChildInstance; } }); return nextChildren; } /** * 将数组转换为映射 * @param {Array} componentChildren * @return {object} 返回一个映射 */ function flattenChildren(componentChildren) { var child; var name; var childrenMap = {}; for (var i = 0; i 注意 flattenChildren 我们这里把数组集合转成了对象 map,以 element 的 key 作为标识，当然对于 text 文本或者没有传入 key 的 element,直接用 index 作为标识。通过这些标识，我们可以从类型的角度来判断两个 component 是否是一样的。 generateComponentChildren 会尽量的复用以前的 component，也就是那些坑，当发现可以复用 component（也就是 key 一致）时，就还用以前的，只需要调用他对应的更新方法 receiveComponent 就行了，这样就会递归的去获取子节点的差异对象然后放到队列了。如果发现不能复用那就是新的节点，我们就需要 instantiateReactComponent 重新生成一个新的 component。 lastIndex，这个代表最后一次访问的老集合节点的最大的位置。 而我们加了个判断，只有_mountIndex 小于这个 lastIndex 的才会需要加入差异队列。有了这个判断上面的例子 2 就不需要 move。而程序也可以好好的运行，实际上大部分都是 2 这种情况。 这是一种顺序优化，lastIndex 一直在更新，代表了当前访问的最右的老的集合的元素。 我们假设上一个元素是 A,添加后更新了 lastIndex。 如果我们这时候来个新元素 B，比 lastIndex 还大说明当前元素在老的集合里面就比上一个 A 靠后。所以这个元素就算不加入差异队列，也不会影响到其他人，不会影响到后面的 path 插入节点。因为我们从 patch 里面知道，新的集合都是按顺序从头开始插入元素的，只有当新元素比 lastIndex 小时才需要变更。其实只要仔细推敲下上面那个例子，就可以理解这种优化手段了。 查看React diff 策略 _patch 的实现 /** * * @param {*} parentNode * @param {*} childNode * @param {*} index */ function insertChildAt(parentNode, childNode, index) { var beforeChild = parentNode.children().get(index); beforeChild ? childNode.insertBefore(beforeChild) : childNode.appendTo(parentNode); } /** * * @param {*} diffQueue */ ReactDOMComponent.prototype._patch = function(diffQueue) { var update; var initialChildren = {}; var deleteChildren = []; for (var i = 0; i _patch 主要就是挨个遍历差异队列，遍历两次，第一次删除掉所有需要变动的节点，然后第二次插入新的节点还有修改的节点。这里为什么可以直接挨个的插入呢？原因就是我们在 diff 阶段添加差异节点到差异队列时，本身就是有序的，也就是说对于新增节点（包括 move 和 insert 的）在队列里的顺序就是最终 dom 的顺序，所以我们才可以挨个的直接根据 index 去塞入节点。 这样整个的更新机制就完成了。我们再来简单回顾下 React 的差异算法： 首先是所有的 component 都实现了 receiveComponent 来负责自己的更新，而浏览器默认元素的更新最为复杂，也就是经常说的 diff algorithm。 react 有一个全局_shouldUpdateReactComponent 用来根据 element 的 key 来判断是更新还是重新渲染，这是第一个差异判断。比如自定义元素里，就使用这个判断，通过这种标识判断，会变得特别高效。 每个类型的元素都要处理好自己的更新： 自定义元素的更新，主要是更新 render 出的节点，做甩手掌柜交给 render 出的节点的对应 component 去管理更新。 text 节点的更新很简单，直接更新文案。 浏览器基本元素的更新，分为两块： 先是更新属性，对比出前后属性的不同，局部更新。并且处理特殊属性，比如事件绑定。 然后是子节点的更新，子节点更新主要是找出差异对象，找差异对象的时候也会使用上面的_shouldUpdateReactComponent 来判断，如果是可以直接更新的就会递归调用子节点的更新，这样也会递归查找差异对象，这里还会使用 lastIndex 这种做一种优化，使一些节点保留位置，之后根据差异对象操作 dom 元素（位置变动，删除， end 这只是个玩具，但实现了 React 最核心的功能，虚拟节点，差异算法，单向数据更新都在这里了。还有很多 React 优秀的东西没有实现，比如对象生成时内存的线程池管理，批量更新机制，事件的优化，服务端的渲染，immutable data 等等。这些东西受限于篇幅就不具体展开了。 React 作为一种解决方案，虚拟节点的想法比较新奇，不过个人还是不能接受这种别扭的写法。使用 React，就要使用他那一整套的开发方式，而他核心的功能其实只是一个差异算法，而这种其实已经有相关的库实现了。 相关资料： React diff 策略 原文地址 react 撸后台: 企业级中后台项目 "},"React/源码分析/从头实现一个简易版React.html":{"url":"React/源码分析/从头实现一个简易版React.html","title":"从头实现一个简易版React","keywords":"","body":"从头实现一个简易版React 从头实现一个简易版React 1. 从头实现一个简易版React（一） 1.1 Virtual DOM的实现 1.2 ReactComponent的实现 1.3 入口的实现 2. 从头实现一个简易版React（二） 2.1 ReactTextComponent 2.2 ReactDomComponent 2.3 ReactCompositComponent 2.4 总结 3. 从头实现一个简易版React（三） 3.1 ReactCompositeComponent 3.2 ReactTextComponent 3.3 ReactDomComponent 总结 仓库 第一节介绍下实现的思路以及结构，第二节讲渲染，第三节讲更新。 1. 从头实现一个简易版React（一） 1.1 Virtual DOM的实现 React的一切都基于Virtual DOM,我们第一步自然先实现它,如下： /** * @param type :代表当前的节点属性 * @param key :用来标识element,用于优化以后的更新 * @param props:节点的属性 */ function VDom(type, key, props) { this.type = type this.key = key this.props = props } // 代码地址：src/react/reactElement.js 实现了vDom后，理所需要一个方法来将我们写的元素转化为vDom。一般我们都是JSX来创建元素的，但它只不过是React.createElment的语法糖。所以，接下来，我们要实现的就是createElement方法： function createElement(type, config, ...children) { const props = {} config = config || {} // 获取key，用来标识element，方便以后高效的更新 const { key = null } = config let propName = '' // 复制config里的内容到props for (propName in config) { if (config.hasOwnProperty(propName) && propName !== 'key') { props[propName] = config[propName] } } // 转化children if (children.length === 1 && Array.isArray(children[0])) { props.children = children[0] } else { props.children = children } return new VDom(type, key, props) } // 代码地址：src/react/reactElement.js 这段代码也非常简单，根据我们传入的参数，生成对应的vDom 1.2 ReactComponent的实现 我们所创建的VDom类型分为3种： 文本类型 原生DOM类型 自定义类型 不同的类型，肯定有不同的渲染和更新逻辑，我们把这些逻辑与vDom一起，封装成对应的ReactComponent类，通过ReactComponent类控制vDom,这里我把它们命名为ReactTextComponent,ReactDomComponent,ReactCompositeComponent,分别对应三种类型。 首先是基类ReactComponet： // component基类，用来处理不同的虚拟dom更新，渲染 class Component { constructor(element) { this._vDom = element // 用来标识当前component this._rootNodeId = null } } // 代码地址：src/react/component/ReactComponent.js 接着再让不同类型的component继承这个基类，每种component类型都有mount和update两个方法，用来执行渲染和更新 class ReactDomComponent extends ReactComponent { // 渲染 mountComponent() {} // 更新 updateComponent() {} } class ReactCompositeComponent extends ReactComponent { // 渲染 mountComponent() {} // 更新 updateComponent() {} } class ReactTextComponent extends ReactComponent { // 渲染 mountComponent() {} // 更新 updateComponent() {} } 1.3 入口的实现 实现了ReactComponent后，我们自然需要一个入口去得到ReactComponent并调用它的mount。在使用React时，通常都是通过 import React from 'react' import ReactDOM from 'react-dom' class App extends React.Component { } ReactDOM.render(, document.getElementById('root')) 这段代码来充当渲染的入口，下面我们来实现这个入口，（为了方便说明，我把render方法也放在了React对象中） import Component from './Component' import createElement from './ReactElement' import instantiateReactComponent from './component/util' import $ from 'jquery' const React = { nextReactRootIndex: 0, // 标识id，确定每个vDom的唯一性 Component, // 所有自定义组件的父类 createElement, // 创建vdom render(vDom, container) { // 入口 var componentInstance = instantiateReactComponent(vDom) //通过vDom生成Component var markup = componentInstance.mountComponent(this.nextReactRootIndex++) container.innerHTML = markup $(document).trigger('mountReady') } } // 代码地址：src/react/index.js 由于渲染和更新都已经封装在不同的ReactComponent里，所以，这里也需要一个方法，根据不同的vDom类型生成对应的ReactComponent，下面我们就来实现这个方法： // component工厂，用来返回一个component实例 function instantiateReactComponent(node) { // 文本节点的情况 if (typeof node === 'string' || typeof node === 'number') { return new ReactTextComponent(node) } // 浏览器默认节点的情况 if (typeof node === 'object' && typeof node.type === 'string') { return new ReactDomComponent(node) } // 自定义的元素节点 if (typeof node === 'object' && typeof node.type === 'function') { return new ReactCompositeComponent(node) } } 然后再调用入口ReactComponent的mount方法，获取渲染内容，再将其渲染出来就行。 2. 从头实现一个简易版React（二） 我们把React元素分为text，basic，custom三种，并分别封装了三种vDom的ReactComponent，用来处理各自的渲染和更新，在这里，我们将重心放在各自ReactComponet的mount方法上。 2.1 ReactTextComponent ReactTextComponent用来处理文本节点，为了标识方便，在返回的内容上加了span标签。 // 用来表示文本节点在渲染，更新，删除时应该做的事情 class ReactTextComponent extends ReactComponent { // 渲染 mountComponent(rootId) { this._rootNodeId = rootId return `${this._vDom}` } } //代码地址：src/react/component/ReactTextComponent.js ReactTextComponent的mount方法非常简单，打上标识符，将内容插入标签内，并把标签内容返回就可以了。 2.2 ReactDomComponent 这个类用来处理原生节点的vDom，在将vDom渲染为原生DOM时，要考虑3点： 元素类型 拼凑属性，包含普通属性及事件的处理 子节点的递归渲染 代码如下： // 用来表示原生节点在渲染，更新，删除时应该做的事情 class ReactDomComponent extends ReactComponent { constructor(vDom) { super(vDom) this._renderedChildComponents = null } // 渲染 mountComponent(rootId) { this._rootNodeId = rootId const { props, type, props: { children = [] } } = this._vDom, childComponents = [] // 设置tag，加上标识 let tagOpen = `${type} data-reactid=${this._rootNodeId}`, tagClose = `/${type}`, content = '' // 拼凑属性 for (let propKey in props) { // 事件 if (/^on[A-Za-z]/.test(propKey)) { const eventType = propKey.replace('on', '') $(document).delegate(`[data-reactid=\"${this._rootNodeId}\"]`, `${eventType}.${this._rootNodeId}`, props[propKey]) } // 普通属性，排除children与事件 if (props[propKey] && propKey !== 'children' && !/^on[A-Za-z]/.test(propKey)) { tagOpen += ` ${propKey}=${props[propKey]}` } } // 获取子节点渲染出的内容 children.forEach((item, index) => { // 再次使用工厂方法实例化子节点的component，拼接好返回 const childComponent = instantiateReactComponent(item) childComponent._mountIndex = index childComponents.push(childComponent) // 子节点的rootId是父节点的rootId加上索引拼接的值 const curRootId = `${this._rootNodeId}.${index}` // 得到子节点的渲染内容 const childMarkup = childComponent.mountComponent(curRootId) // 拼接 content += childMarkup // 保存所有子节点的component this._renderedChildComponents = childComponents }) return `${content}` } } //代码地址：src/react/component/ReactDomComponent.js 在React的官方实现中，自己实现了一套事件系统，这里用了jQuery的事件代替。 在样式上，需要基于传入的style对象创建样式，这里也暂时忽略了。 2.3 ReactCompositComponent 在创建自定义组件时，通常会这样创建 import React from 'react' class App extends React.Component { render() { return ( ) } } 所以，第一步，我们先实现Component这个父类 // 所有自定义组件的父类 class Component { constructor(props) { this.props = props } setState(newState) { this._reactInternalInstance.updateComponent(null, newState) } } //代码地址：src/react/Component.js Component类上我们主要实现了setState方法，至于有什么用，我们放在更新里说。 在自定义组件的vDom中，type保存的是我们创建的Component的引用，所以在ReactCompositeComponent的mount方法中。我们首先根据vDom的type创建组件的实例，在以此调用它初始渲染的生命周期方法，render方法。 在render方法中，返回了组件渲染内容的vDom，我们根据这个vDom创建它的ReactComponent并调用mount(),就得到了真实的渲染内容。 贴代码： export default class extends ReactComponent { constructor(element) { super(element) // 存放对应的组件实例 this._instance = null this._renderedComponent = null } // 渲染 mountComponent(rootId) { this._rootNodeId = rootId const { type: Component, props } = this._vDom // 获取自定义组件的实例 const inst = new Component(props) this._instance = inst // 保留对当前component的引用，下面更新时会用到 inst._reactInternalInstance = this inst.componentWillMount && inst.componentWillMount() // 调用自定义组件的render方法，返回一个Vdom const renderedVdom = inst.render() // 获取renderedComponent的component const renderedComponent = instantiateReactComponent(renderedVdom) this._renderedComponent = renderedComponent // 得到渲染之后的内容 const renderMarkup = renderedComponent.mountComponent(this._rootNodeId) // 在React.render方法最后触发了mountReady事件，所在在这里监听，在渲染完成后触发 $(document).on('mountReady', () => { inst.componentDidMount && inst.componentDidMount() }) return renderMarkup } } // 代码地址：src/react/component/ReactCompositeComponent.js 从这里可以看出，自定义组件的mount方法并不负责具体的渲染，这些都交给了它的render，它把重心放在了创建对象和调用生命周期上。 2.4 总结 文章到这，我们的简易版react已经初步实现了虚拟DOM的创建，生命周期的调用，虚拟DOM的递归渲染和事件处理。 总结一下，每一个vDom都有ReactComponent相对应，递归渲染的本质无非就是获取每个vDom的ReactComponent,并调用它的mount方法。 3. 从头实现一个简易版React（三） 在这一节我们将着重实现 diff算法以及更新 同样，我们会实现三种ReactComponent的update方法。不过在这之前，我们先想想，该如何触发React的更新呢？没错，就是setState方法。 // 所有自定义组件的父类 class Component { constructor(props) { this.props = props } setState(newState) { this._reactInternalInstance.updateComponent(null, newState) } } //代码地址：src/react/Component.js 这里的reactInternalInstance就是我们在渲染ReactCompositeComponent时保存下的自身的实例，通过它调用了ReactCompositeComponent的update方法，接下来，我们就先实现这个update方法。 3.1 ReactCompositeComponent 这里的update方法同mount有点类似，都是调用生命周期和render方法，先上代码： class ReactCompositeComponent extends ReactComponent { constructor(element) { super(element) // 存放对应的组件实例 this._instance = null this._renderedComponent = null } mountComponent(rootId) { //内容略 } // 更新 updateComponent(nextVDom, newState) { // 如果有新的vDom,就使用新的 this._vDom = nextVDom || this._vDom const inst = this._instance // 获取新的state,props const nextState = { ...inst.state, ...newState } const nextProps = this._vDom.props // 判断shouldComponentUpdate if (inst.shouldComponentUpdate && (inst.shouldComponentUpdate(nextProps, nextState) === false)) return inst.componentWillUpdate && inst.componentWillUpdate(nextProps, nextState) // 更改state,props inst.state = nextState inst.props = nextProps const prevComponent = this._renderedComponent // 获取render新旧的vDom const prevRenderVDom = prevComponent._vDom const nextRenderVDom = inst.render() // 判断是需要更新还是重新渲染 if (shouldUpdateReactComponent(prevRenderVDom, nextRenderVDom)) { // 更新 prevComponent.updateComponent(nextRenderVDom) inst.componentDidUpdate && inst.componentDidUpdate() } else { // 重新渲染 this._renderedComponent = instantiateReactComponent(nextRenderVDom) // 重新生成对应的元素内容 const nextMarkUp = this._renderedComponent.mountComponent(this._rootNodeId) // 替换整个节点 $(`[data-reactid=\"${this._rootNodeId}\"]`).replaceWith(nextMarkUp) } } } //代码地址：src/react/component/ReactCompositeComponent.js 有两点要说明： 熟悉React的都知道，很多时候组件的更新，vDom并没有变化，我们可以通过shouldComponentUpdate这个生命周期来优化这点，当shouldComponentUpdate为false时，直接return，不执行下面的代码。 当调用render获取到新的vDom时，将会比较新旧的vDom类型是否相同，这也属于diff算法优化的一部分，如果类型相同，则执行更新，反之，就重新渲染。 // 判断是更新还是渲染 function shouldUpdateReactComponent(prevVDom, nextVDom) { if (prevVDom != null && nextVDom != null) { const prevType = typeof prevVDom const nextType = typeof nextVDom if (prevType === 'string' || prevType === 'number') { return nextType === 'string' || nextType === 'number' } else { return nextType === 'object' && prevVDom.type === nextVDom.type && prevVDom.key === nextVDom.key } } } //代码地址：src/react/component/util.js 注意，这里我们使用到了key，当type相同时使用key可以快速准确得出两个vDom是否相同，这是为什么React要求我们在循环渲染时必须添加key这个props。 3.2 ReactTextComponent ReactTextComponent的update方法非常简单，判断新旧文本是否相同，不同则更新内容，直接贴代码： class ReactTextComponent extends ReactComponent { mountComponent(rootId) { //省略 } // 更新 updateComponent(nextVDom) { const nextText = '' + nextVDom if (nextText !== this._vDom) { this._vDom = nextText } // 替换整个节点 $(`[data-reactid=\"${this._rootNodeId}\"]`).html(this._vDom) } // 代码地址：src/react/component/ReactTextComponent.js } 3.3 ReactDomComponent ReactDomComponent的update最复杂，可以说diff的核心都在这里，本文的重心也就放在这。 整个update分为两块，props的更新和children的更新。 class ReactDomComponent extends ReactComponent { mountComponent(rootId) { //省略 } // 更新 updateComponent(nextVDom) { const lastProps = this._vDom.props const nextProps = nextVDom.props this._vDom = nextVDom // 更新属性 this._updateDOMProperties(lastProps, nextProps) // 再更新子节点 this._updateDOMChildren(nextVDom.props.children) } // 代码地址：src/react/component/ReactDomComponent.js } props的更新非常简单，无非就是遍历新旧props，删除不在新props里的老props，添加不在老props里的新props，更新新旧都有的props，事件特殊处理。 _updateDOMProperties(lastProps, nextProps) { let propKey = '' // 遍历，删除已不在新属性集合里的老属性 for (propKey in lastProps) { // 属性在原型上或者新属性里有，直接跳过 if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) { continue } // 对于事件等特殊属性，需要单独处理 if (/^on[A-Za-z]/.test(propKey)) { const eventType = propKey.replace('on', '') // 针对当前的节点取消事件代理 $(document).undelegate(`[data-reactid=\"${this._rootNodeId}\"]`, eventType, lastProps[propKey]) continue } } // 对于新的属性，需要写到dom节点上 for (propKey in nextProps) { // 更新事件属性 if (/^on[A-Za-z]/.test(propKey)) { var eventType = propKey.replace('on', '') // 以前如果已经有，需要先去掉 lastProps[propKey] && $(document).undelegate(`[data-reactid=\"${this._rootNodeId}\"]`, eventType, lastProps[propKey]) // 针对当前的节点添加事件代理 $(document).delegate(`[data-reactid=\"${this._rootNodeId}\"]`, `${eventType}.${this._rootNodeId}`, nextProps[propKey]) continue } if (propKey === 'children') continue // 更新普通属性 $(`[data-reactid=\"${this._rootNodeId}\"]`).prop(propKey, nextProps[propKey]) } } // 代码地址：src/react/component/ReactDomComponent.js children的更新则相对复杂了很多，陈屹老师的《深入React技术栈》中提到，diff算法分为3块，分别是 tree diff component diff element diff 上文中的shouldUpdateReactComponent就属于component diff，接下来，让我们依据这三种diff实现updateChildren。 // 全局的更新深度标识，用来判定触发patch的时机 let updateDepth = 0 // 全局的更新队列 let diffQueue = [] _updateDOMChildren(nextChildVDoms) { updateDepth++ // diff用来递归查找差异，组装差异对象，并添加到diffQueue中 this._diff(diffQueue, nextChildVDoms) updateDepth-- if (updateDepth === 0) { // 具体的dom渲染 this._patch(diffQueue) diffQueue = [] } 这里通过updateDepth对vDom树进行层级控制，只会对相同层级的DOM节点进行比较，只有当一棵DOM树全部遍历完，才会调用patch处理差异。也就是所谓的tree diff。 确保了同层次后，我们要实现_diff方法。 已经渲染过的子ReactComponents在这里是数组，我们要遍历出里面的vDom进行比较，这里就牵扯到上文中的key，在有key时，我们优先用key来获取vDom，所以，我们首先遍历数组，将其转为map(这里先用object代替，以后会更改成es6的map)，如果有key值的，就用key值作标识，无key的，就用index。 下面是array到map的代码： // 将children数组转化为map export function arrayToMap(array) { array = array || [] const childMap = {} array.forEach((item, index) => { const name = item && item._vDom && item._vDom.key ? item._vDom.key : index.toString(36) childMap[name] = item }) return childMap } 部分diff方法: // 将之前子节点的component数组转化为map const prevChildComponents = arrayToMap(this._renderedChildComponents) // 生成新的子节点的component对象集合 const nextChildComponents = generateComponentsMap(prevChildComponents, nextChildVDoms) 将ReactComponent数组转化为map后，用老的ReactComponents集合和新vDoms数组生成新的ReactComponents集合，这里会使用shouldUpdateReactComponent进行component diff，如果相同，则直接更新即可，反之，就重新生成ReactComponent /** * 用来生成子节点的component * 如果是更新，就会继续使用以前的component，调用对应的updateComponent * 如果是新的节点，就会重新生成一个新的componentInstance */ function generateComponentsMap(prevChildComponents, nextChildVDoms = []) { const nextChildComponents = {} nextChildVDoms.forEach((item, index) => { const name = item.key ? item.key : index.toString(36) const prevChildComponent = prevChildComponents && prevChildComponents[name] const prevVdom = prevChildComponent && prevChildComponent._vDom const nextVdom = item // 判断是更新还是重新渲染 if (shouldUpdateReactComponent(prevVdom, nextVdom)) { // 更新的话直接递归调用子节点的updateComponent prevChildComponent.updateComponent(nextVdom) nextChildComponents[name] = prevChildComponent } else { // 重新渲染的话重新生成component const nextChildComponent = instantiateReactComponent(nextVdom) nextChildComponents[name] = nextChildComponent } }) return nextChildComponents } 经历了以上两步，我们已经获得了新旧同层级的ReactComponents集合。需要做的，只是遍历这两个集合，进行比较，同属性的更新一样，进行移动，新增，和删除，当然，在这个过程中，我会包含我们的第三种优化，element diff。它的策略是这样的：首先对新集合的节点进行循环遍历，通过唯一标识可以判断新老集合中是否存在相同的节点，如果存在相同节点，则进行移动操作，但在移动前需要将当前节点在老集合中的位置与 lastIndex 进行比较，if (prevChildComponent._mountIndex 上完整的diff方法代码： // 差异更新的几种类型 const UPDATE_TYPES = { MOVE_EXISTING: 1, REMOVE_NODE: 2, INSERT_MARKUP: 3 } // 追踪差异 _diff(diffQueue, nextChildVDoms) { // 将之前子节点的component数组转化为map const prevChildComponents = arrayToMap(this._renderedChildComponents) // 生成新的子节点的component对象集合 const nextChildComponents = generateComponentsMap(prevChildComponents, nextChildVDoms) // 重新复制_renderChildComponents this._renderedChildComponents = [] for (let name in nextChildComponents) { nextChildComponents.hasOwnProperty(name) && this._renderedChildComponents.push(nextChildComponents[name]) } let lastIndex = 0 // 代表访问的最后一次老的集合位置 let nextIndex = 0 // 代表到达的新的节点的index // 通过对比两个集合的差异，将差异节点添加到队列中 for (let name in nextChildComponents) { if (!nextChildComponents.hasOwnProperty(name)) continue const prevChildComponent = prevChildComponents && prevChildComponents[name] const nextChildComponent = nextChildComponents[name] // 相同的话，说明是使用的同一个component，需要移动 if (prevChildComponent === nextChildComponent) { // 添加差异对象，类型：MOVE_EXISTING prevChildComponent._mountIndex 调用diff方法后，会回到tree diff那一步，当一整棵树遍历完后，就需要通过Patch将更新的内容渲染出来了，patch方法相对比较简单，由于我们把更新的内容都放入了diffQueue中，只要遍历这个数组，根据不同的类型进行相应的操作就行。 // 渲染 _patch(updates) { // 处理移动和删除的 updates.forEach(({ type, fromIndex, toIndex, parentNode, parentId, markup }) => { const updatedChild = $(parentNode.children().get(fromIndex)) switch (type) { case UPDATE_TYPES.INSERT_MARKUP: insertChildAt(parentNode, $(markup), toIndex) // 插入 break case UPDATE_TYPES.MOVE_EXISTING: deleteChild(updatedChild) // 删除 insertChildAt(parentNode, updatedChild, toIndex) break case UPDATE_TYPES.REMOVE_NODE: deleteChild(updatedChild) break default: break } }) } // 代码地址：src/react/component/ReactDomComponent.js 总结 总结下更新： ReactCompositeComponent：负责调用生命周期，通过component diff将更新都交给了子ReactComponet ReactTextComponent：直接更新内容 ReactDomComponent：先更新props，在更新children，更新children分为三步，tree diff保证同层级比较，使用- shouldUpdateReactComponent进行component diff,最后在element diff通过lastIndex顺序优化 仓库 仓库地址 "},"React/源码分析/从0实现一个tiny-react.html":{"url":"React/源码分析/从0实现一个tiny-react.html","title":"从0实现一个tiny-react","keywords":"","body":"从0实现一个tiny react 从0实现一个tiny react 从0实现一个tiny react(一) 支持JSX 渲染 总结一下： props 和 state 总结一下： 从0实现一个tiny react（二） 复用DOM 更新属性 操作子节点 复用子节点 - key 总结 从0实现一个tiny react（三）生命周期 复用组件实例 生命周期 componentWillMount, componentDidMount, componentDidUpdate componentWillReceiveProps， shouldComponentUpdate， componentWillUpdate componentWillUnmount 其他 从0实现一个tiny react(一) 支持JSX react组件可以完全不用JSX， 用纯js来写。 JSX语法经过babel转化就是纯js代码， 譬如： const hw = Hello World const hw = React.createElement('div', null, \"Hello World\") 这两种是等效的。 babel 通过babylon 来把JSX转化为js 配置如下(transform-react-jsx)： { \"presets\": [ \"es2015\" ], \"plugins\": [ [\"transform-react-jsx\", { \"pragma\": \"createElement\" // default pragma is React.createElement }] ] } 所以对于react库本身的， 是不需要关心jsx语法的 渲染 react 中virtual-dom的概念， 使用一个 js的结构vnode来描述DOM 节点。 然后， 从vnode渲染出DOM树。 这个 vnode由3个属性描述：nodeName(div, Son...), props, children(vnode 组成的数组), 所以 createElement的最简实现 function createElement(type, props, ...args) { let children = [] for(let i = 0; i 从vnode 怎么渲染到dom? 先想一下我们在react里面书写下面的组件的时候 class Father extends Component { render() { return () // React.createElement(Son) --> {nodeName: Son, props:{}, children:[]} } } class Son extends Component { render() { return () // React.createElement(Grandson) --> {nodeName: Grandson, props:{}, children:[]} } } /** *React.createElement( * \"div\", * null, * \"i\", * React.createElement( * \"div\", * null, * \"am\" * ), * React.createElement(GrandText, null) * ); */ class Grandson extends Component { render() { return ( i am ) } } class GrandText extends Component { render() { return ( grandson // React.createElement(Grandson) ) } } render(, document.getElementById('root')) 在react里， 最终渲染出来的就是一个i am grandson。 渲染的过程就是: 渲染Father的Vnode -> 渲染Son的Vnode -> 渲染Grandson的Vnode ->渲染div -> 渲染i -> 渲染am -> 渲染GrandText。 显然这是一个递归的过程：递归的中止条件是 渲染html标签。 当 nodeName 是 html标签， 直接操作dom 当 nodeName 是 react组件 递归操作 组件render返回的vnode 暂时先不考虑 dom操作， 只考虑这个递归方法， 代码如下： function renderVDOM(vnode) { if(typeof vnode == \"string\") { // 字符串 \"i an grandson\" return vnode } else if(typeof vnode.nodeName == \"string\") { let result = { nodeName: vnode.nodeName, props: vnode.props, children: [] } for(let i = 0; i 执行上面的结构将返回 { \"nodeName\": \"div\", \"props\": {}, \"children\": [\"i\", {\"nodeName\": \"div\", \"props\": {}, \"children\": [\"am\"]}, { \"nodeName\": \"div\", \"props\": {}, \"children\": [\"grandson\"] }] } 加入实际DOM操作， 代码如下： function render(vnode, parent) { let dom if(typeof vnode == \"string\") { dom = document.createTextNode(vnode) parent.appendChild(dom) } else if(typeof vnode.nodeName == \"string\") { dom = document.createElement(vnode.nodeName) setAttrs(dom, vnode.props) parent.appendChild(dom) for(let i = 0; i { const v = props[k] if(k == \"className\") { dom.setAttribute(\"class\", v) return } if(k == \"style\") { if(typeof v == \"string\") { dom.style.cssText = v } if(typeof v == \"object\") { for (let i in v) { dom.style[i] = v[i] } } return } if(k[0] == \"o\" && k[1] == \"n\") { const capture = (k.indexOf(\"Capture\") != -1) dom.addEventListener(k.substring(2).toLowerCase(), v, capture) return } dom.setAttribute(k, v) }) } 总结一下： createElement 方法负责创建 vnode render 方法负责根据生成的vnode， 渲染到实际的dom的一个递归方法 (由于组件 最终一定会render html的标签。 所以这个递归一定是能够正常返回的) vnode是字符串的是， 创建textNode节点 当vnode.nodeName是 字符串的时候， 创建dom节点， 根据props设置节点属性， 遍历render children 当vnode.nodeName是 function的时候， 获取render方法的返回值 vnode'， 执行render(vnode') props 和 state v = f(props, state)。 组件的渲染结果由 render方法，props， state共同决定，之前只是讨论了render， 现在引入 props， state。 对于props， 父组件传递过来， 不可变。 设置到属性上面。 由基类Component 设置props class Component { constructor(props) { this.props = props } } 对于 state, 在组件的生命期内是可以修改的，当调用组件的setState方法的时候, 其实就是重新渲染 用一个新DOM树替换老的DOM: parent.replaceChild (newdom, olddom ) 比如当我在 GrandText 上调用setState。 就是父div 把GrandText渲染出来的dom 替换一下。所以 组件实例 必须有机制获取到 olddom 同时 render方法的第二个参数是 parent。 组件实例必须有机制获取到 parentDOM 这2个问题其实是一个问题。 parent = olddom.parentNode, 所以 olddom.parentNode.replaceChild (newdom, olddom ) 。 现在的关键就是获取到olddom， 这里采用的机制是 每个组件实例 记住 直接渲染出的组件实例／DOM（通过__rendered属性）。 下图： 代码实现： function render (vnode, parent, comp) { let dom if(typeof vnode == \"string\") { const dom = ... // 创建文本节点 comp && (comp.__rendered = dom) ... // other op } else if(typeof vnode.nodeName == \"string\") { const dom = ... // 创建 dom节点 comp && (comp.__rendered = dom) ... // other op } else if (typeof vnode.nodeName == \"function\") { const inst = ... // 创建 组件实例 comp && (comp.__rendered = inst) ... // other op } } 其中 comp 参数代表 \"我是被谁渲染的\"。 获取olddom的代码实现： function getDOM(comp) { let rendered = comp.__rendered while (rendered instanceof Component) { //判断对象是否是dom rendered = rendered.__rendered } return rendered } 调用 setState 使用olddom替换老的dom 代码如下： function render(vnode, parent, comp, olddom) { let dom if(typeof vnode == \"string\") { ... if(olddom) { parent.replaceChild(dom, olddom) } else { parent.appendChild(dom) } ... } else if(typeof vnode.nodeName == \"string\") { ... if(olddom) { parent.replaceChild(dom, olddom) } else { parent.appendChild(dom) } ... } else if (typeof vnode.nodeName == \"function\") { ... render(innerVnode, parent, inst, olddom) } } 拼凑一下以上功能， 完整代码实现： ///Component class Component { constructor(props) { this.props = props } setState(state) { setTimeout(() => { this.state = state const vnode = this.render() let olddom = getDOM(this) render(vnode, olddom.parentNode, this, olddom) }, 0) } } function getDOM(comp) { let rendered = comp.__rendered while (rendered instanceof Component) { //判断对象是否是dom rendered = rendered.__rendered } return rendered } ///render function render (vnode, parent, comp, olddom) { let dom if(typeof vnode == \"string\" || typeof vnode == \"number\") { dom = document.createTextNode(vnode) comp && (comp.__rendered = dom) parent.appendChild(dom) if(olddom) { parent.replaceChild(dom, olddom) } else { parent.appendChild(dom) } } else if(typeof vnode.nodeName == \"string\") { dom = document.createElement(vnode.nodeName) comp && (comp.__rendered = dom) setAttrs(dom, vnode.props) if(olddom) { parent.replaceChild(dom, olddom) } else { parent.appendChild(dom) } for(let i = 0; i 总结一下： render方法负责把vnode渲染到实际的DOM， 如果组件渲染的DOM已经存在， 就替换， 并且保持一个 __rendered的引用链 从0实现一个tiny react（二） ui = f(d)！ 这是react考虑ui的方式，开发者可以把重心放到d 数据上面来了。 从开发者的角度来讲 d一旦改变，react将会把ui重新渲染，使其再次满足 ui = f(d), 开发者没有任何dom操作， 交给react就好！！ 怎么重新渲染呢？ (一)文 中我们实现了一种方式， state改变的时候，用新的dom树替换一下老的dom树， 这是完全可行的。 class AppWithNoVDOM extends Component { constructor(props) { super(props) } testApp3() { let result = [] for(let i = 0; i {i}) } return result } render() { return ( { this.setState({}) }}>click me {this.testApp3()} ) } } const startTime = new Date().getTime() render(, document.getElementById(\"root\")) console.log(\"duration:\", new Date().getTime() - startTime) ... setState(state) { setTimeout(() => { this.state = state const vnode = this.render() let olddom = getDOM(this) const startTime = new Date().getTime() render(vnode, olddom.parentNode, this, olddom) console.log(\"duration:\", new Date().getTime() - startTime) }, 0) } ... 我们在 render, setState 设置下时间点。 在10000万个div的情况下， 第一次render和setState触发的render 耗时大概在180ms （可能跟机器配置有关） 当点击的时候， 由于调用this.setState({}), 页面将会重新渲染， 再次建立10000万个div， 但是实际上这里的DOM一点也没改。 应用越复杂， 无用功越多，卡顿越明显 为了解决这个问题， react提出了virtual-dom的概念：vnode(纯js对象) '代表' dom， 在渲染之前， 先比较出oldvnode和newvode的 区别。 然后增量的 更新dom。 virtual-dom 使得ui=f(d) 得以在实际项目上使用。 （注意： virtual-dom 并不会加快应用速度， 只是让应用在不直接操作dom的情况下，通过暴力的比较，增量更新 让应用没有那么慢） 如何增量更新呢？ 复用DOM 回想一下, 在 render函数 里面对于每一个判定为 dom类型的VDOM， 是直接创建一个新的DOM： ```javascript 1.7 ... else if(typeof vnode.nodeName == \"string\") { dom = document.createElement(vnode.nodeName) ... } ... 一定要创建一个 新的DOM 结构吗？ 考虑这种情况：假如一个组件， 初次渲染为 renderBefore， 调用setState再次渲染为 renderAfter 调用setState再再次渲染为 renderAfterAfter。 VNODE如下 ```javascript 1.7 const renderBefore = { tagName: 'div', props: { width: '20px', className: 'xx' }, children:[vnode1, vnode2, vnode3] } const renderAfter = { tagName: 'div', props: { width: '30px', title: 'yy' }, children:[vnode1, vnode2] } const renderAfterAfter = { tagName: 'span', props: { className: 'xx' }, children:[vnode1, vnode2, vnode3] } renderBefore 和renderAfter 都是div， 只不过props和children有部分区别，那我们是不是可以通过修改DOM属性， 修改DOM子节点，把 rederBefore 变化为renderAfter呢？， 这样就避开了DOM创建。 而 renderAfter和renderAfterAfter 属于不同的DOM类型， 浏览器还没提供修改DOM类型的Api，是无法复用的， 是一定要创建新的DOM的。 原则如下： 不同元素类型是无法复用的， span 是无法变成 div的。 对于相同元素: 更新属性， 复用子节点。 所以，现在的代码可能是这样的： ```javascript 1.7 ... else if(typeof vnode.nodeName == \"string\") { if(!olddom || olddom.nodeName != vnode.nodeName.toUpperCase()) { createNewDom(vnode, parent, comp, olddom) } else { diffDOM(vnode, parent, comp, olddom) // 包括 更新属性， 子节点复用 } } ... #### 更新属性 对于 renderBefore => renderAfter 。 属性部分需要做3件事情。 1. renderBefore 和 renderAfter 的属性交集 如果值不同， 更新值 updateAttr 2. renderBefore 和 renderAfter 的属性差集 置空 removeAttr 3. renderAfter 和 renderBefore 的属性差集 设置新值 setAttr ```javascript 1.7 const {onlyInLeft, bothIn, onlyInRight} = diffObject(newProps, oldProps) setAttrs(olddom, onlyInLeft) removeAttrs(olddom, onlyInRight) diffAttrs(olddom, bothIn.left, bothIn.right) function diffObject(leftProps, rightProps) { const onlyInLeft = {} const bothLeft = {} const bothRight = {} const onlyInRight = {} for(let key in leftProps) { if(rightProps[key] === undefined) { onlyInLeft[key] = leftProps[key] } else { bothLeft[key] = leftProps[key] bothRight[key] = rightProps[key] } } for(let key in rightProps) { if(leftProps[key] === undefined) { onlyInRight[key] = rightProps[key] } } return { onlyInRight, onlyInLeft, bothIn: { left: bothLeft, right: bothRight } } } function setAttrs(dom, props) { const allKeys = Object.keys(props) allKeys.forEach(k => { const v = props[k] if(k == \"className\") { dom.setAttribute(\"class\", v) return } if(k == \"style\") { if(typeof v == \"string\") { dom.style.cssText = v //IE } if(typeof v == \"object\") { for (let i in v) { dom.style[i] = v[i] } } return } if(k[0] == \"o\" && k[1] == \"n\") { const capture = (k.indexOf(\"Capture\") != -1) dom.addEventListener(k.substring(2).toLowerCase(), v, capture) return } dom.setAttribute(k, v) }) } function removeAttrs(dom, props) { for(let k in props) { if(k == \"className\") { dom.removeAttribute(\"class\") continue } if(k == \"style\") { dom.style.cssText = \"\" //IE continue } if(k[0] == \"o\" && k[1] == \"n\") { const capture = (k.indexOf(\"Capture\") != -1) const v = props[k] dom.removeEventListener(k.substring(2).toLowerCase(), v, capture) continue } dom.removeAttribute(k) } } /** * 调用者保证newProps 与 oldProps 的keys是相同的 * @param dom * @param newProps * @param oldProps */ function diffAttrs(dom, newProps, oldProps) { for(let k in newProps) { let v = newProps[k] let ov = oldProps[k] if(v === ov) continue if(k == \"className\") { dom.setAttribute(\"class\", v) continue } if(k == \"style\") { if(typeof v == \"string\") { dom.style.cssText = v } else if( typeof v == \"object\" && typeof ov == \"object\") { for(let vk in v) { if(v[vk] !== ov[vk]) { dom.style[vk] = v[vk] } } for(let ovk in ov) { if(v[ovk] === undefined){ dom.style[ovk] = \"\" } } } else { //typeof v == \"object\" && typeof ov == \"string\" dom.style = {} for(let vk in v) { dom.style[vk] = v[vk] } } continue } if(k[0] == \"o\" && k[1] == \"n\") { const capture = (k.indexOf(\"Capture\") != -1) let eventKey = k.substring(2).toLowerCase() dom.removeEventListener(eventKey, ov, capture) dom.addEventListener(eventKey, v, capture) continue } dom.setAttribute(k, v) } } '新'的dom结构 属性和 renderAfter对应了。 但是 children部分 还是之前的 操作子节点 之前 操作子节点的代码： ```javascript 1.7 for(let i = 0; i render 的第3个参数comp '谁渲染了我'， 第4个参数olddom '之前的旧dom元素'。现在复用旧的dom， 所以第4个参数可能是有值的 代码如下： ```javascript 1.7 let olddomChild = olddom.firstChild for(let i = 0; i 综上所述 完整的diffDOM 如下： ```javascript 1.7 function diffDOM(vnode, parent, comp, olddom) { const {onlyInLeft, bothIn, onlyInRight} = diffObject(vnode.props, olddom.__vnode.props) setAttrs(olddom, onlyInLeft) removeAttrs(olddom, onlyInRight) diffAttrs(olddom, bothIn.left, bothIn.right) let olddomChild = olddom.firstChild for(let i = 0; i } 由于需要在diffDOM的时候 从olddom获取 oldVNODE（即 diffObject(vnode.props, olddom.__vnode.props)）。 所以： ```javascript 1.7 // 在创建的时候 ... let dom = document.createElement(vnode.nodeName) dom.__vnode = vnode ... // diffDOM ... const {onlyInLeft, bothIn, onlyInRight} = diffObject(vnode.props, olddom.__vnode.props) ... olddom.__vnode = vnode // 更新完之后， 需要把__vnode的指向 更新 ... 另外 对于 TextNode的复用: ```javascript 1.7 ... if(typeof vnode == \"string\" || typeof vnode == \"number\") { if(olddom && olddom.splitText) { if(olddom.nodeValue !== vnode) { olddom.nodeValue = vnode } } else { dom = document.createTextNode(vnode) if(olddom) { parent.replaceChild(dom, olddom) } else { parent.appendChild(dom) } } } ... 重新 跑一下开头 的例子 setState后渲染时间变成了 20ms 左右。 从 180ms 到20ms 差不多快有一个数量级的差距了。 到底快了多少，取决于前后结构的相似程度， 如果前后结构基本相同，diff是有意义的减少了DOM操作。 #### 复用子节点 - **key** ```javascript 1.7 初始渲染 ... render() { return ( ) } ... setState再次渲染 ... render() { return ( hi ) } ... 我们之前的子节点复用顺序就是按照DOM顺序， 显然这里如果这样处理的话， 可能导致组件都复用不了。 针对这个问题， React是通过给每一个子组件提供一个 \"key\"属性来解决的 对于拥有 同样key的节点， 认为结构相同。 所以问题变成了： f([{key: 'wca'}, {key: 'wcb}, {key: 'wcc}]) = [{key:'spanhi'}, {key: 'wca'}, {key: 'wcb}, {key: 'wcc}] 函数f 通过删除， 插入操作，把olddom的children顺序， 改为和 newProps里面的children一样 （按照key值一样）。类似与 字符串距离, 总结 通过 diff 比较渲染前后 DOM的差别来复用实际的， 我们的性能得到了提高。现在 render方法的描述： render 方法是根据的vnode， 渲染到实际的dom，如果存在olddom会先尝试复用的 一个递归方法 (由于组件 最终一定会render html的标签。 所以这个递归一定是能够正常返回的) vnode是字符串， 如果存在olddom， 且可以复用， 复用之。否则创建textNode节点 当vnode.nodeName是 字符串的时候， 如果存在olddom， 且可以复用， 复用之。否则创建dom节点， 根据props设置节点属性， 遍历render children 当vnode.nodeName是 function的时候， 获取render方法的返回值 vnode'， 执行render(vnode') 从0实现一个tiny react（三）生命周期 在给tinyreact加生命周期之前，先考虑 组件实例的复用 这个前置问题 复用组件实例 render函数 只能返回一个根 ```jsx harmony class A extends Component{ render() { return (...) } } class C extends Component { render() { return ( ... ... ... ) } } 所以 最终的组件树一定是类似这种的 (首字母大写的代表组件， div／span／a...代表原生DOM类型) 是绝对不可能 出现下图这种树结构 (与render函数返回单根的特性矛盾) 注意 __rendered引用 指向了一个inst／dom。 所以可以通过__rendered来复用实例。 下面我们讨论怎么根据__rendered 复用inst 假如在 Father里面调用 setState？ 按照现在render 函数的做法: ```javascript 1.7 else if (typeof vnode.nodeName == \"function\") { let func = vnode.nodeName let inst = new func(vnode.props) ... } 新建 Son 实例 新建 Grandson 实例 diff 渲染 div 再次setState呢? 好吧， 再来一次： 新建 Son 实例 新建 Grandson 实例 diff 渲染 div 第 3步 就是 (二) 讨论的内容， 会用\"最少\"的dom操作， 来更新dom到最新的状态。对于1， 2 每次setState的时候都会新建inst， 在这里是可以复用之前创建好的inst实例的。 但是如果一个组件 初始渲染为 '\\', setState 之后渲染为 '\\' 这种情况呢？ 那inst就不能复用了， 类比一下 DOM 里的 div --> span 。 把render 第四个参数 old ---> olddomOrComp ， 通过这个参数来判断 dom 或者inst 是否可以复用： ```jsx harmony //inst 是否可以复用 function render (vnode, parent, comp, olddomOrComp) { ... } else if(typeof vnode.nodeName === \"string\") { if(!olddomOrComp || olddomOrComp.nodeName !== vnode.nodeName.toUpperCase()) { // } else if (typeof vnode.nodeName == \"function\") { let func = vnode.nodeName let inst if(olddomOrComp && olddomOrComp instanceof func) { // render(innerVnode, parent, inst, inst.__rendered) 这里 在最后的 render(innerVnode, parent, inst, olddom) 被改为了： render(innerVnode, parent, inst, inst.__rendered)。 这样是符合 olddomOrComp定义的。 但是 olddom 其实是有2个作用的 1. 判断dom是否可以复用 2. parent.replaceChild(dom, olddom), olddom确定了新的dom的位置 而 olddomOrComp 是做不到第二点。 即使： parent.replaceChild(dom, getDOM(olddomOrComp)) 也是不行的。 原因是： 假如初始 CompA --> setState后 CompA --> ， 那么inst 不可以复用， inst.__rendered 是undefined， 就从replaceChild变成了appendChild 怎么解决呢？ 引入第5个参数 myIndex: dom的位置问题都交给这个变量。 olddomOrComp只负责决定 复用的问题 so, 加入myIndex的代码如下： ```javascript 1.7 /** * 替换新的Dom， 如果没有在最后插入 * @param parent * @param newDom * @param myIndex */ function setNewDom(parent, newDom, myIndex) { const old = parent.childNodes[myIndex] if (old) { parent.replaceChild(newDom, old) } else { parent.appendChild(newDom) } } function render(vnode, parent, comp, olddomOrComp, myIndex) { let dom if(typeof vnode === \"string\" || typeof vnode === \"number\" ) { ... } else { dom = document.createTextNode(vnode) setNewDom(parent, dom, myIndex) // 重新考虑 Father里面调用 setState。 此时已经不会创建新实例了。 那么 假如现在对 Grandson调用setState呢？ 很不幸， 我们需要创建Granssonson1, Granssonson2, Granssonson3， 调用几次， 我们就得跟着新建几次。 上面的复用方式 并没有解决这个问题, 之前 rendered 引用链 到 dom就结束了。 把rendered这条链 完善吧！！ 首先 对__rendered 重新定义如下: 当X 是组件实例的时候， __rendered 为X渲染出的 组件实例 或者 dom元素 当X 是dom元素的时候， __rendered 为一个数组， 是X的子组件实例 或者 子dom元素Father --__rendered--> Son --__rendered--> Grandson --__rendered--> div --__rendered--> [Granssonson1, Granssonson2, Granssonson3,] 在dom 下创建 \"直接子节点\" 的时候。 需要把这个纪录到dom.rendered 数组中。 或者说， 如果新建的一个dom元素／组件实例 是dom的 \"直接子节点\"， 那么需要把它纪录到 parent.rendered 数组中。 那怎么判断 创建出来的是 \"直接子节点\" 呢？ 答案是render 第3个参数 comp为null的， 很好理解， comp的意思是 \"谁渲染了我\" 很明显， 只有 dom下的 \"直接子节点\" comp才是null， 其他的情况， comp肯定不是null， 比如 Son的comp是Father， Gsss1 的comp是Grandsonson1。。。 并且当setState重新渲染的时候， 如果老的dom／inst没有被复用， 则应该用新的dom／inst 替换 创建dom的时候。 ```javascript 1.7 function createNewDom(vnode, parent, comp, olddomOrComp, myIndex) { ... if (comp) { comp.__rendered = dom } else { parent.__rendered[myIndex] = dom } ... } ``` 组件实例 ```javascript 1.7 else if (typeof vnode.nodeName == \"function\") { ... if(olddomOrComp && olddomOrComp instanceof func) { inst = olddomOrComp } else { inst = new func(vnode.props) if (comp) { comp.__rendered = inst } else { parent.__rendered[myIndex] = inst } } ... } ``` diffDOM 的时候： a. remove多余的节点； b. render子节点的时候olddomOrComp = olddom.rendered[i] ```javascript 1.7 function diffDOM(vnode, parent, comp, olddom) { ... olddom.rendered.slice(vnode.children.length) // .forEach(element => { olddom.removeChild(getDOM(element)) }) olddom.rendered = olddom.rendered.slice(0, vnode.children.length) for(let i = 0; i render(vnode.children[i], olddom, null, olddom.__rendered[i], i) } olddom.__vnode = vnode } ``` 所以完整的代码： ```jsx harmony function render(vnode, parent, comp, olddomOrComp, myIndex) { let dom if(typeof vnode === \"string\" || typeof vnode === \"number\" ) { if(olddomOrComp && olddomOrComp.splitText) { if(olddomOrComp.nodeValue !== vnode) { olddomOrComp.nodeValue = vnode } } else { dom = document.createTextNode(vnode) parent.__rendered[myIndex] = dom //comp 一定是null setNewDom(parent, dom, myIndex) } } else if(typeof vnode.nodeName === \"string\") { if(!olddomOrComp || olddomOrComp.nodeName !== vnode.nodeName.toUpperCase()) { createNewDom(vnode, parent, comp, olddomOrComp, myIndex) } else { diffDOM(vnode, parent, comp, olddomOrComp) } } else if (typeof vnode.nodeName === \"function\") { let func = vnode.nodeName let inst if(olddomOrComp && olddomOrComp instanceof func) { inst = olddomOrComp inst.props = vnode.props } else { inst = new func(vnode.props) if (comp) { comp.__rendered = inst } else { parent.__rendered[myIndex] = inst } } let innerVnode = inst.render() render(innerVnode, parent, inst, inst.__rendered, myIndex) } } function createNewDom(vnode, parent, comp, olddomOrComp, myIndex) { let dom = document.createElement(vnode.nodeName) dom.__rendered = [] // 创建dom的 设置 __rendered 引用 dom.__vnode = vnode if (comp) { comp.__rendered = dom } else { parent.__rendered[myIndex] = dom } setAttrs(dom, vnode.props) setNewDom(parent, dom, myIndex) for(let i = 0; i } function diffDOM(vnode, parent, comp, olddom) { const {onlyInLeft, bothIn, onlyInRight} = diffObject(vnode.props, olddom.__vnode.props) setAttrs(olddom, onlyInLeft) removeAttrs(olddom, onlyInRight) diffAttrs(olddom, bothIn.left, bothIn.right) olddom.__rendered.slice(vnode.children.length) .forEach(element => { olddom.removeChild(getDOM(element)) }) const __renderedArr = olddom.__rendered.slice(0, vnode.children.length) olddom.__rendered = __renderedArr for(let i = 0; i } class Component { constructor(props) { this.props = props } setState(state) { setTimeout(() => { this.state = state const vnode = this.render() let olddom = getDOM(this) const myIndex = getDOMIndex(olddom) render(vnode, olddom.parentNode, this, this.__rendered, myIndex) }, 0) } } function getDOMIndex(dom) { const cn = dom.parentNode.childNodes for(let i= 0; i 现在 __rendered链 完善了， setState触发的渲染, 都会先去尝试复用 组件实例。 ### 生命周期 前面讨论的__rendered 和生命周期有 什么关系呢？ 生命周期是组件实例的生命周期， 之前的工作起码保证了一点: constructor 只会被调用一次了吧。。。 后面讨论的生命周期 都是基于 \"组件实例\"的 复用才有意义。tinyreact 将实现以下的生命周期： 1. componentWillMount 2. componentDidMount 3. componentWillReceiveProps 4. shouldComponentUpdate 5. componentWillUpdate 6. componentDidUpdate 7. componentWillUnmount 他们 和 react同名函数 含义相同 #### componentWillMount, componentDidMount, componentDidUpdate 这三个生命周期 是如此之简单： componentWillMount紧接着 创建实例的时候调用； 渲染完成之后，如果 组件是新建的componentDidMount ， 否则：componentDidUpdate ```jsx harmony else if (typeof vnode.nodeName === \"function\") { let func = vnode.nodeName let inst if(olddomOrComp && olddomOrComp instanceof func) { inst = olddomOrComp inst.props = vnode.props } else { inst = new func(vnode.props) inst.componentWillMount && inst.componentWillMount() if (comp) { comp.__rendered = inst } else { parent.__rendered[myIndex] = inst } } let innerVnode = inst.render() render(innerVnode, parent, inst, inst.__rendered, myIndex) if(olddomOrComp && olddomOrComp instanceof func) { inst.componentDidUpdate && inst.componentDidUpdate() } else { inst.componentDidMount && inst.componentDidMount() } } componentWillReceiveProps， shouldComponentUpdate， componentWillUpdate 当组件 获取新的props的时候， 会调用componentWillReceiveProps， 参数为newProps， 并且在这个方法内部this.props 还是值向oldProps, 由于 props的改变 由 只能由 父组件 触发。 所以只用在 render函数里面处理就ok。不过 要在 inst.props = vnode.props 之前调用componentWillReceiveProps: ```jsx harmony else if (typeof vnode.nodeName === \"function\") { let func = vnode.nodeName let inst if(olddomOrComp && olddomOrComp instanceof func) { inst = olddomOrComp inst.componentWillReceiveProps && inst.componentWillReceiveProps(vnode.props) // inst.props = vnode.props } else { ... } } 当 组件的 props或者state发生改变的时候，组件一定会渲染吗？shouldComponentUpdate说了算！！ 如果组件没有shouldComponentUpdate这个方法， 默认是渲染的。 否则是基于 shouldComponentUpdate的返回值。 这个方法接受两个参数 newProps, newState 。 另外由于 props和 state(setState) 改变都会引起 shouldComponentUpdate调用， 所以: ```jsx harmony function render(vnode, parent, comp, olddomOrComp, myIndex) { ... else if (typeof vnode.nodeName === \"function\") { let func = vnode.nodeName let inst if(olddomOrComp && olddomOrComp instanceof func) { inst = olddomOrComp inst.componentWillReceiveProps && inst.componentWillReceiveProps(vnode.props) // { let shoudUpdate if(this.shouldComponentUpdate) { shoudUpdate = this.shouldComponentUpdate(this.props, state) } else { shoudUpdate = true } this.state = state if (!shoudUpdate) { // 当 shoudUpdate 为false的时候呢， 直接return 就ok了， 但是shoudUpdate 为false 只是表明 不渲染， 但是在 return之前， newProps和newState一定要设置到组件实例上。 注 setState render之后 也是需要调用： componentDidUpdate 当 shoudUpdate == true 的时候。 会调用： componentWillUpdate， 参数为newProps和newState。 这个函数调用之后，就会把nextProps和nextState分别设置到this.props和this.state中。 ```jsx harmony function render(vnode, parent, comp, olddomOrComp, myIndex) { ... else if (typeof vnode.nodeName === \"function\") { ... let shoudUpdate if(inst.shouldComponentUpdate) { shoudUpdate = inst.shouldComponentUpdate(vnode.props, olddomOrComp.state) // inst.props = vnode.props if (!shoudUpdate) { // ... } setState(state) { setTimeout(() => { ... shoudUpdate && this.componentWillUpdate && this.componentWillUpdate(this.props, state) // #### componentWillUnmount 当组件要被销毁的时候， 调用组件的componentWillUnmount。 inst没有被复用的时候， 要销毁。 dom没有被复用的时候， 也要销毁， 而且是树形结构 的递归操作。 有点像 render的递归， 直接看代码： ```jsx harmony function recoveryComp(comp) { if (comp instanceof Component) { // { recoveryComp(element) }) } else { // recoveryComp 是这样的一个 递归函数： 当domOrComp 为组件实例的时候， 首先调用：componentWillUnmount， 然后 recoveryDomOrComp(inst.__rendered) 。 这里的先后顺序关系很重要 当domOrComp 为DOM节点 （非文本 TextNode）, 遍历 recoveryDomOrComp(子节点) 当domOrComp 为TextNode，nothing... 与render一样， 由于组件 最终一定会render html的标签。 所以这个递归一定是能够正常返回的。 哪些地方需要调用recoveryComp ？ 所有olddomOrComp 没有被复用的地方。 因为一旦olddomOrComp 不被复用， 一定有一个新的取得它， 它就要被销毁 多余的 子节点。 div 起初有3个子节点， setState之后变成了2个。 多出来的要被销毁 ```jsx harmony function diffDOM(vnode, parent, comp, olddom) { const {onlyInLeft, bothIn, onlyInRight} = diffObject(vnode.props, olddom.__vnode.props) setAttrs(olddom, onlyInLeft) removeAttrs(olddom, onlyInRight) diffAttrs(olddom, bothIn.left, bothIn.right) const willRemoveArr = olddom.__rendered.slice(vnode.children.length) const renderedArr = olddom.__rendered.slice(0, vnode.children.length) olddom.__rendered = renderedArr for(let i = 0; i { recoveryComp(element) olddom.removeChild(getDOM(element)) }) olddom.__vnode = vnode } 到这里， tinyreact 就有 生命周期了 之前的代码 由于会用到 dom.__rendered。 所以： ```jsx harmony const root = document.getElementById(\"root\") root.__rendered = [] render(, root) 为了不要在 调用render之前 设置：__rendered 做个小的改动 ： ```jsx harmony /** 渲染vnode成实际的dom @param vnode 虚拟dom表示 @param parent 实际渲染出来的dom，挂载的父元素 */ export default function render(vnode, parent) { parent.rendered =[] //rendered renderInner(vnode, parent, null, null, 0) } function renderInner(vnode, parent, comp, olddomOrComp, myIndex) { ... } ### 其他 tinyreact 未实现功能： 1. context 2. 事件代理 3. 多吃调用setState， 只render一次 4. react 顶层Api 5. 。。。 tinyreat 有些地方参考了[preact](https://github.com/developit/preact) npm包: npm install tinyreact --save ``` "},"React/源码分析/实现自己的react之简单rendering.html":{"url":"React/源码分析/实现自己的react之简单rendering.html","title":"实现自己的react之简单rendering","keywords":"","body":"实现自己的react之简单rendering 实现自己的react之简单rendering 元素和组件 原生DOM元素 虚拟元素 组件 自定义组件 React是声明式的 Feact的实现 模仿React来创建Feact应用 Feact中createElement的实现 Feact中Render的实现 创建自定义组件 重新实现render方法 改进复合组件 再次完善Feact.render方法 在这里我们将会从0到1来实现我们自己到react。这样我们可以更好的了解react是如何工作的，为什么存在这么多生命周期的方法以及每个方法在什么时候调用。 需要提出来的是，我们的实现是基于React 15.3，虽然React 16中存在很大的变动，但是我认为去了解这些依然是有用的。 元素和组件 在React中存在三种不同类型的对象： 原生DOM元素、 虚拟元素 组件。 原生DOM元素 原生DOM元素实际上是浏览器用来构建网页的元素。有时React也会对原生DOM元素进行操作。比如调用document.createElement()来创建原生DOM元素，调用element.insertBefore(), element.nodeValue来更新DOM元素。 虚拟元素 虚拟元素是React中非常核心概念。该类元素的思想是，将特定的DOM元素或者DOM树存储在内存中，在需要渲染的时候交由渲染方法进行渲染。虚拟元素既可以是h1和div这样的DOM元素，又可以用户自定义的组件。虚拟元素存在使得DOM元素的更新比直接操作原生DOM原生成本要低许多。 组件 组件是React中另一个核心的概念，而且不同的组件在React中可以做不同的事情。比如ReactDOMComponent主要作为React元素和原生DOM元素沟通的桥梁 自定义组件 当我们调用React.createClass或者使用es6语法继承React.Component时，我们都会创建出一个组件类。该组件类提供了比如componentWillMount和shouldComponentUpdate生命周期的方法，通常我们都会实现这些方法来做我们想做的事情。实际上，在React生命周期中还存在比如mountComponent和receiveComponent这样的方法，这些方法只在react内部来使用，所以我们不会实现这些方法，甚至不知道这些方法的存在。 React是声明式的 在使用React的时候，我们只是对组件类进行了定义，并没有对其进行初始化。组件类的初始化工作是React来完成的。或许你也会发现对于DOM元素我们也没有对其进行初始化，但是我们却隐式对其进行了初始化。比如使用JSX定义组件： class MyComponent extends React.Component { render() { return hello; } } 上述JSX代码会被编译成： class MyComponent extends React.Component { render() { return React.createElement('div', null, 'hello'); } } 通过上述代码可以发现，React.createElement方法会被执行来创建DOM元素。换句话说，我们不会创建DOM元素，是React在初始化组件的时候调用render()来创建DOM元素。因此我们可以说React是声明式的，我们描述我们想要什么，然后React来对其进行实现。 Feact的实现 模仿React来创建Feact应用 首先模仿React来创建Feact应用： Feact.render(hello world, document.getElementById('root')); 我们认为上述的JSX代码编译之后可以得到如下的代码： Feact.render( Feact.createElement('h1', null, 'hello world'), document.getElementById('root') ); 由于JSX是一个很大的话题，所以我们对针对编译之后的代码来实现Feact。 Feact中createElement的实现 const Feact = { createElement(type, props, children) { const element = { type, props: props || {} }; if (children) { element.props.children = children; } return element; } }; element只是一个简单对象，由于描述我们希望如何渲染。 Feact中Render的实现 Feact的Render方法中传递是我们想要的渲染的东西，而且也是应用的起点。在这里，我们先讲render方法定义如下： const Feact = { createElement() { /* 如上*/ }, render(element, container) { const componentInstance = new FeactDOMComponent(element); return componentInstance.mountComponent(container); } }; 当render方法执行完毕，在网页上就可以看到我们想要渲染的东西来。由此可以得出FeactDOMComponent才是DOM元素的实际创建者。FeactDOMComponent的实现如下： class FeactDOMComponent { constructor(element) { this._currentElement = element; } mountComponent(container) { const domElement = document.createElement(this._currentElement.type); const text = this._currentElement.props.children; const textNode = document.createTextNode(text); domElement.appendChild(textNode); container.appendChild(domElement); this._hostNode = domElement; return domElement; } } PS：在mountComponent方法中我们将DOM元素保存在this._hostNode中。在后续的工作中会使用到。 通过上述的代码我们已经实现了一个非常简单的Feact，当然它的功能还是非常受限的。下面我们来自定义组件。 创建自定义组件 显然，我们不希望我们的Feact只能渲染一个写死的DOM元素，下面就让我们的Feact支持自定义组件。 const Feact = { createClass(spec) { function Constructor(props) { this.props = props; } Constructor.prototype.render = spec.render; return Constructor; }, render(element, container) { // 我们上述实现的render方法是不能处理自定义组件的， // 所以我们需要对其重新实现 } }; const MyTitle = Feact.createClass({ render() { return Feact.createElement('h1', null, this.props.message); } }; Feact.render({ Feact.createElement(MyTitle, { message: 'hey there Feact' }), document.getElementById('root') ); 由于我们不考虑使用JSX，所以上述代码看起来比较繁琐。如果我们使用JSX的话，上述代码会变成： Feact.render( , document.getElementById('root') ); 在createElement方法我们既可以传递所要渲染的组件，也可以传递原生DOM元素。如果元素的type是一个字符串，则该元素为原生DOM元素，如果type是一个方法，则该元素为用户自定义的组件。 重新实现render方法 我们一开始实现的render方法是不支持渲染自定义组件的，对其进行改变为： Feact = { render(element, container) { const componentInstance = new FeactCompositeComponentWrapper(element); return componentInstance.mountComponent(container); } } class FeactCompositeComponentWrapper { constructor(element) { this._currentElement = element; } mountComponent(container) { const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); const element = componentInstance.render(); const domComponentInstance = new FeactDOMComponent(element); return domComponentInstance.mountComponent(container); } } 虽然上述的实现还存在改进的地方，但是通过上述代码我们可以发现componentInstance.render()方法在哪里进行调用。为了能够将组件元素渲染在页面中，我们将起传递到FeactDOMComponent中。 改进复合组件 目前我们的组件只能返回原生DOM节点，并不能返回其他的自定义组件。我们希望组件可以返回组件，比如： const MyMessage = Feact.createClass({ render() { if (this.props.asTitle) { return Feact.createElement(MyTitle, { message: this.props.message }); } else { return Feact.createElement('p', null, this.props.message); } } } 这个组件既可以返回原生DOM元素，又可以返回自定义组件。目前的Feact是不能处理这种场景的。当asTitle为true时，FeactCompositeComponentWrapper将会传递给FeactDOMComponent非原生DOM元素。这时FeactDOMComponent就会出问题了。我们对FeactCompositeComponentWrapper进行改进： class FeactCompositeComponentWrapper { constructor(element) { this._currentElement = element; } mountComponent(container) { const Component = this._currentElement.type; const componentInstance = new Component(this._currentElement.props); let element = componentInstance.render(); while (typeof element.type === 'function') { element = (new element.type(element.props)).render(); } const domComponentInstance = new FeactDOMComponent(element); domComponentInstance.mountComponent(container); } } PS：上述改进的方式仅仅是为了满足我们目前的需求。当元素为组件的时候我们会循环调用组件的渲染方法，这种方式会让所有子组件参与进来。如果组件都存在componentWillMount的方法时，这种方式会使得子组件componentWillMount的调用很难处理了。在后续工作中会对其进行修复。 再次完善Feact.render方法 在开始的render方法中只能处理原生DOM元素，现在的render方法只能处理组件元素。我们希望render方法既可以处理原生元素，又可以处理组件。当然我们可以创建一个工厂方法，基于元素的类型返回不同的组件，但是React采用的是另外一种方式。由于FeactCompositeComponentWrapper组件最终生成的是一个FeactDOMComponent，所以我们可以将任意元素使用FeactCompositeComponentWrapper进行包装： const TopLevelWrapper = function(props) { this.props = props; }; TopLevelWrapper.prototype.render = function() { return this.props; }; const Feact = { render(element, container) { const wrapperElement = this.createElement(TopLevelWrapper, element); const componentInstance = new FeactCompositeComponentWrapper(wrapperElement); // as before } }; ToplevelWrapper是一个简单的组件，它的render方法返回的是用户提供的元素，这样原生DOM元素也会被包装一下，所以我们无需去关心传递的是什么元素，都可以统一进行处理。 到这里一个简单的Feact已经实现了，当然在React中还有很多问题需要考虑。 代码链接 原文地址 "},"React/源码分析/Redux源码分析.html":{"url":"React/源码分析/Redux源码分析.html","title":"Redux源码分析","keywords":"","body":"Redux 源码分析 首先让我们来看下 combineReducers 函数 // 传入一个 object export default function combineReducers(reducers) { // 获取该 Object 的 key 值 const reducerKeys = Object.keys(reducers) // 过滤后的 reducers const finalReducers = {} // 获取每一个 key 对应的 value // 在开发环境下判断值是否为 undefined // 然后将值类型是函数的值放入 finalReducers for (let i = 0; i combineReducers 函数总的来说很简单，总结来说就是接收一个对象，将参数过滤后返回一个函数。该函数里有一个过滤参数后的对象 finalReducers，遍历该对象，然后执行对象中的每一个 reducer 函数，最后将新的 state 返回。 接下来让我们来看看 combinrReducers 中用到的两个函数 // 这是执行的第一个用于抛错的函数 function assertReducerShape(reducers) { // 将 combineReducers 中的参数遍历 Object.keys(reducers).forEach(key => { const reducer = reducers[key] // 给他传入一个 action const initialState = reducer(undefined, { type: ActionTypes.INIT }) // 如果得到的 state 为 undefined 就抛错 if (typeof initialState === 'undefined') { throw new Error( `Reducer \"${key}\" returned undefined during initialization. ` + `If the state passed to the reducer is undefined, you must ` + `explicitly return the initial state. The initial state may ` + `not be undefined. If you don't want to set a value for this reducer, ` + `you can use null instead of undefined.` ) } // 再过滤一次，考虑到万一你在 reducer 中给 ActionTypes.INIT 返回了值 // 传入一个随机的 action 判断值是否为 undefined const type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random() .toString(36) .substring(7) .split('') .join('.') if (typeof reducer(undefined, { type }) === 'undefined') { throw new Error( `Reducer \"${key}\" returned undefined when probed with a random type. ` + `Don't try to handle ${ ActionTypes.INIT } or other actions in \"redux/*\" ` + `namespace. They are considered private. Instead, you must return the ` + `current state for any unknown actions, unless it is undefined, ` + `in which case you must return the initial state, regardless of the ` + `action type. The initial state may not be undefined, but can be null.` ) } }) } function getUnexpectedStateShapeWarningMessage( inputState, reducers, action, unexpectedKeyCache ) { // 这里的 reducers 已经是 finalReducers const reducerKeys = Object.keys(reducers) const argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer' // 如果 finalReducers 为空 if (reducerKeys.length === 0) { return ( 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.' ) } // 如果你传入的 state 不是对象 if (!isPlainObject(inputState)) { return ( `The ${argumentName} has unexpected type of \"` + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + `\". Expected argument to be an object with the following ` + `keys: \"${reducerKeys.join('\", \"')}\"` ) } // 将参入的 state 于 finalReducers 下的 key 做比较，过滤出多余的 key const unexpectedKeys = Object.keys(inputState).filter( key => !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key] ) unexpectedKeys.forEach(key => { unexpectedKeyCache[key] = true }) if (action && action.type === ActionTypes.REPLACE) return // 如果 unexpectedKeys 有值的话 if (unexpectedKeys.length > 0) { return ( `Unexpected ${unexpectedKeys.length > 1 ? 'keys' : 'key'} ` + `\"${unexpectedKeys.join('\", \"')}\" found in ${argumentName}. ` + `Expected to find one of the known reducer keys instead: ` + `\"${reducerKeys.join('\", \"')}\". Unexpected keys will be ignored.` ) } } 接下来让我们先来看看 compose 函数 // 这个函数设计的很巧妙，通过传入函数引用的方式让我们完成多个函数的嵌套使用，术语叫做高阶函数 // 通过使用 reduce 函数做到从右至左调用函数 // 对于上面项目中的例子 compose( applyMiddleware(thunkMiddleware), window.devToolsExtension ? window.devToolsExtension() : f => f ) // 经过 compose 函数变成了 applyMiddleware(thunkMiddleware)(window.devToolsExtension()()) // 所以在找不到 window.devToolsExtension 时你应该返回一个函数 export default function compose(...funcs) { if (funcs.length === 0) { return arg => arg } if (funcs.length === 1) { return funcs[0] } return funcs.reduce((a, b) => (...args) => a(b(...args))) } 然后我们来解析 createStore 函数的部分代码 export default function createStore(reducer, preloadedState, enhancer) { // 一般 preloadedState 用的少，判断类型，如果第二个参数是函数且没有第三个参数，就调换位置 if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') { enhancer = preloadedState preloadedState = undefined } // 判断 enhancer 是否是函数 if (typeof enhancer !== 'undefined') { if (typeof enhancer !== 'function') { throw new Error('Expected the enhancer to be a function.') } // 类型没错的话，先执行 enhancer，然后再执行 createStore 函数 return enhancer(createStore)(reducer, preloadedState) } // 判断 reducer 是否是函数 if (typeof reducer !== 'function') { throw new Error('Expected the reducer to be a function.') } // 当前 reducer let currentReducer = reducer // 当前状态 let currentState = preloadedState // 当前监听函数数组 let currentListeners = [] // 这是一个很重要的设计，为的就是每次在遍历监听器的时候保证 currentListeners 数组不变 // 可以考虑下只存在 currentListeners 的情况，如果我在某个 subscribe 中再次执行 subscribe // 或者 unsubscribe，这样会导致当前的 currentListeners 数组大小发生改变，从而可能导致 // 索引出错 let nextListeners = currentListeners // reducer 是否正在执行 let isDispatching = false // 如果 currentListeners 和 nextListeners 相同，就赋值回去 function ensureCanMutateNextListeners() { if (nextListeners === currentListeners) { nextListeners = currentListeners.slice() } } // ...... } 接下来先来介绍 applyMiddleware 函数 在这之前我需要先来介绍一下函数柯里化，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。 function add(a,b) { return a + b } add(1, 2) => 3 // 对于以上函数如果使用柯里化可以这样改造 function add(a) { return b => { return a + b } } add(1)(2) => 3 // 你可以这样理解函数柯里化，通过闭包保存了外部的一个变量， // 然后返回一个接收参数的函数，在该函数中使用了保存的变量， // 然后再返回值。 // 这个函数应该是整个源码中最难理解的一块了 // 该函数返回一个柯里化的函数 // 所以调用这个函数应该这样写 applyMiddleware(...middlewares)(createStore)(...args) export default function applyMiddleware(...middlewares) { return createStore => (...args) => { // 这里执行 createStore 函数，把 applyMiddleware 函数最后次调用的参数传进来 const store = createStore(...args) let dispatch = () => { throw new Error( `Dispatching while constructing your middleware is not allowed. ` + `Other middleware would not be applied to this dispatch.` ) } let chain = [] // 每个中间件都应该有这两个函数 const middlewareAPI = { getState: store.getState, dispatch: (...args) => dispatch(...args) } // 把 middlewares 中的每个中间件都传入 middlewareAPI chain = middlewares.map(middleware => middleware(middlewareAPI)) // 和之前一样，从右至左调用每个中间件，然后传入 store.dispatch dispatch = compose(...chain)(store.dispatch) // 这里只看这部分代码有点抽象，我这里放入 redux-thunk 的代码来结合分析 // createThunkMiddleware返回了3层函数，第一层函数接收 middlewareAPI 参数 // 第二次函数接收 store.dispatch // 第三层函数接收 dispatch 中的参数 {function createThunkMiddleware(extraArgument) { return ({ dispatch, getState }) => next => action => { // 判断 dispatch 中的参数是否为函数 if (typeof action === 'function') { // 是函数的话再把这些参数传进去，直到 action 不为函数，执行 dispatch({tyep: 'XXX'}) return action(dispatch, getState, extraArgument); } return next(action); }; } const thunk = createThunkMiddleware(); export default thunk;} // 最后把经过中间件加强后的 dispatch 于剩余 store 中的属性返回，这样你的 dispatch return { ...store, dispatch } } } 好了，我们现在将困难的部分都攻克了，来看一些简单的代码 // 这个没啥好说的，就是把当前的 state 返回，但是当正在执行 reducer 时不能执行该方法 function getState() { if (isDispatching) { throw new Error( 'You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.' ) } return currentState } // 接收一个函数参数 function subscribe(listener) { if (typeof listener !== 'function') { throw new Error('Expected listener to be a function.') } // 这部分最主要的设计 nextListeners 已经讲过，其他基本没什么好说的 if (isDispatching) { throw new Error( 'You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See http://redux.js.org/docs/api/Store.html##subscribe for more details.' ) } let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) // 返回一个取消订阅函数 return function unsubscribe() { if (!isSubscribed) { return } if (isDispatching) { throw new Error( 'You may not unsubscribe from a store listener while the reducer is executing. ' + 'See http://redux.js.org/docs/api/Store.html##subscribe for more details.' ) } isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) } } function dispatch(action) { // 原生的 dispatch 会判断 action 是否为对象 if (!isPlainObject(action)) { throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) } if (typeof action.type === 'undefined') { throw new Error( 'Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?' ) } // 注意在 Reducers 中是不能执行 dispatch 函数的 // 因为你一旦在 reducer 函数中执行 dispatch，会引发死循环 if (isDispatching) { throw new Error('Reducers may not dispatch actions.') } // 执行 combineReducers 组合后的函数 try { isDispatching = true currentState = currentReducer(currentState, action) } finally { isDispatching = false } // 然后遍历 currentListeners，执行数组中保存的函数 const listeners = (currentListeners = nextListeners) for (let i = 0; i "},"React/源码分析/React-redux源码分析.html":{"url":"React/源码分析/React-redux源码分析.html","title":"React-redux源码分析","keywords":"","body":"react-redux 源码分析 react-redux 源码分析 开始 react-redux API Provider 一个简单的 Connect Connect 的优化 开始 Redux 本身是一个 standalone library，不依托于任何框架，但是由于 React 本身是一个函数式的视图框架，它的理念是 f(state) => view，所以 Redux 大多配合 React 一起使用。这二者的结合点就是 react-redux 这个库。 为了能最直观的体会这个库的思想，我们不看最近的 release，而是选择 16 年 2 月 V4.2.0这个版本进行分析。 react-redux API ，使每个 react 组件都能拿到 store connect 函数，使一个 react 组件变成 container component Provider Provider 本身是一个 react 组件，这一点首先要搞清楚。它的实现原理非常简单，利用了 React 的 context 这一特性。文档 Context - React。 只要在最外层的组件实现一个 getChildContext 这个方法，返回一个对象，内部的组件都可以通过 this.context 拿到这个对象。所以一个简单的 Provider 实现是这样的： class Provider extends React.Component { getChildContext() { return { store: this.props.store } } render() { return this.props.children } } // usage const store = createStore(); ReactDOM.render( , document.querySelector('#root')); 现在，App 下所有的组件都能通过 this.context.store 拿到 store 了 必须要说明的是 context 不建议作为日常开发使用，官方文档的第一段也是“Why Not to Use Context”。首先，这是一个实验性的 API，之后不一定有什么变化。其次，它破坏了 react 的单向数据流。如果你不是一个很有经验的 react 开发者，或者库、框架作者，请尽量不要用 context 这个特性 一个简单的 Connect 我们先看一下 connect 一般情况下是怎么使用的。 export default connect(mapStateToProps, mapDispatchToProps)(MyComponent) 首先，export 出去的是一个增强过的 react 组件，也就是说 connect(mapStateToProps, mapDispatchToProps) 第一步首先返回了一个 HOC Component。 HOC（High Order Component）？一个函数，接受一个 React 组件，并返回一个增强的 React 组件，这个函数就叫做 HOC Component。 我们注意到 connect()() 之后一共有两次执行，那么 connect 第二步具体做了什么呢？通过之前阅读 API 文档我们知道，被这样包裹了一层之后，相应的组件变成了 Container / Smart Component，可以通过 this.props 来获取 store 里的 state，以及 dispatch 这个方法。 这样一来，store.state 的更新也就触发了 this.props 的更新，继而触发了容器组件的 re-render。 所以，connect 第二步就是把 mapStateToProps 和 mapDispatchToProps 里的返回的属性，以及本身的 props 一起，作为 props 传递给了被包裹的组件。 明确了这一点后，只剩下一个问题了：connect 是怎么做到监听 store 变化的呢？答案是用到了 Redux store 的 subscribe 这个 API。下面我们来实现一个简单的 connect： function connect(mapStateToProps, mapDispatchToProps) { return function createHOC(WrappedComponent) { class Connect extends React.Component { constructor(props, context) { this.store = context.store // 提供 } componentDidMount() { this.unsubscribe = this.store.subscribe(this.handleChange.bind(this)) } componentWillUnmount() { this.unsubscribe() } handleChange() { this.forceUpdate() } render() { return ( ) } } Connect.displayName = `Connect(${WrappedComponent.name || WrappedComponent.displayName})` return Connect } } Connect 的优化 如果你能理解到这里，那么你已经了解了 react-redux 这个库的核心思想。但是你应该也注意到了以上代码的最大的一个缺点：那就是只要 store 一变化，组件就会 forceUpdate，即使更新的状态并没有被该组件用到。 剩下的工作就是优化。优化的方向主要有以下几个： 通过 mapStateToProps 和 mapDispatchToProps 计算出组件自己需要的 props。每当 store 变化时，首先计算出这部分 props 有没有变动，仅当这部分变动的时候才重新渲染组件。 缓存上次渲染的组件。这样当第一步计算后的结果不需要重新绘制时，可以直接返回上次缓存的组件。 注意 connect 还有第三个参数 mergeProps，用来将 mapStateToProps 和 mapDispatchToProps 计算出的 props 合并成一个 object。这一点在实现的时候也要一起考虑进去。 mapStateToProps 和 mapDispatchToProps 都可以接受 ownProps 这个参数，所以在源码中我们看到 doStatePropsDependOnOwnProps 和 doDispatchPropsDependOnOwnProps 这两个属性。 我们分别对应来看 react-redux 是怎么解决这几个性能问题的。 对于第一个问题，在 subscribe 后，我们首先计算 store 本身的 state 是不是改变了。 handleChange() { const prevStoreState = this.state.storeState const storeState = this.store.getState() // 这里用 reference check 做初步检查，因为可能有的 action 没有被处理 // 导致 subscribe 触发，而 store 本身没有改变引用 if (prevStoreState !== storeState) { this.hasStoreStateChanged = true this.setState({ storeState }) // 触发 render } } 通过 compute 函数来计算 组件自身从 store 需要的属性： const doStatePropsDependOnOwnProps = finalMapStateToProps.length !== 1 const doDispatchPropsDependOnOwnProps = finalMapDispatchToProps.length !== 1 function computeStateProps(store, props) { const state = store.getState() const stateProps = doStatePropsDependOnOwnProps ? finalMapStateToProps(state, props) : finalMapStateToProps(state) return stateProps } function computeDispatchProps(store, props) { const { dispatch } = store const dispatchProps = doDispatchPropsDependOnOwnProps ? finalMapDispatchToProps(dispatch, props) : finalMapDispatchToProps(dispatch) return dispatchProps } function computeMergedProps(stateProps, dispatchProps, parentProps) { const mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps) return mergedProps } 通过 shallowEqual 对比之前缓存的组件 props 和新计算出的属性，来决定是否需要更新组件： updateStatePropsIfNeeded() { const nextStateProps = computeStateProps(this.store, this.props) if (this.stateProps && shallowEqual(nextStateProps, this.stateProps)) { return false } this.stateProps = nextStateProps // 缓存 return true } updateDispatchPropsIfNeeded() { const nextDispatchProps = computeDispatchProps(this.store, this.props) if (this.dispatchProps && shallowEqual(nextDispatchProps, this.dispatchProps)) { return false } this.dispatchProps = nextDispatchProps // 缓存 return true } updateMergedProps() { this.mergedProps = computeMergedProps( this.stateProps, this.dispatchProps, this.props ) } 最终在 render 函数中进行最终的判断（这里有一个问题需要澄清：为什么不把计算放在 shouldComponentUpdate 里面呢？因为 react 会 batch update，在这个函数里拿到的 props 并不能保证得到及时的更新）： render() { const { haveOwnPropsChanged, hasStoreStateChanged, renderedElement // 上次缓存的 render 结果 } = this // 清空 flags this.haveOwnPropsChanged = false this.hasStoreStateChanged = false // 假设要重新渲染 let shouldUpdateStateProps = true let shouldUpdateDispatchProps = true if (renderedElement) { shouldUpdateStateProps = hasStoreStateChanged || ( haveOwnPropsChanged && doStatePropsDependOnOwnProps ) shouldUpdateDispatchProps = haveOwnPropsChanged && doDispatchPropsDependOnOwnProps } let haveStatePropsChanged = false let haveDispatchPropsChanged = false if (shouldUpdateStateProps) { // 重新计算 StateProps haveStatePropsChanged = this.updateStatePropsIfNeeded() } if (shouldUpdateDispatchProps) { // 重新计算 DispatchProps haveDispatchPropsChanged = this.updateDispatchPropsIfNeeded() } let haveMergedPropsChanged = true if ( haveStatePropsChanged || haveDispatchPropsChanged || haveOwnPropsChanged ) { this.updateMergedProps() } else { haveMergedPropsChanged = false } if (!haveMergedPropsChanged && renderedElement) { return renderedElement } // 这里是一个 connect 额外的配置项，不怎么用到，可以要求 connect 的时候把 refs // 一起作为 props 传下去 if (withRef) { // 缓存渲染结果 this.renderedElement = createElement(WrappedComponent, { ...this.mergedProps, ref: 'wrappedInstance' }) } else { this.renderedElement = createElement(WrappedComponent, this.mergedProps ) } return this.renderedElement } 最后返回这个 HOC 组件： Connect.displayName = `Connect(${getDisplayName(WrappedComponent)})` // Copies non-react specific statics from WrappedComponent // to the Connect component return hoistStatics(Connect, WrappedComponent) 可以看到，大部分 if-else 都集中在 render 这个函数里。由于这里作为判断是否重绘的 flags 比较多，所以可能显得比较乱。每当你感觉乱的时候，一定不要忘了，这一切只是代替了以前的 forceUpdate，回头看一下我们之前的优化方向会很有帮助。 "},"React/源码分析/动手实现Redux.html":{"url":"React/源码分析/动手实现Redux.html","title":"动手实现 Redux","keywords":"","body":"动手实现Redux 动手实现Redux 动手实现 Redux（一）：优雅地修改共享状态 动手实现 Redux（二）：抽离 store 和监控数据变化 抽离出 store 监控数据变化 总结 动手实现 Redux（三）：纯函数（Pure Function）简介 函数的返回结果只依赖于它的参数 函数执行过程没有副作用 总结 动手实现 Redux（四）：共享结构的对象提高性能 共享结构的对象 优化性能 动手实现 Redux（五）：不要问为什么的 reducer reducer 动手实现 Redux（六）：Redux 总结 动手实现 Redux（一）：优雅地修改共享状态 让我们忘掉 React.js、Redux 这些词，从一个例子的代码 + 问题开始推演。 用 create-react-app 新建一个项目 make-redux，修改 public/index.html 里面的 body 结构为： 删除 src/index.js 里面所有的代码，添加下面代码，代表我们应用的状态： const appState = { title: { text: 'React.js 小书', color: 'red', }, content: { text: 'React.js 小书内容', color: 'blue' } } 我们新增几个渲染函数，它会把上面状态的数据渲染到页面上： function renderApp (appState) { renderTitle(appState.title) renderContent(appState.content) } function renderTitle (title) { const titleDOM = document.getElementById('title') titleDOM.innerHTML = title.text titleDOM.style.color = title.color } function renderContent (content) { const contentDOM = document.getElementById('content') contentDOM.innerHTML = content.text contentDOM.style.color = content.color } 很简单，renderApp 会调用 rendeTitle 和 renderContent，而这两者会把 appState 里面的数据通过原始的 DOM 操作更新到页面上，调用： renderApp(appState) 会在页面上看到： 这是一个很简单的 App，但是它存在一个重大的隐患，我们渲染数据的时候，使用的是一个共享状态 appState，每个人都可以修改它。如果我在渲染之前做了一系列其他操作： loadDataFromServer() doSomethingUnexpected() doSomthingMore() // ... renderApp(appState) renderApp(appState) 之前执行了一大堆函数操作，你根本不知道它们会对 appState 做什么事情，renderApp(appState) 的结果根本没法得到保障。一个可以被不同模块任意修改共享的数据状态就是魔鬼，一旦数据可以任意修改，所有对共享状态的操作都是不可预料的（某个模块 appState.title = null 你一点意见都没有），出现问题的时候 debug 起来就非常困难，这就是老生常谈的尽量避免全局变量。 你可能会说我去看一下它们函数的实现就知道了它们修改了什么，在我们这个例子里面还算比较简单，但是真实项目当中的函数调用和数据初始化操作非常复杂，深层次的函数调用修改了状态是很难调试的。 但不同的模块（组件）之间确实需要共享数据，这些模块（组件）还可能需要修改这些共享数据，就像上一节的“主题色”状态（themeColor）。这里的矛盾就是：“模块（组件）之间需要共享数据”，和“数据可能被任意修改导致不可预料的结果”之间的矛盾。 让我们来想办法解决这个问题，我们可以学习 React.js 团队的做法，把事情搞复杂一些，提高数据修改的门槛：模块（组件）之间可以共享数据，也可以改数据。但是我们约定，这个数据并不能直接改，你只能执行某些我允许的某些修改，而且你修改的必须大张旗鼓地告诉我。 我们定义一个函数，叫 dispatch，它专门负责数据的修改： function dispatch (action) { switch (action.type) { case 'UPDATE_TITLE_TEXT': appState.title.text = action.text break case 'UPDATE_TITLE_COLOR': appState.title.color = action.color break default: break } } 所有对数据的操作必须通过 dispatch 函数。它接受一个参数 action，这个 action 是一个普通的 JavaScript 对象，里面必须包含一个 type 字段来声明你到底想干什么。dispatch 在 swtich 里面会识别这个 type 字段，能够识别出来的操作才会执行对 appState 的修改。 上面的 dispatch 它只能识别两种操作，一种是 UPDATE_TITLE_TEXT 它会用 action 的 text 字段去更新 appState.title.text；一种是 UPDATE_TITLE_COLOR，它会用 action 的 color 字段去更新 appState.title.color。可以看到，action 里面除了 type 字段是必须的以外，其他字段都是可以自定义的。 任何的模块如果想要修改 appState.title.text，必须大张旗鼓地调用 dispatch： dispatch({ type: 'UPDATE_TITLE_TEXT', text: '《React.js 小书》' }) // 修改标题文本 dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'blue' }) // 修改标题颜色 我们来看看有什么好处： loadDataFromServer() // => 里面可能通过 dispatch 修改标题文本 doSomethingUnexpected() doSomthingMore() // => 里面可能通过 dispatch 修改标题颜色 // ... renderApp(appState) 我们不需要担心 renderApp(appState) 之前的那堆函数操作会干什么奇奇怪怪得事情，因为我们规定不能直接修改 appState，它们对 appState 的修改必须只能通过 dispatch。而我们看看 dispatch 的实现可以知道，你只能修改 title.text 和 title.color。 如果某个函数修改了 title.text 但是我并不想要它这么干，我需要 debug 出来是哪个函数修改了，我只需要在 dispatch的 switch 的第一个 case 内部打个断点就可以调试出来了。 原来模块（组件）修改共享数据是直接改的： 我们很难把控每一根指向 appState 的箭头，appState 里面的东西就无法把控。但现在我们必须通过一个“中间人” —— dispatch，所有的数据修改必须通过它，并且你必须用 action 来大声告诉它要修改什么，只有它允许的才能修改： 我们再也不用担心共享数据状态的修改的问题，我们只要把控了 dispatch，所有的对 appState 的修改就无所遁形，毕竟只有一根箭头指向 appState 了。 本节完整的代码如下： let appState = { title: { text: 'React.js 小书', color: 'red', }, content: { text: 'React.js 小书内容', color: 'blue' } } function dispatch (action) { switch (action.type) { case 'UPDATE_TITLE_TEXT': appState.title.text = action.text break case 'UPDATE_TITLE_COLOR': appState.title.color = action.color break default: break } } function renderApp (appState) { renderTitle(appState.title) renderContent(appState.content) } function renderTitle (title) { const titleDOM = document.getElementById('title') titleDOM.innerHTML = title.text titleDOM.style.color = title.color } function renderContent (content) { const contentDOM = document.getElementById('content') contentDOM.innerHTML = content.text contentDOM.style.color = content.color } renderApp(appState) // 首次渲染页面 dispatch({ type: 'UPDATE_TITLE_TEXT', text: '《React.js 小书》' }) // 修改标题文本 dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'blue' }) // 修改标题颜色 renderApp(appState) // 把新的数据渲染到页面上 下一节我们会把这种 dispatch 的模式抽离出来，让它变得更加通用。 动手实现 Redux（二）：抽离 store 和监控数据变化 抽离出 store 上一节 的我们有了 appState 和 dispatch： let appState = { title: { text: 'React.js 小书', color: 'red', }, content: { text: 'React.js 小书内容', color: 'blue' } } function dispatch (action) { switch (action.type) { case 'UPDATE_TITLE_TEXT': appState.title.text = action.text break case 'UPDATE_TITLE_COLOR': appState.title.color = action.color break default: break } } 现在我们把它们集中到一个地方，给这个地方起个名字叫做 store，然后构建一个函数 createStore，用来专门生产这种 state 和 dispatch 的集合，这样别的 App 也可以用这种模式了： function createStore (state, stateChanger) { const getState = () => state const dispatch = (action) => stateChanger(state, action) return { getState, dispatch } } createStore 接受两个参数，一个是表示应用程序状态的 state；另外一个是 stateChanger，它来描述应用程序状态会根据 action 发生什么变化，其实就是相当于本节开头的 dispatch 代码里面的内容。 createStore 会返回一个对象，这个对象包含两个方法 getState 和 dispatch。getState 用于获取 state 数据，其实就是简单地把 state 参数返回。 dispatch 用于修改数据，和以前一样会接受 action，然后它会把 state 和 action 一并传给 stateChanger，那么 stateChanger 就可以根据 action 来修改 state 了。 现在有了 createStore，我们可以这么修改原来的代码，保留原来所有的渲染函数不变，修改数据生成的方式： let appState = { title: { text: 'React.js 小书', color: 'red', }, content: { text: 'React.js 小书内容', color: 'blue' } } function stateChanger (state, action) { switch (action.type) { case 'UPDATE_TITLE_TEXT': state.title.text = action.text break case 'UPDATE_TITLE_COLOR': state.title.color = action.color break default: break } } const store = createStore(appState, stateChanger) renderApp(store.getState()) // 首次渲染页面 store.dispatch({ type: 'UPDATE_TITLE_TEXT', text: '《React.js 小书》' }) // 修改标题文本 store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'blue' }) // 修改标题颜色 renderApp(store.getState()) // 把新的数据渲染到页面上 针对每个不同的 App，我们可以给 createStore 传入初始的数据 appState，和一个描述数据变化的函数 stateChanger，然后生成一个 store。需要修改数据的时候通过 store.dispatch，需要获取数据的时候通过 store.getState。 监控数据变化 上面的代码有一个问题，我们每次通过 dispatch 修改数据的时候，其实只是数据发生了变化，如果我们不手动调用 renderApp，页面上的内容是不会发生变化的。但是我们总不能每次 dispatch 的时候都手动调用一下 renderApp，我们肯定希望数据变化的时候程序能够智能一点地自动重新渲染数据，而不是手动调用。 你说这好办，往 dispatch里面加 renderApp 就好了，但是这样 createStore 就不够通用了。我们希望用一种通用的方式“监听”数据变化，然后重新渲染页面，这里要用到观察者模式。修改 createStore： function createStore (state, stateChanger) { const listeners = [] const subscribe = (listener) => listeners.push(listener) const getState = () => state const dispatch = (action) => { stateChanger(state, action) listeners.forEach((listener) => listener()) } return { getState, dispatch, subscribe } } 我们在 createStore 里面定义了一个数组 listeners，还有一个新的方法 subscribe，可以通过 store.subscribe(listener) 的方式给 subscribe 传入一个监听函数，这个函数会被 push 到数组当中。 我们修改了 dispatch，每次当它被调用的时候，除了会调用 stateChanger 进行数据的修改，还会遍历 listeners 数组里面的函数，然后一个个地去调用。相当于我们可以通过 subscribe 传入数据变化的监听函数，每当 dispatch 的时候，监听函数就会被调用，这样我们就可以在每当数据变化时候进行重新渲染： const store = createStore(appState, stateChanger) store.subscribe(() => renderApp(store.getState())) renderApp(store.getState()) // 首次渲染页面 store.dispatch({ type: 'UPDATE_TITLE_TEXT', text: '《React.js 小书》' }) // 修改标题文本 store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'blue' }) // 修改标题颜色 // ...后面不管如何 store.dispatch，都不需要重新调用 renderApp 对观察者模式不熟悉的朋友可能会在这里晕头转向，建议了解一下这个设计模式的相关资料，然后进行练习： 实现一个 EventEmitter 再进行阅读。 我们只需要 subscribe 一次，后面不管如何 dispatch 进行修改数据，renderApp 函数都会被重新调用，页面就会被重新渲染。这样的订阅模式还有好处就是，以后我们还可以拿同一块数据来渲染别的页面，这时 dispatch 导致的变化也会让每个页面都重新渲染： const store = createStore(appState, stateChanger) store.subscribe(() => renderApp(store.getState())) store.subscribe(() => renderApp2(store.getState())) store.subscribe(() => renderApp3(store.getState())) ... 本节的完整代码： function createStore (state, stateChanger) { const listeners = [] const subscribe = (listener) => listeners.push(listener) const getState = () => state const dispatch = (action) => { stateChanger(state, action) listeners.forEach((listener) => listener()) } return { getState, dispatch, subscribe } } function renderApp (appState) { renderTitle(appState.title) renderContent(appState.content) } function renderTitle (title) { const titleDOM = document.getElementById('title') titleDOM.innerHTML = title.text titleDOM.style.color = title.color } function renderContent (content) { const contentDOM = document.getElementById('content') contentDOM.innerHTML = content.text contentDOM.style.color = content.color } let appState = { title: { text: 'React.js 小书', color: 'red', }, content: { text: 'React.js 小书内容', color: 'blue' } } function stateChanger (state, action) { switch (action.type) { case 'UPDATE_TITLE_TEXT': state.title.text = action.text break case 'UPDATE_TITLE_COLOR': state.title.color = action.color break default: break } } const store = createStore(appState, stateChanger) store.subscribe(() => renderApp(store.getState())) // 监听数据变化 renderApp(store.getState()) // 首次渲染页面 store.dispatch({ type: 'UPDATE_TITLE_TEXT', text: '《React.js 小书》' }) // 修改标题文本 store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'blue' }) // 修改标题颜色 总结 现在我们有了一个比较通用的 createStore，它可以产生一种我们新定义的数据类型 store，通过 store.getState 我们获取共享状态，而且我们约定只能通过 store.dispatch 修改共享状态。store 也允许我们通过 store.subscribe 监听数据数据状态被修改了，并且进行后续的例如重新渲染页面的操作。 动手实现 Redux（三）：纯函数（Pure Function）简介 我们接下来会继续优化我们的 createStore 的模式，让它使我们的应用程序获得更好的性能。 但在开始之前，我们先用一节的课程来介绍一下一个函数式编程里面非常重要的概念 —— 纯函数（Pure Function）。 简单来说，一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。这么说肯定比较抽象，我们把它掰开来看： 函数的返回结果只依赖于它的参数。 函数执行过程里面没有副作用。 函数的返回结果只依赖于它的参数 const a = 1 const foo = (b) => a + b foo(2) // => 3 foo 函数不是一个纯函数，因为它返回的结果依赖于外部变量 a，我们在不知道 a 的值的情况下，并不能保证 foo(2) 的返回值是 3。虽然 foo 函数的代码实现并没有变化，传入的参数也没有变化，但它的返回值却是不可预料的，现在 foo(2) 是 3，可能过了一会就是 4 了，因为 a 可能发生了变化变成了 2。 const a = 1 const foo = (x, b) => x + b foo(1, 2) // => 3 现在 foo 的返回结果只依赖于它的参数 x 和 b，foo(1, 2) 永远是 3。今天是 3，明天也是 3，在服务器跑是 3，在客户端跑也 3，不管你外部发生了什么变化，foo(1, 2) 永远是 3。只要 foo 代码不改变，你传入的参数是确定的，那么 foo(1, 2) 的值永远是可预料的。 这就是纯函数的第一个条件：一个函数的返回结果只依赖于它的参数。 函数执行过程没有副作用 一个函数执行过程对产生了外部可观察的变化那么就说这个函数是有副作用的。 我们修改一下 foo： const a = 1 const foo = (obj, b) => { return obj.x + b } const counter = { x: 1 } foo(counter, 2) // => 3 counter.x // => 1 我们把原来的 x 换成了 obj，我现在可以往里面传一个对象进行计算，计算的过程里面并不会对传入的对象进行修改，计算前后的 counter 不会发生任何变化，计算前是 1，计算后也是 1，它现在是纯的。但是我再稍微修改一下它： const a = 1 const foo = (obj, b) => { obj.x = 2 return obj.x + b } const counter = { x: 1 } foo(counter, 2) // => 4 counter.x // => 2 现在情况发生了变化，我在 foo 内部加了一句 obj.x = 2，计算前 counter.x 是 1，但是计算以后 counter.x 是 2。foo 函数的执行对外部的 counter 产生了影响，它产生了副作用，因为它修改了外部传进来的对象，现在它是不纯的。 但是你在函数内部构建的变量，然后进行数据的修改不是副作用： const foo = (b) => { const obj = { x: 1 } obj.x = 2 return obj.x + b } 虽然 foo 函数内部修改了 obj，但是 obj 是内部变量，外部程序根本观察不到，修改 obj 并不会产生外部可观察的变化，这个函数是没有副作用的，因此它是一个纯函数。 除了修改外部的变量，一个函数在执行过程中还有很多方式产生外部可观察的变化，比如说调用 DOM API 修改页面，或者你发送了 Ajax 请求，还有调用 window.reload 刷新浏览器，甚至是 console.log 往控制台打印数据也是副作用。 纯函数很严格，也就是说你几乎除了计算数据以外什么都不能干，计算的时候还不能依赖除了函数参数以外的数据。 总结 一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。 为什么要煞费苦心地构建纯函数？因为纯函数非常“靠谱”，执行一个纯函数你不用担心它会干什么坏事，它不会产生不可预料的行为，也不会对外部产生影响。不管何时何地，你给它什么它就会乖乖地吐出什么。如果你的应用程序大多数函数都是由纯函数组成，那么你的程序测试、调试起来会非常方便。 动手实现 Redux（四）：共享结构的对象提高性能 接下来两节某些地方可能会稍微有一点点抽象，但是我会尽可能用简单的方式进行讲解。如果你觉得理解起来有点困难，可以把这几节多读多理解几遍，其实我们一路走来都是符合“逻辑”的，都是发现问题、思考问题、优化代码的过程。所以最好能够用心留意、思考我们每一个提出来的问题。 细心的朋友可以发现，其实我们之前的例子当中是有比较严重的性能问题的。我们在每个渲染函数的开头打一些 Log 看看： function renderApp (appState) { console.log('render app...') renderTitle(appState.title) renderContent(appState.content) } function renderTitle (title) { console.log('render title...') const titleDOM = document.getElementById('title') titleDOM.innerHTML = title.text titleDOM.style.color = title.color } function renderContent (content) { console.log('render content...') const contentDOM = document.getElementById('content') contentDOM.innerHTML = content.text contentDOM.style.color = content.color } 依旧执行一次初始化渲染，和两次更新，这里代码保持不变： const store = createStore(appState, stateChanger) store.subscribe(() => renderApp(store.getState())) // 监听数据变化 renderApp(store.getState()) // 首次渲染页面 store.dispatch({ type: 'UPDATE_TITLE_TEXT', text: '《React.js 小书》' }) // 修改标题文本 store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'blue' }) // 修改标题颜色 可以在控制台看到： 前三个毫无疑问是第一次渲染打印出来的。中间三个是第一次 store.dispatch 导致的，最后三个是第二次 store.dispatch 导致的。可以看到问题就是，每当更新数据就重新渲染整个 App，但其实我们两次更新都没有动到 appState 里面的 content 字段的对象，而动的是 title 字段。其实并不需要重新 renderContent，它是一个多余的更新操作，现在我们需要优化它。 这里提出的解决方案是，在每个渲染函数执行渲染操作之前先做个判断，判断传入的新数据和旧的数据是不是相同，相同的话就不渲染了。 function renderApp (newAppState, oldAppState = {}) { // 防止 oldAppState 没有传入，所以加了默认参数 oldAppState = {} if (newAppState === oldAppState) return // 数据没有变化就不渲染了 console.log('render app...') renderTitle(newAppState.title, oldAppState.title) renderContent(newAppState.content, oldAppState.content) } function renderTitle (newTitle, oldTitle = {}) { if (newTitle === oldTitle) return // 数据没有变化就不渲染了 console.log('render title...') const titleDOM = document.getElementById('title') titleDOM.innerHTML = newTitle.text titleDOM.style.color = newTitle.color } function renderContent (newContent, oldContent = {}) { if (newContent === oldContent) return // 数据没有变化就不渲染了 console.log('render content...') const contentDOM = document.getElementById('content') contentDOM.innerHTML = newContent.text contentDOM.style.color = newContent.color } 然后我们用一个 oldState 变量保存旧的应用状态，在需要重新渲染的时候把新旧数据传进入去： const store = createStore(appState, stateChanger) let oldState = store.getState() // 缓存旧的 state store.subscribe(() => { const newState = store.getState() // 数据可能变化，获取新的 state renderApp(newState, oldState) // 把新旧的 state 传进去渲染 oldState = newState // 渲染完以后，新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染 }) ... 希望到这里没有把大家忽悠到，上面的代码根本不会达到我们的效果。看看我们的 stateChanger： function stateChanger (state, action) { switch (action.type) { case 'UPDATE_TITLE_TEXT': state.title.text = action.text break case 'UPDATE_TITLE_COLOR': state.title.color = action.color break default: break } } 即使你修改了 state.title.text，但是 state 还是原来那个 state，state.title 还是原来的 state.title，这些引用指向的还是原来的对象，只是对象内的内容发生了改变。所以即使你在每个渲染函数开头加了那个判断又什么用？这就像是下面的代码那样自欺欺人： let appState = { title: { text: 'React.js 小书', color: 'red', }, content: { text: 'React.js 小书内容', color: 'blue' } } const oldState = appState appState.title.text = '《React.js 小书》' oldState !== appState // false，其实两个引用指向的是同一个对象，我们却希望它们不同。 但是，我们接下来就要让这种事情变成可能。 共享结构的对象 希望大家都知道这种 ES6 的语法： const obj = { a: 1, b: 2} const obj2 = { ...obj } // => { a: 1, b: 2 } const obj2 = { ...obj } 其实就是新建一个对象 obj2，然后把 obj 所有的属性都复制到 obj2 里面，相当于对象的浅复制。上面的 obj 里面的内容和 obj2 是完全一样的，但是却是两个不同的对象。除了浅复制对象，还可以覆盖、拓展对象属性： const obj = { a: 1, b: 2} const obj2 = { ...obj, b: 3, c: 4} // => { a: 1, b: 3, c: 4 }，覆盖了 b，新增了 c 我们可以把这种特性应用在 state 的更新上，我们禁止直接修改原来的对象，一旦你要修改某些东西，你就得把修改路径上的所有对象复制一遍，例如，我们不写下面的修改代码： appState.title.text = '《React.js 小书》' 取而代之的是，我们新建一个 appState，新建 appState.title，新建 appState.title.text： let newAppState = { // 新建一个 newAppState ...appState, // 复制 appState 里面的内容 title: { // 用一个新的对象覆盖原来的 title 属性 ...appState.title, // 复制原来 title 对象里面的内容 text: '《React.js 小书》' // 覆盖 text 属性 } } 如果我们用一个树状的结构来表示对象结构的话： appState 和 newAppState 其实是两个不同的对象，因为对象浅复制的缘故，其实它们里面的属性 content 指向的是同一个对象；但是因为 title 被一个新的对象覆盖了，所以它们的 title 属性指向的对象是不同的。同样地，修改 appState.title.color： let newAppState1 = { // 新建一个 newAppState1 ...newAppState, // 复制 newAppState1 里面的内容 title: { // 用一个新的对象覆盖原来的 title 属性 ...newAppState.title, // 复制原来 title 对象里面的内容 color: \"blue\" // 覆盖 color 属性 } } 我们每次修改某些数据的时候，都不会碰原来的数据，而是把需要修改数据路径上的对象都 copy 一个出来。这样有什么好处？看看我们的目的达到了： appState !== newAppState // true，两个对象引用不同，数据变化了，重新渲染 appState.title !== newAppState.title // true，两个对象引用不同，数据变化了，重新渲染 appState.content !== appState.content // false，两个对象引用相同，数据没有变化，不需要重新渲染 修改数据的时候就把修改路径都复制一遍，但是保持其他内容不变，最后的所有对象具有某些不变共享的结构（例如上面三个对象都共享 content 对象）。大多数情况下我们可以保持 50% 以上的内容具有共享结构，这种操作具有非常优良的特性，我们可以用它来优化上面的渲染性能。 优化性能 我们修改 stateChanger，让它修改数据的时候，并不会直接修改原来的数据 state，而是产生上述的共享结构的对象： function stateChanger (state, action) { switch (action.type) { case 'UPDATE_TITLE_TEXT': return { // 构建新的对象并且返回 ...state, title: { ...state.title, text: action.text } } case 'UPDATE_TITLE_COLOR': return { // 构建新的对象并且返回 ...state, title: { ...state.title, color: action.color } } default: return state // 没有修改，返回原来的对象 } } 代码稍微比原来长了一点，但是是值得的。每次需要修改的时候都会产生新的对象，并且返回。而如果没有修改（在 default 语句中）则返回原来的 state 对象。 因为 stateChanger 不会修改原来对象了，而是返回对象，所以我们需要修改一下 createStore。让它用每次 stateChanger(state, action) 的调用结果覆盖原来的 state： function createStore (state, stateChanger) { const listeners = [] const subscribe = (listener) => listeners.push(listener) const getState = () => state const dispatch = (action) => { state = stateChanger(state, action) // 覆盖原对象 listeners.forEach((listener) => listener()) } return { getState, dispatch, subscribe } } 保持上面的渲染函数开头的对象判断不变，再看看控制台： 前三个是首次渲染。后面的 store.dispatch 导致的重新渲染都没有关于 content 的 Log 了。因为产生共享结构的对象，新旧对象的 content 引用指向的对象是一样的，所以触发了 renderContent 函数开头的： ... if (newContent === oldContent) return ... 我们成功地把不必要的页面渲染优化掉了，问题解决。另外，并不需要担心每次修改都新建共享结构对象会有性能、内存问题，因为构建对象的成本非常低，而且我们最多保存两个对象引用（oldState 和 newState），其余旧的对象都会被垃圾回收掉。 本节完整代码： function createStore (state, stateChanger) { const listeners = [] const subscribe = (listener) => listeners.push(listener) const getState = () => state const dispatch = (action) => { state = stateChanger(state, action) // 覆盖原对象 listeners.forEach((listener) => listener()) } return { getState, dispatch, subscribe } } function renderApp (newAppState, oldAppState = {}) { // 防止 oldAppState 没有传入，所以加了默认参数 oldAppState = {} if (newAppState === oldAppState) return // 数据没有变化就不渲染了 console.log('render app...') renderTitle(newAppState.title, oldAppState.title) renderContent(newAppState.content, oldAppState.content) } function renderTitle (newTitle, oldTitle = {}) { if (newTitle === oldTitle) return // 数据没有变化就不渲染了 console.log('render title...') const titleDOM = document.getElementById('title') titleDOM.innerHTML = newTitle.text titleDOM.style.color = newTitle.color } function renderContent (newContent, oldContent = {}) { if (newContent === oldContent) return // 数据没有变化就不渲染了 console.log('render content...') const contentDOM = document.getElementById('content') contentDOM.innerHTML = newContent.text contentDOM.style.color = newContent.color } let appState = { title: { text: 'React.js 小书', color: 'red', }, content: { text: 'React.js 小书内容', color: 'blue' } } function stateChanger (state, action) { switch (action.type) { case 'UPDATE_TITLE_TEXT': return { // 构建新的对象并且返回 ...state, title: { ...state.title, text: action.text } } case 'UPDATE_TITLE_COLOR': return { // 构建新的对象并且返回 ...state, title: { ...state.title, color: action.color } } default: return state // 没有修改，返回原来的对象 } } const store = createStore(appState, stateChanger) let oldState = store.getState() // 缓存旧的 state store.subscribe(() => { const newState = store.getState() // 数据可能变化，获取新的 state renderApp(newState, oldState) // 把新旧的 state 传进去渲染 oldState = newState // 渲染完以后，新的 newState 变成了旧的 oldState，等待下一次数据变化重新渲染 }) renderApp(store.getState()) // 首次渲染页面 store.dispatch({ type: 'UPDATE_TITLE_TEXT', text: '《React.js 小书》' }) // 修改标题文本 store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'blue' }) // 修改标题颜色 动手实现 Redux（五）：不要问为什么的 reducer 经过了这么多节的优化，我们有了一个很通用的 createStore： function createStore (state, stateChanger) { const listeners = [] const subscribe = (listener) => listeners.push(listener) const getState = () => state const dispatch = (action) => { state = stateChanger(state, action) // 覆盖原对象 listeners.forEach((listener) => listener()) } return { getState, dispatch, subscribe } } 它的使用方式是： let appState = { title: { text: 'React.js 小书', color: 'red', }, content: { text: 'React.js 小书内容', color: 'blue' } } function stateChanger (state, action) { switch (action.type) { case 'UPDATE_TITLE_TEXT': return { ...state, title: { ...state.title, text: action.text } } case 'UPDATE_TITLE_COLOR': return { ...state, title: { ...state.title, color: action.color } } default: return state } } const store = createStore(appState, stateChanger) ... 我们再优化一下，其实 appState 和 stateChanger 可以合并到一起去： function stateChanger (state, action) { if (!state) { return { title: { text: 'React.js 小书', color: 'red', }, content: { text: 'React.js 小书内容', color: 'blue' } } } switch (action.type) { case 'UPDATE_TITLE_TEXT': return { ...state, title: { ...state.title, text: action.text } } case 'UPDATE_TITLE_COLOR': return { ...state, title: { ...state.title, color: action.color } } default: return state } } stateChanger 现在既充当了获取初始化数据的功能，也充当了生成更新数据的功能。如果有传入 state 就生成更新数据，否则就是初始化数据。这样我们可以优化 createStore 成一个参数，因为 state 和 stateChanger 合并到一起了： function createStore (stateChanger) { let state = null const listeners = [] const subscribe = (listener) => listeners.push(listener) const getState = () => state const dispatch = (action) => { state = stateChanger(state, action) listeners.forEach((listener) => listener()) } dispatch({}) // 初始化 state return { getState, dispatch, subscribe } } createStore 内部的 state 不再通过参数传入，而是一个局部变量 let state = null。createStore 的最后会手动调用一次 dispatch({})，dispatch 内部会调用 stateChanger，这时候的 state 是 null，所以这次的 dispatch 其实就是初始化数据了。createStore 内部第一次的 dispatch 导致 state 初始化完成，后续外部的 dispatch 就是修改数据的行为了。 我们给 stateChanger 这个玩意起一个通用的名字：reducer，不要问为什么，它就是个名字而已，修改 createStore 的参数名字： function createStore (reducer) { let state = null const listeners = [] const subscribe = (listener) => listeners.push(listener) const getState = () => state const dispatch = (action) => { state = reducer(state, action) listeners.forEach((listener) => listener()) } dispatch({}) // 初始化 state return { getState, dispatch, subscribe } } 这是一个最终形态的 createStore，它接受的参数叫 reducer，reducer 是一个函数，细心的朋友会发现，它其实是一个纯函数（Pure Function）。 reducer createStore 接受一个叫 reducer 的函数作为参数，这个函数规定是一个纯函数，它接受两个参数，一个是 state，一个是 action。 如果没有传入 state 或者 state 是 null，那么它就会返回一个初始化的数据。如果有传入 state 的话，就会根据 action 来“修改“数据，但其实它没有、也规定不能修改 state，而是要通过上节所说的把修改路径的对象都复制一遍，然后产生一个新的对象返回。如果它不能识别你的 action，它就不会产生新的数据，而是（在 default 内部）把 state 原封不动地返回。 reducer 是不允许有副作用的。你不能在里面操作 DOM，也不能发 Ajax 请求，更不能直接修改 state，它要做的仅仅是 —— 初始化和计算新的 state。 现在我们可以用这个 createStore 来构建不同的 store 了，只要给它传入符合上述的定义的 reducer 即可： function themeReducer (state, action) { if (!state) return { themeName: 'Red Theme', themeColor: 'red' } switch (action.type) { case 'UPATE_THEME_NAME': return { ...state, themeName: action.themeName } case 'UPATE_THEME_COLOR': return { ...state, themeColor: action.themeColor } default: return state } } const store = createStore(themeReducer) ... 动手实现 Redux（六）：Redux 总结 不知不觉地，到这里大家不仅仅已经掌握了 Redux，而且还自己动手写了一个 Redux。我们从一个非常原始的代码开始，不停地在发现问题、解决问题、优化代码的过程中进行推演，最后把 Redux 模式自己总结出来了。这就是所谓的 Redux 模式，我们再来回顾一下这几节我们到底干了什么事情。 我们从一个简单的例子的代码中发现了共享的状态如果可以被任意修改的话，那么程序的行为将非常不可预料，所以我们提高了修改数据的门槛：你必须通过 dispatch 执行某些允许的修改操作，而且必须大张旗鼓的在 action 里面声明。 这种模式挺好用的，我们就把它抽象出来一个 createStore，它可以产生 store，里面包含 getState 和 dispatch 函数，方便我们使用。 后来发现每次修改数据都需要手动重新渲染非常麻烦，我们希望自动重新渲染视图。所以后来加入了订阅者模式，可以通过 store.subscribe 订阅数据修改事件，每次数据更新的时候自动重新渲染视图。 接下来我们发现了原来的“重新渲染视图”有比较严重的性能问题，我们引入了“共享结构的对象”来帮我们解决问题，这样就可以在每个渲染函数的开头进行简单的判断避免没有被修改过的数据重新渲染。 我们优化了 stateChanger 为 reducer，定义了 reducer 只能是纯函数，功能就是负责初始 state，和根据 state 和 action 计算具有共享结构的新的 state。 createStore 现在可以直接拿来用了，套路就是： // 定一个 reducer function reducer (state, action) { /* 初始化 state 和 switch case */ } // 生成 store const store = createStore(reducer) // 监听数据变化重新渲染页面 store.subscribe(() => renderApp(store.getState())) // 首次渲染页面 renderApp(store.getState()) // 后面可以随意 dispatch 了，页面自动更新 store.dispatch(...) 现在的代码跟 React.js 一点关系都没有，接下来我们要把 React.js 和 Redux 结合起来，用 Redux 模式帮助管理 React.js 的应用状态。 "},"React/源码分析/动手实现React-redux.html":{"url":"React/源码分析/动手实现React-redux.html","title":"动手实现 React-redux","keywords":"","body":"动手实现 React-redux 动手实现 React-redux 动手实现 React-redux（一）：初始化工程 动手实现 React-redux（二）：结合 context 和 store 动手实现 React-redux（三）：connect 和 mapStateToProps 动手实现 React-redux（四）：mapDispatchToProps 动手实现 React-redux（五）：Provider 动手实现 React-redux（六）：React-redux 总结 动手实现 React-redux（一）：初始化工程 可以看到 Redux 并不复杂，它那些看起来匪夷所思的设定其实都是为了解决特定的问题而存在的，我们把问题想清楚以后就不难理解它的那些奇怪的设定了。这节开始我们来看看如何把 Redux 和 React.js 结合起来，你会发现其实它们也并不复杂。 回顾一下，我们在 前端应用状态管理 —— 状态提升 中提过，前端中应用的状态存在的问题：一个状态可能被多个组件依赖或者影响，而 React.js 并没有提供好的解决方案，我们只能把状态提升到依赖或者影响这个状态的所有组件的公共父组件上，我们把这种行为叫做状态提升。但是需求不停变化，共享状态没完没了地提升也不是办法。 后来我们在 React.js 的 context 中提出，我们可用把共享状态放到父组件的 context 上，这个父组件下所有的组件都可以从 context 中直接获取到状态而不需要一层层地进行传递了。但是直接从 context 里面存放、获取数据增强了组件的耦合性；并且所有组件都可以修改 context 里面的状态就像谁都可以修改共享状态一样，导致程序运行的不可预料。 既然这样，为什么不把 context 和 store 结合起来？毕竟 store 的数据不是谁都能修改，而是约定只能通过 dispatch 来进行修改，这样的话每个组件既可以去 context 里面获取 store 从而获取状态，又不用担心它们乱改数据了。 听起来不错，我们动手试一下。我们还是拿“主题色”这个例子做讲解，假设我们现在需要做下面这样的组件树： Header 和 Content 的组件的文本内容会随着主题色的变化而变化，而 Content 下的子组件 ThemeSwitch 有两个按钮，可以切换红色和蓝色两种主题，按钮的颜色也会随着主题色的变化而变化。 用 create-react-app 新建一个工程，然后安装一个 React 提供的第三方库 prop-types： npm install --save prop-types 安装好后在 src/ 目录下新增三个文件：Header.js、Content.js、ThemeSwitch.js。 修改 src/Header.js： import React, { Component } from 'react' import PropTypes from 'prop-types' class Header extends Component { render () { return ( React.js 小书 ) } } export default Header 修改 src/ThemeSwitch.js： import React, { Component } from 'react' import PropTypes from 'prop-types' class ThemeSwitch extends Component { render () { return ( Red Blue ) } } export default ThemeSwitch 修改 src/Content.js： import React, { Component } from 'react' import PropTypes from 'prop-types' import ThemeSwitch from './ThemeSwitch' class Content extends Component { render () { return ( React.js 小书内容 ) } } export default Content 修改 src/index.js： import React, { Component } from 'react' import PropTypes from 'prop-types' import ReactDOM from 'react-dom' import Header from './Header' import Content from './Content' import './index.css' class Index extends Component { render () { return ( ) } } ReactDOM.render( , document.getElementById('root') ) 这样我们就简单地把整个组件树搭建起来了，用 npm start 启动工程，然后可以看到页面上显示： 当然现在文本都没有颜色，而且点击按钮也不会有什么反应，我们还没有加入表示主题色的状态和相关的业务逻辑，下一节我们就把相关的逻辑加进去。 动手实现 React-redux（二）：结合 context 和 store 既然要把 store 和 context 结合起来，我们就先构建 store。在 src/index.js 加入之前创建的 createStore 函数，并且构建一个 themeReducer 来生成一个 store： import React, { Component } from 'react' import PropTypes from 'prop-types' import ReactDOM from 'react-dom' import Header from './Header' import Content from './Content' import './index.css' function createStore (reducer) { let state = null const listeners = [] const subscribe = (listener) => listeners.push(listener) const getState = () => state const dispatch = (action) => { state = reducer(state, action) listeners.forEach((listener) => listener()) } dispatch({}) // 初始化 state return { getState, dispatch, subscribe } } const themeReducer = (state, action) => { if (!state) return { themeColor: 'red' } switch (action.type) { case 'CHANGE_COLOR': return { ...state, themeColor: action.themeColor } default: return state } } const store = createStore(themeReducer) ... themeReducer 定义了一个表示主题色的状态 themeColor，并且规定了一种操作 CHNAGE_COLOR，只能通过这种操作修改颜色。现在我们把 store 放到 Index 的 context 里面，这样每个子组件都可以获取到 store 了，修改 src/index.js 里面的 Index： class Index extends Component { static childContextTypes = { store: PropTypes.object } getChildContext () { return { store } } render () { return ( ) } } 如果有些同学已经忘记了 context 的用法，可以参考之前的章节： React.js 的 context 。 然后修改 src/Header.js，让它从 Index 的 context 里面获取 store，并且获取里面的 themeColor 状态来设置自己的颜色： class Header extends Component { static contextTypes = { store: PropTypes.object } constructor () { super() this.state = { themeColor: '' } } componentWillMount () { this._updateThemeColor() } _updateThemeColor () { const { store } = this.context const state = store.getState() this.setState({ themeColor: state.themeColor }) } render () { return ( React.js 小书 ) } } 其实也很简单，我们在 constructor 里面初始化了组件自己的 themeColor 状态。然后在生命周期中 componentWillMount 调用 _updateThemeColor，_updateThemeColor 会从 context 里面把 store 取出来，然后通过 store.getState() 获取状态对象，并且用里面的 themeColor 字段设置组件的 state.themeColor。 然后在 render 函数里面获取了 state.themeColor 来设置标题的样式，页面上就会显示： 如法炮制 Content.js： class Content extends Component { static contextTypes = { store: PropTypes.object } constructor () { super() this.state = { themeColor: '' } } componentWillMount () { this._updateThemeColor() } _updateThemeColor () { const { store } = this.context const state = store.getState() this.setState({ themeColor: state.themeColor }) } render () { return ( React.js 小书内容 ) } } 还有 src/ThemeSwitch.js： class ThemeSwitch extends Component { static contextTypes = { store: PropTypes.object } constructor () { super() this.state = { themeColor: '' } } componentWillMount () { this._updateThemeColor() } _updateThemeColor () { const { store } = this.context const state = store.getState() this.setState({ themeColor: state.themeColor }) } render () { return ( Red Blue ) } } 这时候，主题已经完全生效了，整个页面都是红色的： 当然现在点按钮还是没什么效果，我们接下来给按钮添加事件。其实也很简单，监听 onClick 事件然后 store.dispatch 一个 action 就好了，修改 src/ThemeSwitch.js： class ThemeSwitch extends Component { static contextTypes = { store: PropTypes.object } constructor () { super() this.state = { themeColor: '' } } componentWillMount () { this._updateThemeColor() } _updateThemeColor () { const { store } = this.context const state = store.getState() this.setState({ themeColor: state.themeColor }) } // dispatch action 去改变颜色 handleSwitchColor (color) { const { store } = this.context store.dispatch({ type: 'CHANGE_COLOR', themeColor: color }) } render () { return ( Red Blue ) } } 我们给两个按钮都加上了 onClick 事件监听，并绑定到了 handleSwitchColor 方法上，两个按钮分别给这个方法传入不同的颜色 red 和 blue，handleSwitchColor 会根据传入的颜色 store.dispatch 一个 action 去修改颜色。 当然你现在点击按钮还是没有反应的。因为点击按钮的时候，只是更新 store 里面的 state，而并没有在 store.state 更新以后去重新渲染数据，我们其实就是忘了 store.subscribe 了。 给 Header.js、Content.js、ThemeSwitch.js 的 componentWillMount 生命周期都加上监听数据变化重新渲染的代码： ... componentWillMount () { const { store } = this.context this._updateThemeColor() store.subscribe(() => this._updateThemeColor()) } ... 通过 store.subscribe，在数据变化的时候重新调用 _updateThemeColor，而 _updateThemeColor 会去 store 里面取最新的 themeColor 然后通过 setState 重新渲染组件，这时候组件就更新了。现在可以自由切换主题色了： 我们顺利地把 store 和 context 结合起来，这是 Redux 和 React.js 的第一次胜利会师，当然还有很多需要优化的地方。 动手实现 React-redux（三）：connect 和 mapStateToProps 我们来观察一下刚写下的这几个组件，可以轻易地发现它们有两个重大的问题： 有大量重复的逻辑：它们基本的逻辑都是，取出 context，取出里面的 store，然后用里面的状态设置自己的状态，这些代码逻辑其实都是相同的。 对 context 依赖性过强：这些组件都要依赖 context 来取数据，使得这个组件复用性基本为零。想一下，如果别人需要用到里面的 ThemeSwitch 组件，但是他们的组件树并没有 context 也没有 store，他们没法用这个组件了。 对于第一个问题，我们在 高阶组件 的章节说过，可以把一些可复用的逻辑放在高阶组件当中，高阶组件包装的新组件和原来组件之间通过 props 传递信息，减少代码的重复程度。 对于第二个问题，我们得弄清楚一件事情，到底什么样的组件才叫复用性强的组件。如果一个组件对外界的依赖过于强，那么这个组件的移植性会很差，就像这些严重依赖 context 的组件一样。 如果一个组件的渲染只依赖于外界传进去的 props 和自己的 state，而并不依赖于其他的外界的任何数据，也就是说像纯函数一样，给它什么，它就吐出（渲染）什么出来。这种组件的复用性是最强的，别人使用的时候根本不用担心任何事情，只要看看 PropTypes 它能接受什么参数，然后把参数传进去控制它就行了。 我们把这种组件叫做 Pure Component，因为它就像纯函数一样，可预测性非常强，对参数（props）以外的数据零依赖，也不产生副作用。这种组件也叫 Dumb Component，因为它们呆呆的，让它干啥就干啥。写组件的时候尽量写 Dumb Component 会提高我们的组件的可复用性。 到这里思路慢慢地变得清晰了，我们需要高阶组件帮助我们从 context 取数据，我们也需要写 Dumb 组件帮助我们提高组件的复用性。所以我们尽量多地写 Dumb 组件，然后用高阶组件把它们包装一层，高阶组件和 context 打交道，把里面数据取出来通过 props 传给 Dumb 组件。 我们把这个高阶组件起名字叫 connect，因为它把 Dumb 组件和 context 连接（connect）起来了： import React, { Component } from 'react' import PropTypes from 'prop-types' export connect = (WrappedComponent) => { class Connect extends Component { static contextTypes = { store: PropTypes.object } // TODO: 如何从 store 取数据？ render () { return } } return Connect } connect 函数接受一个组件 WrappedComponent 作为参数，把这个组件包含在一个新的组件 Connect 里面，Connect 会去 context 里面取出 store。现在要把 store 里面的数据取出来通过 props 传给 WrappedComponent。 但是每个传进去的组件需要 store 里面的数据都不一样的，所以除了给高阶组件传入 Dumb 组件以外，还需要告诉高级组件我们需要什么数据，高阶组件才能正确地去取数据。为了解决这个问题，我们可以给高阶组件传入类似下面这样的函数： const mapStateToProps = (state) => { return { themeColor: state.themeColor, themeName: state.themeName, fullName: `${state.firstName} ${state.lastName}` ... } } 这个函数会接受 store.getState() 的结果作为参数，然后返回一个对象，这个对象是根据 state 生成的。mapStateTopProps 相当于告知了 Connect 应该如何去 store 里面取数据，然后可以把这个函数的返回结果传给被包装的组件： import React, { Component } from 'react' import PropTypes from 'prop-types' export const connect = (mapStateToProps) => (WrappedComponent) => { class Connect extends Component { static contextTypes = { store: PropTypes.object } render () { const { store } = this.context let stateProps = mapStateToProps(store.getState()) // {...stateProps} 意思是把这个对象里面的属性全部通过 `props` 方式传递进去 return } } return Connect } connect 现在是接受一个参数 mapStateToProps，然后返回一个函数，这个返回的函数才是高阶组件。它会接受一个组件作为参数，然后用 Connect 把组件包装以后再返回。 connect 的用法是： ... const mapStateToProps = (state) => { return { themeColor: state.themeColor } } Header = connect(mapStateToProps)(Header) ... 有些朋友可能会问为什么不直接 const connect = (mapStateToProps, WrappedComponent)，而是要额外返回一个函数。这是因为 React-redux 就是这么设计的，而个人观点认为这是一个 React-redux 设计上的缺陷，这里有机会会在关于函数编程的章节再给大家科普，这里暂时不深究了。 我们把上面 connect 的函数代码单独分离到一个模块当中，在 src/ 目录下新建一个 react-redux.js，把上面的 connect 函数的代码复制进去，然后就可以在 src/Header.js 里面使用了： import React, { Component } from 'react' import PropTypes from 'prop-types' import { connect } from './react-redux' class Header extends Component { static propTypes = { themeColor: PropTypes.string } render () { return ( React.js 小书 ) } } const mapStateToProps = (state) => { return { themeColor: state.themeColor } } Header = connect(mapStateToProps)(Header) export default Header 可以看到 Header 删掉了大部分关于 context 的代码，它除了 props 什么也不依赖，它是一个 Pure Component，然后通过 connect 取得数据。我们不需要知道 connect 是怎么和 context 打交道的，只要传一个 mapStateToProps 告诉它应该怎么取数据就可以了。同样的方式修改 src/Content.js： import React, { Component } from 'react' import PropTypes from 'prop-types' import ThemeSwitch from './ThemeSwitch' import { connect } from './react-redux' class Content extends Component { static propTypes = { themeColor: PropTypes.string } render () { return ( React.js 小书内容 ) } } const mapStateToProps = (state) => { return { themeColor: state.themeColor } } Content = connect(mapStateToProps)(Content) export default Content connect 还没有监听数据变化然后重新渲染，所以现在点击按钮只有按钮会变颜色。我们给 connect 的高阶组件增加监听数据变化重新渲染的逻辑，稍微重构一下 connect： export const connect = (mapStateToProps) => (WrappedComponent) => { class Connect extends Component { static contextTypes = { store: PropTypes.object } constructor () { super() this.state = { allProps: {} } } componentWillMount () { const { store } = this.context this._updateProps() store.subscribe(() => this._updateProps()) } _updateProps () { const { store } = this.context let stateProps = mapStateToProps(store.getState(), this.props) // 额外传入 props，让获取数据更加灵活方便 this.setState({ allProps: { // 整合普通的 props 和从 state 生成的 props ...stateProps, ...this.props } }) } render () { return } } return Connect } 我们在 Connect 组件的 constructor 里面初始化了 state.allProps，它是一个对象，用来保存需要传给被包装组件的所有的参数。生命周期 componentWillMount 会调用调用 _updateProps 进行初始化，然后通过 store.subscribe 监听数据变化重新调用 _updateProps。 为了让 connect 返回新组件和被包装的组件使用参数保持一致，我们会把所有传给 Connect 的 props 原封不动地传给 WrappedComponent。所以在 _updateProps 里面会把 stateProps 和 this.props 合并到 this.state.allProps 里面，再通过 render 方法把所有参数都传给 WrappedComponent。 mapStateToProps 也发生点变化，它现在可以接受两个参数了，我们会把传给 Connect 组件的 props 参数也传给它，那么它生成的对象配置性就更强了，我们可以根据 store 里面的 state 和外界传入的 props 生成我们想传给被包装组件的参数。 现在已经很不错了，Header.js 和 Content.js 的代码都大大减少了，并且这两个组件 connect 之前都是 Dumb 组件。接下来会继续重构 ThemeSwitch。 动手实现 React-redux（四）：mapDispatchToProps 在重构 ThemeSwitch 的时候我们发现，ThemeSwitch 除了需要 store 里面的数据以外，还需要 store 来 dispatch： ... // dispatch action 去改变颜色 handleSwitchColor (color) { const { store } = this.context store.dispatch({ type: 'CHANGE_COLOR', themeColor: color }) } ... 目前版本的 connect 是达不到这个效果的，我们需要改进它。 想一下，既然可以通过给 connect 函数传入 mapStateToProps 来告诉它如何获取、整合状态，我们也可以想到，可以给它传入另外一个参数来告诉它我们的组件需要如何触发 dispatch。我们把这个参数叫 mapDispatchToProps： const mapDispatchToProps = (dispatch) => { return { onSwitchColor: (color) => { dispatch({ type: 'CHANGE_COLOR', themeColor: color }) } } } 和 mapStateToProps 一样，它返回一个对象，这个对象内容会同样被 connect 当作是 props 参数传给被包装的组件。不一样的是，这个函数不是接受 state 作为参数，而是 dispatch，你可以在返回的对象内部定义一些函数，这些函数会用到 dispatch 来触发特定的 action。 调整 connect 让它能接受这样的 mapDispatchToProps： export const connect = (mapStateToProps, mapDispatchToProps) => (WrappedComponent) => { class Connect extends Component { static contextTypes = { store: PropTypes.object } constructor () { super() this.state = { allProps: {} } } componentWillMount () { const { store } = this.context this._updateProps() store.subscribe(() => this._updateProps()) } _updateProps () { const { store } = this.context let stateProps = mapStateToProps ? mapStateToProps(store.getState(), this.props) : {} // 防止 mapStateToProps 没有传入 let dispatchProps = mapDispatchToProps ? mapDispatchToProps(store.dispatch, this.props) : {} // 防止 mapDispatchToProps 没有传入 this.setState({ allProps: { ...stateProps, ...dispatchProps, ...this.props } }) } render () { return } } return Connect } 在 _updateProps 内部，我们把store.dispatch 作为参数传给 mapDispatchToProps ，它会返回一个对象 dispatchProps。接着把 stateProps、dispatchProps、this.props 三者合并到 this.state.allProps 里面去，这三者的内容都会在 render 函数内全部传给被包装的组件。 另外，我们稍微调整了一下，在调用 mapStateToProps 和 mapDispatchToProps 之前做判断，让这两个参数都是可以缺省的，这样即使不传这两个参数程序也不会报错。 这时候我们就可以重构 ThemeSwitch，让它摆脱 store.dispatch： import React, { Component } from 'react' import PropTypes from 'prop-types' import { connect } from './react-redux' class ThemeSwitch extends Component { static propTypes = { themeColor: PropTypes.string, onSwitchColor: PropTypes.func } handleSwitchColor (color) { if (this.props.onSwitchColor) { this.props.onSwitchColor(color) } } render () { return ( Red Blue ) } } const mapStateToProps = (state) => { return { themeColor: state.themeColor } } const mapDispatchToProps = (dispatch) => { return { onSwitchColor: (color) => { dispatch({ type: 'CHANGE_COLOR', themeColor: color }) } } } ThemeSwitch = connect(mapStateToProps, mapDispatchToProps)(ThemeSwitch) export default ThemeSwitch 光看 ThemeSwitch 内部，是非常清爽干净的，只依赖外界传进来的 themeColor 和 onSwitchColor。但是 ThemeSwitch 内部并不知道这两个参数其实都是我们去 store 里面取的，它是 Dumb 的。这时候这三个组件的重构都已经完成了，代码大大减少、不依赖 context，并且功能和原来一样。 动手实现 React-redux（五）：Provider 我们要把 context 相关的代码从所有业务组件中清除出去，现在的代码里面还有一个地方是被污染的。那就是 src/index.js 里面的 Index： ... class Index extends Component { static childContextTypes = { store: PropTypes.object } getChildContext () { return { store } } render () { return ( ) } } ... 其实它要用 context 就是因为要把 store 存放到里面，好让子组件 connect 的时候能够取到 store。我们可以额外构建一个组件来做这种脏活，然后让这个组件成为组件树的根节点，那么它的子组件都可以获取到 context 了。 我们把这个组件叫 Provider，因为它提供（provide）了 store： 在 src/react-redux.js 新增代码： export class Provider extends Component { static propTypes = { store: PropTypes.object, children: PropTypes.any } static childContextTypes = { store: PropTypes.object } getChildContext () { return { store: this.props.store } } render () { return ( {this.props.children} ) } } Provider 做的事情也很简单，它就是一个容器组件，会把嵌套的内容原封不动作为自己的子组件渲染出来。它还会把外界传给它的 props.store 放到 context，这样子组件 connect 的时候都可以获取到。 可以用它来重构我们的 src/index.js： ... // 头部引入 Provider import { Provider } from './react-redux' ... // 删除 Index 里面所有关于 context 的代码 class Index extends Component { render () { return ( ) } } // 把 Provider 作为组件树的根节点 ReactDOM.render( , document.getElementById('root') ) 这样我们就把所有关于 context 的代码从组件里面删除了。 动手实现 React-redux（六）：React-redux 总结 到这里大家已经掌握了 React-redux 的基本用法和概念，并且自己动手实现了一个 React-redux，我们回顾一下这几节都干了什么事情。 React.js 除了状态提升以外并没有更好的办法帮我们解决组件之间共享状态的问题，而使用 context 全局变量让程序不可预测。通过 Redux 的章节，我们知道 store 里面的内容是不可以随意修改的，而是通过 dispatch 才能变更里面的 state。所以我们尝试把 store 和 context 结合起来使用，可以兼顾组件之间共享状态问题和共享状态可能被任意修改的问题。 第一个版本的 store 和 context 结合有诸多缺陷，有大量的重复逻辑和对 context 的依赖性过强。我们尝试通过构建一个高阶组件 connect 函数的方式，把所有的重复逻辑和对 context 的依赖放在里面 connect 函数里面，而其他组件保持 Pure（Dumb） 的状态，让 connect 跟 context 打交道，然后通过 props 把参数传给普通的组件。 而每个组件需要的数据和需要触发的 action 都不一样，所以调整 connect，让它可以接受两个参数 mapStateToProps 和 mapDispatchToProps，分别用于告诉 connect 这个组件需要什么数据和需要触发什么 action。 最后为了把所有关于 context 的代码完全从我们业务逻辑里面清除掉，我们构建了一个 Provider 组件。Provider 作为所有组件树的根节点，外界可以通过 props 给它提供 store，它会把 store 放到自己的 context 里面，好让子组件 connect 的时候都能够获取到。 这几节的成果就是 react-redux.js 这个文件里面的两个内容：connect 函数和 Provider 容器组件。这就是 React-redux 的基本内容，当然它是一个残疾版本的 React-redux，很多地方需要完善。例如上几节提到的性能问题，现在不相关的数据变化的时候其实所有组件都会重新渲染的，这个性能优化留给读者做练习。 通过这种方式大家不仅仅知道了 React-redux 的基础概念和用法，而且还知道这些概念到底是解决什么问题，为什么 React-redux 这么奇怪，为什么要 connect，为什么要 mapStateToProps 和 mapDispatchToProps，什么是 Provider，我们通过解决一个个问题就知道它们到底为什么要这么设计的了。 "},"React/源码分析/从0实现一个lu-redux.html":{"url":"React/源码分析/从0实现一个lu-redux.html","title":"从0实现一个lu-redux","keywords":"","body":"从0实现一个lu-redux 从0实现一个lu-redux 从0实现一个lu-redux so tiny ! 另一个灵魂 middleware 辅助函数 其他 从0实现一个lu-redux 讲真，redux已经很小了，去掉注释代码也就300行吧， 大家可以去读一下， 注释写的也是非常详细了。 redux 更多的是对思维上的变化：数据改变 + 视图更新 二者分开，各自管理自己。 现在，让我们从无到有！！ so tiny ! redux 是这样的一个流程：触发一个action --> redux做一些逻辑，返回state --> 触发监听程序。 这不就是图形界面的事件机制吗（在web 上就是addEventListener）！ 所以一个 最小的redux： class Store { constructor(reducer, state = {}) { this.state = state this.listeners = [] this.reducer = reducer } dispatch(action) { this.state = this.reducer(this.state, action) this.listeners.forEach(listener => listener()) } getState() { return this.state } subscribe(listener) { this.listeners.push(listener) } } 我们的这个 Store 和 redux的store提供了想的api： dispatch 触发一个action getState 返回当前状态 subscribe 增加一个监听器 让我们用这个最小的例子实现一个 计数器在线地址 function reducer(state, action) { switch (action.type) { case 'addOne': { return { ...state, count: state.count + 1 } } default: { return state } } } const store = new Store(reducer, {count: 0}) store.subscribe(() => { console.log('subscribe test:', store.getState()) }) store.dispatch({type: 'addOne'}) store.dispatch({type: 'addOne'}) 另一个灵魂 middleware redux的中文文档 上关于middleware的部分， 已经讲的很好了。现在我们从另一个角度来看这个问题， 首先，middleware 是redux在dispatch前后，提供的扩展机制。 比如日志功能， 需要在dispath一个action之前记录一下状态，然后reducer处理完逻辑之后， 再次记录一下。 这不就是 面向切面编程吗！ 时髦的AOP！ 用java的话不管是 静态代理还是动态代理, 写起来都挺复杂的。 但是js实现 很简单： function enhancer(originF) { return function(...args) { console.log('before') var result = originF(...args) console.log('after') return result } } enhancer 方法接受一个方法A， 返回一个增强的方法B。 对B我们可以再次 增强，所以这里是可以链式调用的: var fEnhancer = function (originF) { return function (...args) { console.log('this is fEnhancer before') var r = originF(...args) console.log('this is fEnhancer after') return r } } var hEnhancer = function (originF) { return function (...args) { console.log('this is hEnhancer before') var r = originF(...args) console.log('this is hEnhancer after') return r } } var gEnhancer = function (originF) { return function (...args) { console.log('this is gEnhancer before') var r = originF(...args) console.log('this is gEnhancer after') return r } } function justPrint() { console.log('justPrint...') } fEnhancer(hEnhancer(gEnhancer(justPrint)))() 这个例子输出在线地址： this is fEnhancer before this is hEnhancer before this is gEnhancer before justPrint... this is gEnhancer after this is hEnhancer after this is fEnhancer after 对于 fEnhancer(hEnhancer(gEnhancer(justPrint))) 等效的写法如下： var enhancerArray = [gEnhancer, hEnhancer, fEnhancer] function enhancerFun(originF) { let of = originF enhancerArray.forEach(enhancer => { of = enhancer(of) }) return of } 更加流弊的写法， 也就是redux的实现(巧妙的使用了数组的reduce方法)： var enhancerArray = [gEnhancer, hEnhancer, fEnhancer] function enhancerFun2(originF) { return enhancerArray.reduce((a, b) => (...args) => a(b(...args)))(originF) } 回到 redux， 需要我们增强的是dispatch， 所以只需要 enhancerFun(store.dispatch)。 这里有两个问题： 第一个问题 由于我们的dispatch里面使用了 this， 而这个增强的调用： var r = originF() 这里就丢掉了this。解决方法如下： class Store { constructor(reducer, state) { this.state = state this.listeners = [] this.reducer = reducer this.dispatch = this.dispatch.bind(this) this.getState = this.getState.bind(this) this.subscribe = this.subscribe.bind(this) } ... } 这样在任何地方调用 store的方法， 都没有问题了 第二个问题：在gEnhancer 里面我们想要调用 store.getState() 来记录 调用dispatch 前后的状态怎么办？ （我们不可能每次去import store吧， 因为在写enhancer的时候， 可能压根就不知道 store在哪里呢。 ） 方法如下： var fEnhancer = function ({ getState, dispatch }) { return function (originF) { return function (...args) { console.log('this is fEnhancer before', getState()) var r = originF(...args) console.log('this is fEnhancer after', getState()) return r } } } 通过闭包的形式， 我们让 fEnhancer 内部的逻辑 可以直接使用 getState。 那middleware是什么呢？ 这里的fEnhancer就是标准的一个 redux middleware, 是的，redux-logger可以不用了， 让我们用fEnhancer吧。 对应的 applyMiddleware： function applyMiddleware(store, ...args) { console.log(args) const enArr = args.map(middleware => middleware({ getState: store.getState, dispatch: store.dispatch })) let of = store.dispatch enArr.forEach(en => { of = en(of) }) store.dispatch = of } 现在， 给我们开头的reducer 增强一下吧！！ 在线地址 辅助函数 到这里， tineyredux其实已经结束了。 但是redux为了方便开发者 提供了两个辅助函数： combineReducers 和 bindActionCreators。 bindActionCreators 就是在 原本调用 actionCreator的时候，默认帮你dispatch一下： actionCreator() ==》 store.dispatch(actionCreator())。 也可以理解为 '增强': function bindActionCreator(creator, dispatch) { return function (...args) { dispatch(creator(args)) // { result[key] = bindActionCreator(creators[key], dispatch) }) return result } combineReducers 是为了解决另外的痛点， 比如如下的store 和reducer： { clock: { count: 0 }, yk: { age: 0 } ... } function reducer(state, action) { switch (action.type) { case 'clock_add':... case 'clock_cnum'... case 'yk_older': ... case 'yk_forever18': ... default: { return state } } } 大部分情况， 我们发现我们的应用，clock数据部分，对应clock自己的逻辑， yk数据部分的修改逻辑也只会关心自己（通常这都是2个页面的数据了）。 所以这里的一个 \"大switch\" 是可以切分的。 function clockReducer(state, action) { switch (action.type) { case 'clock_addOne': ... case 'clock_cnum': ... default: { return state } } } function ykReducer(state, action) { switch (action.type) { case 'yk_older': ... case 'yk_forever18': ... default: { return state } } } function reducer(state, action) { return { clock: clockReducer(state, action), yk: ykReducer(state, action), } } combineReducers 就是对小的reducer进行合并的： function combineReducers(reducers) { return function (state, action) { const keys = Object.keys(reducers) const newState = {} keys.forEach(key => { newState[key] = reducers[key](state[key], action) }) return newState } } 题外话： 这里的 combineReducers 如果小reducer特别多， 会有一些性能问题： 因为对于每一个 action，都是走了所有的reducer。 如果我们场景特殊， 是我们刚才说的 一块数据的逻辑 只对于一个reducer， 可以使用下面的变种(只会执行一个reducer， 需要保证action前缀和store中key一致)： function combineReducersVariant(reducers) { return function (state, action) { const lineIndex = action.type.indexOf(\"_\") const actionKey = action.type.substring(0, lineIndex) const newS = reducers[actionKey](state[actionKey], action) return state[actionKey] === newS ? state : { ...state, [actionKey]: newS } } } 其他 代码托管在 "},"React/源码分析/从0实现一个tiny-react-redux.html":{"url":"React/源码分析/从0实现一个tiny-react-redux.html","title":"从0实现一个tiny-react-redux","keywords":"","body":"从0实现一个tiny react-redux 从0实现一个tiny react-redux 从0实现一个tiny react-redux 不用react-redux connect Provider 其他 从0实现一个tiny react-redux react-redux 是一个连接react和redux的库， 方便把redux状态库在react中使用。 不用react-redux 先让我们来个裸的redux 和react结合的例子试试手 样例store（本文都会以这个store为例） import { createStore, applyMiddleware } from 'redux' import logger from 'redux-logger' function reduer(state, action) { switch (action.type) { case 'add': { return { ...state, count: state.count + 1 } } default: { return state } } } const store = createStore(reduer, { count: 0 }, applyMiddleware(logger)) 这个store接受一个 type为add的action。 假设现在有一个 组件HelloWorld 监听展示这个 store的count值。 class HelloWorld extends Component { constructor(props) { super(props) store.subscribe(() => { this.setState({}) }) } render() { const state = store.getState() return ( store.dispatch({type: 'add'})} style={{color: 'red'}} > {state.count} ) } } ReactDOM.render(, document.getElementById(\"root\")) 在线地址。 打开f12，当我们点击的时候 会发现有redux日志输出，并且渲染的值和store保持了一致。 connect HelloWorld 已经向我们展示了当react把状态交给redux的处理方式。 但是这里有这样的问题： redux侵入了每一个组件，每个组件都要引入store 每个组件和redux交互的逻辑，就是constructor里面监听， 取对应的state。。。诸多逻辑无法方便复用 让我们用react-redux的思路来思考这个问题。 react-redux需要做什么呢？ 组件要监听store 从store取出对应的数据，放到组件的props上 所以： class HelloWorld extends Component { render() { return ( store.dispatch({type: 'add'})} >{this.props.count} store.dispatch({type: 'delete'})} >xxx ) } } function reduxHoc(WrappedComponent, mapStateToProps) { return class Rh extends Component { constructor(props) { super(props) this.sub = store.subscribe(() => { this.setState({}) }) this._beforeProps = mapStateToProps(store.getState(), props) } componentWillUnmount() { this.sub() } shouldComponentUpdate() { const newProps = mapStateToProps(store.getState(), this.props) if (this._beforeProps === newProps) { return false } this._beforeProps = newProps return true } render() { return } } } HelloWorld = reduxHoc(HelloWorld, state => state) 这里的reduxHoc方法返回了一个React组件类，类比与“高阶函数”的概念，这里叫做“高价组件”。高阶组件详解。reduxHoc 接受2个参数WrappedComponent, mapStateToProps，分别是要被包装的组件（这里是HelloWorld)以及 把state映射到props的mapStateToProps。 返回的Rh组件此刻已经监听了store的变化，并且会把从store映射过来的props 传递给WrappedComponent组件。 react-redux的connect 方法不仅接受mapStateToProps，还接受mapDispatchToProps。更近一步，把reduxHoc改为connect吧 function connect(mapStateToProps, mapDispatchToProps) { return function (WrappedComponent) { return class Hoc extends Component { constructor(props, context) { super(props) this.unsubscribe = store.subscribe(() => { this.setState({}) }) this.memorizeProps = this.calculateProps() } calculateProps() { const o1 = mapStateToProps(store.getState(), this.props) let o2 = null if(mapDispatchToProps) { o2 = mapDispatchToProps(store.dispatch, this.props) } else { o2 = { dispatch: store.dispatch } } return { ...o1, ...o2 } } componentWillUnmount() { this.unsubscribe() this.unsubscribe = null } shouldComponentUpdate() { const nextProps = this.calculateProps() const isEqual = shallowEqual(nextProps, this.memorizeProps) if (isEqual) { return false } else { this.memorizeProps = nextProps return true } } render() { return ( ) } } } } function shallowEqual(objA, objB) { if (objA === objB) { return true; } const keysA = Object.keys(objA); const keysB = Object.keys(objB); if (keysA.length !== keysB.length) { return false; } // Test for A's keys different from B. const hasOwn = Object.prototype.hasOwnProperty; for (let i = 0; i 这里的connect使用方式和 react-redux的connect是一致的了（react-redux的connect其实接受4个参数）。有一点需要注意：reduxHoc和connect的shouldComponentUpdate 都只是 浅比较了引用， 这是因为redux库是无副作用的，所以来自redux库的对象只要引用相同就一定完全没有改变， 可以不用再次渲染。反过来说：如果store里面的值改变了，但是页面没有重新渲染，说明redux的逻辑写的有问题。 Provider 前面提到的connect方法， 虽然现在store没有侵入具体业务组件， 但是connect方法里面却用到了store。而我们在使用react-redux这个库的时候， 可能压根儿就不知道store在哪里。 或者我们需要把store传给这个库，来生成connect函数。 换一个角度， react不仅提供了props来传递数据。 还提供了context， context传递数据是透传的形式， 关于conext的详细介绍请看。 在最外层的根组件提供store， 然后所有的组件都可以通过context获取store。 class Provider extends Component { static childContextTypes = { store: PropTypes.object } getChildContext() { return { store: this.props.store } } render() { return Children.only(this.props.children) } } 对应的connect写法 function connect(mapStateToProps, mapDispatchToProps) { return function (WrappedComponent) { return class Hoc extends Component { static contextTypes = { store: PropTypes.object } constructor(props, context) { super(props) this.store = props.store || context.store this.unsubscribe = this.store.subscribe(() => { this.setState({}) }) this.memorizeProps = this.calculateProps() } calculateProps() { const o1 = mapStateToProps(this.store.getState(), this.props) let o2 = null if(mapDispatchToProps) { o2 = mapDispatchToProps(this.store.dispatch, this.props) } else { o2 = { dispatch: this.store.dispatch } } return { ...o1, ...o2 } } componentWillUnmount() { this.unsubscribe() this.unsubscribe = null } shouldComponentUpdate() { const nextProps = this.calculateProps() const isEqual = shallowEqual(nextProps, this.memorizeProps) if (isEqual) { return false } else { this.memorizeProps = nextProps return true } } render() { return ( ) } } } } 其他 代码托管在 安装： npm install tiny-tredux "},"React/源码分析/从0开始实现react-router.html":{"url":"React/源码分析/从0开始实现react-router.html","title":"从0开始实现react-router","keywords":"","body":"从0开始实现 react-router 从0开始实现 react-router history api 监听url改变 Route matchPath 渲染 Link Github & npm react-router 已经经历了好几个版本的大更新。 在这里我们打算参照v4.0的设计思想 创一个轮子: tiny-router history api 现代浏览器提供了 提供了对history栈中内容的操作的api。 重要的有 pushState, replaceState。 var stateObj = { foo: \"bar\" }; history.pushState(stateObj, \"page 2\", \"bar.html\"); 这将使浏览器地址栏显示为 http://xxxx/bar.html，但并不会导致浏览器加载 bar.html ，甚至不会检查bar.html 是否存在。 var stateObj = { foo: \"bar\" }; history.replaceState(stateObj, \"page 2\", \"bar.html\"); 这也将使浏览器地址显示 http://xxxx/bar.html， 也不会加载。 浏览器也不会检查bar.html 是否存在。 pushState和replaceState的区别在于 回退的时候。 push是在history栈中加了一个记录， 而repalce是替换一个记录。 这两个方法都接收3个参数， 分别是： 状态对象 — 状态对象state是一个JavaScript对象。 标题 URL — 该参数定义了新的历史URL记录。新URL必须与当前URL同源。 监听url改变 每当url改变的时候，视图view对应改变，就是一个基本的路由了。 通过history api可以很方便的修改url。 现在我们需要做的是监听每次url的改变，从而达到修改view的目的， 我们需要对history对象进行一些封装， 从而达到监听的目的。 代码如下： const his = window.history class History { constructor() { this.listeners = [] } push = path => { his.pushState({}, \"\", path); this.notifyAll() } listen = listener => { this.listeners.push(listener) return () => { this.listeners = this.listeners.filter(ele => ele !== listener) } } notifyAll = () => { this.listeners.forEach(lis => { lis() }) } } export default new History() 声明一个History类， 可以注册listener， 当push一个地址的时候， History类底层调用history.push 方法去修改路由， 然后通知注册的listener。 这样在路由改变的时候，我们的处理函数就可以第一时间的进行处理了。 Route react-router v4.0 里面最重要的组件莫过于Route。 这个组件接收一个path属性， 一旦url和path匹配， 就展示这个Route指定的组件。页面上一次可以展示出多个Route组件，只要Route的path属性和url匹配。 我们的Route 是一样的。 为了实现这个效果， 我们需要在每次url变化的时候检测新的url和path是否匹配,一旦匹配，就展示对应的组件。这就需要每个Route组件在初始化的时候在History上注册一个监听器， 从而让Route可以及时的响应url变化 代码如下： class Route extends Component { constructor(props) { super(props) this.state = { match: matchPath(...) } this.unlisten = history.listen(this.urlChange) } componentWillUnmount() { this.unlisten() } urlChange = () => { const pathname = location.pathname this.setState({ match: matchPath(...) }) } render() { const { match } = this.state if(!match) return // 具体的渲染... } } matchPath Route的path 可以是字符串或者正则表达式。 除此之外Route还有 exact（精确匹配）， strict（结尾/）， sensitive(大小写)这3个属性。 他们共同决定了一个匹配url的正则表达式PathReg（这里的匹配规则和react-router是完全一样的）。 我们假定path， exact， strict， sensitive属性是不可改变的（实际上来说， 也的确没有修改它们的必要）。 这样话， 我们就可以在Route组件初始化的时候生成这个PathReg。 const compilePath = (pattern = '/', options) => { const { exact = false, strict = false, sensitive = false } = options const keys = [] const re = pathToRegexp(pattern, keys, { end: exact, strict, sensitive }) return { re, keys } } class Route extends Component { static propTypes = { path: PropTypes.string, component: PropTypes.func, render: PropTypes.func, exact: PropTypes.bool, strict: PropTypes.bool, } constructor(props) { super(props) this.pathReAndKeys = compilePath(props.path, { exact: props.exact, strict: props.strict, sensitive: props.sensitive }) this.state = { match: matchPath(...) } this.unlisten = history.listen(this.urlChange) } } 我们在组件的constructor里面， 预先生成了pathReAndKeys。 然后在每次matchPath的时候， 直接使用这个正则。 mathPath的代码如下： const matchPath = (pathname, props, pathReAndKeys) => { const { path = '/', exact = false } = props const { re, keys } = pathReAndKeys const match = re.exec(pathname) if (!match) return null const [ url, ...values ] = match const isExact = pathname === url if (exact && !isExact) return null return { path, // the path pattern used to match url: path === '/' && url === '' ? '/' : url, // the matched portion of the URL isExact, // whether or not we matched exactly params: keys.reduce((memo, key, index) => { memo[key.name] = values[index] return memo }, {}) } } 当路由不匹配的时候， 直接返回null。 否则返回一个匹配信息的对象。 例如： url path match.params /user /user {} /user/12 /user/:id {id: '12'} /user/12/update /user/:id/:op {id: 12, op: 'update'} 这里处理路径用了path-to-regexp 这个库。 渲染 匹配路径只是过程， 渲染出对应的view才是最终的目标！Route组件提供了 3个属性： component， render， children。 具体用法如下： // one class A extends Component { render() { return A } } // Route默认会把匹配的信息注入到组件A的props // two (A)} // three Route默认会把匹配的信息注入到组件A的props 完整的Route 代码如下： import React, { Component } from 'react' import PropTypes from 'prop-types' import { compilePath, matchPath } from './util' import history from './history' class Route extends Component { static propTypes = { path: PropTypes.string, component: PropTypes.func, render: PropTypes.func, exact: PropTypes.bool, strict: PropTypes.bool, } constructor(props) { super(props) this.pathReAndKeys = compilePath(props.path, { exact: props.exact, strict: props.strict, sensitive: props.sensitive }) this.state = { match: matchPath(location.pathname, props, this.pathReAndKeys) } this.unlisten = history.listen(this.urlChange) } componentWillReceiveProps(nextProps) { const {path, exact, strict} = this.props if (nextProps.path !== path || nextProps.exact !== exact || nextProps.strict !== strict) { console.warn(\"you should not change path, exact, strict props\") } } componentWillUnmount() { this.unlisten() } urlChange = () => { const pathname = location.pathname this.setState({ match: matchPath(pathname, this.props, this.pathReAndKeys) }) } render() { const { match } = this.state if(!match) return const { children, component, render } = this.props if (component) { const Comp = component return } if (render) { return render({ match }) } return React.cloneElement(React.Children.only(children), { match }) } } export default Route Link 与react-router相同。 我们同样提供一个Link组件， 来实现 “声明式”的路由跳转。 Link本质上来说就是一个原生的a标签， 然后在点击的时候history.push到to属性所指定的地址去。 import React, { Component } from 'react' import history from './history' export default class Link extends Component { handleClick = e => { const { onClick, to } = this.props if (onClick){ onClick(e) } e.preventDefault() history.push(to) } render() { return ( ) } } Github & npm 代码托管在git 安装 npm install tinyy-router (注意是 tinyy 两个y，因为tiny-router已经被使用了) "},"React/源码分析/路由实现及react-router-v4源码分析.html":{"url":"React/源码分析/路由实现及react-router-v4源码分析.html","title":"路由实现及react-router v4源码分析","keywords":"","body":"前端路由实现及 react-router v4 源码分析 前端路由实现及 react-router v4 源码分析 前言 路由 SPA 路由实现 hash 路由 基于 history 的路由实现 react 中的路由 源码分析 预备知识 history match location packages Router Route Switch matchPath Link withRouter 理解 前言 react-router 目前作为 react 最流行的路由管理库，已经成为了某种意义上的官方路由库（不过下一代的路由库 reach-router 已经蓄势待发了），并且更新到了 v4 版本，完成了一切皆组件的升级。本文将对 react-router v4（以下简称 rr4） 的源码进行分析，来理解 rr4 是如何帮助我们管理路由状态的。 路由 在分析源码之前，先来对路由有一个认识。在 SPA 盛行之前，还不存在前端层面的路由概念，每个 URL 对应一个页面，所有的跳转或者链接都通过 标签来完成，随着 SPA 的逐渐兴盛及 HTML5 的普及，hash 路由及基于 history 的路由库越来越多。 路由库最大的作用就是同步 URL 与其对应的回调函数。对于基于 history 的路由，它通过 history.pushState 来修改 URL，通过 window.addEventListener('popstate', callback) 来监听前进/后退事件；对于 hash 路由，通过操作 window.location 的字符串来更改 hash，通过 window.addEventListener('hashchange', callback) 来监听 URL 的变化。 SPA 路由实现 hash 路由 class Router { constructor() { // 储存 hash 与 callback 键值对 this.routes = {}; // 当前 hash this.currentUrl = ''; // 记录出现过的 hash this.history = []; // 作为指针,默认指向 this.history 的末尾,根据后退前进指向 history 中不同的 hash this.currentIndex = this.history.length - 1; this.backIndex = this.history.length - 1 this.refresh = this.refresh.bind(this); this.backOff = this.backOff.bind(this); // 默认不是后退操作 this.isBack = false; window.addEventListener('load', this.refresh, false); window.addEventListener('hashchange', this.refresh, false); } route(path, callback) { this.routes[path] = callback || function() {}; } refresh() { console.log('refresh') this.currentUrl = location.hash.slice(1) || '/'; this.history.push(this.currentUrl); this.currentIndex++; if (!this.isBack) { this.backIndex = this.currentIndex } this.routes[this.currentUrl](); console.log('指针:', this.currentIndex, 'history:', this.history); this.isBack = false; } // 后退功能 backOff() { // 后退操作设置为true console.log(this.currentIndex) console.log(this.backIndex) this.isBack = true; this.backIndex 完整实现 hash-router，参考 hash router 。 其实知道了路由的原理，想要实现一个 hash 路由并不困难，比较需要注意的是 backOff 的实现，包括 hash router 中对 backOff 的实现也是有 bug 的，浏览器的回退会触发 hashChange 所以会在 history 中 push 一个新的路径，也就是每一步都将被记录。所以需要一个 backIndex 来作为返回的 index 的标识，在点击新的 URL 的时候再将 backIndex 回归为 this.currentIndex。 基于 history 的路由实现 class Routers { constructor() { this.routes = {}; // 在初始化时监听popstate事件 this._bindPopState(); } // 初始化路由 init(path) { history.replaceState({path: path}, null, path); this.routes[path] && this.routes[path](); } // 将路径和对应回调函数加入hashMap储存 route(path, callback) { this.routes[path] = callback || function() {}; } // 触发路由对应回调 go(path) { history.pushState({path: path}, null, path); this.routes[path] && this.routes[path](); } // 后退 backOff(){ history.back() } // 监听popstate事件 _bindPopState() { window.addEventListener('popstate', e => { const path = e.state && e.state.path; this.routes[path] && this.routes[path](); }); } } 参考 H5 Router 相比 hash 路由，h5 路由不再需要有些丑陋去的去修改 window.location 了，取而代之使用 history.pushState 来完成对 window.location 的操作，使用 window.addEventListener('popstate', callback) 来对前进/后退进行监听，至于后退则可以直接使用 window.history.back() 或者 window.history.go(-1) 来直接实现，由于浏览器的 history 控制了前进/后退的逻辑，所以实现简单了很多。 react 中的路由 react 作为一个前端视图框架，本身是不具有除了 view （数据与界面之间的抽象）之外的任何功能的，为 react 引入一个路由库的目的与上面的普通 SPA 目的一致，只不过上面路由更改触发的回调函数是我们自己写的操作 DOM 的函数；在 react 中我们不直接操作 DOM，而是管理抽象出来的 VDOM 或者说 JSX，对 react 的来说路由需要管理组件的生命周期，对不同的路由渲染不同的组件。 源码分析 预备知识 在前面我们了解了创建路由的目的，普通 SPA 路由的实现及 react 路由的目的，先来认识一下 rr4 的周边知识，然后就开始对 react-router 的源码分析。 history history 库，是 rr4 依赖的一个对 window.history 加强版的 history 库。 match 源自 history 库，表示当前的 URL 与 path 的匹配的结果 match: { path: \"/\", // 用来匹配的 path url: \"/\", // 当前的 URL params: {}, // 路径中的参数 isExact: pathname === \"/\" // 是否为严格匹配 } location 还是源自 history 库，是 history 库基于 window.location 的一个衍生。 hash: \"\" // hash key: \"nyi4ea\" // 一个 uuid pathname: \"/explore\" // URL 中路径部分 search: \"\" // URL 参数 state: undefined // 路由跳转时传递的 state 我们带着问题去分析源码，先逐个分析每个组件的作用，在最后会有回答，在这里先举一个 rr4 的小 DEMO 页面初始化时的渲染过程？ 点击一个 Link 跳转及渲染更新的过程？ packages rr4 将路由拆成了几个包 —— react-router 负责通用的路由逻辑，react-router-dom 负责浏览器的路由管理，react-router-native 负责 react-native 的路由管理，通用的部分直接从 react-router 中导入，用户只需引入 react-router-dom 或 react-router-native 即可，react-router 作为依赖存在不再需要单独引入。 Router import React from 'react' import { render } from 'react-dom' import { BrowserRouter } from 'react-router-dom' import App from './components/App'; render(){ return( ) )} 这是我们调用 Router 的方式，这里拿 BrowserRouter 来举例。 BrowserRouter 的源码在 react-router-dom 中，它是一个高阶组件，在内部创建一个全局的 history 对象（可以监听整个路由的变化），并将 history 作为 props 传递给 react-router 的 Router 组件（Router 组件再会将这个 history 的属性作为 context 传递给子组件） render() { return ; } 其实整个 Router 的核心是在 react-router 的 Router 组件中，如下，借助 context 向 Route 传递组件，这也解释了为什么 Router 要在所有 Route 的外面。 getChildContext() { return { router: { ...this.context.router, history: this.props.history, route: { location: this.props.history.location, match: this.state.match } } }; } 这是 Router 传递给子组件的 context，事实上 Route 也会将 router 作为 context 向下传递，如果我们在 Route 渲染的组件中加入 static contextTypes = { router: PropTypes.shape({ history: PropTypes.object.isRequired, route: PropTypes.object.isRequired, staticContext: PropTypes.object }) }; 来通过 context 访问 router，不过 rr4 一般通过 props 传递，将 history, location, match 作为三个独立的 props 传递给要渲染的组件，这样访问起来方便一点（实际上已经完全将 router 对象的属性完全传递了）。 在 Router 的 componentWillMount 中， 添加了 componentWillMount() { const { children, history } = this.props; invariant( children == null || React.Children.count(children) === 1, \"A may have only one child element\" ); // Do this here so we can setState when a changes the // location in componentWillMount. This happens e.g. when doing // server rendering using a . this.unlisten = history.listen(() => { this.setState({ match: this.computeMatch(history.location.pathname) }); }); } history.listen 能够监听路由的变化并执行回调事件。 在这里每次路由的变化执行的回调事件为 this.setState({ match: this.computeMatch(history.location.pathname) }); 相比于在 setState 里做的操作，setState 本身的意义更大 —— 每次路由变化 -> 触发顶层 Router 的回调事件 -> Router 进行 setState -> 向下传递 nextContext（context 中含有最新的 location）-> 下面的 Route 获取新的 nextContext 判断是否进行渲染。 之所以把这个 subscribe 的函数写在 componentWillMount 里，就像源码中给出的注释：是为了 SSR 的时候，能够使用 Redirect。 Route Route 的作用是匹配路由，并传递给要渲染的组件 props。 在 Route 的 componentWillReceiveProps 中 componentWillReceiveProps(nextProps, nextContext) { ... this.setState({ match: this.computeMatch(nextProps, nextContext.router) }); } Route 接受上层的 Router 传入的 context，Router 中的 history 监听着整个页面的路由变化，当页面发生跳转时，history 触发监听事件，Router 向下传递 nextContext，就会更新 Route 的 props 和 context 来判断当前 Route 的 path 是否匹配 location，如果匹配则渲染，否则不渲染。 是否匹配的依据就是 computeMatch 这个函数，在下文会有分析，这里只需要知道匹配失败则 match 为 null，如果匹配成功则将 match 的结果作为 props 的一部分，在 render 中传递给传进来的要渲染的组件。 接下来看一下 Route 的 render 部分。 render() { const { match } = this.state; // 布尔值，表示 location 是否匹配当前 Route 的 path const { children, component, render } = this.props; // Route 提供的三种可选的渲染方式 const { history, route, staticContext } = this.context.router; // Router 传入的 context const location = this.props.location || route.location; const props = { match, location, history, staticContext }; if (component) return match ? React.createElement(component, props) : null; // Component 创建 if (render) return match ? render(props) : null; // render 创建 if (typeof children === \"function\") return children(props); // 回调 children 创建 if (children && !isEmptyChildren(children)) // 普通 children 创建 return React.Children.only(children); return null; } rr4 提供了三种渲染组件的方法：component props，render props 和 children props，渲染的优先级也是依次按照顺序，如果前面的已经渲染后了，将会直接 return。 component (props) —— 由于使用 React.createElement 创建，所以可以传入一个 class component。 render (props) —— 直接调用 render() 展开子元素，所以需要传入 stateless function component。 children (props) —— 其实和 render 差不多，区别是不判断 match，总是会被渲染。 children（子元素）—— 如果以上都没有，那么会默认渲染子元素，但是只能有一个子元素。 这里解释一下官网的 tips，component 是使用 React.createElement 来创建新的元素，所以如果传入一个内联函数，比如 (hello world)} 的话，由于每次的 props.component 都是新创建的，所以 React 在 diff 的时候会认为进来了一个全新的组件，所以会将旧的组件 unmount，再 re-mount。这时候就要使用 render，少了一层包裹的 component 元素，render 展开后的元素类型每次都是一样的，就不会发生 re-mount 了（children 也不会发生 re-mount）。 Switch 我们紧接着 Route 来看 Switch，Switch 是用来嵌套在 Route 的外面，当 Switch 中的第一个 Route 匹配之后就不会再渲染其他的 Route 了。 render() { const { route } = this.context.router; const { children } = this.props; const location = this.props.location || route.location; let match, child; React.Children.forEach(children, element => { if (match == null && React.isValidElement(element)) { const { path: pathProp, exact, strict, sensitive, from } = element.props; const path = pathProp || from; child = element; match = matchPath( location.pathname, { path, exact, strict, sensitive }, route.match ); } }); return match ? React.cloneElement(child, { location, computedMatch: match }) : null; } Switch 也是通过 matchPath 这个函数来判断是否匹配成功，一直按照 Switch 中 children 的顺序依次遍历子元素，如果匹配失败则 match 为 null，如果匹配成功则标记这个子元素和它对应的 location、computedMatch。在最后的时候使用 React.cloneElement 渲染，如果没有匹配到的子元素则返回 null。 接下来我们看下 matchPath 是如何判断 location 是否符合 path 的。 matchPath matchPath 返回的是一个如下结构的对象 { path, // 用来进行匹配的路径，其实是直接导出的传入 matchPath 的 options 中的 path url: path === \"/\" && url === \"\" ? \"/\" : url, // 整个的 URL isExact, // url 与 path 是否是 exact 的匹配 // 返回的是一个键值对的映射 // 比如你的 path 是 /users/:id，然后匹配的 pathname 是 /user/123 // 那么 params 的返回值就是 {id: '123'} params: keys.reduce((memo, key, index) => { memo[key.name] = values[index]; return memo; }, {}) } 这些信息将作为匹配的参数传递给 Route 和 Switch（Switch 只是一个代理，它的作用还是渲染 Route，Switch 计算得到的 computedMatch 会传递给要渲染的 Route，此时 Route 将直接使用这个 computedMatch 而不需要再自己来计算）。 在 matchPath 内部 compilePath 时，有个 const patternCache = {}; const cacheLimit = 10000; let cacheCount = 0; 作为 pathToRegexp 的缓存，因为 ES6 的 import 模块导出的是值的引用，所以将 patternCache 可以理解为一个全局变量缓存，缓存以 {option:{pattern: }} 的形式存储，之后如果需要匹配相同 pattern 和 option 的 path，则可以直接从缓存中获得正则表达式和 keys。 加缓存的原因是路由页面大部分情况下都是相似的，比如要访问 /user/123 或 /users/234，都会使用 /user/:id 这个 path 去匹配，没有必要每次都生成一个新的正则表达式。SPA 在页面整个访问的过程中都维护着这份缓存。 Link 实际上我们可能写的最多的就是 Link 这个标签了，我们从它的 render 函数开始看 render() { const { replace, to, innerRef, ...props } = this.props; // eslint-disable-line no-unused-vars invariant( this.context.router, \"You should not use outside a \" ); invariant(to !== undefined, 'You must specify the \"to\" property'); const { history } = this.context.router; const location = typeof to === \"string\" ? createLocation(to, null, null, history.location) : to; const href = history.createHref(location); // 最终创建的是一个 a 标签 return ( ); } 可以看到 Link 最终还是创建一个 a 标签来包裹住要跳转的元素，但是如果只是一个普通的带 href 的 a 标签，那么就会直接跳转到一个新的页面而不是 SPA 了，所以在这个 a 标签的 handleClick 中会 preventDefault 禁止默认的跳转，所以这里的 href 并没有实际的作用，但仍然可以标示出要跳转到的页面的 URL 并且有更好的 html 语义。 在 handleClick 中，对没有被 “preventDefault的 && 鼠标左键点击的 && 非 _blank 跳转 的&& 没有按住其他功能键的“ 单击进行 preventDefault，然后 push 进 history 中，这也是前面讲过的 —— 路由的变化 与 页面的跳转 是不互相关联的，rr4 在 Link 中通过 history 库的 push 调用了 HTML5 history 的 pushState，但是这仅仅会让路由变化，其他什么都没有改变。还记不记得 Router 中的 listen，它会监听路由的变化，然后通过 context 更新 props 和 nextContext 让下层的 Route 去重新匹配，完成需要渲染部分的更新。 handleClick = event => { if (this.props.onClick) this.props.onClick(event); if ( !event.defaultPrevented && // onClick prevented default event.button === 0 && // ignore everything but left clicks !this.props.target && // let browser handle \"target=_blank\" etc. !isModifiedEvent(event) // ignore clicks with modifier keys ) { event.preventDefault(); const { history } = this.context.router; const { replace, to } = this.props; if (replace) { history.replace(to); } else { history.push(to); } } }; withRouter const withRouter = Component => { const C = props => { const { wrappedComponentRef, ...remainingProps } = props; return ( ( )} /> ); }; C.displayName = `withRouter(${Component.displayName || Component.name})`; C.WrappedComponent = Component; C.propTypes = { wrappedComponentRef: PropTypes.func }; return hoistStatics(C, Component); }; export default withRouter; withRouter 的作用是让我们在普通的非直接嵌套在 Route 中的组件也能获得路由的信息，这时候我们就要 WithRouter(wrappedComponent) 来创建一个 HOC 传递 props，WithRouter 的其实就是用 Route 包裹了 SomeComponent 的一个 HOC。 创建 Route 有三种方法，这里直接采用了传递 children props 的方法，因为这个 HOC 要原封不动的渲染 wrappedComponent（children props 比较少用得到，某种程度上是一个内部方法）。 在最后返回 HOC 时，使用了 hoistStatics 这个方法，这个方法的作用是保留 SomeComponent 类的静态方法，因为 HOC 是在 wrappedComponent 的外层又包了一层 Route，所以要将 wrappedComponent 类的静态方法转移给新的 Route，具体参见 Static Methods Must Be Copied Over。 理解 现在回到一开始的问题，重新理解一下点击一个 Link 跳转的过程。 有两件事需要完成： 路由的改变 页面的渲染部分的改变 过程如下： 在最一开始 mount Router 的时候，Router 在 componentWillMount 中 listen 了一个回调函数，由 history 库管理，路由每次改变的时候触发这个回调函数。这个回调函数会触发 setState。 当点击 Link 标签的时候，实际上点击的是页面上渲染出来的 a 标签，然后通过 preventDefault 阻止 a 标签的页面跳转。 Link 中也能拿到 Router -> Route 中通过 context 传递的 history，执行 hitsory.push(to)，这个函数实际上就是包装了一下 window.history.pushState()，是 HTML5 history 的 API，但是 pushState 之后除了地址栏有变化其他没有任何影响，到这一步已经完成了目标1：路由的改变。 第1步中，路由改变是会触发 Router 的 setState 的，在 Router 那章有写道：每次路由变化 -> 触发顶层 Router 的监听事件 -> Router 触发 setState -> 向下传递新的 nextContext（nextContext 中含有最新的 location） 下层的 Route 拿到新的 nextContext 通过 matchPath 函数来判断 path 是否与 location 匹配，如果匹配则渲染，不匹配则不渲染，完成目标2：页面的渲染部分的改变。 "},"React/dva/React+DvaJS之hook路由权限控制.html":{"url":"React/dva/React+DvaJS之hook路由权限控制.html","title":"React+DvaJS 之 hook 路由权限控制","keywords":"","body":"React+DvaJS 之 hook 路由权限控制 在model的subscriptions中进行匹配，分发到effects中进行判断和跳转 effects 有三个参数: put 用于触发 action 。 yield put({ type: 'todos/add', payload: 'Learn Dva' }); call 用于调用异步逻辑，支持 promise 。 const result = yield call(fetch, '/todos'); select 用于从 state 里获取数据。 const todos = yield select(state => state.todos); 基于 action 进行页面跳转 import { routerRedux } from 'dva/router'; // Inside Effects yield put(routerRedux.push('/logout')); // Outside Effects dispatch(routerRedux.push('/logout')); // With query routerRedux.push({ pathname: '/logout', query: { page: 2, }, }); 除 push(location) 外还有更多方法，详见这里 示例如下： state: { isLogin: false, loginfail:false, }, subscriptions: { setup({ dispatch, history }) { history.listen(location => { if (location.pathname.includes('app')) { dispatch({ type: 'loginhook', }); } }); }, }, effects: { * login({ payload },{call, put}) { const { data } = yield call(login, payload); if (data && data.success) { yield put({ type: 'checklogin', payload:{ isLogin:true, } }); yield put(routerRedux.push('/app/users')); }else{ yield put({ type: 'loginfail', payload:{ loginfail:true, } }); } }, * loginhook({ payload },{select,call, put}){ const isLogin = yield select(({session}) => session.isLogin); console.log('logincheck',isLogin); if(isLogin === false){ yield put((routerRedux.push('/login'))); } }, }, reducers: { checklogin(state,action) { return {...state,isLogin:action.payload.isLogin }; }, loginfail(state,action) { return {...state, loginfail:action.payload.loginfail}; }, } "},"React/react-native/react-native.html":{"url":"React/react-native/react-native.html","title":"React Native","keywords":"","body":"1. start $ brew update && brew doctor $ xcode-select --install $ brew install watchman $ brew install flow $ npm install react-native-cli -g $ android-sdk $ brew install android-sdk $ brew cask install java # 安装java sdk $ vi ~/.bash_profile $ android 北京 朝阳区 黄杉木店路9号绿森时代广场7层 2. mac os x配置adb全局命令的方法 步骤如下: 启动终端Terminal （如果当前用户文件夹下已有.bash_profile文件，则直接跳到5） 进入当前用户的home目录（命令行输入echo $HOME） 创建.bash_profile（命令行输入touch .bash_profile） 打开.bash_profile文件（命令行输入open -e .bash_profile） 编辑.bash_profile文件 在.bash_profile文件中输入 export PATH=/Users/JianDan/dev_android/adt-bundle-mac-x86_64-20130729/sdk/platform-tools/:$PATH 注意：在网上搜索了很多文章，多数写的是 PATH=${PATH}:/eclipse/android_sdk/platform-tools（这样写的解释 是：如果是需要添加很多命令到PATH下时，需要用“:”(英文的冒号)隔开即可，因为android和adb这些命令是在不同的 文件夹中的，这样才能两者兼得.），而没有最后面:$PATH，结果我重复了N次创建删除 .bash_profile文件，也复制 粘贴了N次PATH=${PATH}:/eclipse/android_sdk/platform-tools，就是配置不对。 保存文件，关闭.bash_profile 更新刚配置的环境变量 输入source .bash_profile 验证配置是否成功 adb shell 3. my .bash_profile configuration # nvm export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\" # This loads nvm # emulator export PATH=/Users/admin/Library/Android/sdk/emulator/:$PATH # adb export PATH=/Users/admin/Library/Android/sdk/platform-tools/:$PATH 4. android 模拟器 $ cd ~/Library/Android/sdk/emulator $ ./emulator -list-avds $ ./emulator @name # or $ emulator -list-avds $ emulator -avd name 5. zshrc 配置 $ cd ~ $ open .zshrc # 在.zshrc文件末尾增加.bash_profile的引用： source ~/.bash_profile # 保存后更新配置 $ source .zshrc 6. zsh & bash 切换 $ chsh -s /bin/zsh # or $ chsh -s `which zsh` # 如果要切换回去bash： $ chsh -s /bin/bash "},"Vue/Vue生命周期.html":{"url":"Vue/Vue生命周期.html","title":"Vue生命周期分析","keywords":"","body":"生命周期分析 生命周期函数就是组件在初始化或者数据更新时会触发的钩子函数。 在初始化时，会调用以下代码，生命周期就是通过 callHook 调用的 Vue.prototype._init = function(options) { initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, 'beforeCreate') // 拿不到 props data initInjections(vm) initState(vm) initProvide(vm) callHook(vm, 'created') } 可以发现在以上代码中，beforeCreate 调用的时候，是获取不到 props 或者 data 中的数据的，因为这些数据的初始化都在 initState 中。 接下来会执行挂载函数 export function mountComponent { callHook(vm, 'beforeMount') // ... if (vm.$vnode == null) { vm._isMounted = true callHook(vm, 'mounted') } } beforeMount 就是在挂载前执行的，然后开始创建 VDOM 并替换成真实 DOM，最后执行 mounted 钩子。这里会有个判断逻辑，如果是外部 new Vue({}) 的话，不会存在 $vnode ，所以直接执行 mounted 钩子了。如果有子组件的话，会递归挂载子组件，只有当所有子组件全部挂载完毕，才会执行根组件的挂载钩子。 接下来是数据更新时会调用的钩子函数 function flushSchedulerQueue() { // ... for (index = 0; index MAX_UPDATE_COUNT) { warn( 'You may have an infinite update loop ' + (watcher.user ? `in watcher with expression \"${watcher.expression}\"` : `in a component render function.`), watcher.vm ) break } } } callUpdatedHooks(updatedQueue) } function callUpdatedHooks(queue) { let i = queue.length while (i--) { const watcher = queue[i] const vm = watcher.vm if (vm._watcher === watcher && vm._isMounted) { callHook(vm, 'updated') } } } 上图还有两个生命周期没有说，分别为 activated 和 deactivated ，这两个钩子函数是 keep-alive 组件独有的。用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。 最后就是销毁组件的钩子函数了 Vue.prototype.$destroy = function() { // ... callHook(vm, 'beforeDestroy') vm._isBeingDestroyed = true // remove self from parent const parent = vm.$parent if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) { remove(parent.$children, vm) } // teardown watchers if (vm._watcher) { vm._watcher.teardown() } let i = vm._watchers.length while (i--) { vm._watchers[i].teardown() } // remove reference from data ob // frozen object may not have observer. if (vm._data.__ob__) { vm._data.__ob__.vmCount-- } // call the last hook... vm._isDestroyed = true // invoke destroy hooks on current rendered tree vm.__patch__(vm._vnode, null) // fire destroyed hook callHook(vm, 'destroyed') // turn off all instance listeners. vm.$off() // remove __vue__ reference if (vm.$el) { vm.$el.__vue__ = null } // release circular reference (##6759) if (vm.$vnode) { vm.$vnode.parent = null } } 在执行销毁操作前会调用 beforeDestroy 钩子函数，然后进行一系列的销毁操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕后才会执行根组件的 destroyed 钩子函数。 "},"Vue/vueRouter使用query和params传参的使用和区别.html":{"url":"Vue/vueRouter使用query和params传参的使用和区别.html","title":"vueRouter使用query和params传参的使用和区别","keywords":"","body":"vueRouter使用query和params传参的使用和区别 基础 router-link跳转router1 params：/router1/:id ，/router1/123，/router1/789 ,这里的id叫做params query：/router1?id=123 ,/router1?id=456 ,这里的id叫做query。 params传参和query传参有什么区别： 用法上的刚query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。注意接收参数的时候，已经是$route而不是$router了哦！！ 展示上的query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示 params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。params一旦设置在路由，params就是路由的一部分，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。 比如：跳转/router1/:id 正确 错误 params、query不设置也可以传参，params不设置的时候，刷新页面或者返回参数会丢失，这一点的在上面说过了 "},"Vue/Vue组件data为什么必须是函数.html":{"url":"Vue/Vue组件data为什么必须是函数.html","title":"Vue组件data为什么必须是函数","keywords":"","body":"Vue 组件data为什么必须是函数？ 在创建或注册模板的时候，传入一个data属性作为用来绑定的数据。但是在组件中，data必须是一个函数，而不能直接把一个对象赋值给它。 Vue.component('my-component', { template: 'OK', data() { return {} // 返回一个唯一的对象，不要和其他组件共用一个对象进行返回 }, }) 在前面看到，在new Vue()的时候，是可以给data直接赋值为一个对象的。这是怎么回事，为什么到了组件这里就不行了。 你要理解，上面这个操作是一个简易操作，实际上，它首先需要创建一个组件构造器，然后注册组件。注册组件的本质其实就是建立一个组件构造器的引用。使用组件才是真正创建一个组件实例。所以，注册组件其实并不产生新的组件类，但会产生一个可以用来实例化的新方式。 理解这点之后，再理解js的原型链： var MyComponent = function() {} MyComponent.prototype.data = { a: 1, b: 2, } // 上面是一个虚拟的组件构造器，真实的组件构造器方法很多 var component1 = new MyComponent() var component2 = new MyComponent() // 上面实例化出来两个组件实例，也就是通过调用，创建的两个实例 component1.data.a === component2.data.a // true component1.data.b = 5 component2.data.b // 5 可以看到上面代码中最后三句，这就比较坑爹了，如果两个实例同时引用一个对象，那么当你修改其中一个属性的时候，另外一个实例也会跟着改。这怎么可以，两个实例应该有自己各自的域才对。所以，需要通过下面方法来进行处理： var MyComponent = function() { this.data = this.data() } MyComponent.prototype.data = function() { return { a: 1, b: 2, } } var MyComponent = function() { this.data = this.data() } MyComponent.prototype.data = function() { return { a: 1, b: 2, } } function () { return { a: 1, b: 2, } } var component1 = new MyComponent() var component2 = new MyComponent() undefined component1.data===component2.data false component1.data Object {a: 1, b: 2} 这样每一个实例的data属性都是独立的，不会相互影响了。所以，你现在知道为什么vue组件的data必须是函数了吧。这都是因为js本身的特性带来的，跟vue本身设计无关。其实vue不应该把这个方法名取为data()，应该叫setData或其他更容易立即的方法名。 "},"Vue/Vue组件通信的方法.html":{"url":"Vue/Vue组件通信的方法.html","title":"Vue组件通信的方法","keywords":"","body":"Vue组件通信的方法 Vue组件通信的方法 通过设置监听单一事件可以管理组件之间的通信 通过设置监听单一事件可以管理组件之间的通信 【组件】是Vue框架的最核心的概念，通过Vue构建的应用，每一个模块都可以看成是一个单独的组件，那么每个组件之间就避免不了要互相通信、传输数据，其中一种方法：通过设置监听单一事件可以管理组件之间的通信，彼此传输数据，具体方法如下： 比如现在有三个组件：组件a、组件b和组件c，点击组件a和b中的按钮，将它们各自的数据传输给组件c并加以显示，这样就涉及到了组件a或b动态修改组件c中的数据这个问题了。 html部分： js部分： //new一个空中vue对象，用于操作$emit、和$on事件 var Fn = new Vue(); //组件a var A = { template : ` 这是a组件的数据 释放a组件的数据 `, data : function(){ return { a : '这是a组件的数据！！！' } }, methods : { //设置一个方法，设置一个data-a事件，并传输当前this.a的数据 func : function(){ Fn.$emit('data-a', this.a); } } } //组件b var B = { template : ` 这是b组件的数据 释放b组件的数据 `, data : function(){ return { a : '这是b组件的数据！！！' } }, methods : { //设置一个方法，设置一个data-b事件，并传输当前this.a的数据 func : function(){ Fn.$emit('data-b', this.a); } } } //组件c var C = { template : ` 这是c组件的数据： 获取a组件中的数据为:{{a}} 获取b组件中的数据为：{{b}} `, data : function(){ return { a : '', b : '' } }, mounted : function(){ var This = this; //监听到data-a事件是否有发生变化，如果发生变化，则取到想对应的数据（回调函数的参数） Fn.$on('data-a', function(msg){ //这一这里不能用this.a来获取数据，因为this指向不同 This.a = msg; }); //监听到data-b事件是否有发生变化，如果发生变化，则取到想对应的数据（回调函数的参数） Fn.$on('data-b', function(msg){ this.b = msg; }.bind(this));//通过bind方法来改变this指向 } } //实例化vue对象 new Vue({ el : '#wrap', components : { 'my-a' : A, 'my-b' : B, 'my-c' : C } }); "},"Vue/vue中8种组件通信方式.html":{"url":"Vue/vue中8种组件通信方式.html","title":"vue中8种组件通信方式","keywords":"","body":"vue中8种组件通信方式 vue中8种组件通信方式 一、props / $emit 1. 父组件向子组件传值 2. 子组件向父组件传值 二、 $children / $parent 三、provide/ inject 概念: 举例验证 四、ref / refs 五、eventBus 六、Vuex 1. Vuex介绍 2. Vuex各个模块 3. Vuex实例应用 七、 localStorage / sessionStorage 八、 $attrs与 $listeners 总结 一、props / $emit 父组件通过 props 的方式向子组件传递数据，而通过 $emit 子组件可以向父组件通信。 1. 父组件向子组件传值 下面通过一个例子说明父组件如何向子组件传递数据：在子组件article.vue中如何获取父组件section.vue中的数据articles:['红楼梦', '西游记','三国演义'] // section父组件 import comArticle from './test/article.vue' export default { name: 'HelloWorld', components: { comArticle }, data() { return { articleList: ['红楼梦', '西游记', '三国演义'] } } } // 子组件 article.vue {{item}} export default { props: ['articles'] } 总结: prop 只可以从上一级组件传递到下一级组件（父子组件），即所谓的单向数据流。而且 prop 只读，不可被修改，所有修改都会失效并警告。 2. 子组件向父组件传值 对于$emit 我自己的理解是这样的: $emit绑定一个自定义事件, 当这个语句被执行时, 就会将参数arg传递给父组件,父组件通过v-on监听并接收参数。 通过一个例子，说明子组件如何向父组件传递数据。 在上个例子的基础上, 点击页面渲染出来的ariticle的item, 父组件中显示在数组中的下标 // 父组件中 {{currentIndex}} import comArticle from './test/article.vue' export default { name: 'HelloWorld', components: { comArticle }, data() { return { currentIndex: -1, articleList: ['红楼梦', '西游记', '三国演义'] } }, methods: { onEmitIndex(idx) { this.currentIndex = idx } } } {{item}} export default { props: ['articles'], methods: { emitIndex(index) { this.$emit('onEmitIndex', index) } } } 二、 $children / $parent 上面这张图片是vue官方的解释，通过$parent和$children就可以访问组件的实例，拿到实例代表什么？代表可以访问此组件的所有方法和data。接下来就是怎么实现拿到指定组件的实例。 使用方法 // 父组件中 {{msg}} 点击改变子组件值 import ComA from './test/comA.vue' export default { name: 'HelloWorld', components: { ComA }, data() { return { msg: 'Welcome' } }, methods: { changeA() { // 获取到子组件A this.$children[0].messageA = 'this is new value' } } } // 子组件中 {{messageA}} 获取父组件的值为: {{parentVal}} export default { data() { return { messageA: 'this is old' } }, computed:{ parentVal(){ return this.$parent.msg; } } } 要注意边界情况，如在#app上拿$parent得到的是new Vue()的实例，在这实例上再拿$parent得到的是undefined，而在最底层的子组件拿$children是个空数组。也要注意得到$parent和$children的值不一样，$children 的值是数组，而$parent是个对象 总结: 上面两种方式用于父子组件之间的通信， 而使用props进行父子组件通信更加普遍; 二者皆不能用于非父子组件之间的通信。 三、provide/ inject 概念: provide/ inject 是vue2.2.0新增的api, 简单来说就是父组件中通过provide来提供变量, 然后再子组件中通过inject来注入变量。 注意: 这里不论子组件嵌套有多深, 只要调用了inject 那么就可以注入provide中的数据，而不局限于只能从当前父组件的props属性中回去数据 举例验证 接下来就用一个例子来验证上面的描述:假设有三个组件: A.vue、B.vue、C.vue 其中 C是B的子组件，B是A的子组件 // A.vue import comB from '../components/test/comB.vue' export default { name: \"A\", provide: { for: \"demo\" }, components:{ comB } } // B.vue {{demo}} import comC from '../components/test/comC.vue' export default { name: \"B\", inject: ['for'], data() { return { demo: this.for } }, components: { comC } } // C.vue {{demo}} export default { name: \"C\", inject: ['for'], data() { return { demo: this.for } } } 四、ref / refs ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据， 我们看一个ref 来访问组件的例子: // 子组件 A.vue export default { data () { return { name: 'Vue.js' } }, methods: { sayHello () { console.log('hello') } } } // 父组件 app.vue export default { mounted () { const comA = this.$refs.comA; console.log(comA.name); // Vue.js comA.sayHello(); // hello } } 五、eventBus eventBus 又称为事件总线，在vue中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。 eventBus也有不方便之处, 当项目较大,就容易造成难以维护的灾难 在Vue的项目中怎么使用eventBus来实现组件之间的数据通信呢?具体通过下面几个步骤 初始化 首先需要创建一个事件总线并将其导出, 以便其他模块可以使用或者监听它. // event-bus.js import Vue from 'vue' export const EventBus = new Vue() 发送事件 假设你有两个组件: additionNum 和 showNum, 这两个组件可以是兄弟组件也可以是父子组件；这里我们以兄弟组件为例: import showNumCom from './showNum.vue' import additionNumCom from './additionNum.vue' export default { components: { showNumCom, additionNumCom } } // addtionNum.vue 中发送事件 +加法器 import {EventBus} from './event-bus.js' console.log(EventBus) export default { data(){ return{ num:1 } }, methods:{ additionHandle(){ EventBus.$emit('addition', { num:this.num++ }) } } } 接收事件 // showNum.vue 中接收事件 计算和: import { EventBus } from './event-bus.js' export default { data() { return { count: 0 } }, mounted() { EventBus.$on('addition', param => { this.count = this.count + param.num; }) } } 这样就实现了在组件addtionNum.vue中点击相加按钮, 在showNum.vue中利用传递来的 num 展示求和的结果. 移除事件监听者 如果想移除事件的监听, 可以像下面这样操作: import { eventBus } from 'event-bus.js' EventBus.$off('addition', {}) 六、Vuex 1. Vuex介绍 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. Vuex 解决了多个视图依赖于同一状态和来自不同视图的行为需要变更同一状态的问题，将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上 2. Vuex各个模块 state：用于数据的存储，是store中的唯一数据源 getters：如vue中的计算属性一样，基于state数据的二次包装，常用于数据的筛选和多个数据的相关性计算 mutations：类似函数，改变state数据的唯一途径，且不能用于处理异步事件 actions：类似于mutation，用于提交mutation来改变状态，而不直接变更状态，可以包含任意异步操作 modules：类似于命名空间，用于项目中将各个模块的状态分开定义和操作，便于维护 3. Vuex实例应用 // 父组件 import ChildA from './components/ChildA' // 导入A组件 import ChildB from './components/ChildB' // 导入B组件 export default { name: 'App', components: {ChildA, ChildB} // 注册A、B组件 } // 子组件childA 我是A组件 点我让B组件接收到数据 因为你点了B，所以我的信息发生了变化：{{BMessage}} export default { data() { return { AMessage: 'Hello，B组件，我是A组件' } }, computed: { BMessage() { // 这里存储从store里获取的B组件的数据 return this.$store.state.BMsg } }, methods: { transform() { // 触发receiveAMsg，将A组件的数据存放到store里去 this.$store.commit('receiveAMsg', { AMsg: this.AMessage }) } } } // 子组件 childB 我是B组件 点我让A组件接收到数据 因为你点了A，所以我的信息发生了变化：{{AMessage}} export default { data() { return { BMessage: 'Hello，A组件，我是B组件' } }, computed: { AMessage() { // 这里存储从store里获取的A组件的数据 return this.$store.state.AMsg } }, methods: { transform() { // 触发receiveBMsg，将B组件的数据存放到store里去 this.$store.commit('receiveBMsg', { BMsg: this.BMessage }) } } } vuex的store.js import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) const state = { // 初始化A和B组件的数据，等待获取 AMsg: '', BMsg: '' } const mutations = { receiveAMsg(state, payload) { // 将A组件的数据存放于state state.AMsg = payload.AMsg }, receiveBMsg(state, payload) { // 将B组件的数据存放于state state.BMsg = payload.BMsg } } export default new Vuex.Store({ state, mutations }) 七、 localStorage / sessionStorage 这种通信比较简单,缺点是数据和状态比较混乱,不太容易维护。 通过window.localStorage.getItem(key) 获取数据 通过window.localStorage.setItem(key,value) 存储数据 注意用JSON.parse() / JSON.stringify() 做数据格式转换localStorage / sessionStorage可以结合vuex, 实现数据的持久保存,同时使用vuex解决数据和状态混乱问题. 八、 $attrs与 $listeners 现在我们来讨论一种情况， 我们一开始给出的组件关系图中A组件与D组件是隔代关系， 那它们之前进行通信有哪些方式呢？ 使用props绑定来进行一级一级的信息传递, 如果D组件中状态改变需要传递数据给A, 使用事件系统一级级往上传递 使用eventBus,这种情况下还是比较适合使用, 但是碰到多人合作开发时, 代码维护性较低, 可读性也低 使用Vuex来进行数据管理, 但是如果仅仅是传递数据, 而不做中间处理,使用Vuex处理感觉有点大材小用了. 在vue2.4中，为了解决该需求，引入了$attrs 和$listeners ， 新增了inheritAttrs 选项。 在版本2.4以前，默认情况下,父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)，将会“回退”且作为普通的HTML特性应用在子组件的根元素上。接下来看一个跨级通信的例子: // app.vue // index.vue const childCom1 = () => import(\"./childCom1.vue\"); export default { components: { childCom1 }, data() { return { name: \"zhang\", age: \"18\", gender: \"女\", height: \"158\" }; } }; // childCom1.vue name: {{ name}} childCom1的$attrs: {{ $attrs }} const childCom2 = () => import(\"./childCom2.vue\"); export default { components: { childCom2 }, inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性 props: { name: String // name作为props属性绑定 }, created() { console.log(this.$attrs); // { \"age\": \"18\", \"gender\": \"女\", \"height\": \"158\", \"title\": \"程序员成长指北\" } } }; // childCom2.vue age: {{ age}} childCom2: {{ $attrs }} export default { inheritAttrs: false, props: { age: String }, created() { console.log(this.$attrs); // { \"gender\": \"女\", \"height\": \"158\", \"title\": \"程序员成长指北\" } } }; 总结 常见使用场景可以分为三类: 父子组件通信: props; $parent / $children; provide / inject ; ref ; $attrs / $listeners 兄弟组件通信: eventBus ; vuex 跨级通信: eventBus；Vuex；provide / inject 、$attrs / $listeners "},"Vue/NextTick原理分析.html":{"url":"Vue/NextTick原理分析.html","title":"NextTick原理分析","keywords":"","body":"NextTick 原理分析 nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。 在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。 对于实现 macrotasks ，会先判断是否能使用 setImmediate ，不能的话降级为 MessageChannel ，以上都不行的话就使用 setTimeout if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) { macroTimerFunc = () => { setImmediate(flushCallbacks) } } else if ( typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) || // PhantomJS MessageChannel.toString() === '[object MessageChannelConstructor]') ) { const channel = new MessageChannel() const port = channel.port2 channel.port1.onmessage = flushCallbacks macroTimerFunc = () => { port.postMessage(1) } } else { /* istanbul ignore next */ macroTimerFunc = () => { setTimeout(flushCallbacks, 0) } } nextTick 同时也支持 Promise 的使用，会判断是否实现了 Promise export function nextTick(cb?: Function, ctx?: Object) { let _resolve // 将回调函数整合进一个数组中 callbacks.push(() => { if (cb) { try { cb.call(ctx) } catch (e) { handleError(e, ctx, 'nextTick') } } else if (_resolve) { _resolve(ctx) } }) if (!pending) { pending = true if (useMacroTask) { macroTimerFunc() } else { microTimerFunc() } } // 判断是否可以使用 Promise // 可以的话给 _resolve 赋值 // 这样回调函数就能以 promise 的方式调用 if (!cb && typeof Promise !== 'undefined') { return new Promise(resolve => { _resolve = resolve }) } } "},"Vue/从Vue.js源码看nextTick机制.html":{"url":"Vue/从Vue.js源码看nextTick机制.html","title":"从Vue.js源码看nextTick机制","keywords":"","body":"从Vue.js源码看nextTick机制 从Vue.js源码看nextTick机制 操作DOM Watcher队列 nextTick flushSchedulerQueue 为什么要异步更新视图 访问真实DOM节点更新后的数据 操作DOM 在使用vue.js的时候，有时候因为一些特定的业务场景，不得不去操作DOM，比如这样： {{test}} tet export default { data () { return { test: 'begin' }; }, methods () { handleClick () { this.test = 'end'; console.log(this.$refs.test.innerText);//打印“begin” } } } 打印的结果是begin，为什么我们明明已经将test设置成了“end”，获取真实DOM节点的innerText却没有得到我们预期中的“end”，而是得到之前的值“begin”呢？ Watcher队列 带着疑问，我们找到了Vue.js源码的Watch实现。当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。我们来看一下update的实现。 update () { /* istanbul ignore else */ if (this.lazy) { this.dirty = true } else if (this.sync) { /*同步则执行run直接渲染视图*/ this.run() } else { /*异步推送到观察者队列中，下一个tick时调用。*/ queueWatcher(this) } } 我们发现Vue.js默认是使用异步执行DOM更新。 当异步执行update的时候，会调用queueWatcher函数。 /*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/ export function queueWatcher (watcher: Watcher) { /*获取watcher的id*/ const id = watcher.id /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/ if (has[id] == null) { has[id] = true if (!flushing) { /*如果没有flush掉，直接push到队列中即可*/ queue.push(watcher) } else { // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i >= 0 && queue[i].id > watcher.id) { i-- } queue.splice(Math.max(i, index) + 1, 0, watcher) } // queue the flush if (!waiting) { waiting = true nextTick(flushSchedulerQueue) } } } 查看queueWatcher的源码我们发现，Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候会继续会有Watch对象被push进这个队列queue，等待下一个tick时，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。 那么，什么是下一个tick？ nextTick vue.js提供了一个nextTick函数，其实也就是上面调用的nextTick。 nextTick的实现比较简单，执行的目的是在microtask或者task中推入一个funtion，在当前栈执行完毕（也行还会有一些排在前面的需要执行的任务）以后执行nextTick传入的funtion，看一下源码： /** * Defer a task to execute it asynchronously. */ /* 延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个function 这个函数的作用是在task或者microtask中推入一个timerFunc， 在当前调用栈执行完以后以此执行直到执行到timerFunc 目的是延迟到当前调用栈执行完以后执行 */ export const nextTick = (function () { /*存放异步执行的回调*/ const callbacks = [] /*一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送*/ let pending = false /*一个函数指针，指向函数将被推送到任务队列中，等到主线程任务执行完时，任务队列中的timerFunc被调用*/ let timerFunc /*下一个tick时的回调*/ function nextTickHandler () { /*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/ pending = false /*执行所有callback*/ const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i = 9.3.3 when triggered in touch event handlers. It // completely stops working after triggering a few times... so, if native // Promise is available, we will use it: /* istanbul ignore if */ /* 这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法 优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。 如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。 参考：https://www.zhihu.com/question/55364497 */ if (typeof Promise !== 'undefined' && isNative(Promise)) { /*使用Promise*/ var p = Promise.resolve() var logError = err => { console.error(err) } timerFunc = () => { p.then(nextTickHandler).catch(logError) // in problematic UIWebViews, Promise.then doesn't completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn't being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // \"force\" the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) } } else if (typeof MutationObserver !== 'undefined' && ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === '[object MutationObserverConstructor]' )) { // use MutationObserver where native Promise is not available, // e.g. PhantomJS IE11, iOS7, Android 4.4 /*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*/ var counter = 1 var observer = new MutationObserver(nextTickHandler) var textNode = document.createTextNode(String(counter)) observer.observe(textNode, { characterData: true }) timerFunc = () => { counter = (counter + 1) % 2 textNode.data = String(counter) } } else { // fallback to setTimeout /* istanbul ignore next */ /*使用setTimeout将回调推入任务队列尾部*/ timerFunc = () => { setTimeout(nextTickHandler, 0) } } /* 推送到队列中下一个tick时执行 cb 回调函数 ctx 上下文 */ return function queueNextTick (cb?: Function, ctx?: Object) { let _resolve /*cb存到callbacks中*/ callbacks.push(() => { if (cb) { try { cb.call(ctx) } catch (e) { handleError(e, ctx, 'nextTick') } } else if (_resolve) { _resolve(ctx) } }) if (!pending) { pending = true timerFunc() } if (!cb && typeof Promise !== 'undefined') { return new Promise((resolve, reject) => { _resolve = resolve }) } } })() 它是一个立即执行函数,返回一个queueNextTick接口。 传入的cb会被push进callbacks中存放起来，然后执行timerFunc（pending是一个状态标记，保证timerFunc在下一个tick之前只执行一次） timerFunc是什么？ 看了源码发现timerFunc会检测当前环境而不同实现，其实就是按照Promise，MutationObserver，setTimeout优先级，哪个存在使用哪个，最不济的环境下使用setTimeout。 两者的具体实现 macrotasks: setTimeout ，setInterval， setImmediate，requestAnimationFrame,I/O ，UI渲染 microtasks: Promise， process.nextTick， Object.observe， MutationObserver 再简单点可以总结为： 在 macrotask 队列中执行最早的那个 task ，然后移出 再执行 microtask 队列中所有可用的任务，然后移出 下一个循环，执行下一个 macrotask 中的任务 (再跳到第2步) 这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法。 优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法的回调函数都会在microtask中执行，它们会比setTimeout更早执行，所以优先使用。 如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。 为什么要优先使用microtask？我在顾轶灵在知乎的回答中学习到： JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、 MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。实在不行，只能用 setTimeout 创建 task 了。 为啥要用 microtask？根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。 首先是Promise，(Promise.resolve()).then()可以在microtask中加入它的回调， MutationObserver新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入microtask，即textNode.data = String(counter)时便会加入该回调。 至于 MutationObserver 如何模拟 nextTick 这点，直接看源码，其实就是创建一个 TextNode 并监听内容变化，然后要 nextTick 的时候去改一下这个节点的文本内容： var counter = 1 var observer = new MutationObserver(nextTickHandler) var textNode = document.createTextNode(String(counter)) observer.observe(textNode, { characterData: true }) timerFunc = () => { counter = (counter + 1) % 2 textNode.data = String(counter) } setTimeout是最后的一种备选方案，并且默认有4ms延时，setTimeout延时0不会老老实实立即执行： setTimeout(function(){ console.log(\"我不是立即执行的,一般我会延时4ms,哈哈\"); },0); 它会将回调函数加入task中，等到执行。 setTimeout(function(){console.log(4)},0); new Promise(function(resolve){ console.log(1) for( var i=0 ; i 再看这个，两个自执行同时执行： (function test() { setTimeout(function () { console.log(4) }, 0); new Promise(function executor (resolve) { console.log(1); for(var i = 0; i 整个执行过程是一个 main thread 【主线程】 ，但并不意味着先执行第一个自执行后再执行第二个，因为两个自执行中的 setTimeout 进入的是同一个事件循环中等待，因此他俩在最后分别输出了了 4 和 42。 当一个程序有：setTimeout， setInterval ，setImmediate， I/O， UI渲染，Promise ，process.nextTick， Object.observe， MutationObserver的时候： 先执行 macrotasks：I/O -》 UI渲染 再执行 microtasks ：process.nextTick -》 Promise -》MutationObserver ->Object.observe 再把setTimeout setInterval setImmediate 塞入一个新的macrotasks，依次： setTimeout ，setInterval --》setImmediate 综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。 setImmediate(function(){ console.log(1); },0); setTimeout(function(){ console.log(2); },0); new Promise(function(resolve){ console.log(3); resolve(); console.log(4); }).then(function(){ console.log(5); }); console.log(6); process.nextTick(function(){ console.log(7); }); console.log(8); 结果是：3 4 6 8 7 5 2 1 flushSchedulerQueue /*Github:https://github.com/answershuto*/ /** * Flush both queues and run the watchers. */ /*nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers*/ function flushSchedulerQueue () { flushing = true let watcher, id // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component's user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component's watcher run, // its watchers can be skipped. /* 给queue排序，这样做可以保证： 1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。 2.一个组件的user watchers比render watcher先运行，因为user watchers往往比render watcher更早创建 3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。 */ queue.sort((a, b) => a.id - b.id) // do not cache length because more watchers might be pushed // as we run existing watchers /*这里不用index = queue.length;index > 0; index--的方式写是因为不要将length进行缓存，因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/ for (index = 0; index MAX_UPDATE_COUNT) { warn( 'You may have an infinite update loop ' + ( watcher.user ? `in watcher with expression \"${watcher.expression}\"` : `in a component render function.` ), watcher.vm ) break } } } // keep copies of post queues before resetting state /**/ /*得到队列的拷贝*/ const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() /*重置调度者的状态*/ resetSchedulerState() // call component updated and activated hooks /*使子组件状态都改编成active同时调用activated钩子*/ callActivatedHooks(activatedQueue) /*调用updated钩子*/ callUpdateHooks(updatedQueue) // devtool hook /* istanbul ignore if */ if (devtools && config.devtools) { devtools.emit('flush') } } flushSchedulerQueue是下一个tick时的回调函数，主要目的是执行Watcher的run函数，用来更新视图 为什么要异步更新视图 来看一下下面这一段代码 {{test}} export default { data () { return { test: 0 }; }, created () { for(let i = 0; i 现在有这样的一种情况，created的时候test的值会被++循环执行1000次。 每次++时，都会根据响应式触发setter->Dep->Watcher->update->patch。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。 访问真实DOM节点更新后的数据 所以我们需要在修改data中的数据后访问真实的DOM节点更新后的数据，只需要这样，我们把文章第一个例子进行修改。 {{test}} tet export default { data () { return { test: 'begin' }; }, methods () { handleClick () { this.test = 'end'; this.$nextTick(() => { console.log(this.$refs.test.innerText);//打印\"end\" }); console.log(this.$refs.test.innerText);//打印“begin” } } } 使用Vue.js的global API的$nextTick方法，即可在回调中获取已经更新好的DOM实例了。 "},"Vue/VueRouter源码分析.html":{"url":"Vue/VueRouter源码分析.html","title":"VueRouter源码分析","keywords":"","body":"VueRouter 源码解析 VueRouter 源码解析 路由注册 VueRouter 实例化 创建路由匹配对象 路由初始化 路由跳转 路由注册 使用路由之前，需要调用 Vue.use(VueRouter)，这是因为让插件可以使用 Vue export function initUse(Vue: GlobalAPI) { Vue.use = function(plugin: Function | Object) { // 判断重复安装插件 const installedPlugins = this._installedPlugins || (this._installedPlugins = []) if (installedPlugins.indexOf(plugin) > -1) { return this } const args = toArray(arguments, 1) // 插入 Vue args.unshift(this) // 一般插件都会有一个 install 函数 // 通过该函数让插件可以使用 Vue if (typeof plugin.install === 'function') { plugin.install.apply(plugin, args) } else if (typeof plugin === 'function') { plugin.apply(null, args) } installedPlugins.push(plugin) return this } } 接下来看下 install 函数的部分实现 export function install(Vue) { // 确保 install 调用一次 if (install.installed && _Vue === Vue) return install.installed = true // 把 Vue 赋值给全局变量 _Vue = Vue const registerInstance = (vm, callVal) => { let i = vm.$options._parentVnode if ( isDef(i) && isDef((i = i.data)) && isDef((i = i.registerRouteInstance)) ) { i(vm, callVal) } } // 给每个组件的钩子函数混入实现 // 可以发现在 `beforeCreate` 钩子执行时 // 会初始化路由 Vue.mixin({ beforeCreate() { // 判断组件是否存在 router 对象，该对象只在根组件上有 if (isDef(this.$options.router)) { // 根路由设置为自己 this._routerRoot = this this._router = this.$options.router // 初始化路由 this._router.init(this) // 很重要，为 _route 属性实现双向绑定 // 触发组件渲染 Vue.util.defineReactive(this, '_route', this._router.history.current) } else { // 用于 router-view 层级判断 this._routerRoot = (this.$parent && this.$parent._routerRoot) || this } registerInstance(this, this) }, destroyed() { registerInstance(this) } }) // 全局注册组件 router-link 和 router-view Vue.component('RouterView', View) Vue.component('RouterLink', Link) } 对于路由注册来说，核心就是调用 Vue.use(VueRouter)，使得 VueRouter 可以使用 Vue。然后通过 Vue 来调用 VueRouter 的 install 函数。在该函数中，核心就是给组件混入钩子函数和全局注册两个路由组件。 VueRouter 实例化 在安装插件后，对 VueRouter 进行实例化。 const Home = { template: 'home' } const Foo = { template: 'foo' } const Bar = { template: 'bar' } // 3. Create the router const router = new VueRouter({ mode: 'hash', base: __dirname, routes: [ { path: '/', component: Home }, // all paths are defined without the hash. { path: '/foo', component: Foo }, { path: '/bar', component: Bar } ] }) 来看一下 VueRouter 的构造函数 constructor(options: RouterOptions = {}) { // ... // 路由匹配对象 this.matcher = createMatcher(options.routes || [], this) // 根据 mode 采取不同的路由方式 let mode = options.mode || 'hash' this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false if (this.fallback) { mode = 'hash' } if (!inBrowser) { mode = 'abstract' } this.mode = mode switch (mode) { case 'history': this.history = new HTML5History(this, options.base) break case 'hash': this.history = new HashHistory(this, options.base, this.fallback) break case 'abstract': this.history = new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !== 'production') { assert(false, `invalid mode: ${mode}`) } } } 在实例化 VueRouter 的过程中，核心是创建一个路由匹配对象，并且根据 mode 来采取不同的路由方式。 创建路由匹配对象 export function createMatcher( routes: Array, router: VueRouter ): Matcher { // 创建路由映射表 const { pathList, pathMap, nameMap } = createRouteMap(routes) function addRoutes(routes) { createRouteMap(routes, pathList, pathMap, nameMap) } // 路由匹配 function match( raw: RawLocation, currentRoute?: Route, redirectedFrom?: Location ): Route { //... } return { match, addRoutes } } createMatcher 函数的作用就是创建路由映射表，然后通过闭包的方式让 addRoutes 和 match 函数能够使用路由映射表的几个对象，最后返回一个 Matcher 对象。 接下来看 createMatcher 函数时如何创建映射表的 export function createRouteMap( routes: Array, oldPathList?: Array, oldPathMap?: Dictionary, oldNameMap?: Dictionary ): { pathList: Array, pathMap: Dictionary, nameMap: Dictionary } { // 创建映射表 const pathList: Array = oldPathList || [] const pathMap: Dictionary = oldPathMap || Object.create(null) const nameMap: Dictionary = oldNameMap || Object.create(null) // 遍历路由配置，为每个配置添加路由记录 routes.forEach(route => { addRouteRecord(pathList, pathMap, nameMap, route) }) // 确保通配符在最后 for (let i = 0, l = pathList.length; i , pathMap: Dictionary, nameMap: Dictionary, route: RouteConfig, parent?: RouteRecord, matchAs?: string ) { // 获得路由配置下的属性 const { path, name } = route const pathToRegexpOptions: PathToRegexpOptions = route.pathToRegexpOptions || {} // 格式化 url，替换 / const normalizedPath = normalizePath(path, parent, pathToRegexpOptions.strict) // 生成记录对象 const record: RouteRecord = { path: normalizedPath, regex: compileRouteRegex(normalizedPath, pathToRegexpOptions), components: route.components || { default: route.component }, instances: {}, name, parent, matchAs, redirect: route.redirect, beforeEnter: route.beforeEnter, meta: route.meta || {}, props: route.props == null ? {} : route.components ? route.props : { default: route.props } } if (route.children) { // 递归路由配置的 children 属性，添加路由记录 route.children.forEach(child => { const childMatchAs = matchAs ? cleanPath(`${matchAs}/${child.path}`) : undefined addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs) }) } // 如果路由有别名的话 // 给别名也添加路由记录 if (route.alias !== undefined) { const aliases = Array.isArray(route.alias) ? route.alias : [route.alias] aliases.forEach(alias => { const aliasRoute = { path: alias, children: route.children } addRouteRecord( pathList, pathMap, nameMap, aliasRoute, parent, record.path || '/' // matchAs ) }) } // 更新映射表 if (!pathMap[record.path]) { pathList.push(record.path) pathMap[record.path] = record } // 命名路由添加记录 if (name) { if (!nameMap[name]) { nameMap[name] = record } else if (process.env.NODE_ENV !== 'production' && !matchAs) { warn( false, `Duplicate named routes definition: ` + `{ name: \"${name}\", path: \"${record.path}\" }` ) } } } 以上就是创建路由匹配对象的全过程，通过用户配置的路由规则来创建对应的路由映射表。 路由初始化 当根组件调用 beforeCreate 钩子函数时，会执行以下代码 beforeCreate () { // 只有根组件有 router 属性，所以根组件初始化时会初始化路由 if (isDef(this.$options.router)) { this._routerRoot = this this._router = this.$options.router this._router.init(this) Vue.util.defineReactive(this, '_route', this._router.history.current) } else { this._routerRoot = (this.$parent && this.$parent._routerRoot) || this } registerInstance(this, this) } 接下来看下路由初始化会做些什么 init(app: any /* Vue component instance */) { // 保存组件实例 this.apps.push(app) // 如果根组件已经有了就返回 if (this.app) { return } this.app = app // 赋值路由模式 const history = this.history // 判断路由模式，以哈希模式为例 if (history instanceof HTML5History) { history.transitionTo(history.getCurrentLocation()) } else if (history instanceof HashHistory) { // 添加 hashchange 监听 const setupHashListener = () => { history.setupListeners() } // 路由跳转 history.transitionTo( history.getCurrentLocation(), setupHashListener, setupHashListener ) } // 该回调会在 transitionTo 中调用 // 对组件的 _route 属性进行赋值，触发组件渲染 history.listen(route => { this.apps.forEach(app => { app._route = route }) }) } 在路由初始化时，核心就是进行路由的跳转，改变 URL 然后渲染对应的组件。接下来来看一下路由是如何进行跳转的。 路由跳转 transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) { // 获取匹配的路由信息 const route = this.router.match(location, this.current) // 确认切换路由 this.confirmTransition(route, () => { // 以下为切换路由成功或失败的回调 // 更新路由信息，对组件的 _route 属性进行赋值，触发组件渲染 // 调用 afterHooks 中的钩子函数 this.updateRoute(route) // 添加 hashchange 监听 onComplete && onComplete(route) // 更新 URL this.ensureURL() // 只执行一次 ready 回调 if (!this.ready) { this.ready = true this.readyCbs.forEach(cb => { cb(route) }) } }, err => { // 错误处理 if (onAbort) { onAbort(err) } if (err && !this.ready) { this.ready = true this.readyErrorCbs.forEach(cb => { cb(err) }) } }) } 在路由跳转中，需要先获取匹配的路由信息，所以先来看下如何获取匹配的路由信息 function match( raw: RawLocation, currentRoute?: Route, redirectedFrom?: Location ): Route { // 序列化 url // 比如对于该 url 来说 /abc?foo=bar&baz=qux##hello // 会序列化路径为 /abc // 哈希为 ##hello // 参数为 foo: 'bar', baz: 'qux' const location = normalizeLocation(raw, currentRoute, false, router) const { name } = location // 如果是命名路由，就判断记录中是否有该命名路由配置 if (name) { const record = nameMap[name] // 没找到表示没有匹配的路由 if (!record) return _createRoute(null, location) const paramNames = record.regex.keys .filter(key => !key.optional) .map(key => key.name) // 参数处理 if (typeof location.params !== 'object') { location.params = {} } if (currentRoute && typeof currentRoute.params === 'object') { for (const key in currentRoute.params) { if (!(key in location.params) && paramNames.indexOf(key) > -1) { location.params[key] = currentRoute.params[key] } } } if (record) { location.path = fillParams( record.path, location.params, `named route \"${name}\"` ) return _createRoute(record, location, redirectedFrom) } } else if (location.path) { // 非命名路由处理 location.params = {} for (let i = 0; i 接下来看看如何创建路由 // 根据条件创建不同的路由 function _createRoute( record: ?RouteRecord, location: Location, redirectedFrom?: Location ): Route { if (record && record.redirect) { return redirect(record, redirectedFrom || location) } if (record && record.matchAs) { return alias(record, location, record.matchAs) } return createRoute(record, location, redirectedFrom, router) } export function createRoute( record: ?RouteRecord, location: Location, redirectedFrom?: ?Location, router?: VueRouter ): Route { const stringifyQuery = router && router.options.stringifyQuery // 克隆参数 let query: any = location.query || {} try { query = clone(query) } catch (e) {} // 创建路由对象 const route: Route = { name: location.name || (record && record.name), meta: (record && record.meta) || {}, path: location.path || '/', hash: location.hash || '', query, params: location.params || {}, fullPath: getFullPath(location, stringifyQuery), matched: record ? formatMatch(record) : [] } if (redirectedFrom) { route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery) } // 让路由对象不可修改 return Object.freeze(route) } // 获得包含当前路由的所有嵌套路径片段的路由记录 // 包含从根路由到当前路由的匹配记录，从上至下 function formatMatch(record: ?RouteRecord): Array { const res = [] while (record) { res.unshift(record) record = record.parent } return res } 至此匹配路由已经完成，我们回到 transitionTo 函数中，接下来执行 confirmTransition transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) { // 确认切换路由 this.confirmTransition(route, () => {} } confirmTransition(route: Route, onComplete: Function, onAbort?: Function) { const current = this.current // 中断跳转路由函数 const abort = err => { if (isError(err)) { if (this.errorCbs.length) { this.errorCbs.forEach(cb => { cb(err) }) } else { warn(false, 'uncaught error during route navigation:') console.error(err) } } onAbort && onAbort(err) } // 如果是相同的路由就不跳转 if ( isSameRoute(route, current) && route.matched.length === current.matched.length ) { this.ensureURL() return abort() } // 通过对比路由解析出可复用的组件，需要渲染的组件，失活的组件 const { updated, deactivated, activated } = resolveQueue( this.current.matched, route.matched ) function resolveQueue( current: Array, next: Array ): { updated: Array, activated: Array, deactivated: Array } { let i const max = Math.max(current.length, next.length) for (i = 0; i = [].concat( // 失活的组件钩子 extractLeaveGuards(deactivated), // 全局 beforeEach 钩子 this.router.beforeHooks, // 在当前路由改变，但是该组件被复用时调用 extractUpdateHooks(updated), // 需要渲染组件 enter 守卫钩子 activated.map(m => m.beforeEnter), // 解析异步路由组件 resolveAsyncComponents(activated) ) // 保存路由 this.pending = route // 迭代器，用于执行 queue 中的导航守卫钩子 const iterator = (hook: NavigationGuard, next) => { // 路由不相等就不跳转路由 if (this.pending !== route) { return abort() } try { // 执行钩子 hook(route, current, (to: any) => { // 只有执行了钩子函数中的 next，才会继续执行下一个钩子函数 // 否则会暂停跳转 // 以下逻辑是在判断 next() 中的传参 if (to === false || isError(to)) { // next(false) this.ensureURL(true) abort(to) } else if ( typeof to === 'string' || (typeof to === 'object' && (typeof to.path === 'string' || typeof to.name === 'string')) ) { // next('/') 或者 next({ path: '/' }) -> 重定向 abort() if (typeof to === 'object' && to.replace) { this.replace(to) } else { this.push(to) } } else { // 这里执行 next // 也就是执行下面函数 runQueue 中的 step(index + 1) next(to) } }) } catch (e) { abort(e) } } // 经典的同步执行异步函数 runQueue(queue, iterator, () => { const postEnterCbs = [] const isValid = () => this.current === route // 当所有异步组件加载完成后，会执行这里的回调，也就是 runQueue 中的 cb() // 接下来执行 需要渲染组件的导航守卫钩子 const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid) const queue = enterGuards.concat(this.router.resolveHooks) runQueue(queue, iterator, () => { // 跳转完成 if (this.pending !== route) { return abort() } this.pending = null onComplete(route) if (this.router.app) { this.router.app.$nextTick(() => { postEnterCbs.forEach(cb => { cb() }) }) } }) }) } export function runQueue (queue: Array, fn: Function, cb: Function) { const step = index => { // 队列中的函数都执行完毕，就执行回调函数 if (index >= queue.length) { cb() } else { if (queue[index]) { // 执行迭代器，用户在钩子函数中执行 next() 回调 // 回调中判断传参，没有问题就执行 next()，也就是 fn 函数中的第二个参数 fn(queue[index], () => { step(index + 1) }) } else { step(index + 1) } } } // 取出队列中第一个钩子函数 step(0) } 接下来介绍导航守卫 const queue: Array = [].concat( // 失活的组件钩子 extractLeaveGuards(deactivated), // 全局 beforeEach 钩子 this.router.beforeHooks, // 在当前路由改变，但是该组件被复用时调用 extractUpdateHooks(updated), // 需要渲染组件 enter 守卫钩子 activated.map(m => m.beforeEnter), // 解析异步路由组件 resolveAsyncComponents(activated) ) 第一步是先执行失活组件的钩子函数 function extractLeaveGuards(deactivated: Array): Array { // 传入需要执行的钩子函数名 return extractGuards(deactivated, 'beforeRouteLeave', bindGuard, true) } function extractGuards( records: Array, name: string, bind: Function, reverse?: boolean ): Array { const guards = flatMapComponents(records, (def, instance, match, key) => { // 找出组件中对应的钩子函数 const guard = extractGuard(def, name) if (guard) { // 给每个钩子函数添加上下文对象为组件自身 return Array.isArray(guard) ? guard.map(guard => bind(guard, instance, match, key)) : bind(guard, instance, match, key) } }) // 数组降维，并且判断是否需要翻转数组 // 因为某些钩子函数需要从子执行到父 return flatten(reverse ? guards.reverse() : guards) } export function flatMapComponents( matched: Array, fn: Function ): Array { // 数组降维 return flatten( matched.map(m => { // 将组件中的对象传入回调函数中，获得钩子函数数组 return Object.keys(m.components).map(key => fn(m.components[key], m.instances[key], m, key) ) }) ) } 第二步执行全局 beforeEach 钩子函数 beforeEach(fn: Function): Function { return registerHook(this.beforeHooks, fn) } function registerHook(list: Array, fn: Function): Function { list.push(fn) return () => { const i = list.indexOf(fn) if (i > -1) list.splice(i, 1) } } 在 VueRouter 类中有以上代码，每当给 VueRouter 实例添加 beforeEach 函数时就会将函数 push 进 beforeHooks 中。 第三步执行 beforeRouteUpdate 钩子函数，调用方式和第一步相同，只是传入的函数名不同，在该函数中可以访问到 this 对象。 第四步执行 beforeEnter 钩子函数，该函数是路由独享的钩子函数。 第五步是解析异步组件。 export function resolveAsyncComponents(matched: Array): Function { return (to, from, next) => { let hasAsync = false let pending = 0 let error = null // 该函数作用之前已经介绍过了 flatMapComponents(matched, (def, _, match, key) => { // 判断是否是异步组件 if (typeof def === 'function' && def.cid === undefined) { hasAsync = true pending++ // 成功回调 // once 函数确保异步组件只加载一次 const resolve = once(resolvedDef => { if (isESModule(resolvedDef)) { resolvedDef = resolvedDef.default } // 判断是否是构造函数 // 不是的话通过 Vue 来生成组件构造函数 def.resolved = typeof resolvedDef === 'function' ? resolvedDef : _Vue.extend(resolvedDef) // 赋值组件 // 如果组件全部解析完毕，继续下一步 match.components[key] = resolvedDef pending-- if (pending { const msg = `Failed to resolve async component ${key}: ${reason}` process.env.NODE_ENV !== 'production' && warn(false, msg) if (!error) { error = isError(reason) ? reason : new Error(msg) next(error) } }) let res try { // 执行异步组件函数 res = def(resolve, reject) } catch (e) { reject(e) } if (res) { // 下载完成执行回调 if (typeof res.then === 'function') { res.then(resolve, reject) } else { const comp = res.component if (comp && typeof comp.then === 'function') { comp.then(resolve, reject) } } } } }) // 不是异步组件直接下一步 if (!hasAsync) next() } } 以上就是第一个 runQueue 中的逻辑，第五步完成后会执行第一个 runQueue 中回调函数 // 该回调用于保存 `beforeRouteEnter` 钩子中的回调函数 const postEnterCbs = [] const isValid = () => this.current === route // beforeRouteEnter 导航守卫钩子 const enterGuards = extractEnterGuards(activated, postEnterCbs, isValid) // beforeResolve 导航守卫钩子 const queue = enterGuards.concat(this.router.resolveHooks) runQueue(queue, iterator, () => { if (this.pending !== route) { return abort() } this.pending = null // 这里会执行 afterEach 导航守卫钩子 onComplete(route) if (this.router.app) { this.router.app.$nextTick(() => { postEnterCbs.forEach(cb => { cb() }) }) } }) 第六步是执行 beforeRouteEnter 导航守卫钩子，beforeRouteEnter 钩子不能访问 this 对象，因为钩子在导航确认前被调用，需要渲染的组件还没被创建。但是该钩子函数是唯一一个支持在回调中获取 this 对象的函数，回调会在路由确认执行。 beforeRouteEnter (to, from, next) { next(vm => { // 通过 `vm` 访问组件实例 }) } 下面来看看是如何支持在回调中拿到 this 对象的 function extractEnterGuards( activated: Array, cbs: Array, isValid: () => boolean ): Array { // 这里和之前调用导航守卫基本一致 return extractGuards( activated, 'beforeRouteEnter', (guard, _, match, key) => { return bindEnterGuard(guard, match, key, cbs, isValid) } ) } function bindEnterGuard( guard: NavigationGuard, match: RouteRecord, key: string, cbs: Array, isValid: () => boolean ): NavigationGuard { return function routeEnterGuard(to, from, next) { return guard(to, from, cb => { // 判断 cb 是否是函数 // 是的话就 push 进 postEnterCbs next(cb) if (typeof cb === 'function') { cbs.push(() => { // 循环直到拿到组件实例 poll(cb, match.instances, key, isValid) }) } }) } } // 该函数是为了解决 issus ##750 // 当 router-view 外面包裹了 mode 为 out-in 的 transition 组件 // 会在组件初次导航到时获得不到组件实例对象 function poll( cb: any, // somehow flow cannot infer this is a function instances: Object, key: string, isValid: () => boolean ) { if ( instances[key] && !instances[key]._isBeingDestroyed // do not reuse being destroyed instance ) { cb(instances[key]) } else if (isValid()) { // setTimeout 16ms 作用和 nextTick 基本相同 setTimeout(() => { poll(cb, instances, key, isValid) }, 16) } } 第七步是执行 beforeResolve 导航守卫钩子，如果注册了全局 beforeResolve 钩子就会在这里执行。 第八步就是导航确认，调用 afterEach 导航守卫钩子了。 以上都执行完成后，会触发组件的渲染 history.listen(route => { this.apps.forEach(app => { app._route = route }) }) 以上回调会在 updateRoute 中调用 updateRoute(route: Route) { const prev = this.current this.current = route this.cb && this.cb(route) this.router.afterHooks.forEach(hook => { hook && hook(route, prev) }) } 至此，路由跳转已经全部分析完毕。核心就是判断需要跳转的路由是否存在于记录中，然后执行各种导航守卫函数，最后完成 URL 的改变和组件的渲染。 "},"Vue/Vue&&MVVM原理.html":{"url":"Vue/Vue&&MVVM原理.html","title":"Vue&&MVVM原理","keywords":"","body":"MVVM原理 MVVM原理 划重点 Object.defineProperty() Vue为参照去实现怎么写MVVM 打造MVVM 数据劫持 数据代理 数据编译 发布订阅 数据更新视图 双向数据绑定 computed(计算属性) && mounted(钩子函数) 总结 补充 划重点 MVVM 双向数据绑定 在Angular1.x版本的时候通过的是脏值检测来处理 而现在无论是React还是Vue还是最新的Angular，其实实现方式都更相近了 那就是通过数据劫持+发布订阅模式 真正实现其实靠的也是ES5中提供的Object.defineProperty，当然这是不兼容的所以Vue等只支持了IE8+ Object.defineProperty() let obj = {}; let song = '发如雪'; obj.singer = '周杰伦'; Object.defineProperty(obj, 'music', { // 1. value: '七里香', configurable: true, // 2. 可以配置对象，删除属性 // writable: true, // 3. 可以修改对象 enumerable: true, // 4. 可以枚举 // ☆ get,set设置时不能设置writable和value，它们代替了二者且是互斥的 get() { // 5. 获取obj.music的时候就会调用get方法 return song; }, set(val) { // 6. 将修改的值重新赋给song song = val; } }); // 下面打印的部分分别是对应代码写入顺序执行 console.log(obj); // {singer: '周杰伦', music: '七里香'} // 1 delete obj.music; // 如果想对obj里的属性进行删除，configurable要设为true 2 console.log(obj); // 此时为 {singer: '周杰伦'} obj.music = '听妈妈的话'; // 如果想对obj的属性进行修改，writable要设为true 3 console.log(obj); // {singer: '周杰伦', music: \"听妈妈的话\"} for (let key in obj) { // 默认情况下通过defineProperty定义的属性是不能被枚举(遍历)的 // 需要设置enumerable为true才可以 // 不然你是拿不到music这个属性的，你只能拿到singer console.log(key); // singer, music 4 } console.log(obj.music); // '发如雪' 5 obj.music = '夜曲'; // 调用set设置新的值 console.log(obj.music); // '夜曲' 6 Vue为参照去实现怎么写MVVM // index.html {{song}} 《{{album.name}}》是{{singer}}2005年11月发行的专辑 主打歌为{{album.theme}} 作词人为{{singer}}等人。 为你弹奏肖邦的{{album.theme}} // 写法和Vue一样 let mvvm = new Mvvm({ el: '#app', data: { // Object.defineProperty(obj, 'song', '发如雪'); song: '发如雪', album: { name: '十一月的萧邦', theme: '夜曲' }, singer: '周杰伦' } }); 打造MVVM // 创建一个Mvvm构造函数 // 这里用es6方法将options赋一个初始值，防止没传，等同于options || {} function Mvvm(options = {}) { // vm.$options Vue上是将所有属性挂载到上面 // 所以我们也同样实现,将所有属性挂载到了$options this.$options = options; // this._data 这里也和Vue一样 let data = this._data = this.$options.data; // 数据劫持 observe(data); } 数据劫持 为什么要做数据劫持？? 观察对象，给对象增加Object.defineProperty vue特点是不能新增不存在的属性 不存在的属性没有get和set 深度响应 因为每次赋予一个新对象时会给这个新对象增加defineProperty(数据劫持) ```js // 创建一个Observe构造函数 // 写数据劫持的主要逻辑 function Observe(data) { // 所谓数据劫持就是给对象增加get,set // 先遍历一遍对象再说 for (let key in data) { // 把data属性通过defineProperty的方式定义属性 let val = data[key]; observe(val); // 递归继续向下找，实现深度的数据劫持 Object.defineProperty(data, key, { configurable: true, get() { return val; }, set(newVal) { // 更改值的时候 if (val === newVal) { // 设置的值和以前值一样就不理它 return; } val = newVal; // 如果以后再获取值(get)的时候，将刚才设置的值再返回去 observe(newVal); // 当设置为新值后，也需要把新值再去定义成属性 } }); } } // 外面再写一个函数 // 不用每次调用都写个new // 也方便递归调用 function observe(data) { // 如果不是对象的话就直接return掉 // 防止递归溢出 if (!data || typeof data !== 'object') return; return new Observe(data); } 以上代码就实现了数据劫持，不过可能也有些疑惑的地方比如：**递归** ```js let mvvm = new Mvvm({ el: '#app', data: { a: { b: 1 }, c: 2 } }); 我们在控制台里看下 被标记的地方就是通过递归observe(val)进行数据劫持添加上了get和set，递归继续向a里面的对象去定义属性，亲测通过可放心食用 接下来说一下observe(newVal)这里为什么也要递归 还是在可爱的控制台上，敲下这么一段代码 mvvm._data.a = {b:'ok'} 然后继续看图说话 通过observe(newVal)加上了 现在大致明白了为什么要对设置的新值也进行递归observe了吧，哈哈，so easy 数据劫持已完成，我们再做个数据代理 数据代理 数据代理就是让我们每次拿data里的数据时，不用每次都写一长串，如mvvm._data.a.b这种，我们其实可以直接写成mvvm.a.b这种显而易见的方式 下面继续看下去，+号表示实现部分 function Mvvm(options = {}) { // 数据劫持 observe(data); // this 代理了this._data + for (let key in data) { Object.defineProperty(this, key, { configurable: true, get() { return this._data[key]; // 如this.a = {b: 1} }, set(newVal) { this._data[key] = newVal; } }); + } } // 此时就可以简化写法了 console.log(mvvm.a.b); // 1 mvvm.a.b = 'ok'; console.log(mvvm.a.b); // 'ok' 写到这里数据劫持和数据代理都实现了，那么接下来就需要编译一下了，把｛{}｝里面的内容解析出来 数据编译 function Mvvm(options = {}) { // observe(data); // 编译 + new Compile(options.el, this); } // 创建Compile构造函数 function Compile(el, vm) { // 将el挂载到实例上方便调用 vm.$el = document.querySelector(el); // 在el范围里将内容都拿到，当然不能一个一个的拿 // 可以选择移到内存中去然后放入文档碎片中，节省开销 let fragment = document.createDocumentFragment(); while (child = vm.$el.firstChild) { fragment.appendChild(child); // 此时将el中的内容放入内存中 } // 对el里面的内容进行替换 function replace(frag) { Array.from(frag.childNodes).forEach(node => { let txt = node.textContent; let reg = /\\{\\{(.*?)\\}\\}/g; // 正则匹配｛{}｝ if (node.nodeType === 3 && reg.test(txt)) { // 即是文本节点又有大括号的情况｛{}｝ console.log(RegExp.$1); // 匹配到的第一个分组 如： a.b, c let arr = RegExp.$1.split('.'); let val = vm; arr.forEach(key => { val = val[key]; // 如this.a.b }); // 用trim方法去除一下首尾空格 node.textContent = txt.replace(reg, val).trim(); } // 如果还有子节点，继续递归replace if (node.childNodes && node.childNodes.length) { replace(node); } }); } replace(fragment); // 替换内容 vm.$el.appendChild(fragment); // 再将文档碎片放入el中 } 现在数据已经可以编译了，但是我们手动修改后的数据并没有在页面上发生改变 下面我们就来看看怎么处理，其实这里就用到了特别常见的设计模式，发布订阅模式 发布订阅 发布订阅主要靠的就是数组关系，订阅就是放入函数，发布就是让数组里的函数执行 // 发布订阅模式 订阅和发布 如[fn1, fn2, fn3] function Dep() { // 一个数组(存放函数的事件池) this.subs = []; } Dep.prototype = { addSub(sub) { this.subs.push(sub); }, notify() { // 绑定的方法，都有一个update方法 this.subs.forEach(sub => sub.update()); } }; // 监听函数 // 通过Watcher这个类创建的实例，都拥有update方法 function Watcher(fn) { this.fn = fn; // 将fn放到实例上 } Watcher.prototype.update = function() { this.fn(); }; let watcher = new Watcher(() => console.log(111)); // let dep = new Dep(); dep.addSub(watcher); // 将watcher放到数组中,watcher自带update方法， => [watcher] dep.addSub(watcher); dep.notify(); // 111, 111 数据更新视图 现在我们要订阅一个事件，当数据改变需要重新刷新视图，这就需要在replace替换的逻辑里来处理 通过new Watcher把数据订阅一下，数据一变就执行改变内容的操作 function replace(frag) { // 省略... // 替换的逻辑 node.textContent = txt.replace(reg, val).trim(); // 监听变化 // 给Watcher再添加两个参数，用来取新的值(newVal)给回调函数传参 + new Watcher(vm, RegExp.$1, newVal => { node.textContent = txt.replace(reg, newVal).trim(); + }); } // 重写Watcher构造函数 function Watcher(vm, exp, fn) { this.fn = fn; + this.vm = vm; + this.exp = exp; // 添加一个事件 // 这里我们先定义一个属性 + Dep.target = this; + let arr = exp.split('.'); + let val = vm; + arr.forEach(key => { // 取值 + val = val[key]; // 获取到this.a.b，默认就会调用get方法 + }); + Dep.target = null; } 当获取值的时候就会自动调用get方法，于是我们去找一下数据劫持那里的get方法 function Observe(data) { + let dep = new Dep(); // 省略... Object.defineProperty(data, key, { get() { + Dep.target && dep.addSub(Dep.target); // 将watcher添加到订阅事件中 [watcher] return val; }, set(newVal) { if (val === newVal) { return; } val = newVal; observe(newVal); + dep.notify(); // 让所有watcher的update方法执行即可 } }) } 当set修改值的时候执行了dep.notify方法，这个方法是执行watcher的update方法，那么我们再对update进行修改一下 Watcher.prototype.update = function() { // notify的时候值已经更改了 // 再通过vm, exp来获取新的值 + let arr = this.exp.split('.'); + let val = this.vm; + arr.forEach(key => { + val = val[key]; // 通过get获取到新的值 + }); this.fn(val); // 将每次拿到的新值去替换｛{}｝的内容即可 }; 现在我们数据的更改可以修改视图了，这很good，还剩最后一点，我们再来看看面试常考的双向数据绑定吧 双向数据绑定 // html结构 // 数据部分 data: { a: { b: 1 }, c: 2 } function replace(frag) { // 省略... + if (node.nodeType === 1) { // 元素节点 let nodeAttr = node.attributes; // 获取dom上的所有属性,是个类数组 Array.from(nodeAttr).forEach(attr => { let name = attr.name; // v-model type let exp = attr.value; // c text if (name.includes('v-')){ node.value = vm[exp]; // this.c 为 2 } // 监听变化 new Watcher(vm, exp, function(newVal) { node.value = newVal; // 当watcher触发时会自动将内容放进输入框中 }); node.addEventListener('input', e => { let newVal = e.target.value; // 相当于给this.c赋了一个新值 // 而值的改变会调用set，set中又会调用notify，notify中调用watcher的update方法实现了更新 vm[exp] = newVal; }); }); + } if (node.childNodes && node.childNodes.length) { replace(node); } } computed(计算属性) && mounted(钩子函数) // html结构 求和的值是{{sum}} data: { a: 1, b: 9 }, computed: { sum() { return this.a + this.b; }, noop() {} }, mounted() { setTimeout(() => { console.log('所有事情都搞定了'); }, 1000); } function Mvvm(options = {}) { // 初始化computed,将this指向实例 + initComputed.call(this); // 编译 new Compile(options.el, this); // 所有事情处理好后执行mounted钩子函数 + options.mounted.call(this); // 这就实现了mounted钩子函数 } function initComputed() { let vm = this; let computed = this.$options.computed; // 从options上拿到computed属性 {sum: ƒ, noop: ƒ} // 得到的都是对象的key可以通过Object.keys转化为数组 Object.keys(computed).forEach(key => { // key就是sum,noop Object.defineProperty(vm, key, { // 这里判断是computed里的key是对象还是函数 // 如果是函数直接就会调get方法 // 如果是对象的话，手动调一下get方法即可 // 如： sum() {return this.a + this.b;},他们获取a和b的值就会调用get方法 // 所以不需要new Watcher去监听变化了 get: typeof computed[key] === 'function' ? computed[key] : computed[key].get, set() {} }); }); } 总结 通过Object.defineProperty的get和set进行数据劫持 通过遍历data数据进行数据代理到this上 通过｛{}｝对数据进行编译 通过发布订阅模式实现数据与视图同步 通过通过通过，收了，感谢大官人的留步了 补充 针对以上代码在实现编译的时候还是会有一些小bug，再次经过研究和高人指点，完善了编译，下面请看修改后的代码 修复：两个相邻的｛{}｝正则匹配，后一个不能正确编译成对应的文本，如 function Compile(el, vm) { // 省略... function replace(frag) { // 省略... if (node.nodeType === 3 && reg.test(txt)) { function replaceTxt() { node.textContent = txt.replace(reg, (matched, placeholder) => { console.log(placeholder); // 匹配到的分组 如：song, album.name, singer... new Watcher(vm, placeholder, replaceTxt); // 监听变化，进行匹配替换内容 return placeholder.split('.').reduce((val, key) => { return val[key]; }, vm); }); }; // 替换 replaceTxt(); } } } 上面代码主要实现依赖的是reduce方法，reduce 为数组中的每一个元素依次执行回调函数 "},"Vue/撸一个简单的Vue.html":{"url":"Vue/撸一个简单的Vue.html","title":"撸一个简单的Vue","keywords":"","body":"撸一个简单的Vue 撸一个简单的Vue 内部的原理实现一个简单的vue Object.defineProperty() 流程图 html代码结构 js调用 Vue结构 Vue constructor 初始化 proxyData 代理data observer 劫持监听 compile 解析dom Watcher 完整代码 内部的原理实现一个简单的vue Object.defineProperty() 因为vue主要是通过数据劫持来实现的，通过get、set来完成数据的读取和更新。 var obj = {name:'wclimb'} var age = 24 Object.defineProperty(obj,'age',{ enumerable: true, // 可枚举 configurable: false, // 不能再define get () { return age }, set (newVal) { console.log('我改变了',age +' -> '+newVal); age = newVal } }) > obj.age > 24 > obj.age = 25; > 我改变了 24 -> 25 > 25 从上面可以看到通过get获取数据，通过set监听到数据变化执行相应操作 流程图 html代码结构 改变值 {{form}} js调用 new Vue({ el: '#wrap', data:{ form: '这是form的值', test: '我是粗体', }, methods:{ changeValue(){ console.log(this.form) this.form = '值被我改变了，气不气？' } } }) Vue结构 class Vue{ constructor(){} proxyData(){} observer(){} compile(){} compileText(){} } class Watcher{ constructor(){} update(){} } Vue constructor 构造函数主要是数据的初始化 proxyData 数据代理 observer 劫持监听所有数据 compile 解析dom compileText 解析dom里处理纯双花括号的操作 Watcher 更新视图操作 Vue constructor 初始化 class Vue{ constructor(options = {}){ this.$el = document.querySelector(options.el); let data = this.data = options.data; // 代理data，使其能直接this.xxx的方式访问data，正常的话需要this.data.xxx Object.keys(data).forEach((key)=> { this.proxyData(key); }); this.methods = options.methods // 事件方法 this.watcherTask = {}; // 需要监听的任务列表 this.observer(data); // 初始化劫持监听所有数据 this.compile(this.$el); // 解析dom } } 上面主要是初始化操作，针对传过来的数据进行处理 proxyData 代理data class Vue{ constructor(options = {}){ ...... } proxyData(key){ let that = this; Object.defineProperty(that, key, { configurable: false, enumerable: true, get () { return that.data[key]; }, set (newVal) { that.data[key] = newVal; } }); } } 上面主要是代理data到最上层，this.xxx的方式直接访问data observer 劫持监听 class Vue{ constructor(options = {}){ ...... } proxyData(key){ ...... } observer(data){ let that = this Object.keys(data).forEach(key=>{ let value = data[key] this.watcherTask[key] = [] Object.defineProperty(data,key,{ configurable: false, enumerable: true, get(){ return value }, set(newValue){ if(newValue !== value){ value = newValue that.watcherTask[key].forEach(task => { task.update() }) } } }) }) } } 同样是使用Object.defineProperty来监听数据，初始化需要订阅的数据。 把需要订阅的数据到push到watcherTask里，等到时候需要更新的时候就可以批量更新数据了下面就是； 遍历订阅池，批量更新视图。 set(newValue){ if(newValue !== value){ value = newValue // 批量更新视图 that.watcherTask[key].forEach(task => { task.update() }) } } compile 解析dom class Vue{ constructor(options = {}){ ...... } proxyData(key){ ...... } observer(data){ ...... } compile(el){ var nodes = el.childNodes; for (let i = 0; i 0){ this.compile(node) } if(node.hasAttribute('v-model') && (node.tagName === 'INPUT' || node.tagName === 'TEXTAREA')){ node.addEventListener('input',(()=>{ let attrVal = node.getAttribute('v-model') this.watcherTask[attrVal].push(new Watcher(node,this,attrVal,'value')) node.removeAttribute('v-model') return () => { this.data[attrVal] = node.value } })()) } if(node.hasAttribute('v-html')){ let attrVal = node.getAttribute('v-html'); this.watcherTask[attrVal].push(new Watcher(node,this,attrVal,'innerHTML')) node.removeAttribute('v-html') } this.compileText(node,'innerHTML') if(node.hasAttribute('@click')){ let attrVal = node.getAttribute('@click') node.removeAttribute('@click') node.addEventListener('click',e => { this.methods[attrVal] && this.methods[attrVal].bind(this)() }) } } } }, compileText(node,type){ let reg = /\\{\\{(.*?)\\}\\}/g, txt = node.textContent; if(reg.test(txt)){ node.textContent = txt.replace(reg,(matched,value)=>{ let tpl = this.watcherTask[value] || [] tpl.push(new Watcher(node,this,value,type)) if(value.split('.').length > 1){ let v = null value.split('.').forEach((val,i)=>{ v = !v ? this[val] : v[val] }) return v }else{ return this[value] } }) } } } 首先我们先遍历el元素下面的所有子节点，node.nodeType === 3 的意思是当前元素是文本节点，node.nodeType === 1 的意思是当前元素是元素节点。因为可能有的是纯文本的形式，如纯双花括号就是纯文本的文本节点，然后通过判断元素节点是否还存在子节点，如果有的话就递归调用compile方法。下面重头戏来了，我们拆开看： if(node.hasAttribute('v-html')){ let attrVal = node.getAttribute('v-html'); this.watcherTask[attrVal].push(new Watcher(node,this,attrVal,'innerHTML')) node.removeAttribute('v-html') } 上面这个首先判断node节点上是否有v-html这种指令，如果存在的话，我们就发布订阅，怎么发布订阅呢？只需要把当前需要订阅的数据push到watcherTask里面，然后到时候在设置值的时候就可以批量更新了，实现双向数据绑定，也就是下面的操作 that.watcherTask[key].forEach(task => { task.update() }) 然后push的值是一个Watcher的实例，首先他new的时候会先执行一次，执行的操作就是去把纯双花括号 -> 1，也就是说把我们写好的模板数据更新到模板视图上。 最后把当前元素属性剔除出去，我们用Vue的时候也是看不到这种指令的，不剔除也不影响 至于Watcher是什么，看下面就知道了 Watcher class Watcher{ constructor(el,vm,value,type){ this.el = el; this.vm = vm; this.value = value; this.type = type; this.update() } update(){ this.el[this.type] = this.vm.data[this.value] } } 之前发布订阅之后走了这里面的操作，意思就是把当前元素如：node.innerHTML = ‘这是data里面的值’、node.value = ‘这个是表单的数据’ 那么我们为什么不直接去更新呢，还需要update做什么，不是多此一举吗？ 其实update记得吗？我们在订阅池里面需要批量更新，就是通过调用Watcher原型上的update方法。 完整代码 index.js ```js class Vue{ constructor(options = {}){ this.$el = document.querySelector(options.el); let data = this.data = options.data; // 代理data，使其能直接this.xxx的方式访问data，正常的话需要this.data.xxx Object.keys(data).forEach((key)=> { this.proxyData(key); }); this.methods = options.methods // 事件方法 this.watcherTask = {}; // 需要监听的任务列表 this.observer(data); // 初始化劫持监听所有数据 this.compile(this.$el); // 解析dom } proxyData(key){ let that = this; Object.defineProperty(that, key, { configurable: false, enumerable: true, get () { return that.data[key]; }, set (newVal) { that.data[key] = newVal; } }); } observer(data){ let that = this Object.keys(data).forEach(key=>{ let value = data[key] this.watcherTask[key] = [] Object.defineProperty(data,key,{ configurable: false, enumerable: true, get(){ return value }, set(newValue){ if(newValue !== value){ value = newValue that.watcherTask[key].forEach(task => { task.update() }) } } }) }) } compile(el){ var nodes = el.childNodes; for (let i = 0; i 0){ this.compile(node) } if(node.hasAttribute('v-model') && (node.tagName === 'INPUT' || node.tagName === 'TEXTAREA')){ node.addEventListener('input',(()=>{ let attrVal = node.getAttribute('v-model') this.watcherTask[attrVal].push(new Watcher(node,this,attrVal,'value')) node.removeAttribute('v-model') return () => { this.data[attrVal] = node.value } })()) } if(node.hasAttribute('v-html')){ let attrVal = node.getAttribute('v-html'); this.watcherTask[attrVal].push(new Watcher(node,this,attrVal,'innerHTML')) node.removeAttribute('v-html') } this.compileText(node,'innerHTML') if(node.hasAttribute('@click')){ let attrVal = node.getAttribute('@click') node.removeAttribute('@click') node.addEventListener('click',e => { this.methods[attrVal] && this.methods[attrVal].bind(this)() }) } } } } compileText(node,type){ let reg = /\\{\\{(.*?)\\}\\}/g, txt = node.textContent; if(reg.test(txt)){ node.textContent = txt.replace(reg,(matched,value)=>{ let tpl = this.watcherTask[value] || [] tpl.push(new Watcher(node,this,value,type)) if(value.split('.').length > 1){ let v = null value.split('.').forEach((val,i)=>{ v = !v ? this[val] : v[val] }) return v }else{ return this[value] } }) } } } class Watcher{ constructor(el,vm,value,type){ this.el = el; this.vm = vm; this.value = value; this.type = type; this.update() } update(){ this.el[this.type] = this.vm.data[this.value] } } - **index.html** ```html MyVue {{obj.test}} 改变值 {{form}} new Vue({ el: '#wrap', data:{ form: '这是form的值', test: '我是粗体', obj:{ test:123 } }, methods:{ changeValue(){ console.log(this.form) this.form = '值被我改变了，气不气？' } } }) "},"Vue/剖析Vue原理&实现双向绑定MVVM.html":{"url":"Vue/剖析Vue原理&实现双向绑定MVVM.html","title":"剖析Vue原理&实现双向绑定MVVM","keywords":"","body":"剖析Vue原理&实现双向绑定MVVM 剖析Vue原理&实现双向绑定MVVM mvvm双向绑定code 几种实现双向绑定的做法 发布者-订阅者模式 脏值检查 数据劫持 思路整理 1、实现Observer observer.js 2、实现Compile compile.js 3、实现Watcher watcher.js 4、实现MVVM mvvm双向绑定code {{word}} change model var vm = new MVVM({ el: '#mvvm-app', data: { word: 'Hello World!' }, methods: { sayHi: function() { this.word = 'Hi, everybody!'; } } }); 效果： 几种实现双向绑定的做法 目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。 实现数据绑定的做法有大致如下几种： 发布者-订阅者模式（backbone.js） 脏值检查（angular.js） 数据劫持（vue.js） 发布者-订阅者模式 发布者-订阅者模式: 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是 vm.set('property', value), 这里有篇文章讲的比较详细，有兴趣可点这里 这种方式现在毕竟太low了，我们更希望通过 vm.property = value 这种方式更新数据，同时自动更新视图，于是有了下面两种方式 脏值检查 脏值检查: angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply() 数据劫持 数据劫持: vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 思路整理 已经了解到vue是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过Object.defineProperty()来实现对属性的劫持，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一， 要实现mvvm的双向绑定，就必须要实现以下几点： 实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图 mvvm入口函数，整合以上三者 上述流程如图所示： 1、实现Observer 利用Obeject.defineProperty()来监听属性变动, 将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。。相关代码可以是这样： var data = {name: 'kindeng'}; observe(data); data.name = 'dmq'; // 哈哈哈，监听到值变化了 kindeng --> dmq function observe(data) { if (!data || typeof data !== 'object') { return; } // 取出所有属性遍历 Object.keys(data).forEach(function(key) { defineReactive(data, key, data[key]); }); }; function defineReactive(data, key, val) { observe(val); // 监听子属性 Object.defineProperty(data, key, { enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() { return val; }, set: function(newVal) { console.log('哈哈哈，监听到值变化了 ', val, ' --> ', newVal); val = newVal; } }); } 这样我们已经可以监听每个数据的变化了，那么监听到变化之后就是怎么通知订阅者了，所以接下来我们需要实现一个消息订阅器，很简单，维护一个数组，用来收集订阅者，数据变动触发notify，再调用订阅者的update方法，代码改善之后是这样： // ... 省略 function defineReactive(data, key, val) { var dep = new Dep(); observe(val); // 监听子属性 Object.defineProperty(data, key, { // ... 省略 set: function(newVal) { if (val === newVal) return; console.log('哈哈哈，监听到值变化了 ', val, ' --> ', newVal); val = newVal; dep.notify(); // 通知所有订阅者 } }); } function Dep() { this.subs = []; } Dep.prototype = { addSub: function(sub) { this.subs.push(sub); }, notify: function() { this.subs.forEach(function(sub) { sub.update(); }); } }; 那么问题来了，谁是订阅者？怎么往订阅器添加订阅者？没错，上面的思路整理中我们已经明确订阅者应该是Watcher, 而且var dep = new Dep();是在 defineReactive方法内部定义的，所以想通过dep添加订阅者，就必须要在闭包内操作，所以我们可以在 getter里面动手脚： // Observer.js // ...省略 Object.defineProperty(data, key, { get: function() { // 由于需要在闭包内添加watcher，所以通过Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target && dep.addDep(Dep.target); return val; } // ... 省略 }); // Watcher.js Watcher.prototype = { get: function(key) { Dep.target = this; this.value = data[key]; // 这里会触发属性的getter，从而添加订阅者 Dep.target = null; } } observer.js function Observer(data) { this.data = data; this.walk(data); } Observer.prototype = { walk: function(data) { var me = this; Object.keys(data).forEach(function(key) { me.convert(key, data[key]); }); }, convert: function(key, val) { this.defineReactive(this.data, key, val); }, defineReactive: function(data, key, val) { var dep = new Dep(); var childObj = observe(val); Object.defineProperty(data, key, { enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() { if (Dep.target) { dep.depend(); } return val; }, set: function(newVal) { if (newVal === val) { return; } val = newVal; // 新的值是object的话，进行监听 childObj = observe(newVal); // 通知订阅者 dep.notify(); } }); } }; function observe(value, vm) { if (!value || typeof value !== 'object') { return; } return new Observer(value); }; var uid = 0; function Dep() { this.id = uid++; this.subs = []; } Dep.prototype = { addSub: function(sub) { this.subs.push(sub); }, depend: function() { Dep.target.addDep(this); }, removeSub: function(sub) { var index = this.subs.indexOf(sub); if (index != -1) { this.subs.splice(index, 1); } }, notify: function() { this.subs.forEach(function(sub) { sub.update(); }); } }; Dep.target = null; 这里已经实现了一个Observer了，已经具备了监听数据和数据变化通知订阅者的功能，完整代码。那么接下来就是实现Compile了 2、实现Compile compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示： 因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将跟节点el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中 function Compile(el) { this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) { this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); } } Compile.prototype = { init: function() { this.compileElement(this.$fragment); }, node2Fragment: function(el) { var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) { fragment.appendChild(child); } return fragment; } }; compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明： Compile.prototype = { // ... 省略 compileElement: function(el) { var childNodes = el.childNodes, me = this; [].slice.call(childNodes).forEach(function(node) { var text = node.textContent; var reg = /\\{\\{(.*)\\}\\}/; // 表达式文本 // 按元素节点方式编译 if (me.isElementNode(node)) { me.compile(node); } else if (me.isTextNode(node) && reg.test(text)) { me.compileText(node, RegExp.$1); } // 遍历编译子节点 if (node.childNodes && node.childNodes.length) { me.compileElement(node); } }); }, compile: function(node) { var nodeAttrs = node.attributes, me = this; [].slice.call(nodeAttrs).forEach(function(attr) { // 规定：指令以 v-xxx 命名 // 如 中指令为 v-text var attrName = attr.name; // v-text if (me.isDirective(attrName)) { var exp = attr.value; // content var dir = attrName.substring(2); // text if (me.isEventDirective(dir)) { // 事件指令, 如 v-on:click compileUtil.eventHandler(node, me.$vm, exp, dir); } else { // 普通指令 compileUtil[dir] && compileUtil[dir](node, me.$vm, exp); } } }); } }; // 指令处理集合 var compileUtil = { text: function(node, vm, exp) { this.bind(node, vm, exp, 'text'); }, // ...省略 bind: function(node, vm, exp, dir) { var updaterFn = updater[dir + 'Updater']; // 第一次初始化视图 updaterFn && updaterFn(node, vm[exp]); // 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher new Watcher(vm, exp, function(value, oldValue) { // 一旦属性值有变化，会收到通知执行此更新函数，更新视图 updaterFn && updaterFn(node, value, oldValue); }); } }; // 更新函数 var updater = { textUpdater: function(node, value) { node.textContent = typeof value == 'undefined' ? '' : value; } // ...省略 }; 这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了{{}}表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如中v-text便是指令，而other-attr不是指令，只是普通的属性。 监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知 至此，一个简单的Compile就完成了，完整代码。接下来要看看Watcher这个订阅者的具体实现了 compile.js function Compile(el, vm) { this.$vm = vm; this.$el = this.isElementNode(el) ? el : document.querySelector(el); if (this.$el) { this.$fragment = this.node2Fragment(this.$el); this.init(); this.$el.appendChild(this.$fragment); } } Compile.prototype = { node2Fragment: function(el) { var fragment = document.createDocumentFragment(), child; // 将原生节点拷贝到fragment while (child = el.firstChild) { fragment.appendChild(child); } return fragment; }, init: function() { this.compileElement(this.$fragment); }, compileElement: function(el) { var childNodes = el.childNodes, me = this; [].slice.call(childNodes).forEach(function(node) { var text = node.textContent; var reg = /\\{\\{(.*)\\}\\}/; if (me.isElementNode(node)) { me.compile(node); } else if (me.isTextNode(node) && reg.test(text)) { me.compileText(node, RegExp.$1); } if (node.childNodes && node.childNodes.length) { me.compileElement(node); } }); }, compile: function(node) { var nodeAttrs = node.attributes, me = this; [].slice.call(nodeAttrs).forEach(function(attr) { var attrName = attr.name; if (me.isDirective(attrName)) { var exp = attr.value; var dir = attrName.substring(2); // 事件指令 if (me.isEventDirective(dir)) { compileUtil.eventHandler(node, me.$vm, exp, dir); // 普通指令 } else { compileUtil[dir] && compileUtil[dir](node, me.$vm, exp); } node.removeAttribute(attrName); } }); }, compileText: function(node, exp) { compileUtil.text(node, this.$vm, exp); }, isDirective: function(attr) { return attr.indexOf('v-') == 0; }, isEventDirective: function(dir) { return dir.indexOf('on') === 0; }, isElementNode: function(node) { return node.nodeType == 1; }, isTextNode: function(node) { return node.nodeType == 3; } }; // 指令处理集合 var compileUtil = { text: function(node, vm, exp) { this.bind(node, vm, exp, 'text'); }, html: function(node, vm, exp) { this.bind(node, vm, exp, 'html'); }, model: function(node, vm, exp) { this.bind(node, vm, exp, 'model'); var me = this, val = this._getVMVal(vm, exp); node.addEventListener('input', function(e) { var newValue = e.target.value; if (val === newValue) { return; } me._setVMVal(vm, exp, newValue); val = newValue; }); }, class: function(node, vm, exp) { this.bind(node, vm, exp, 'class'); }, bind: function(node, vm, exp, dir) { var updaterFn = updater[dir + 'Updater']; updaterFn && updaterFn(node, this._getVMVal(vm, exp)); new Watcher(vm, exp, function(value, oldValue) { updaterFn && updaterFn(node, value, oldValue); }); }, // 事件处理 eventHandler: function(node, vm, exp, dir) { var eventType = dir.split(':')[1], fn = vm.$options.methods && vm.$options.methods[exp]; if (eventType && fn) { node.addEventListener(eventType, fn.bind(vm), false); } }, _getVMVal: function(vm, exp) { var val = vm; exp = exp.split('.'); exp.forEach(function(k) { val = val[k]; }); return val; }, _setVMVal: function(vm, exp, value) { var val = vm; exp = exp.split('.'); exp.forEach(function(k, i) { // 非最后一个key，更新val的值 if (i 3、实现Watcher Watcher订阅者作为Observer和Compile之间通信的桥梁，主要做的事情是: 在自身实例化时往属性订阅器(dep)里面添加自己 自身必须有一个update()方法 待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 如果有点乱，可以回顾下前面的思路整理 function Watcher(vm, exp, cb) { this.cb = cb; this.vm = vm; this.exp = exp; // 此处为了触发属性的getter，从而在dep添加自己，结合Observer更易理解 this.value = this.get(); } Watcher.prototype = { update: function() { this.run(); // 属性值变化收到通知 }, run: function() { var value = this.get(); // 取到最新值 var oldVal = this.value; if (value !== oldVal) { this.value = value; this.cb.call(this.vm, value, oldVal); // 执行Compile中绑定的回调，更新视图 } }, get: function() { Dep.target = this; // 将当前订阅者指向自己 var value = this.vm[exp]; // 触发getter，添加自己到属性订阅器中 Dep.target = null; // 添加完毕，重置 return value; } }; // 这里再次列出Observer和Dep，方便理解 Object.defineProperty(data, key, { get: function() { // 由于需要在闭包内添加watcher，所以可以在Dep定义一个全局target属性，暂存watcher, 添加完移除 Dep.target && dep.addDep(Dep.target); return val; } // ... 省略 }); Dep.prototype = { notify: function() { this.subs.forEach(function(sub) { sub.update(); // 调用订阅者的update方法，通知变化 }); } }; 实例化Watcher的时候，调用get()方法，通过Dep.target = watcherInstance标记订阅者是当前watcher实例，强行触发属性定义的getter方法，getter方法执行的时候，就会在属性的订阅器dep添加当前watcher实例，从而在属性值有变化的时候，watcherInstance就能收到更新通知。 watcher.js function Watcher(vm, expOrFn, cb) { this.cb = cb; this.vm = vm; this.expOrFn = expOrFn; this.depIds = {}; if (typeof expOrFn === 'function') { this.getter = expOrFn; } else { this.getter = this.parseGetter(expOrFn); } this.value = this.get(); } Watcher.prototype = { update: function() { this.run(); }, run: function() { var value = this.get(); var oldVal = this.value; if (value !== oldVal) { this.value = value; this.cb.call(this.vm, value, oldVal); } }, addDep: function(dep) { // 1. 每次调用run()的时候会触发相应属性的getter // getter里面会触发dep.depend()，继而触发这里的addDep // 2. 假如相应属性的dep.id已经在当前watcher的depIds里，说明不是一个新的属性，仅仅是改变了其值而已 // 则不需要将当前watcher添加到该属性的dep里 // 3. 假如相应属性是新的属性，则将当前watcher添加到新属性的dep里 // 如通过 vm.child = {name: 'a'} 改变了 child.name 的值，child.name 就是个新属性 // 则需要将当前watcher(child.name)加入到新的 child.name 的dep里 // 因为此时 child.name 是个新值，之前的 setter、dep 都已经失效，如果不把 watcher 加入到新的 child.name 的dep中 // 通过 child.name = xxx 赋值的时候，对应的 watcher 就收不到通知，等于失效了 // 4. 每个子属性的watcher在添加到子属性的dep的同时，也会添加到父属性的dep // 监听子属性的同时监听父属性的变更，这样，父属性改变时，子属性的watcher也能收到通知进行update // 这一步是在 this.get() --> this.getVMVal() 里面完成，forEach时会从父级开始取值，间接调用了它的getter // 触发了addDep(), 在整个forEach过程，当前wacher都会加入到每个父级过程属性的dep // 例如：当前watcher的是'child.child.name', 那么child, child.child, child.child.name这三个属性的dep都会加入当前watcher if (!this.depIds.hasOwnProperty(dep.id)) { dep.addSub(this); this.depIds[dep.id] = dep; } }, get: function() { Dep.target = this; var value = this.getter.call(this.vm, this.vm); Dep.target = null; return value; }, parseGetter: function(exp) { if (/[^\\w.$]/.test(exp)) return; var exps = exp.split('.'); return function(obj) { for (var i = 0, len = exps.length; i 4、实现MVVM MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。 一个简单的MVVM构造器是这样子： function MVVM(options) { this.$options = options; var data = this._data = this.$options.data; observe(data, this); this.$compile = new Compile(options.el || document.body, this) } 但是这里有个问题，从代码中可看出监听的数据对象是options.data，每次需要更新视图，则必须通过var vm = new MVVM({data:{name: 'kindeng'}}); vm._data.name = 'dmq'; 这样的方式来改变数据。 显然不符合我们一开始的期望，我们所期望的调用方式应该是这样的： var vm = new MVVM({data: {name: 'kindeng'}}); vm.name = 'dmq'; 所以这里需要给MVVM实例添加一个属性代理的方法，使访问vm的属性代理为访问vm._data的属性，改造后的代码如下： function MVVM(options) { this.$options = options; var data = this._data = this.$options.data, me = this; // 属性代理，实现 vm.xxx -> vm._data.xxx Object.keys(data).forEach(function(key) { me._proxy(key); }); observe(data, this); this.$compile = new Compile(options.el || document.body, this) } MVVM.prototype = { _proxy: function(key) { var me = this; Object.defineProperty(me, key, { configurable: false, enumerable: true, get: function proxyGetter() { return me._data[key]; }, set: function proxySetter(newVal) { me._data[key] = newVal; } }); } }; "},"Vue/150行代码实现一个低配版的MVVM库.html":{"url":"Vue/150行代码实现一个低配版的MVVM库.html","title":"150行代码实现一个低配版的MVVM库","keywords":"","body":"150行代码实现一个低配版的MVVM库 150行代码实现一个低配版的MVVM库 原理篇 名词定义 为什么是低配版？ 什么是双向绑定 单向显示的设计思路（viewModel -> view） 先看看API的设计 思考题1 逆向修改的设计思路（viewModel 思考题2 同步机制 脏检查大法 setter大法 设计思路 总体设计图 代码篇 第一步 先把骨架搭好, 血肉晚点再填充 代码 github 再加150行代码教你实现一个低配版的web component库（1） —设计篇 什么才是好的 web component 设计 什么是component 我心目中的web component API设计 一个Web Component库必须具备的基本素（功）养（能） 第一点Mvvm 第二点Shadow Style 第三点Communication 第四点生命周期 再加150行代码教你实现一个低配版的web component库（2） —原理篇 先回顾一下 三大部分是 四大功能是 Component定义文件格式如下 Web Component库大致流程 组件通讯 再加150行代码教你实现一个低配版的web component库（3） —代码篇 component定义格式 设计图 还是先搭骨架，再填血肉 SegmentFault ComponentDefinition Loader ComponentGenerator 填上骨肉 上最终实现代码 github 原理篇 名词定义 先给低配版的库起一个响亮的名字-- SegmentFault.js 吧 （以下简称sf.js） 设置在DOM Element上的自定义属性前缀统一以 sf- 开头 （如 ） 为什么是低配版？ 没有sf-repeat 不支持select，checkbox，radio等控件的双向绑定 没有sf-if 很多都没有 什么是双向绑定 首先明白一个概念，什么是双向绑定？在说双向绑定之前，我们先说说单向显示。 单向显示 说白了就是view动态地显示变量。比如在ng或其它一些主流框架里类似这种写法 //scope.message= \"segmentfault\"; segmentfault 为什么说是单向呢，因为都是 viewModel上某个变量(message) -> view (h3)的一个过程，viewModel上的变量被view所呈现。 再来看看 逆向修改 前面说了单向是viewMode->view的过程，那逆向就是 viewModel ，换句话说就是viewModel被view修改的过程。例如angular中 一旦用户在input控件中输入值，便会实时地改变viewModel中message这个变量的值。这是一个view -> viewModel 的过程。 所谓的双向绑定就是一个 viewMode ->（显示） view ->（修改）viewModel 的过程。 双向绑定 = 单向显示 + 逆向修改注意： 单向显示可能发生在所有的类型DOM节点上，而逆向修改只可能发生在INPUT,SELECT,TEXTAREA等交互型控件上。 单向显示的设计思路（viewModel -> view） 先看看API的设计 // --- viewModel --- function ViewModel(){ this.message = \"segmentfault\"; } var vm = new ViewModel(); 要实现这个功能，我们的sf库应该需要哪几步操作呢？(先自己想想，独立思考下) 注册ViewModel，我们的库需要知道哪些object是viewModel 扫描整个DOM Tree找到有哪些DOM节点上被配置了sf-xxxx这个attribute 纪录这些被单向绑定的DOM节点和viewModel之间的映射关系 使用DOM API， element.innerText = vm.prop, element.value = vm.prop, element.xxxx = vm.prop 来显示数据 思考题1 Q：如果我们要单向绑定不是innerText,value 而是作为样式的class，style呢？ A：没错，使用sf-class=\"vm.myClass\" sf-style=\"vm.myStyle\"就好了，其它原生属性也以此类推 \"sf-\" + native attribute is good! 逆向修改的设计思路（viewModel 主流的一些mvvm框架上一般这么设计API，还是拿angular举例子 这里我个人并不认同这种xx-model的命名方式来作为双向绑定的一种标识，比如angular的ng-model，或Vue的v-model，撇开前缀不说，这个model很让人困惑，我们知道input控件是本身就有value这个native的属性的，这个属性就是代表着input输入和输出的值，如果要给一个input进行双向绑定我们应该很自然而然地使用一个 -value就可以了,完全没有必要弄出一个新的attribute叫做-model的,从而增加学习成本。 所以，我们就设计一个叫做sf-value的attribute来做API 拍脑袋想想，view要改变数据只可能发生在可以和用户交互的一些html控件上，比如input家族（text, radio, checkbox), select, textarea上。 像h1~hn家族，这辈子是没有机会的。 要实现view改写viewModel，我们的库应该需要哪几步操作呢？ 扫描整个DOM Tree，找到哪些INPUT，SELECT，TEXTAREA节点上被配置了sf-value这个attribute 纪录这些被双向绑定的DOM节点和viewModel之间的映射关系 sf.js库自动给这个写DOM加上onchange或者oninput的事件监听 一旦监听到change/input事件，立即获取这个DOM的value值，把这个element.value赋给与之绑定的viewModel的变量上。 思考题2 Q：那么问题来了，vm.message被input修改了，谁去通知其它同样绑定了vm.message的view呢？ A：请看下一段 同步机制 脏检查大法 脏检查大法 这三个字想必大家已经如雷贯耳，我2年多前出去面试的时候被问及最多的就是angular的脏检查，什么是脏检查？angular脏检查的时机是什么？ 脏检查的原理就是，拷贝一份copy_viewModel在内存中，一旦有用户点击，输入操作，或ajax请求，setInterval，setTimeout等这些可能导致viewModel发生改变的行为，框架都会把copy_viewModel和最新的viewModel进行深度比较，一旦发现有属性（如vm.message）发生变化，则重新渲染与message绑定的DOM节点。 这也是为什么，一旦你没有使用ng自带的$http，$interval,$timeout,ng-click这些angular自己封装的API去操作viewModel，angular都不会自动去同步view，因为已经超出他的管辖范围了，你必须手动调用apply函数去强制执行一次脏检查，以同步view。 setter大法 听说VUE是使用的这种同步机制，其核心原理就是使用Object.defineProperty(obj, prop, descriptor) 这个API，在setter中加点料，一旦有任何地方执行 vm.message = \"new value\"语句，则setter都会被调用，由setter去触发重新渲染view的逻辑。 相较这两种同步机制，似乎setter更加轻便，性能更好。所以本文使用了setter的方式来实现同步机制（关键是实现setter机制使用的代码较少）。 设计思路 给setter加点料 总体设计图 所以归纳来说一个MVVM库主要由3块组成 MVVM库 = 单向显示 + 逆向修改 + 同步机制 下图为sf.js的实现机制 其中Renderer负责单向显示和逆向修改，Watcher负责监视viewModel为同步机制的核心模块， Scanner负责sf.js初始化时扫描DOM Tree生成view和viewModel的映射关系。 SegmentFault模块则负责维护view-viewModel Map，以及各个模块间的调度 代码篇 第一步 先把骨架搭好, 血肉晚点再填充 设计的类不多，一共就5个 //SegmentFault.ts export let SegmentFault = class SegmentFault { private viewModelPool = {}; //用来维护viewModel的别名alias与viewModel之间的关系 private viewViewModelMap = {};//用来维护viewModel和被绑定的view之间的关系 public registerViewModel(alias:string, vm:object) {};//在sf正式运作之前我们先要注册一个下viewModel并给他起一个别名 public init() {}; //sf库开始运作的入口函数 public refresh(alias:string){}; // 暴露一个强制刷新整个viewModel的方法，因为毕竟有你监控不到的角落 } SegmentFault是对用户暴露的唯一的对象，就像Angular他会暴露一个angular对象给用户使用一样。 最终，用户会这样来操作SF以达到双向绑定的目的 不妨再看看使用效果 var sf = new SegmentFault(); //生成一个sf的实例 sf.registerViewModel(\"vm\", new ViewModel()); //注册一个viewModel，起一个叫vm的别名 sf.init(); //调用init方法，开始初始化，sf正式开始一些列工作 //以下是viewModel的定义 function ViewModel() { this.message = \"hello, SegmentFault\"; this.buttonClickHandler = function() { this.message = \"clicked: \" + this.message; }; } 有没有觉得SF的API干净利落，清新爽洁！ 根据设计图的Step 1，先给已注册的viewModel加上监视，这里我们需要一个Watcher类 export class Watcher { private sf; //构造函数里传入一个sf的对象，便于callback调用时的作用域确定。。。这是后话 constructor(sf) { this.sf = sf; } public observe(viewModel, callback) {} //暗中观察 } 再来看一下Step 2, 另一个主要的类Scanner，Scanner是干什么的呢？作用就一个遍历整个DOM Tree把出现sf-xxxx这个attribute的Elements全部挑出来，然后找sf-xxxx = expression，等号右边这个表达式里如果出现了viewModel的alias，那就说么这个element是跟viewModel搭界了，是绑定在一起了，scanner负责把这对\"恋人\"关系用一个数据结构维护一下，等全部扫描完了一起返回给SegmentFault去听候发落。 //Scanner.ts export class Scanner { private prefix = \"sf-\"; //库的前缀 private viewModelPool; constructor(viewModelPool) { this.viewModelPool = viewModelPool; //Scanner肯定是为SegmentFault服务的，所以初始化的时候SegmentFault会把之前注册过的viewModel信息传给Scanner，便于它去扫描。 } public scanBindDOM():object {} //找出attribute里带sf-，且等号右边表达式里含有viewModel的alias的Element，并返回一个view与viewModel的map } 接下去，SegmentFault会获得Scanner.scanBindDOM()所返回的view_viewModel Map,来看看这个Map的具体数据结构 //template { \"vm_alias\":[ { \"viewModel\":viewModel, \"element\":element, \"expression\":expression, \"attributeName\":attributeName } ] } //如果实际中的DOM Tree是这样的， //那么，Scanner扫描到的结果应该是 { \"userVM\":[ { \"viewModel\": userViewModel, \"element\": , \"expression\": \"vm.username\", \"attributeName\": \"sf-text\" }, { \"viewModel\": userViewModel, \"element\": , \"expression\": \"vm.username\", \"attributeName\": \"sf-value\" } ] } 我的实现中特地定一个了一个BoundItem类来描述 {\"viewModel\":viewModel,\"element\":element,\"expression\":expression,\"attributeName\":attributeName} //BoundItem.ts export class BoundItem { public viewModel: object; public element: Element; public expression: string; public attributeName: string; constructor(viewModel: object, element: Element, expression: string, attributeName: string) { this.viewModel = viewModel; this.element = element; this.expression = expression; this.attributeName = attributeName; } } 拿到view_viewModel map后，SegmentFault会调用Renderer去挨个渲染每一个BoundItem。 export class Renderer{ public render(boundItem:BoundItem) {}; } 好至此，几个主要的类都一一登场了，接下去我们完善下SegmentFault类，让ta和其它几个类联动起来 import {Scanner} from \"./Scanner\"; import {Watcher} from \"./Watcher\"; import {Renderer} from \"./Renderer\"; export let SegmentFault = class SegmentFault { private viewModelPool = {}; private viewViewModelMap = {}; private renderer = new Renderer(); public init() { let scanner = new Scanner(this.viewModelPool); let watcher = new Watcher(this); //step 1, 暗中观察各个viewModel for (let key in this.viewModelPool) { watcher.observe(this.viewModelPool[key],this.viewModelChangedHandler); } //step 2 3, 扫描DOM Tree并返回Map this.viewViewModelMap = scanner.scanBindDOM(); //step 4, 渲染DOM Object.keys(this.viewViewModelMap).forEach(alias=>{ this.refresh(alias); }); }; public registerViewModel(alias:string, viewModel:object) { viewModel[\"_alias\"] = alias; window[alias] = this.viewModelPool[alias] = viewModel; }; public refresh(alias:string){ let boundItems = this.viewViewModelMap[alias]; boundItems.forEach(boundItem => { this.renderer.render(boundItem); }); } private viewModelChangedHandler(viewModel,prop) { this.refresh(viewModel._alias); } } 好，写到这里，骨架全部构建完成，你有没有兴趣自己花点时间去填充血肉呢? 代码 //Watcher.ts export class Watcher { private sf; constructor(sf) { this.sf = sf; } public observe(viewModel, callback) { let host = this.sf; for (var key in viewModel) { var defaultValue = viewModel[key]; (function (k, dv) { if (k !== \"_alias\") { Object.defineProperty(viewModel, k, { get: function () { return dv; }, set: function (value) { dv = value; console.log(\"do something after set a new value\"); callback.call(host, viewModel, k); } }); } })(key, defaultValue); } } } //Scanner.ts import { BoundItem } from \"./BoundItem\"; export class Scanner { private prefix = \"sf-\"; private viewModelPool; constructor(viewModelPool) { this.viewModelPool = viewModelPool; } public scanBindDOM() :object{ let boundMap = {}; let boundElements = this.getAllBoundElements(this.prefix); boundElements.forEach(element => { for (let i = 0; i -1) { let attributeName = attr.nodeName; let expression = element.getAttribute(attributeName); for (let alias in this.viewModelPool) { if (expression.search(alias + \".\") != -1) { let boundItem = new BoundItem(this.viewModelPool[alias], element, expression,attributeName); if (!boundMap[alias]) { boundMap[alias] = [boundItem]; } else { boundMap[alias].push(boundItem); } } } } } }); return boundMap; } private fuzzyFind(element:HTMLElement,text:string):HTMLElement { if (element && element.attributes) { for (let i = 0; i -1) { return element; } } } return null; } private getAllBoundElements(prefix): Array { let elements = []; let allChildren = document.querySelectorAll(\"*\"); for (let i = 0; i //BoundItem.ts export class BoundItem { public viewModel: object; public element: Element; public expression: string; public attributeName: string; private interactiveDomConfig = { \"INPUT\":{ \"text\":\"input\", \"password\":\"input\", \"email\":\"input\", \"url\":\"input\", \"tel\":\"input\", \"radio\":\"change\", \"checkbox\":\"change\", \"color\":\"change\", \"date\":\"change\", \"datetime\":\"change\", \"datetime-local\":\"change\", \"month\":\"change\", \"number\":\"change\", \"range\":\"change\", \"search\":\"change\", \"time\":\"change\", \"week\":\"change\", \"button\":\"N/A\", \"submit\":\"N/A\" }, \"SELECT\":\"change\", \"TEXTAREA\":\"change\" } constructor(viewModel: object, element: Element, expression: string, attributeName: string) { this.viewModel = viewModel; this.element = element; this.expression = expression; this.attributeName = attributeName; this.addListener(this.element,this.expression); } private addListener(element,expression){ let tagName = element.tagName; let eventName = this.interactiveDomConfig[tagName]; if(!eventName){ return; } if(typeof eventName === \"object\"){ let type = element.getAttribute(\"type\"); eventName = eventName[type]; } element.addEventListener(eventName, (e)=> { let newValue = (element as HTMLInputElement).value; let cmd = expression + \"= \\\"\" + newValue + \"\\\"\"; try{ eval(cmd); }catch(e){ console.error(e); } }); } } //Renderer.ts import {BoundItem} from \"./BoundItem\"; export class Renderer{ public render(boundItem:BoundItem) { var value = this.getValue(boundItem.viewModel, boundItem.expression); var attribute = boundItem.attributeName.split('-')[1]; if (attribute.toLowerCase() === \"innertext\") { attribute = \"innerText\"; } boundItem.element[attribute] = value; }; private getValue(viewModel, expression) { return (function () { var alias = viewModel._alias; var tempScope = {}; tempScope[alias] = viewModel; try { var pattern = new RegExp(\"\\\\b\" + alias + \"\\\\b\", \"gm\"); expression = expression.replace(pattern, \"tempScope.\" + alias); var result = eval(expression); tempScope = null; return result; } catch (e) { throw e; } })(); } } github github 再加150行代码教你实现一个低配版的web component库（1） —设计篇 本篇是在上两篇的基础之上对代码进行进一步扩展，从而实现web component功能，所以读者务必掌握mvvm的实现机制才能深入理解本篇的内容（mvvm是web component的基石）。 什么才是好的 web component 设计 目前市面上各大主流前端框架，凡事带web component功能的，他们的设计水准基本都不入我的法眼，唯一看得上眼的是google的polymer，但是在某些API设计层面也显得略微繁琐（想了解polymer的朋友看一翻一下我专栏里面10篇polymer入门系列教程） 什么是component html提供的原生标签，比如DIV, BUTTON, INPUT家族，Hx家族等等，这些就好比俄罗斯方块里的一块块标准积木,我们称它们为stand component 某一天这些积木不能满足你的需求了，被扩展或被组合形成了非基本形状 这些新形状就是custom component，自定义组件！为什么要有component呢，好处是什么呢？ 可以复用 结构清晰 独立开发 我心目中的web component 在座的各位都写过index.html么？很简单 主要就分成3大块内容，style, dom, script 然后外面用个包裹 所以这期低配版web component库设计目的很简单，作为一个开发人员，我希望在写一个custom component的时候也能按照index.html的原生风格来写，这是多么的优雅，自然，没有学习成本啊！ 这也应该是无数人心目中的web component设计 API设计 所以，我们的SegmentFault.js v2.0的Web Component的设计宗旨就是，尽量接近原生的html结构和使用习惯,接近原生从而把学习成本降到最低，是我追求的东西 //js 写个具体的例子 button{ color:red; } p{ color:yellow; } this.message = \"this is a component\"; this.buttonName = \"click me\"; this.clickHandler = function(){ alert(this.message); }; 一个Component的描述文件定义好了，那么接下去就是如何引入它了。沿用上篇Mvvm中的风格，我们给SegmentFault这个Class弄个registerComponent(tagName,compPath)方法，比如在index.html中 var sf = new SegmentFault(); sf.registerController(\"xxx\",xxx); ... sf.registerComponent(\"my-comp\",\"components/myComp.html\"); ... sf.init(); 而在父组件中我们就可以通过\"my-comp\"这个我们刚刚注册时起的标签名来引入这个组件 ... 怎么样！四个字：干净利落 一个Web Component库必须具备的基本素（功）养（能） Mvvm 具备双向绑定功能 Shadow Style 具有独立的不污染全局的css功能 Communication 具有和父子兄弟组件通讯的功能 拥有生命周期 （属于高级功能，本低配版库不涉及） 第一点Mvvm Mvvm之前已经实现，我们只要套用之前的实现即可 第二点Shadow Style 可能很多人对这个没什么概念，我沿用前文中的内容，比如我们在component中定义了它的style，如 button{ color:red; } p{ color:yellow; } ... ... 这里我们在标签中，定义了css，其中p和button的写法在传统观念中都是会影响html页面中所有的p元素和button元素的，这是我们不希望发生的，我们希望的是这个标签生效的作用域仅仅是在当前的，被定义的component中。这种有独立作用域的css就叫Shadow Style。 要实现Shadow Style，其实有比较简单的做法，本篇设计篇中不会涉及，你可以趁此独立思考下，待下篇看看是否与我不谋而合，或者有比我更加高级的方案。 第三点Communication 即组件之间的通讯，经常有人在sf中问到这个组件通讯问题，其实这个问题是有比较标准的答案的，即3点 父子通讯: 父->子 通过 set 属性， 子->父 抛事件 兄弟通讯: 大儿子 抛事件给 -> 父 -> set 小儿子 的属性 远亲通讯: 走消息总线 （其实就在一个单例上搞事件机制） 要实现通讯机制，其实也不复杂，主要就2个功能，1 父组件可以set子组件的属性， 2 组件可以向外层抛事件，外层也可以监听组件抛出的事件，所以，我们会如此设计这块的内容，觉个例子,代码说话 ... 大家注意看，从父组件的角度，我可以使用sf- + propertyName(这里是msg) 来实现外部父组件对组件的赋值，而且还能使用sf-on + 自定义事件名称（这里是customevent） 对组件进行监听。 换个角度，从子组件角度出发，我可以被外部赋值，我可以可以向外部dispatch事件。 //... this.buttonName = \"click me\"; this.clickHandler = function () { alert(this.message); this.dispatchEvent(\"customevent\", \"hello world\");//为component的vm,内置一个dispatchEvent方法，用法和原生的事件机制一毛一样。 }; Object.defineProperty(this, \"msg\", { set: function (value) { if (value) { this.message = value; } } }); 使用Object.defineProperty可以很大程度上满足我们对set property的需求，另外再给component的vm挂载一个内置的函数this.dispatchEvent来发送自定义事件我们就功德圆满了。 第四点生命周期 你可以给一个组件：由注册->加载定义->显示到DOM Tree->内容更新->从DOM Tree移除->销毁 等一系时间节点定义他的生命周期，如果是做的比较考究的库，你可以把这这些时间节点的变更都一一向用户通知，或者提供api供用户控制。本文设计的低配版库阉割了这部分高级功能，我们就是一教学向的库，不整这些有的没的。 再加150行代码教你实现一个低配版的web component库（2） —原理篇 先回顾一下 上文说道一个基本款的custom web component由3大部分组成，同时也必须具备4大功能 三大部分是 Template(DOM) Style Script (viewModel) 四大功能是 Mvvm Shadow Style Communication Lifecycle （本文不涉及LC的API,但在实现中会隐形的涵盖这部分内容） Component定义文件格式如下 button{ color:red; } p{ color:yellow; } this.message = \"this is a component\"; this.buttonName = \"click me\"; this.clickHandler = function(){ alert(this.message); }; Web Component库大致流程 黑框以下是不是很眼熟，就是Mvvm篇中的流程。加入Component功能我们几乎不用动Mvvm部分的代码，只要在调用Scanner扫描viewModel和view的映射关系之前，我们把含有Component tag的主DOM Tree升级加工即可。其实Component定义文件中的和也是view和viewModel的关系。我们把Component的定义文件渲染到主DOM Tree上翻译成view和viewModel的关系，再由Mvvm篇中的Scanner，Renderer做扫描和渲染即可。是不是很简单？ 我们把着重点放在黑框上面的部分，也就是生成Component的流程，我们更加图中的steps，一步步来看 先放张局部大图 Step 1：RegisterComponent，这一步，是要在SF库init初始化之前就要进行的，我们给新的component起个名字tagName，比如my-comp，这样我们在以后就可以用这个tag在任何地方引入这个component，另外还需要把component定义文件的路径告诉SF，方便其在初始化的时候加载这些定义文件 //伪代码 var sf = new SegmentFault(); sf.registerComponent(\"my-comp\",\"./components/myComp.html\"); sf.init(); Step 2 3 4: Loader加载器在sf.init()时被调用，去加载\"./components/myComp.html\"这些路径上的component定义文件，并且把这些定义和tagName形成一份Map返回给SF Step 5: （第五步相当重要，web component 99%的精髓都在这一步，请认真阅读） SF拿到Map后，通知Generator去扫描DOM Tree一旦发现有标签出现，则使出DOM替换大法，把Map中my-comp对应的component定义中的template部分的DOM，替换上去。如下图 DOM替换大法 思考题： Q:辣么，Component定义中的里的viewModel怎么办？ A: 使用new Function()或者eval把中的viewModel生成一个function,我们姑且叫它CompViewModel，然后把template 上的sf-xxx=“this.xxxx”的attribute中，等式的左边全部含有this的部分，替换成vm_随机数，比如 替换成 还记得这个vm_2333是什么的？没错如果你没有白看Mvvm那两篇教程的话，vm_2333就是viewModel实例的alias。那还等什么?赶紧调用sf.registerViewModle(\"vm_2333\",new CompViewModel())注册这个component的viewModel吧！ 有没有发现web component库的套路，是不是很简单？第一步，把index.html（或父组件）中含有的component tagName找出来，然后一通替换和伪装，第二步，让SF把它当成Mvvm篇中的普通view-viewModel和关系去处理即可。 template和script处理完了，那么接下去就只剩下style，如何让标签中的css定义的作用于只发生在当前？ 我给出的办法是，还是移花接木大法 p{ color:red; } 第一步，要把这坨css加到index.html的head中去，这样css才会生效，但是这样会污染全局 ... p{ color:red; } 第二步，把这坨css进行加工,加上作用域 .myComp ,这样的话，根据css selector语义，只有在class=\"myComp\"的DOM下的p元素才会生效 ... .myComp p{ color:red; } 第三步，当然是给代表component的DOM最外层上增加一个叫myComp的class了，一个简单版的Shadow Style就这样实现了。 至此，一个component的三大组成说完，四大功能还剩communication没有讲 组件通讯 很简单，实现2个接口即可实现组件通讯，具体见上篇《设计篇》有提到 Component的属性可以被父组件set进值 viewModel可以向外dispatch事件 这2个接口都可以在step 5中通过一些小动作，给加进去，本篇就不具体解释了，作为思考题大家回去思考，俗话说的的talk is cheap，show me the code，具体实现会在第三篇《代码篇》中给出，大家看了自己一目了然，比我这里浪费口舌能更好的理解。 再加150行代码教你实现一个低配版的web component库（3） —代码篇 component定义格式 button{ color:red; } p{ color:yellow; } this.message = \"this is a component\"; this.buttonName = \"click me\"; this.clickHandler = function(){ alert(this.message); }; 设计图 还是先搭骨架，再填血肉 这次增加web component功能，只是在原来mvvm的基础上新增了3个类，分别是Loader，ComponentGenerator，和一个描述component定义的类型ComponentDefinition 我们看到设计图中的入口是register component，我们需要给SegmentFault类增加个registerComponent的接口 SegmentFault export let SegmentFault = class SegmentFault { ... private componentPool = {}; //传入自定义component的tagName，tagName可以随便起，例如my-comp //path为定义文件的路径，例如components/myComp.html public registerComponent(tagName,path){ this.componentPool[tagName] = path; } ... } ComponentDefinition ComponentDefinitiony用来维护component的定义文件，我们需要把每个xxxComp.html定义文件中的以及component的tagName维护在内存对象中 export class ComponentDefinition{ public tagName; //例如 中的my-comp就是tagName，tagName由registerComponent时传入。 public style; //样式，即中的字符串 public template; //DOM，即中的字符串 public script; //逻辑，即中的字符串 constructor(tagName,style,template,script){ this.tagName = tagName; this.style = style; this.template = template; this.script = script; } } Loader 这个类就是在sf.init的时候去加载所有定义的component定义文件，把html中的内容维护在内存对象中，并且也会同时维护一张map，来反应tagName和ComponentDefinition之间的映射关系，鉴于是通过ajax请求来load，这些*.html定义文件，所以会使用promise的返回类型。 import {ComponentDefinition} from \"./ComponentDefinition\"; export class Loader { private componentPool; private componentDefinitionPool = {}; constructor(componentPool) { this.componentPool = componentPool; } //通过ajax请求，异步加载各个.html的定义文件，并维护componentDefinitionPool public load(): Promise { } } ComponentGenerator Loader加载完定义之后，就需要Generator来扫描解析整棵DOM Tree，并用template中的内容替换这种tag标签了，具体原理请参考《原理篇》 主要分成2步 扫描scan，和 替换生成generator！由于需要递归扫描子节点，我比较多的使用了async/await来确保同步。 export class ComponentGenerator { private sf; private componentDefinitionPool; constructor(sf, componentDefinitionPool) { this.componentDefinitionPool = componentDefinitionPool; this.sf = sf; } public async scanComponent(element): Promise { } private async generate(tagElement: HTMLElement, compDef: ComponentDefinition, attrs) { } } 填上骨肉 上最终实现代码 //SegmentFault.ts import {Scanner} from \"./Scanner\"; import {Watcher} from \"./Watcher\"; import {Renderer} from \"./Renderer\"; import {Loader} from \"./component/Loader\"; import {ComponentGenerator} from \"./component/ComponentGenerator\"; export let SegmentFault = class SegmentFault { private viewModelPool = {}; private viewViewModelMap = {}; private renderer = new Renderer(); private generator:ComponentGenerator; public init():Promise{ return new Promise((resolve,reject)=>{ let loader = new Loader(this.componentPool); loader.load().then( componentDefinitionPool =>{ console.log(componentDefinitionPool); if(componentDefinitionPool){ this.generator = new ComponentGenerator(this,componentDefinitionPool); return this.generator.scanComponent(document); }else{ return; } }).then(()=>{ let scanner = new Scanner(this.viewModelPool); let watcher = new Watcher(this); for (let key in this.viewModelPool) { watcher.observe(this.viewModelPool[key],this.viewModelChangedHandler); } this.viewViewModelMap = scanner.scanBindDOM(); Object.keys(this.viewViewModelMap).forEach(alias=>{ this.refresh(alias); }); resolve(); }); }); }; public registerViewModel(alias:string, viewModel:object) { viewModel[\"_alias\"] = alias; window[alias] = this.viewModelPool[alias] = viewModel; }; public refresh(alias:string){ let boundItems = this.viewViewModelMap[alias]; boundItems.forEach(boundItem => { this.renderer.render(boundItem); }); } private viewModelChangedHandler(viewModel,prop) { this.refresh(viewModel._alias); } private componentPool = {}; public registerComponent(tagName,path){ this.componentPool[tagName] = path; } } //ComponentDefinition.ts export class ComponentDefinition{ public tagName; public style; public template; public script; constructor(tagName,style,template,script){ this.tagName = tagName; this.style = style; this.template = template; this.script = script; } } //Loader.ts import {ComponentDefinition} from \"./ComponentDefinition\"; export class Loader { private componentPool; private componentDefinitionPool = {}; constructor(componentPool) { this.componentPool = componentPool; } public load(): Promise { let compArray = []; for (var tagName in this.componentPool) { compArray.push({ name: tagName, path: this.componentPool[tagName] }); } return this.doAsyncSeries(compArray).then(result=>{ return result; }); } private doAsyncSeries(componentArray): Promise { return componentArray.reduce( (promise, comp) =>{ return promise.then( (result) => { return fetch(comp.path).then((response) => { return response.text().then(definition => { let def = this.getComponentDefinition(comp.name,definition); this.componentDefinitionPool[comp.name] = def; return this.componentDefinitionPool; }); }); }); }, new Promise((resolve, reject) => { resolve(); })); } private getComponentDefinition(tagName:string, htmlString: string): ComponentDefinition { let tempDom: HTMLElement = document.createElement(\"div\"); tempDom.innerHTML = htmlString; let template: string = tempDom.querySelectorAll(\"template\")[0] && tempDom.querySelectorAll(\"template\")[0].innerHTML; let script: string = tempDom.querySelectorAll(\"script\")[0] && tempDom.querySelectorAll(\"script\")[0].innerHTML; let style: string = tempDom.querySelectorAll( \"style\")[0] && tempDom.querySelectorAll( \"style\")[0].innerHTML; return new ComponentDefinition(tagName,style,template,script); } } //ComponentGenerator.ts import { ComponentDefinition } from \"./ComponentDefinition\"; export class ComponentGenerator { private sf; private componentDefinitionPool; constructor(sf, componentDefinitionPool) { this.componentDefinitionPool = componentDefinitionPool; this.sf = sf; } public async scanComponent(element): Promise { let compDef: ComponentDefinition = this.componentDefinitionPool[element.localName]; if (compDef) { let attrs = element.attributes; return this.generate(element, compDef, attrs); } else { if (element.children && element.children.length > 0) { for (let i = 0; i 1) { template = tempFragment.outerHTML; } tagElement.insertAdjacentHTML('beforeBegin' as InsertPosition, template); let htmlDom = tagElement.previousElementSibling; htmlDom.classList.add(tagElement.localName); let vm_instance; if (compDef.script) { let debugComment = \"//# sourceURL=\"+tagElement.tagName+\".js\"; let script = compDef.script + debugComment; let ViewModelClass: Function = new Function(script); vm_instance = new ViewModelClass.prototype.constructor(); this.sf.registerViewModel(randomAlias, vm_instance); vm_instance._dom = htmlDom; vm_instance.dispatchEvent = (eventType: string, data: any, bubbles: boolean = false, cancelable: boolean = true) => { let event = new CustomEvent(eventType.toLowerCase(), { \"bubbles\": bubbles, \"cancelable\": cancelable }); event['data'] = data; vm_instance._dom.dispatchEvent(event); }; for (let i = 0; i 0) { for (let j = 0; j { var newValue = value.replace(/^\\s*/, \"\"); if (newValue) { newArray.push(newValue); } }); stylesheet = newArray.join(\"}\\n\" + \".\" + tagName + \" \"); stylesheet = \".\" + tagName + \" \" + stylesheet + \"}\"; style.innerHTML = stylesheet; head.appendChild(style); } } github github地址 "},"Vue/160行代码仿Vue实现极简双向绑定[详细注释].html":{"url":"Vue/160行代码仿Vue实现极简双向绑定[详细注释].html","title":"160行代码仿Vue实现极简双向绑定[详细注释]","keywords":"","body":"160行代码仿Vue实现极简双向绑定[详细注释] 160行代码仿Vue实现极简双向绑定[详细注释] 前言 了解Object.defineProperty() 实现思路： mvvm系列的双向绑定，关键步骤： 流程图 具体代码实现： html结构： 调用方法： 创建myVue函数： Watcher函数: 实现数据监听器_observer()： 实现Compile 模板编译 完整代码&demo地址 前言 现在的前端面试不管你用的什么框架，总会问你这个框架的双向绑定机制，有的甚至要求你现场实现一个双向绑定出来，那对于没有好好研究过这方面知识的同学来说，当然是很难的，接下来本文用160行代码带你实现一个极简的双向绑定机制 效果GIF： 了解Object.defineProperty() 这个API是实现双向绑定的核心，最主要的作用是重写数据的get、set方法 使用方式： let obj = { singer: \"周杰伦\" }; let value = \"青花瓷\"; Object.defineProperty(obj, \"music\", { // value: '七里香', // 设置属性的值 下面设置了get set函数 所以这里不能设置 configurable: false, // 是否可以删除属性 默认不能删除 // writable: true, // 是否可以修改对象 下面设置了get set函数 所以这里不能设置 enumerable: true, // music是否可以被枚举 默认是不能被枚举(遍历) // ☆ get,set设置时不能设置writable和value，要一对一对设置，交叉设置/同时存在 就会报错 get() { // 获取obj.music的时候就会调用get方法 // let value = \"强行设置get的返回值\"; // 打开注释 读取属性永远都是‘强行设置get的返回值’ return value; }, set(val) { // 将修改的值重新赋给song value = val; } }); console.log(obj.music); // 青花瓷 delete obj.music; // configurable设为false 删除无效 console.log(obj.music); // 青花瓷 obj.music = \"听妈妈的话\"; console.log(obj.music); // 听妈妈的话 for (let key in obj) { // 默认情况下通过defineProperty定义的属性是不能被枚举(遍历)的 // 需要设置enumerable为true才可以 否则只能拿到singer 属性 console.log(key); // singer, music } 示例demo： demo 重点 get,set设置时不能设置writable和value, 他们是一对情侣的存在，交叉设置或同时存在,会报错 通过defineProperty设置的属性，默认不能删除，不能遍历，当然你可以通过设置更改他们。 get、set 是函数，可以做的事情很多。 更详细的可以看一下MDN 实现思路： mvvm系列的双向绑定，关键步骤： 实现数据监听器Observer，用Object.defineProperty()重写数据的get、set，值更新就在set中通知订阅者更新数据。 实现模板编译Compile，深度遍历dom树，对每个元素节点的指令模板进行替换数据以及订阅数据。 实现Watch用于连接Observer和Compile，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。 mvvm入口函数，整合以上三者。 流程图 具体代码实现： html结构： {{ testData1 }} {{ testData2 }} 调用方法： 采用类Vue方式来使用双向绑定： window.onload = function () { var app = new myVue({ el: '#app', // dom data: { // 数据 testData1: '仿Vue', testData2: '极简双向绑定', name: 'OBKoro1' } }) } 创建myVue函数： 实际上这里是我们实现思路中的第四步，用于整合数据监听器this._observer()、指令解析器this._compile()以及连接Observer和Compile的_watcherTpl的watch池。 function myVue(options = {}) { // 防止没传，设一个默认值 this.$options = options; // 配置挂载 this.$el = document.querySelector(options.el); // 获取dom this._data = options.data; // 数据挂载 this._watcherTpl = {}; // watcher池 this._observer(this._data); // 传入数据，执行函数，重写数据的get set this._compile(this.$el); // 传入dom，执行函数，编译模板 发布订阅 }; Watcher函数: 这是实现思路中的第三步，因为下方数据监听器_observer()需要用到Watcher函数，所以这里就先讲了。 像实现思路中所说的，这里起到了连接Observer和Compile的作用： 在模板编译_compile()阶段发布订阅 在赋值操作的时候，更新视图// new Watcher() 为this._compile()发布订阅+ 在this._observer()中set(赋值)的时候更新视图 function Watcher(el, vm, val, attr) { this.el = el; // 指令对应的DOM元素 this.vm = vm; // myVue实例 this.val = val; // 指令对应的值 this.attr = attr; // dom获取值，如value获取input的值 / innerHTML获取dom的值 this.update(); // 更新视图 } Watcher.prototype.update = function () { this.el[this.attr] = this.vm._data[this.val]; // 获取data的最新值 赋值给dom 更新视图 } 实现数据监听器_observer()： 实现思路中的第一步，用Object.defineProperty()遍历data重写所有属性的get set。 然后在给对象的某个属性赋值的时候，就会触发set。 在set中我们可以监听到数据的变化，然后就可以触发watch更新视图。 myVue.prototype._observer = function (obj) { var _this = this; Object.keys(obj).forEach(key => { // 遍历数据 _this._watcherTpl[key] = { // 每个数据的订阅池() _directives: [] }; var value = obj[key]; // 获取属性值 var watcherTpl = _this._watcherTpl[key]; // 数据的订阅池 Object.defineProperty(_this._data, key, { // 双向绑定最重要的部分 重写数据的set get configurable: true, // 可以删除 enumerable: true, // 可以遍历 get() { console.log(`${key}获取值：${value}`); return value; // 获取值的时候 直接返回 }, set(newVal) { // 改变值的时候 触发set console.log(`${key}更新：${newVal}`); if (value !== newVal) { value = newVal; watcherTpl._directives.forEach((item) => { // 遍历订阅池 item.update(); // 遍历所有订阅的地方(v-model+v-bind+{{}}) 触发this._compile()中发布的订阅Watcher 更新视图 }); } } }) }); } 实现Compile 模板编译 这里是实现思路中的第三步，让我们来总结一下这里做了哪些事情： 首先是深度遍历dom树，遍历每个节点以及子节点。 将模板中的变量替换成数据，初始化渲染页面视图。 把指令绑定的属性添加到对应的订阅池中 一旦数据有变动，收到通知，更新视图。myVue.prototype._compile = function(el) { var _this = this, nodes = el.children; // 获取app的dom for (var i = 0, len = nodes.length; i set触发watch 更新视图 }; })(i) ); } if (node.hasAttribute(\"v-bind\")) { // v-bind指令 var attrVal = node.getAttribute(\"v-bind\"); // 绑定的data _this._watcherTpl[attrVal]._directives.push( new Watcher(node, _this, attrVal, \"innerHTML\") // 将dom替换成属性的数据并发布订阅 在set的时候更新数据 ); } var reg = /\\{\\{\\s*([^}]+\\S)\\s*\\}\\}/g, txt = node.textContent; // 正则匹配 双括号｛{}｝ if (reg.test(txt)) { node.textContent = txt.replace(reg, (matched, placeholder) => { // matched匹配的文本节点包括｛{}｝, placeholder 是｛{}｝中间的属性名 var getName = _this._watcherTpl; // 所有绑定watch的数据 getName = getName[placeholder]; // 获取对应watch 数据的值 if (!getName._directives) { // 没有事件池 创建事件池 getName._directives = []; } getName._directives.push( new Watcher(node, _this, placeholder, \"innerHTML\") // 将dom替换成属性的数据并发布订阅 在set的时候更新数据 ); return placeholder.split(\".\").reduce((val, key) => { return _this._data[key]; // 获取数据的值 触发get 返回当前值 }, _this.$el); }); } } }; 完整代码&demo地址 GitHub完整代码 仿Vue极简双向绑定 #app { margin-top: 3vh; text-align: center; } 仿Vue实现极简双向绑定 v-bind形式： dom 深度遍历 {{}}}形式： {{ name }} {{ testData1 }} {{ testData2 }} window.onload = function () { var app = new myVue({ // 构造函数 el: '#app', // dom data: { testData1: '仿Vue', testData2: '极简双向绑定', name: 'OBKoro1' } }) } // mvvm入口函数 用于整合 数据监听器_observer、 指令解析器_compile、连接Observer和Compile的_watcherTpl function myVue(options = {}) { // 防止没传，设一个默认值 this.$options = options; // 配置挂载 this.$el = document.querySelector(options.el); // 获取dom this._data = options.data; // 数据挂载 this._watcherTpl = {}; // watcher池 this._observer(this._data); // 传入数据，执行函数，重写数据的get set this._compile(this.$el); // 传入dom，执行函数，编译模板 发布订阅 }; // 重写data 的 get set 更改数据的时候，触发watch 更新视图 myVue.prototype._observer = function (obj) { var _this = this; Object.keys(obj).forEach(key => { // 遍历数据 _this._watcherTpl[key] = { // 每个数据的订阅池() _directives: [] }; var value = obj[key]; // 获取属性值 var watcherTpl = _this._watcherTpl[key]; // 数据的订阅池 Object.defineProperty(_this._data, key, { // 双向绑定最重要的部分 重写数据的set get configurable: true, // 可以删除 enumerable: true, // 可以遍历 get() { console.log(`${key}获取值：${value}`); return value; // 获取值的时候 直接返回 }, set(newVal) { // 改变值的时候 触发set console.log(`${key}更新：${newVal}`); if (value !== newVal) { value = newVal; watcherTpl._directives.forEach((item) => { // 遍历订阅池 item.update(); // 遍历所有订阅的地方(v-model+v-bind+{{}}) 触发this._compile()中发布的订阅Watcher 更新视图 }); } } }) }); } // 模板编译 myVue.prototype._compile = function (el) { var _this = this, nodes = el.children; // 获取app的dom for (var i = 0, len = nodes.length; i set触发watch 更新视图 } })(i)); } if (node.hasAttribute('v-bind')) { // v-bind指令 var attrVal = node.getAttribute('v-bind'); // 绑定的data _this._watcherTpl[attrVal]._directives.push(new Watcher( // 将dom替换成属性的数据并发布订阅 在set的时候更新数据 node, _this, attrVal, 'innerHTML' )) } var reg = /\\{\\{\\s*([^}]+\\S)\\s*\\}\\}/g, txt = node.textContent; // 正则匹配{{}} if (reg.test(txt)) { node.textContent = txt.replace(reg, (matched, placeholder) => { // matched匹配的文本节点包括{{}}, placeholder 是{{}}中间的属性名 var getName = _this._watcherTpl; // 所有绑定watch的数据 getName = getName[placeholder]; // 获取对应watch 数据的值 if (!getName._directives) { // 没有事件池 创建事件池 getName._directives = []; } getName._directives.push(new Watcher( // 将dom替换成属性的数据并发布订阅 在set的时候更新数据 node, _this, placeholder, 'innerHTML' )); return placeholder.split('.').reduce((val, key) => { return _this._data[key]; // 获取数据的值 触发get 返回当前值 }, _this.$el); }); } } } // new Watcher() 为this._compile()发布订阅+ 在this._observer()中set(赋值)的时候更新视图 function Watcher(el, vm, val, attr) { this.el = el; // 指令对应的DOM元素 this.vm = vm; // myVue实例 this.val = val; // 指令对应的值 this.attr = attr; // dom获取值，如value获取input的值 / innerHTML获取dom的值 this.update(); // 更新视图 } Watcher.prototype.update = function () { this.el[this.attr] = this.vm._data[this.val]; // 获取data的最新值 赋值给dom 更新视图 } "},"Vue/vue-SSR-cookie问题.html":{"url":"Vue/vue-SSR-cookie问题.html","title":"Vue SSR cookie问题","keywords":"","body":"Vue SSR 的 Cookies 问题 Vue SSR 的 Cookies 问题 第一种方案 第二种方案 第三种方案 第四种方案 code 一个网站一旦涉及到多用户, 就很难从 Cookies 中逃脱, Vue SSR 的 cookies 也真算是遇到的一个不小的问题, 从开始玩 SSR 开始到现在, 一共想出了3种方案, 从最早的把 Cookies 注入到 state 中, 到把 Cookies 注入到 global, 到现在的将 Cookies 注入到组件的 asyncData 方法. 随着 Vue 的升级, 第一种方案已经不再适用, 第二种也有不少的限制, 于是想到第三种方案, 下来就说说具体实现的方法: 第一种方案 第一种方案已经不再适用, 这里不再细说 第二种方案 思路: 将 cookies 注入到 ssr 的 context里, 然后在请求 api 时读取, 再追加到 axios 的header 首先在 server.js 里将 cookies 加到 context里 const context = { title: 'M.M.F 小屋', description: 'M.M.F 小屋', url: req.url, cookies: req.cookies } renderer.renderToString(context, (err, html) => { if (err) { return errorHandler(err) } res.end(html) }) 之后, Vue 会把 context 加到 global.__VUE_SSR_CONTEXT__ 在 api.js 里读取 cookies import axios from 'axios' import qs from 'qs' import md5 from 'md5' import config from './config-server' const SSR = global.__VUE_SSR_CONTEXT__ const cookies = SSR.cookies || {} const parseCookie = cookies => { let cookie = '' Object.keys(cookies).forEach(item => { cookie+= item + '=' + cookies[item] + '; ' }) return cookie } export default { async post(url, data) { const cookie = parseCookie(cookies) const res = await axios({ method: 'post', url: config.api + url, data: qs.stringify(data), timeout: config.timeout, headers: { 'X-Requested-With': 'XMLHttpRequest', 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', cookie } }) return res }, } 为什么可以这么做? 默认情况下，Vue 对于每次渲染，bundle renderer 将创建一个新的 V8 上下文并重新执行整个 bundle。应用程序代码与服务器进程隔离, 所以每个访问的用户上下文都是独立的, 不会互相影响. 但是从Vue@2.3.0开始, 在createBundleRenderer方法的选项中, 添加了runInNewContext选项, 使用 runInNewContext: false，bundle 代码将与服务器进程在同一个 global 上下文中运行，所以我们不能再将 cookies 放在 global, 因为这会让所有用户共用同一个 cookies. 为什么现在不这么做? 那我们继续将runInNewContext设置成true, 不就好了吗? 当然也是可以的, 但是重新创建上下文并执行整个 bundle 还是相当昂贵的，特别是当应用很大的时候. 第三种方案 思路: 将 Cookies 作为参数注入到组件的asyncData方法, 然后用传参数的方法把 cookies 传给 api, 不得不说这种方法很麻烦, 但是这是个人能想到的比较好的方法 步骤1: 还是在 server.js 里, 把 cookies 注入到 context 中 const context = { title: 'M.M.F 小屋', url: req.url, cookies: req.cookies, } renderer.renderToString(context, (err, html) => { if (err) { return handleError(err) } res.end(html) }) 步骤2: 在entry-server.js里, 将cookies作为参数传给 asyncData 方法 Promise.all(matchedComponents.map(({asyncData}) => asyncData && asyncData({ store, route: router.currentRoute, cookies: context.cookies, isServer: true, isClient: false }))).then(() => { context.state = store.state context.isProd = process.env.NODE_ENV === 'production' resolve(app) }).catch(reject) 步骤3: 在组件里, 把 cookies 做为参数给 Vuex 的 actions export default { name: 'frontend-index', async asyncData({store, route, cookies}, config = { page: 1}) { config.cookies = cookies await store.dispatch('frontend/article/getArticleList', config) } // ..... } 步骤4: 在 Vuex 里将 cookies 做为参数给 api import api from '~api' const state = () => ({ lists: { data: [], hasNext: 0, page: 1, path: '' }, }) const actions = { async ['getArticleList']({commit, state}, config) { // vuex 作为临时缓存 if (state.lists.data.length > 0 && config.path === state.lists.path && config.page === 1) { return } let cookies if (config.cookies) { cookies = config.cookies delete config.cookies } const { data: { data, code} } = await api.get('frontend/article/list', {...config, cache: true}, cookies) if (data && code === 200) { commit('receiveArticleList', { ...config, ...data, }) } }, } const mutations = { ['receiveArticleList'](state, {list, hasNext, hasPrev, page, path}) { if (page === 1) { list = [].concat(list) } else { list = state.lists.data.concat(list) } state.lists = { data: list, hasNext, hasPrev, page, path } }, } const getters = { } export default { namespaced: true, state, actions, mutations, getters } 这里一定要注意, state 一定要用函数返回值来初始化 state, 不然会导致所有用户共用 state 步骤5: 在 api 里接收 cookies, 并加到 axios 的 headers 里 import axios from 'axios' import qs from 'qs' import config from './config-server' const parseCookie = cookies => { let cookie = '' Object.keys(cookies).forEach(item => { cookie+= item + '=' + cookies[item] + '; ' }) return cookie } export default { get(url, data, cookies = {}) { const cookie = parseCookie(cookies) return axios({ method: 'get', url: config.api + url, data: qs.stringify(data), timeout: config.timeout, headers: { 'X-Requested-With': 'XMLHttpRequest', 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', cookie } }) }, } 如果你没有将 axios 重新封装, 那么也可以把第五步省略, 直接在第四部把 cookies 给 axios 即可 第四种方案 步骤1: 还是在 server.js 里, 把 cookies 注入到 context 中 const context = { title: 'M.M.F 小屋', url: req.url, cookies: req.cookies, } renderer.renderToString(context, (err, html) => { if (err) { return handleError(err) } res.end(html) }) 步骤2: 在entry-server.js里, 将cookies作为参数传给 api.setCookies 方法, api.setCookies 是什么东西后面会有 api.setCookies(context.cookies) // 这一句 Promise.all(matchedComponents.map(({asyncData}) => asyncData && asyncData({ store, route: router.currentRoute, cookies: context.cookies, isServer: true, isClient: false }))).then(() => { // ... } 步骤3: 重写 api.js import axios from 'axios' import qs from 'qs' import config from './config-server' const parseCookie = cookies => { let cookie = '' Object.keys(cookies).forEach(item => { cookie+= item + '=' + cookies[item] + '; ' }) return cookie } export default { api: null, cookies: {}, setCookies(value) { value = value || {} this.cookies = value this.api = axios.create({ baseURL: config.api, headers: { 'X-Requested-With': 'XMLHttpRequest', cookie: parseCookie(value) }, timeout: config.timeout, }) }, post(url, data) { if (!this.api) this.setCookies() return this.api({ method: 'post', url, data: qs.stringify(data), headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', } }).then(res => { return res }) }, get(url, params) { if (!this.api) this.setCookies() return this.api({ method: 'get', url, params, }).then(res => { return res }) } } code github地址 "},"Vue/理解vue-ssr原理并自己搭建简单的ssr框架.html":{"url":"Vue/理解vue-ssr原理并自己搭建简单的ssr框架.html","title":"理解vue ssr原理并自己搭建简单的ssr框架","keywords":"","body":"理解vue ssr原理并自己搭建简单的ssr框架 理解vue ssr原理并自己搭建简单的ssr框架 1. 前言 2. 引入 3. 原理解析 第一步：编写entry-client.js和entry-server.js 第二步：配置webpack 第三步：启动服务 DEMO 1. 前言 大多数Vue项目要支持SSR应该是为了SEO考虑，毕竟对于WEB应用来说，搜索引擎是一个很大的流量入口。Vue SSR现在已经比较成熟了，但是如果是把一个SPA应用改造成SSR应用，成本还是有些高的，这工作量无异于重构前端。另外对前端的技术要求也是挺高的，需要对Vue比较熟悉，还要有Node.js 和 webpack 的应用经验。 2. 引入 Vue是一个构建客户端应用的框架，即vue组件是在浏览器中进行渲染的。所谓服务端渲染，指的是把vue组件在服务器端渲染为组装好的HTML字符串，然后将它们直接发送到浏览器，最后需要将这些静态标记\"激活\"为客户端上完全可交互的应用程序。 服务端渲染的优点 更好的SEO，搜索引擎爬虫可以抓取渲染好的页面 更快的内容到达时间（首屏加载更快），因为服务端只需要返回渲染好的HTML，这部分代码量很小的，所以用户体验更好 服务端渲染的缺点 首先就是开发成本比较高，比如某些声明周期钩子函数（如beforeCreate、created）能同时运行在服务端和客户端，因此第三方库要做特殊处理，才能在服务器渲染应用程序中运行。 由于服务端渲染要用Nodejs做中间层，所以部署项目时，需要处于Node.js server运行环境。在高流量环境下，还要做好服务器负载和缓存策略 3. 原理解析 第一步：编写entry-client.js和entry-server.js entry-client.js只在浏览器环境下执行，所以需要显示调用$mount方法，挂载DOM节点 ```js import Vue from 'vue'; import App from './App.vue'; import createStore from './store/index.js'; function createApp() { const store = createStore(); const app = new Vue({ store, render: h => h(App) }); return {app, store} } const { app, store } = createApp(); // 使用window.__INITIAL_STATE__中的数据替换整个state中的数据，这样服务端渲染结束后，客户端也可以自由操作state中的数据 if (window.__INITIAL_STATE__) { store.replaceState(window.__INITIAL_STATE__); } app.$mount('#app'); ``` entry-server.js需要导出一个函数，在服务端渲染期间会被调用 import Vue from 'vue'; import App from './App.vue'; import createStore from './store/index.js'; export default function(context) { // context是上下文对象 const store = createStore(); let app = new Vue({ store, render: h => h(App) }); // 找到所有 asyncData 方法 let components = App.components; let asyncDataArr = []; // promise集合 for (let key in components) { if (!components.hasOwnProperty(key)) continue; let component = components[key]; if (component.asyncData) { asyncDataArr.push(component.asyncData({store})) // 把store传给asyncData } } // 所有请求并行执行 return Promise.all(asyncDataArr).then(() => { // context.state 赋值成什么，window.__INITIAL_STATE__ 就是什么 // 这下你应该明白entry-client.js中window.__INITIAL_STATE__是哪来的了，它是在服务端渲染期间被添加进上下文的 context.state = store.state; return app; }); }; 上面的asyncData是干嘛用的？其实，这个函数是专门请求数据用的，你可能会问请求数据为什么不在beforeCreate或者created中完成，还要专门定义一个函数？虽然beforeCreate和created在服务端也会被执行（其他周期函数只会在客户端执行），但是我们都知道请求是异步的，这就导致请求发出后，数据还没返回，渲染就已经结束了，所以无法把 Ajax 返回的数据也一并渲染出来。因此需要想个办法，等到所有数据都返回后再渲染组件 asyncData需要返回一个promise，这样就可以等到所有请求都完成后再渲染组件。下面是在foo组价中使用asyncData的示例，在这里完成数据的请求 export default { asyncData: function({store}) { return store.dispatch('GET_ARTICLE') // 返回promise }, computed: { article() { return this.$store.state.article } } } 第二步：配置webpack webpack配置比较简单，但是也需要针对client和server端单独配置 webpack.client.conf.js显然是用来打包客户端应用的 module.exports = merge(base, { entry: { client: path.join(__dirname, '../entry-client.js') } }); webpack.server.conf.js用来打包服务端应用，这里需要指定node环境 module.exports = merge(base, { target: 'node', // 指定是node环境 entry: { server: path.join(__dirname, '../entry-server.js') }, output: { filename: '[name].js', // server.js libraryTarget: 'commonjs2' // 必须按照 commonjs规范打包才能被服务器调用。 }, plugins: [ new HtmlWebpackPlugin({ template: path.join(__dirname, '../index.ssr.html'), filename: 'index.ssr.html', files: { js: 'client.js' }, // client.js需要在html中引入 excludeChunks: ['server'] // server.js只在服务端执行，所以不能打包到html中 }) ] }); 第三步：启动服务 打包完成后就可以启动服务了，在start.js中我们需要把server.js加载进来，然后通过renderToString方法把渲染好的html返回给浏览器 const bundle = fs.readFileSync(path.resolve(__dirname, 'dist/server.js'), 'utf-8'); const renderer = require('vue-server-renderer').createBundleRenderer(bundle, { template: fs.readFileSync(path.resolve(__dirname, 'dist/index.ssr.html'), 'utf-8') // 服务端渲染数据 }); server.get('*', (req, res) => { renderer.renderToString((err, html) => { // console.log(html) if (err) { console.error(err); res.status(500).end('服务器内部错误'); return; } res.end(html); }) }); DEMO demo地址 "},"Vue/Vue插件开发.html":{"url":"Vue/Vue插件开发.html","title":"Vue插件开发","keywords":"","body":"开发插件 开发插件 官方文档 vue-toast 插件 开发 vue-toast 插件 完整code： js CSS： 使用： download code 官方文档 Vue.js 的插件应该有一个公开方法 install。这个方法的第一个参数是 Vue 构造器，第二个参数是一个可选的选项对象： MyPlugin.install = function (Vue, options) { // 1. 添加全局方法或属性, 如: vue-custom-element Vue.myGlobalMethod = function () { // 逻辑... } // 2. 添加全局资源：指令/过滤器/过渡等，如 vue-touch Vue.directive('my-directive', { bind (el, binding, vnode, oldVnode) { // 逻辑... } ... }) // 3. 注入组件 Vue.mixin({ created: function () { // 逻辑... } ... }) // 4. 添加实例方法，通过把它们添加到 Vue.prototype 上实现 Vue.prototype.$myMethod = function (methodOptions) { // 逻辑... } } vue-toast 插件 vue-toast 插件则是通过添加实例方法实现的。我们先来看个小例子。 先新建个js文件来编写插件：toast.js // toast.js var Toast = {}; Toast.install = function (Vue, options) { Vue.prototype.$msg = 'Hello World'; } module.exports = Toast; 在 main.js 中，需要导入 toast.js 并且通过全局方法 Vue.use() 来使用插件： // main.js import Vue from 'vue'; import Toast from './toast.js'; Vue.use(Toast); 然后，我们在组件中来获取该插件定义的 $msg 属性。 // App.vue export default { mounted(){ console.log(this.$msg); // Hello World } } 可以看到，控制台成功的打印出了 Hello World 。既然 $msg 能获取到，那么我们就可以来实现我们的 vue-toast 插件了。 开发 vue-toast 插件 需求：在组件中通过调用 this.$toast(‘网络请求失败’) 来弹出提示，默认在底部显示。可以通过调用 this.$toast.top() 或 this.$toast.center() 等方法来实现在不同位置显示。 整理一下思路，弹出提示的时候，我可以在 body 中添加一个 div 用来显示提示信息，不同的位置我通过添加不同的类名来定位，那就可以开始写了。 // toast.js var Toast = {}; Toast.install = function (Vue, options) { Vue.prototype.$toast = (tips) => { let toastTpl = Vue.extend({ // 1、创建构造器，定义好提示信息的模板 template: '' + tips + '' }); let tpl = new toastTpl().$mount().$el; // 2、创建实例，挂载到文档以后的地方 document.body.appendChild(tpl); // 3、把创建的实例添加到body中 setTimeout(function () { // 4、延迟2.5秒后移除该提示 document.body.removeChild(tpl); }, 2500) } } module.exports = Toast; 好像很简单，我们就实现了 this.$toast() ，接下来显示不同位置 // toast.js ['bottom', 'center', 'top'].forEach(type => { Vue.prototype.$toast[type] = (tips) => { return Vue.prototype.$toast(tips,type) } }) 这里把 type 传给 $toast 在该方法里进行不同位置的处理，上面说了通过添加不同的类名(toast-bottom、toast-top、toast-center)来实现，那 $toast 方法需要小小修改一下 Vue.prototype.$toast = (tips,type) => { // 添加 type 参数 let toastTpl = Vue.extend({ // 模板添加位置类 template: '' + tips + '' }); ... } 好像差不多了。但是如果我想默认在顶部显示，我每次都要调用 this.$toast.top() 好像就有点多余了，我能不能this.$toast() 就直接在我想要的地方呢？还有我不想要 2.5s 后才消失呢？这时候注意到 Toast.install(Vue,options) 里的options 参数，我们可以在 Vue.use() 通过 options 传进我们想要的参数。最后修改插件如下： var Toast = {}; Toast.install = function (Vue, options) { let opt = { defaultType:'bottom', // 默认显示位置 duration:'2500' // 持续时间 } for(let property in options){ opt[property] = options[property]; // 使用 options 的配置 } Vue.prototype.$toast = (tips,type) => { if(type){ opt.defaultType = type; // 如果有传type，位置则设为该type } if(document.getElementsByClassName('vue-toast').length){ // 如果toast还在，则不再执行 return; } let toastTpl = Vue.extend({ template: '' + tips + '' }); let tpl = new toastTpl().$mount().$el; document.body.appendChild(tpl); setTimeout(function () { document.body.removeChild(tpl); }, opt.duration) } ['bottom', 'center', 'top'].forEach(type => { Vue.prototype.$toast[type] = (tips) => { return Vue.prototype.$toast(tips,type) } }) } module.exports = Toast; 这样子一个简单的 vue 插件就实现了，并且可以通过 npm 打包发布，下次就可以使用 npm install 来安装了。 完整code： js /** * Updated by libin on 2017/11/5. */ var Toast = {}; var showToast = false, // 存储toast显示状态 showLoad = false, // 存储loading显示状态 toastVM = null, // 存储toast vm loadNode = null; // 存储loading节点元素 Toast.install = function(Vue, options) { var opt = { defaultType: 'bottom', duration: '2500', wordWrap: false }; for(var property in options) { opt[property] = options[property]; } Vue.prototype.$toast = function(tips, type) { var curType = type ? type : opt.defaultType; var wordWrap = opt.wordWrap ? 'lx-word-wrap' : ''; var style = opt.width ? 'style=\"width: ' + opt.width + '\"' : ''; var tmp = '{{tip}}'; if(showToast) { // 如果toast还在，则不再执行 return; } if(!toastVM) { var toastTpl = Vue.extend({ data: function() { return { show: showToast, tip: tips, type: 'lx-toast-' + curType } }, template: tmp }); toastVM = new toastTpl(); console.log(toastVM) var tpl = toastVM.$mount().$el; document.body.appendChild(tpl); } toastVM.type = 'lx-toast-' + curType; toastVM.tip = tips; toastVM.show = showToast = true; setTimeout(function() { toastVM.show = showToast = false; }, opt.duration) }; ['bottom', 'center', 'top'].forEach(function(type) { Vue.prototype.$toast[type] = function(tips) { return Vue.prototype.$toast(tips, type) } }); Vue.prototype.$loading = function(tips=\"loading...\", type) { if(type == 'close') { if(loadNode){ loadNode.show = showLoad = false; }else{ return false; } } else { if(showLoad) { // 如果loading还在，则不再执行 return; } var loadTpl = Vue.extend({ data: function() { return { show: showLoad } }, template: ` ${tips} ` }); loadNode = new loadTpl(); var tpl = loadNode.$mount().$el; document.body.appendChild(tpl); loadNode.show = showLoad = true; } }; ['open', 'close'].forEach(function(type) { Vue.prototype.$loading[type] = function(tips) { return Vue.prototype.$loading(tips, type) } }); } export default Toast; CSS： .lx-toast { position: fixed; bottom: 100px; left: 50%; box-sizing: border-box; max-width: 80%; height: 40px; line-height: 20px; padding: 10px 20px; transform: translateX(-50%); -webkit-transform: translateX(-50%); text-align: center; z-index: 9999; font-size: 14px; color: #fff; border-radius: 5px; background: rgba(0, 0, 0, 0.7); animation: show-toast .5s; -webkit-animation: show-toast .5s; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; } .lx-toast.lx-word-wrap { width: 80%; white-space: inherit; height: auto; } .lx-toast.lx-toast-top { top: 50px; bottom: inherit; } .lx-toast.lx-toast-center { top: 50%; margin-top: -20px; bottom: inherit; } @keyframes show-toast { from { opacity: 0; transform: translate(-50%, -10px); -webkit-transform: translate(-50%, -10px); } to { opacity: 1; transform: translate(-50%, 0); -webkit-transform: translate(-50%, 0); } } .lx-load-mark { position: fixed; left: 0; top: 0; width: 100%; height: 100%; z-index: 9999; } .lx-load-box { position: fixed; z-index: 3; width: 7.6em; min-height: 7.6em; top: 180px; left: 50%; margin-left: -3.8em; background: rgba(0, 0, 0, 0.7); text-align: center; border-radius: 5px; color: #FFFFFF; } .lx-load-content { margin-top: 64%; font-size: 14px; } .lx-loading { position: absolute; width: 0px; left: 50%; top: 38%; } .loading_leaf { position: absolute; top: -1px; opacity: 0.25; } .loading_leaf:before { content: \" \"; position: absolute; width: 9.14px; height: 3.08px; background: #d1d1d5; box-shadow: rgba(0, 0, 0, 0.0980392) 0px 0px 1px; border-radius: 1px; -webkit-transform-origin: left 50% 0px; transform-origin: left 50% 0px; } .loading_leaf_0 { -webkit-animation: opacity-0 1.25s linear infinite; animation: opacity-0 1.25s linear infinite; } .loading_leaf_0:before { -webkit-transform: rotate(0deg) translate(7.92px, 0px); transform: rotate(0deg) translate(7.92px, 0px); } .loading_leaf_1 { -webkit-animation: opacity-1 1.25s linear infinite; animation: opacity-1 1.25s linear infinite; } .loading_leaf_1:before { -webkit-transform: rotate(30deg) translate(7.92px, 0px); transform: rotate(30deg) translate(7.92px, 0px); } .loading_leaf_2 { -webkit-animation: opacity-2 1.25s linear infinite; animation: opacity-2 1.25s linear infinite; } .loading_leaf_2:before { -webkit-transform: rotate(60deg) translate(7.92px, 0px); transform: rotate(60deg) translate(7.92px, 0px); } .loading_leaf_3 { -webkit-animation: opacity-3 1.25s linear infinite; animation: opacity-3 1.25s linear infinite; } .loading_leaf_3:before { -webkit-transform: rotate(90deg) translate(7.92px, 0px); transform: rotate(90deg) translate(7.92px, 0px); } .loading_leaf_4 { -webkit-animation: opacity-4 1.25s linear infinite; animation: opacity-4 1.25s linear infinite; } .loading_leaf_4:before { -webkit-transform: rotate(120deg) translate(7.92px, 0px); transform: rotate(120deg) translate(7.92px, 0px); } .loading_leaf_5 { -webkit-animation: opacity-5 1.25s linear infinite; animation: opacity-5 1.25s linear infinite; } .loading_leaf_5:before { -webkit-transform: rotate(150deg) translate(7.92px, 0px); transform: rotate(150deg) translate(7.92px, 0px); } .loading_leaf_6 { -webkit-animation: opacity-6 1.25s linear infinite; animation: opacity-6 1.25s linear infinite; } .loading_leaf_6:before { -webkit-transform: rotate(180deg) translate(7.92px, 0px); transform: rotate(180deg) translate(7.92px, 0px); } .loading_leaf_7 { -webkit-animation: opacity-7 1.25s linear infinite; animation: opacity-7 1.25s linear infinite; } .loading_leaf_7:before { -webkit-transform: rotate(210deg) translate(7.92px, 0px); transform: rotate(210deg) translate(7.92px, 0px); } .loading_leaf_8 { -webkit-animation: opacity-8 1.25s linear infinite; animation: opacity-8 1.25s linear infinite; } .loading_leaf_8:before { -webkit-transform: rotate(240deg) translate(7.92px, 0px); transform: rotate(240deg) translate(7.92px, 0px); } .loading_leaf_9 { -webkit-animation: opacity-9 1.25s linear infinite; animation: opacity-9 1.25s linear infinite; } .loading_leaf_9:before { -webkit-transform: rotate(270deg) translate(7.92px, 0px); transform: rotate(270deg) translate(7.92px, 0px); } .loading_leaf_10 { -webkit-animation: opacity-10 1.25s linear infinite; animation: opacity-10 1.25s linear infinite; } .loading_leaf_10:before { -webkit-transform: rotate(300deg) translate(7.92px, 0px); transform: rotate(300deg) translate(7.92px, 0px); } .loading_leaf_11 { -webkit-animation: opacity-11 1.25s linear infinite; animation: opacity-11 1.25s linear infinite; } .loading_leaf_11:before { -webkit-transform: rotate(330deg) translate(7.92px, 0px); transform: rotate(330deg) translate(7.92px, 0px); } @-webkit-keyframes opacity-0 { 0% { opacity: 0.25; } 0.01% { opacity: 0.25; } 0.02% { opacity: 1; } 60.01% { opacity: 0.25; } 100% { opacity: 0.25; } } @-webkit-keyframes opacity-1 { 0% { opacity: 0.25; } 8.34333% { opacity: 0.25; } 8.35333% { opacity: 1; } 68.3433% { opacity: 0.25; } 100% { opacity: 0.25; } } @-webkit-keyframes opacity-2 { 0% { opacity: 0.25; } 16.6767% { opacity: 0.25; } 16.6867% { opacity: 1; } 76.6767% { opacity: 0.25; } 100% { opacity: 0.25; } } @-webkit-keyframes opacity-3 { 0% { opacity: 0.25; } 25.01% { opacity: 0.25; } 25.02% { opacity: 1; } 85.01% { opacity: 0.25; } 100% { opacity: 0.25; } } @-webkit-keyframes opacity-4 { 0% { opacity: 0.25; } 33.3433% { opacity: 0.25; } 33.3533% { opacity: 1; } 93.3433% { opacity: 0.25; } 100% { opacity: 0.25; } } @-webkit-keyframes opacity-5 { 0% { opacity: 0.270958333333333; } 41.6767% { opacity: 0.25; } 41.6867% { opacity: 1; } 1.67667% { opacity: 0.25; } 100% { opacity: 0.270958333333333; } } @-webkit-keyframes opacity-6 { 0% { opacity: 0.375125; } 50.01% { opacity: 0.25; } 50.02% { opacity: 1; } 10.01% { opacity: 0.25; } 100% { opacity: 0.375125; } } @-webkit-keyframes opacity-7 { 0% { opacity: 0.479291666666667; } 58.3433% { opacity: 0.25; } 58.3533% { opacity: 1; } 18.3433% { opacity: 0.25; } 100% { opacity: 0.479291666666667; } } @-webkit-keyframes opacity-8 { 0% { opacity: 0.583458333333333; } 66.6767% { opacity: 0.25; } 66.6867% { opacity: 1; } 26.6767% { opacity: 0.25; } 100% { opacity: 0.583458333333333; } } @-webkit-keyframes opacity-9 { 0% { opacity: 0.687625; } 75.01% { opacity: 0.25; } 75.02% { opacity: 1; } 35.01% { opacity: 0.25; } 100% { opacity: 0.687625; } } @-webkit-keyframes opacity-10 { 0% { opacity: 0.791791666666667; } 83.3433% { opacity: 0.25; } 83.3533% { opacity: 1; } 43.3433% { opacity: 0.25; } 100% { opacity: 0.791791666666667; } } @-webkit-keyframes opacity-11 { 0% { opacity: 0.895958333333333; } 91.6767% { opacity: 0.25; } 91.6867% { opacity: 1; } 51.6767% { opacity: 0.25; } 100% { opacity: 0.895958333333333; } } 使用： import '@/assets/css/toast.css'; import Toast from '@/assets/js/vue-toast.js'; Vue.use(Toast, { defaultType: 'center', duration: 3000, wordWrap: true, width: '150px' }); fun2() { this.$toast.top('Vue插件'); }, fun3() { this.$toast.center('Vue插件'); }, fun4() { this.$toast.bottom('Vue插件'); }, fun5() { this.$loading('加载中...'); setTimeout(function(){ this.$loading.close(); }.bind(this),2000) }, fun6() { this.$loading.open(); }, fun7() { this.$loading.close(); } download code download code "},"git/git基本使用.html":{"url":"git/git基本使用.html","title":"git基本使用","keywords":"","body":"git基本使用 git基本使用 开始 基本命令 使用合并流程 分支命名 注意事项 alias 别名 git合并一个分支上改动的部分文件到另外一个分支 git远程分支强制覆盖本地文件 公共远程分支版本回退的方法 6. 附： 开始 git config --global user.name xxx git config --global user.email xxx 基本命令 git checkout -b xxx ： 创建分支并切换到分支xxx git status ： 查看当前分支状态 git add . : 将新添加的文件加入暂存区 git commit -am “注释” ：添加并提交所有修改文件 git merge xxx : 将xxx(本地)分支的代码合并到当前分支 git pull : 从远端获取, 或git pull origin xxx(分支名) git push : 更新到远端, 或git push origin xxx(分支名) git add filename : 添加未跟踪的文件到暂存区 git add . : 添加所有未跟踪的文件到暂存区 git log : 日志 git reflog git reset --hard 139dcfaa git push -f -u origin master 使用合并流程 [master下]创建分支: git checkout -b xxx [分支下] 开发代码并不断commit, 开发完毕 [分支下] 切换到master: git checkout master [master下] 更新代码: git pull [master下] 切换到分支xxx: git checkout xxx [分支下] 合并master到分支： git merge master [分支下] 切换master: git checkout master [master下] 合并分支xxx到master: git merge xxx [master下] 更新到远端 git push 分支命名 建议采用git-flow规范： 新项目，新功能： feature/xxx 快速更改，修复bug: hotfix/xxx 注意事项 windows下客户端: sourcetree(注册需翻墙), tortoiseGit, mac下客户端: sourcetree, tower master分支尽量不要进行耗时项目开发，远端master要保持随时可以上线版本 push之前要先pull 所有命令操作都在根目录下执行。 不建议单文件commit， 每次commit都是提交当前所有的修改 alias 别名 使用命令行的同学可以在git bash里 vi ~/.gitconfig, 将下面别名加入文件末尾: [alias] cm = commit co = checkout ac = !git add -A && git commit st = status -sb tags = tag -l branches = branch -a cleanup = git config --global alias.cleanup \"git branch --merged | grep -v '*' | xargs git branch -d\" remotes = remote -v lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit -- git合并一个分支上改动的部分文件到另外一个分支 $ git checkeout master $ git checkout --path branchXX file git远程分支强制覆盖本地文件 $ git reset --hard origin/master 公共远程分支版本回退的方法 $ git revert HEAD # 撤销最近一次提交 $ git revert HEAD~1 # 撤销上上次的提交，注意：数字从0开始 $ git revert 0ffaacc # 撤销0ffaacc这次提交 git revert 命令意思是撤销某次提交。它会产生一个新的提交，虽然代码回退了，但是版本依然是向前的，所以,当你用revert回退之后，所有人pull之后，他们的代码也自动的回退了。但是，要注意以下几点： revert 是撤销一次提交，所以后面的commit id是你需要回滚到的版本的前一次提交 使用revert HEAD是撤销最近的一次提交，如果你最近一次提交是用revert命令产生的，那么你再执行一次，就相当于撤销了上次的撤销操作，换句话说，你连续执行两次revert HEAD命令，就跟没执行是一样的 使用revert HEAD~1 表示撤销最近2次提交，这个数字是从0开始的，如果你之前撤销过产生了commi id，那么也会计算在内的。 如果使用 revert 撤销的不是最近一次提交，那么一定会有代码冲突，需要你合并代码，合并代码只需要把当前的代码全部去掉，保留之前版本的代码就可以了. 自己的分支回滚直接用reset公共分支回滚用revert 6. 附： git配置，供参考（~/.gitconfig） [user] name = Lu jingce email = lujingce@163.com [alias] st = status br = branch bra = branch -a cm = commit -m cam = commit -a -m co = checkout cf = checkout -f diffn = diff --numstat diffs = diff --shortstat diffd = diff --dirstat lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit -- [push] default = simple "},"git/git分支管理策略.html":{"url":"git/git分支管理策略.html","title":"git分支管理策略","keywords":"","body":"git工作流 工作流 基于gitflow, 简化版本 参考文档: http://nvie.com/posts/a-successful-git-branching-model/ 区别： 不设release, develop分支， 暂不打tag， 保留master, feature/*, hotfix/* 项目 feprogram/taoche等项目锁定master, 不允许直接在master下改动，需要提交merge request进行review act等项目进行敏捷开发, 不锁定master, 分支自行管理 crm等项目设立develop分支，特性分支开发完成后合并入develop, master分支从develop单向merge 工作流程 基于最新master建立分支，功能分支feature/xxx 或 线上bug修复分支 hotfix/xxx 在分支下开发 开发完成， merge master到当前分支，release灰度/上线。 推荐工作流程 切换到release分支；pull最新代码；建立自己的工作分支（新功能开发、快速验证，bug修复建议都建分支）：git checkout -b dev_xmli；或者创建开发同一功能几个人公用的分支(如：dev-insurance, change-price)；在自己的分支上提交（commit）；开发完毕，做测试；切换到release分支，pull;切换到工作分支，merge代码： git merge release，合并线上最新更改，测试一下自己的更改；切换到release, 然后 git merge dev_xmli，把自己的更改合并到线上分支；提交代码到服务器-- git push;如有必要告知其他同事更新代码，尤其是项目文件的改动；如果是发布的release，打tag；git tag -a v1.8.0提交tag:git push --tags "},"git/publish脚本.html":{"url":"git/publish脚本.html","title":"publish脚本","keywords":"","body":"为了每次自动发布gitbook书籍到github.io上去，自定义脚本： #!/bin/bash cd doc # gitbook install # install the plugins and build the static site gitbook build cd .. # checkout to the gh-pages branch git checkout gh-pages # pull the latest updates git pull origin gh-pages if [[ \"$?\" != \"0\" ]]; then exit 1 fi # copy the static site files into the current directory. \\cp -Rf doc/_book/* . # remove 'node_modules' and '_book' directory # git clean -fx gitbook/node_modules # git clean -fx gitbook/_book rm -rf doc/_book/ # remove website css files, except last one ccount=`ls website-* | wc -w` if [[ \"$ccount\" > 1 ]];then allcss=($(ls website-*)) c=0 for css in \"${allcss[@]}\"; do let \"c=c+1\" if [[ $c -ge $ccount ]]; then break; fi rm -f $css done fi # add all files git add --all # commit git commit -a -m \"Update docs\" # push to the origin git push origin gh-pages # checkout to the master branch git checkout master "},"git/gitbook.html":{"url":"git/gitbook.html","title":"gitbook","keywords":"","body":"发布到github pages 构建书籍 首先，使用 gitbook build 将书籍内容输出到默认目录，也就是当前目录下的 _book 目录。 $ gitbook build Starting build ... Successfully built! $ ls _book GLOSSARY.html chapter1 chapter2 gitbook glossary_index.json index.html search_index.json 创建 gh-pages 分支 执行如下命令来创建分支，并且删除不需要的文件： $ git checkout --orphan gh-pages $ git rm --cached -r . $ git clean -df $ rm -rf *~ 现在，目录下应该只剩下 _book 目录了，首先，忽略一些文件： $ echo \"*~\" > .gitignore $ echo \"_book\" >> .gitignore $ git add .gitignore $ git commit -m \"Ignore some files\" 然后，加入 _book 下的内容到分支中： $ cp -r _book/* . $ git add . $ git commit -m \"Publish book\" 上传书籍内容到 GitHub 现在，可以将编译好的书籍内容上传到 GitHub 中 test 项目的 gh-pages 分支了，虽然这里还没有创建分支，上传和创建会一步完成！ $ git push -u origin gh-pages 部署到 gh-pages 分支 这个步骤我使用了 gh-pages 这个工具，它可以将文件夹一键发布到 GitHub 项目下的 gh-pages 分支中（其他分支也可以发布，但是在本文下用到的就是 gh-pages 这个分支） 安装 gh-pages 工具 $ npm install -g gh-pages 输入以下指令 $ gh-pages -d _book 然后 _book 下的所有文档都会部署到 gh-pages 分支 GitHub Pages 的静态资源支持下面 3 个来源： master 分支 master 分支的 /docs 目录 gh-pages 分支 执行下面命令，将 _book 目录推送到 GitHub 仓库的 gh-pages 分支。 $ git subtree push --prefix=_book origin gh-pages 或者在生成静态网页时，将保存的目录指定为 ./docs $ gitbook build ./ ./docs 然后直接推送到 GitHub 仓库的 git push origin master "},"规范/分支开发规范.html":{"url":"规范/分支开发规范.html","title":"分支开发规范","keywords":"","body":"分支开发规范 master分支 大部分项目都不要直接在master下直接开发 master分支需要确保是完全同步线上的状态， 任何时间点打包master分支都可以直接上线 分支创建规范 feature/xxx: 新需求，功能性开发 hotfix/xxx: bug修复 分支生命周期 分支上线前merge master, 上线后第一时间将分支合并入master 分支开发完成并合入master之后, 说明该分支生命周期已经完结，请删除分支 关于删除分支 方法一： gitlab中删除 方法二： 命令行执行git push origin --delete [branch_name] 分支删除后本地查看仍然可以看到 方法一： sourcetree pull/fetch操作时有个选项，勾选同步远程分支 方法二： 命令行执行git remote prune origin 方法三: 任意分支下执行git pull -p 日志 严禁使用空日志提交项目 不要使用没有任何内容的日志， 比如 'up' 'update' '更新' 'nomessage' 等等 日志体现相关项目及改动内容 "},"规范/es6编码规范.html":{"url":"规范/es6编码规范.html","title":"ES6编码规范","keywords":"","body":"es6编码规范 Airbnb JavaScript 代码规范（ES6） 1：关键字import // ES5 var MyComponent = require('./MyComponent.js'); // ES6 import MyComponent from './MyComponent'; 2：关键字exports // ES5 var Mycomponent = React.createClass({}); module.exports = MyComponent; // ES6,用export default来实现相同的功能 // ES6 export default class MyComponent extends React.Component {} 3：定义组件 // ES5 var Phono = { name, age, getAge: function() { return age } } // ES6 //名字：function() 的写法了，而是直接使用 名字()，在方法的最后也不能在有逗号了 class Photo { name age getAge() { return this.age } getName() { return this.name; } } 4：箭头函数 arrow function 注意：箭头函数中不能使用arguments对象 //ES5与ES6对比 //ES5： function name(参数) {运算表达式;return 表达式} //ES6： (参数) => {运算表达式;return 表达式} // 箭头函数的例子 () => 1; v => v + 1; (a, b) => a + b; () => { alert(\"foo\"); } e => { if (e == 0) { return 0; } return 1000 / e; } //例如 (x, y) => { x++; y--; return x + y } // 等同于 s = function(x, y) { x++; y--; return x + y; }; //例如 f = v => v; //上面的箭头函数等同于： f = function(v) { return v; }; f = () => 5; // 等同于 f = function() { return 5 }; sum = (num1, num2) => num1 + num2; // 等同于 sum = function(num1, num2) { return num1 + num2; }; //如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 sum = (num1, num2) => { return num1 + num2; } //由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。 getTempItem = id => ({ id: id, name: \"Temp\" }); //箭头函数可以与变量解构结合使用 const full = ({ first, last }) => first + ' ' + last; // 等同于 function full(person) { return person.first + ' ' + person.last; } //click clickBtn = (event) => { event.stopPropagation() } $('btn').on('click', (event => event.stopPropagation())) $('btn').on('click', (event) => { return event.stopPropagation() }) 5：class, extends和super class Animal { constructor() { this.type = 'animal' } says(say) { console.log(this.type + ' says ' + say) } } let animal = new Animal() animal.says('hello') //animal says hello class Cat extends Animal { constructor() { //super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。 //ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 super() this.type = 'cat' } } let cat = new Cat() cat.says('hello') //cat says hello 定义类时，方法的顺序如下： constructor public get/set 公用访问器，set只能传一个参数 public methods 公用方法，以函数命名区分，不带下划线 private get/set 私有访问器，私有相关命名应加上下划线_为前缀 private methods 私有方法 class SomeClass { constructor() { // constructor } get aval() { // public getter } set aval(val) { // public setter } doSth() { // 公用方法 } get _aval() { // private getter } set _aval() { // private setter } _doSth() { // 私有方法 } } 6 ：声明变量 // 可以初始化变量 let a = obj || {} 7 ：for循环 var arr = ['val1', 'val2', 'val3']; for (var i = 0; i { console.log(val); console.log(index); console.log(array); }) arr.forEach((val, index, array) => { console.log(val); console.log(index); console.log(array); }) for (let i = 0; i 8 ：赋值的方法 this.str = \"CH\"; var str = this.str && this.str.toLowerCase(); //输出 \"ch\" this.str = null; var str = this.str && this.str.toLowerCase(); //输出 null //相当于 if (this.str) { //当this.str字符串存在，则把他转为小写赋值给str str = this.str.toLowerCase(); } else { //否则把他自己赋值给str str = this.str; } if (a == 1) { b() } //可以写成 a == 1 && b() // ES5 var a = arr[0], b = arr[1], c = arr[2]; // ES6 let [a,b,c]=arr; 嵌套数组解构 var arr = [[1, 2, [3, 4]], 5, 6]; var [[d, e, [f, g]], h, i] = arr; console.log(d);//1 console.log(f);//3 console.log(i);//6 函数传参解构 var arr = ['this is a string', 2, 3]; function fn1([a, b, c]) { console.log(a); console.log(b); console.log(c); } fn1(arr); //this is a string //2 //3 for循环解构 var arr = [[11, 12], [21, 22], [31, 32]]; for (let [a, b] of arr) { console.log(a); console.log(b); } //11 //12 //21 //22 //31 //32 对象赋值解构 var obj = { name: 'chris', sex: 'male', age: 26, son: { sonname: '大熊', sonsex: 'male', sonage: 1 } }; var {name, sex, age, son} = obj; console.log(name + ' ' + sex + ' ' + age); //chris male 26 console.log(son); // { sonname: '大熊', sonsex: 'male', sonage: 1 } 对象传参解构 var obj = { name: 'chris', sex: 'male', age: 26, son: { sonname: '大熊', sonsex: 'male', sonage: 1 } }; function fn2({sex, age, name}) { console.log(name + ' ' + sex + ' ' + age); } fn2(obj); //chris male 26 变量名与对象属性名不一致解构 var obj = { name: 'chris', sex: 'male', age: 26 }; var {name: nickname, age: howold} = obj; console.log(nickname + ' ' + howold); //chris 26 嵌套对象解构 var obj = { name: 'chris', sex: 'male', age: 26, son: { sonname: '大熊', sonsex: 'male', sonage: 1 } }; var {name, sex, age, son: {sonname, sonsex, sonage}} = obj; console.log(sonname + ' ' + sonsex + ' ' + sonage); //大熊 male 1 //Babel暂不支持这种嵌套解构 obj = { name: 'chris', sex: 'male', age: [1, 2, 3] } {name, sex, age: [a, b, c]} = obj; console.log(c); 嵌套对象属性重名，解构时需要更改变量名 var obj = { name: 'chris', sex: 'male', age: 26, son: { name: '大熊', sex: 'male', age: 1 } }; //赋值解构 var {name: fathername, son: {name, sex, age}} = obj; console.log(fathername); //chris console.log(name); //大熊 //传参解构 function fn3({sex, age, name, son: {name: sonname}}) { console.log(name + ' ' + sex + ' ' + age + ' ' + sonname); } fn3(obj); //chris male 26 大熊 循环解构对象 var arr = [{name: 'chris', age: 26}, {name: 'jack', age: 27}, {name: 'peter',age: 28}]; for (let {age, name} of arr) { console.log(name + ' ' + age); } //chris 26 //jack 27 //peter 28 解构的特殊应用场景 //变量互换 var x = 1, y = 2; var [x, y] = [y, x]; console.log(x); //2 console.log(y); //1 //字符串解构 var str = 'love'; var [a, b, c, d] = str; console.log(a);//l console.log(b);//o console.log(c);//v console.log(d);//e 9：短路求值简写方式 if (variable1 !== null || variable1 !== undefined || variable1 !== '') { let variable2 = variable1; } const variable2 = variable1 || 'new'; 10： if存在条件简写方法 if (likeJavaScript === true) {} //简写： if (likeJavaScript) {} let a; if (a !== true) { // do something... } //简写： let a; if (!a) { // do something... } 11： 默认参数值 function volume(l, w, h) { if (w === undefined) w = 3; if (h === undefined) h = 4; return l * w * h; } //简写： volume = (l, w = 3, h = 4) => (l * w * h); volume(2) //output: 24 12：模板字符串 const welcome = 'You have logged in as ' + first + ' ' + last + '.' const db = 'http://' + host + ':' + port + '/' + database; //推荐 const welcome = `You have logged in as ${first} ${last}`; const db = `http://${host}:${port}/${database}`; 13：扩展运算符简写 // joining arrays const odd = [1, 3, 5]; const nums = [2, 4, 6].concat(odd); // cloning arrays const arr = [1, 2, 3, 4]; const arr2 = arr.slice() //简写： // joining arrays const odd = [1, 3, 5]; const nums = [2, 4, 6, ...odd]; console.log(nums); // [ 2, 4, 6, 1, 3, 5 ] // cloning arrays const arr = [1, 2, 3, 4]; const arr2 = [...arr]; //不像concat()函数，可以使用扩展运算符来在一个数组中任意处插入另一个数组。 const odd = [1, 3, 5]; const nums = [2, ...odd, 4, 6]; //也可以使用扩展运算符解构： const { a, b, ...z } = { a: 1, b: 2, c: 3, d: 4 }; console.log(a) // 1 console.log(b) // 2 console.log(z) // { c: 3, d: 4 } 14 ：强制参数简写 function foo(bar) { if (bar === undefined) { throw new Error('Missing parameter!'); } return bar; } //简写： mandatory = () => { throw new Error('Missing parameter!'); } foo = (bar = mandatory()) => { return bar; } 15： Array.find简写 const pets = [ { type: 'Dog', name: 'Max' }, { type: 'Cat', name: 'Karl' }, { type: 'Dog', name: 'Tommy' }, ] function findDog(name) { for (let i = 0; i pet.type === 'Dog' && pet.name === 'Tommy'); 16 ：Object[key]简写 //考虑一个验证函数 function validate(values) { if (!values.first) return false; if (!values.last) return false; return true; } console.log(validate({ first: 'Bruce', last: 'Wayne' })); // true //假设当需要不同域和规则来验证，能否编写一个通用函数在运行时确认？ // 对象验证规则 const schema = { first: { required: true }, last: { required: true } } // 通用验证函数 const validate = (schema, values) => { for (field in schema) { if (schema[field].required) { if (!values[field]) { return false; } } } return true; } console.log(validate(schema, { first: 'Bruce' })); // false console.log(validate(schema, { first: 'Bruce', last: 'Wayne' })); // true "},"规范/vue编码规范.html":{"url":"规范/vue编码规范.html","title":"vue编码规范","keywords":"","body":"VUE组件编码规范 相关文档 vue 1.x: [http://v1.vuejs.org/api/] vue-ressource 1.x: [https://github.com/pagekit/vue-resource/blob/develop/docs/http.md] vue-router 0.x: [https://github.com/vuejs/vue-router/tree/1.0/docs/zh-cn] 请注意区分项目使用的库版本及相关文档，以上三个包都在vue.dll.js依赖包里 项目通过组件来规划 // 示例项目aaa aaa/ components/ : 项目内组件 pages/ : 项目视图存放目录 html/: 项目页面存放目录 index.hbs index.js: 项目入口文件 // index.hbs , 尽量只用一个标记，无其他内容 // 如果有seo相关内容，凡在里面，作为slot插入组件内 // index.js // 若项目不复杂，可直接使用template new Vue({ el: '#main', template: ` `, components: {componentA,componentB,componentC} }) // 相对复杂的项目或使用路由的项目，建立页面级别的组件 new Vue({ el : '#main', template: ``, components: {Index} }) // pages/index.vue export default { name: 'index' } 目录划分 libs/vue-components ： 用于存放全项目公用的vue组件 xxx/components: 比如xinche.m/components, 用于存放单一项目公用的vue组件, 或跟此单一项目业务强相关的vue组件 xxx/yyy/components: 比如xinche.m/about/components, 用于存放子项目自己使用的vue组件，一般不提供给外部其他项目使用 公用组件目录结构 xxx/ index.vue : 主组件文件 *.png/*.gif : 组件使用的图片（公用组件尽量不要使用大于10k的图片） README.md: 组件使用说明文档 组件命名 有意义的， 简短，具有可读性。2-3个单词 符合自定义元素规范，使用-连字符分隔单词， 如app-header 组件单一原则 每一个vue组件专注于解决单一的问题，独立，可复用 一个组件尽量不要超过100行，如果组件太臃肿，需要拆分成更小的组件 props原子化 组件的props尽量使用原始数据类型，避免使用复杂对象 // 不适用复杂对象 const option = {title:'xxx', inApp: true} // 使用原始数据类型 // 注意inApp驼峰的props书写在组件标记内需要改成in-app类型 // 注意props值传入的如果不是字符串，需要v-bind:props来绑定 验证组件的props // 尽量不使用简写props export default { props: ['title', 'isApp'] } // 验证props export default { props: { title: { type: String, default: , required: true }, isApp: { type: Boolean, default: false } } } 合理使用this // 组件内不要出现如下之类 const self = this // 充分利用es6特性，使用this created(){ this.title = 123 } 组件使用name // 单一组件的导出不建议指定名称, 直接使用default导出 export default {} // 组件建议添加name属性 export default { name: 'appHeader\" } 组件不要使用双向绑定的props // 不要使用.sync类型的props export default { props: { type: String, twoway: true } } // 子组件通知父级数据变更，应采用调用父级传入的函数型props回调，或者事件通知的方式 避免使用this.$parent 直接访问上下文降低了组建的复用性，应避免使用，尽量通过事件通知 尽量使用this.$http而不是jquery.ajax vue组件应尽量使用自己的resource插件，符合promise规范 // 最外层需要将插件引入 import Vue from 'vue' import VueResource from 'vue-resource' Vue.use(VueResource) 组件内尽量不要直接使用window上的全局变量 // 不要使用window上的全局变量，降低组件复用性和增加维护成本 this.$http.get(APIURL, {}) // 通过props传入组件的所有外部依赖 this.$http.get(this.api, {}) props向下传递，事件向上传递 当必须要操作dom时，才使用this.$refs, 而不是jQuery 组件顶级class规范化，建议component-xxx开头命名 xxx 提供api文档 建议组件api文档写到组件同目录README.md里 "},"规范/Airbnb-React-JSX编码规范.html":{"url":"规范/Airbnb-React-JSX编码规范.html","title":"Airbnb-React-JSX编码规范","keywords":"","body":"Airbnb React/JSX 编码规范 算是最合理的React/JSX编码规范之一了 此编码规范主要基于目前流行的JavaScript标准，尽管某些其他约定(如async/await，静态class属性)可能在不同的项目中被引入或者被禁用。目前的状态是任何stage-3之前的规范都不包括也不推荐使用。 内容目录 基本规范 Class vs React.createClass vs stateless Mixins 命名 声明模块 代码对齐 单引号还是双引号 空格 属性 Refs引用 括号 标签 函数/方法 模块生命周期 isMounted Basic Rules 基本规范 每个文件只写一个模块. 但是多个无状态模块可以放在单个文件中. eslint: react/no-multi-comp. 推荐使用JSX语法. 不要使用 React.createElement，除非从一个非JSX的文件中初始化你的app. 创建模块 Class vs React.createClass vs stateless 如果你的模块有内部状态或者是refs, 推荐使用 class extends React.Component 而不是 React.createClass. eslint: react/prefer-es6-class react/prefer-stateless-function // bad const Listing = React.createClass({ // ... render() { return {this.state.hello}; } }); // good class Listing extends React.Component { // ... render() { return {this.state.hello}; } } 如果你的模块没有状态或是没有引用refs， 推荐使用普通函数（非箭头函数）而不是类: // bad class Listing extends React.Component { render() { return {this.props.hello}; } } // bad (relying on function name inference is discouraged) const Listing = ({ hello }) => ( {hello} ); // good function Listing({ hello }) { return {hello}; } Mixins 不要使用 mixins. 为什么? Mixins 会增加隐式的依赖，导致命名冲突，并且会以雪球式增加复杂度。在大多数情况下Mixins可以被更好的方法替代，如：组件化，高阶组件，工具模块等。 Naming 命名 扩展名: React模块使用 .jsx 扩展名. 文件名: 文件名使用帕斯卡命名. 如, ReservationCard.jsx. 引用命名: React模块名使用帕斯卡命名，实例使用骆驼式命名. eslint: react/jsx-pascal-case // bad import reservationCard from './ReservationCard'; // good import ReservationCard from './ReservationCard'; // bad const ReservationItem = ; // good const reservationItem = ; 模块命名: 模块使用当前文件名一样的名称. 比如 ReservationCard.jsx 应该包含名为 ReservationCard的模块. 但是，如果整个文件夹是一个模块，使用 index.js作为入口文件，然后直接使用 index.js 或者文件夹名作为模块的名称: // bad import Footer from './Footer/Footer'; // bad import Footer from './Footer/index'; // good import Footer from './Footer'; 高阶模块命名: 对于生成一个新的模块，其中的模块名 displayName 应该为高阶模块名和传入模块名的组合. 例如, 高阶模块 withFoo(), 当传入一个 Bar 模块的时候， 生成的模块名 displayName 应该为 withFoo(Bar). 为什么？一个模块的 displayName 可能会在开发者工具或者错误信息中使用到，因此有一个能清楚的表达这层关系的值能帮助我们更好的理解模块发生了什么，更好的Debug. // bad export default function withFoo(WrappedComponent) { return function WithFoo(props) { return ; } } // good export default function withFoo(WrappedComponent) { function WithFoo(props) { return ; } const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component'; WithFoo.displayName = `withFoo(${wrappedComponentName})`; return WithFoo; } 属性命名: 避免使用DOM相关的属性来用作其他的用途。 为什么？对于style 和 className这样的属性名，我们都会默认它们代表一些特殊的含义，如元素的样式，CSS class的名称。在你的应用中使用这些属性来表示其他的含义会使你的代码更难阅读，更难维护，并且可能会引起bug。 // bad // good Declaration 声明模块 不要使用 displayName 来命名React模块，而是使用引用来命名模块， 如 class 名称. // bad export default React.createClass({ displayName: 'ReservationCard', // stuff goes here }); // good export default class ReservationCard extends React.Component { } Alignment 代码对齐 遵循以下的JSX语法缩进/格式. eslint: react/jsx-closing-bracket-location react/jsx-closing-tag-location // bad // good, 有多行属性的话, 新建一行关闭标签 // 若能在一行中显示, 直接写成一行 // 子元素按照常规方式缩进 Quotes 单引号还是双引号 对于JSX属性值总是使用双引号(\"), 其他均使用单引号('). eslint: jsx-quotes 为什么? HTML属性也是用双引号, 因此JSX的属性也遵循此约定. // bad // good Spacing 空格 总是在自动关闭的标签前加一个空格，正常情况下也不需要换行. eslint: no-multi-spaces, react/jsx-tag-spacing // bad // very bad // bad // good 不要在JSX {} 引用括号里两边加空格. eslint: react/jsx-curly-spacing // bad // good Props 属性 JSX属性名使用骆驼式风格camelCase. // bad // good 如果属性值为 true, 可以直接省略. eslint: react/jsx-boolean-value // bad // good // good 标签总是添加 alt 属性. 如果图片以presentation(感觉是以类似PPT方式显示?)方式显示，alt 可为空, 或者 要包含role=\"presentation\". eslint: jsx-a11y/alt-text // bad // good // good // good 不要在 alt 值里使用如 \"image\", \"photo\", or \"picture\"包括图片含义这样的词， 中文也一样. eslint: jsx-a11y/img-redundant-alt 为什么? 屏幕助读器已经把 img 标签标注为图片了, 所以没有必要再在 alt 里说明了. // bad // good 使用有效正确的 aria role属性值 ARIA roles. eslint: jsx-a11y/aria-role // bad - not an ARIA role // bad - abstract ARIA role // good 不要在标签上使用 accessKey 属性. eslint: jsx-a11y/no-access-key 为什么? 屏幕助读器在键盘快捷键与键盘命令时造成的不统一性会导致阅读性更加复杂. // bad // good 避免使用数组的index来作为属性key的值，推荐使用唯一ID. (为什么?) // bad {todos.map((todo, index) => )} // good {todos.map(todo => ( ))} 对于所有非必须的属性，总是手动去定义defaultProps属性. 为什么? propTypes 可以作为模块的文档说明, 并且声明 defaultProps 的话意味着阅读代码的人不需要去假设一些默认值。更重要的是, 显示的声明默认属性可以让你的模块跳过属性类型的检查. // bad function SFC({ foo, bar, children }) { return {foo}{bar}{children}; } SFC.propTypes = { foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node, }; // good function SFC({ foo, bar, children }) { return {foo}{bar}{children}; } SFC.propTypes = { foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node, }; SFC.defaultProps = { bar: '', children: null, }; 尽可能少地使用扩展运算符 为什么? 除非你很想传递一些不必要的属性。对于React v15.6.1和更早的版本，你可以给DOM传递一些无效的HTML属性 例外情况: 使用了变量提升的高阶组件 function HOC(WrappedComponent) { return class Proxy extends React.Component { Proxy.propTypes = { text: PropTypes.string, isLoading: PropTypes.bool }; render() { return } } } 只有在清楚明白扩展对象时才使用扩展运算符。这非常有用尤其是在使用Mocha测试组件的时候。 export default function Foo { const props = { text: '', isPublished: false } return (); } 特别提醒：尽可能地筛选出不必要的属性。同时，使用prop-types-exact来预防问题出现。 // good render() { const { irrelevantProp, ...relevantProps } = this.props; return } // bad render() { const { irrelevantProp, ...relevantProps } = this.props; return } Refs 总是在Refs里使用回调函数. eslint: react/no-string-refs // bad // good { this.myRef = ref; }} /> Parentheses 括号 将多行的JSX标签写在 ()里. eslint: react/jsx-wrap-multilines // bad render() { return ; } // good render() { return ( ); } // good, 单行可以不需要 render() { const body = hello; return {body}; } Tags 标签 对于没有子元素的标签来说总是自己关闭标签. eslint: react/self-closing-comp // bad // good 如果模块有多行的属性， 关闭标签时新建一行. eslint: react/jsx-closing-bracket-location // bad // good Methods 函数 使用箭头函数来获取本地变量. function ItemList(props) { return ( {props.items.map((item, index) => ( doSomethingWith(item.name, index)} /> ))} ); } 当在 render() 里使用事件处理方法时，提前在构造函数里把 this 绑定上去. eslint: react/jsx-no-bind 为什么? 在每次 render 过程中， 再调用 bind 都会新建一个新的函数，浪费资源. // bad class extends React.Component { onClickDiv() { // do stuff } render() { return ; } } // good class extends React.Component { constructor(props) { super(props); this.onClickDiv = this.onClickDiv.bind(this); } onClickDiv() { // do stuff } render() { return ; } } 在React模块中，不要给所谓的私有函数添加 _ 前缀，本质上它并不是私有的. 为什么？_ 下划线前缀在某些语言中通常被用来表示私有变量或者函数。但是不像其他的一些语言，在JS中没有原生支持所谓的私有变量，所有的变量函数都是共有的。尽管你的意图是使它私有化，在之前加上下划线并不会使这些变量私有化，并且所有的属性（包括有下划线前缀及没有前缀的）都应该被视为是共有的。了解更多详情请查看Issue #1024, 和 #490 。 // bad React.createClass({ _onClickSubmit() { // do stuff }, // other stuff }); // good class extends React.Component { onClickSubmit() { // do stuff } // other stuff } 在 render 方法中总是确保 return 返回值. eslint: react/require-render-return // bad render() { (); } // good render() { return (); } Ordering React 模块生命周期 class extends React.Component 的生命周期函数: 可选的 static 方法 constructor 构造函数 getChildContext 获取子元素内容 componentWillMount 模块渲染前 componentDidMount 模块渲染后 componentWillReceiveProps 模块将接受新的数据 shouldComponentUpdate 判断模块需不需要重新渲染 componentWillUpdate 上面的方法返回 true， 模块将重新渲染 componentDidUpdate 模块渲染结束 componentWillUnmount 模块将从DOM中清除, 做一些清理任务 点击回调或者事件处理器 如 onClickSubmit() 或 onChangeDescription() render 里的 getter 方法 如 getSelectReason() 或 getFooterContent() 可选的 render 方法 如 renderNavigation() 或 renderProfilePicture() render render() 方法 如何定义 propTypes, defaultProps, contextTypes, 等等其他属性... import React from 'react'; import PropTypes from 'prop-types'; const propTypes = { id: PropTypes.number.isRequired, url: PropTypes.string.isRequired, text: PropTypes.string, }; const defaultProps = { text: 'Hello World', }; class Link extends React.Component { static methodsAreOk() { return true; } render() { return {this.props.text}; } } Link.propTypes = propTypes; Link.defaultProps = defaultProps; export default Link; React.createClass 的生命周期函数，与使用class稍有不同: eslint: react/sort-comp displayName 设定模块名称 propTypes 设置属性的类型 contextTypes 设置上下文类型 childContextTypes 设置子元素上下文类型 mixins 添加一些mixins statics defaultProps 设置默认的属性值 getDefaultProps 获取默认属性值 getInitialState 或者初始状态 getChildContext componentWillMount componentDidMount componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount clickHandlers or eventHandlers like onClickSubmit() or onChangeDescription() getter methods for render like getSelectReason() or getFooterContent() Optional render methods like renderNavigation() or renderProfilePicture() render isMounted 不要再使用 isMounted. eslint: react/no-is-mounted 为什么? isMounted 反人类设计模式:(), 在 ES6 classes 中无法使用， 官方将在未来的版本里删除此方法. ⬆ 回到顶部 "},"other/Emoji表情.html":{"url":"other/Emoji表情.html","title":"Emoji表情","keywords":"","body":"Emoji表情 将对应emoji表情的符号码复制后输入你的markdown文本即可显示emoji表情。 如:blush:，显示为:blush: 人物 syntax preview syntax preview syntax preview :bowtie: :bowtie: :smile: :smile: :laughing: :laughing: :blush: :blush: :smiley: :smiley: :relaxed: :relaxed: :smirk: :smirk: :heart_eyes: :heart_eyes: :kissing_heart: :kissing_heart: :kissing_closed_eyes: :kissing_closed_eyes: :flushed: :flushed: :relieved: :relieved: :satisfied: :satisfied: :grin: :grin: :wink: :wink: :stuck_out_tongue_winking_eye: :stuck_out_tongue_winking_eye: :stuck_out_tongue_closed_eyes: :stuck_out_tongue_closed_eyes: :grinning: :grinning: :kissing: :kissing: :kissing_smiling_eyes: :kissing_smiling_eyes: :stuck_out_tongue: :stuck_out_tongue: :sleeping: :sleeping: :worried: :worried: :frowning: :frowning: :anguished: :anguished: :open_mouth: :open_mouth: :grimacing: :grimacing: :confused: :confused: :hushed: :hushed: :expressionless: :expressionless: :unamused: :unamused: :sweat_smile: :sweat_smile: :sweat: :sweat: :disappointed_relieved: :disappointed_relieved: :weary: :weary: :pensive: :pensive: :disappointed: :disappointed: :confounded: :confounded: :fearful: :fearful: :cold_sweat: :cold_sweat: :persevere: :persevere: :cry: :cry: :sob: :sob: :joy: :joy: :astonished: :astonished: :scream: :scream: :neckbeard: :neckbeard: :tired_face: :tired_face: :angry: :angry: :rage: :rage: :triumph: :triumph: :sleepy: :sleepy: :yum: :yum: :mask: :mask: :sunglasses: :sunglasses: :dizzy_face: :dizzy_face: :imp: :imp: :smiling_imp: :smiling_imp: :neutral_face: :neutral_face: :no_mouth: :no_mouth: :innocent: :innocent: :alien: :alien: :yellow_heart: :yellow_heart: :blue_heart: :blue_heart: :purple_heart: :purple_heart: :heart: :heart: :green_heart: :green_heart: :broken_heart: :broken_heart: :heartbeat: :heartbeat: :heartpulse: :heartpulse: :two_hearts: :two_hearts: :revolving_hearts: :revolving_hearts: :cupid: :cupid: :sparkling_heart: :sparkling_heart: :sparkles: :sparkles: :star: :star: :star2: :star2: :dizzy: :dizzy: :boom: :boom: :collision: :collision: :anger: :anger: :exclamation: :exclamation: :question: :question: :grey_exclamation: :grey_exclamation: :grey_question: :grey_question: :zzz: :zzz: :dash: :dash: :sweat_drops: :sweat_drops: :notes: :notes: :musical_note: :musical_note: :fire: :fire: :hankey: :hankey: :poop: :poop: :: :shit: :+1: :+1: :thumbsup: :thumbsup: :-1: :-1: :thumbsdown: :thumbsdown: :ok_hand: :ok_hand: :punch: :punch: :facepunch: :facepunch: :fist: :fist: :v: :v: :wave: :wave: :hand: :hand: :raised_hand: :raised_hand: :open_hands: :open_hands: :point_up: :point_up: :point_down: :point_down: :point_left: :point_left: :point_right: :point_right: :raised_hands: :raised_hands: :pray: :pray: :point_up_2: :point_up_2: :clap: :clap: :muscle: :muscle: :metal: :metal: :fu: :fu: :walking: :walking: :runner: :runner: :running: :running: :couple: :couple: :family: :family: :two_men_holding_hands: :two_men_holding_hands: :two_women_holding_hands: :two_women_holding_hands: :dancer: :dancer: :dancers: :dancers: :ok_woman: :ok_woman: :no_good: :no_good: :information_desk_person: :information_desk_person: :raising_hand: :raising_hand: :bride_with_veil: :bride_with_veil: :person_with_pouting_face: :person_with_pouting_face: :person_frowning: :person_frowning: :bow: :bow: :couplekiss: :couplekiss: :couple_with_heart: :couple_with_heart: :massage: :massage: :haircut: :haircut: :nail_care: :nail_care: :boy: :boy: :girl: :girl: :woman: :woman: :man: :man: :baby: :baby: :older_woman: :older_woman: :older_man: :older_man: :person_with_blond_hair: :person_with_blond_hair: :man_with_gua_pi_mao: :man_with_gua_pi_mao: :man_with_turban: :man_with_turban: :construction_worker: :construction_worker: :cop: :cop: :angel: :angel: :princess: :princess: :smiley_cat: :smiley_cat: :smile_cat: :smile_cat: :heart_eyes_cat: :heart_eyes_cat: :kissing_cat: :kissing_cat: :smirk_cat: :smirk_cat: :scream_cat: :scream_cat: :crying_cat_face: :crying_cat_face: :joy_cat: :joy_cat: :pouting_cat: :pouting_cat: :japanese_ogre: :japanese_ogre: :japanese_goblin: :japanese_goblin: :see_no_evil: :see_no_evil: :hear_no_evil: :hear_no_evil: :speak_no_evil: :speak_no_evil: :guardsman: :guardsman: :skull: :skull: :feet: :feet: :lips: :lips: :kiss: :kiss: :droplet: :droplet: :ear: :ear: :eyes: :eyes: :nose: :nose: :tongue: :tongue: :love_letter: :love_letter: :bust_in_silhouette: :bust_in_silhouette: :busts_in_silhouette: :busts_in_silhouette: :speech_balloon: :speech_balloon: :thought_balloon: :thought_balloon: :feelsgood: :feelsgood: :finnadie: :finnadie: :goberserk: :goberserk: :godmode: :godmode: :hurtrealbad: :hurtrealbad: :rage1: :rage1: :rage2: :rage2: :rage3: :rage3: :rage4: :rage4: :suspect: :suspect: :trollface: :trollface: 自然 syntax preview syntax preview syntax preview :sunny: :sunny: :umbrella: :umbrella: :cloud: :cloud: :snowflake: :snowflake: :snowman: :snowman: :zap: :zap: :cyclone: :cyclone: :foggy: :foggy: :ocean: :ocean: :cat: :cat: :dog: :dog: :mouse: :mouse: :hamster: :hamster: :rabbit: :rabbit: :wolf: :wolf: :frog: :frog: :tiger: :tiger: :koala: :koala: :bear: :bear: :pig: :pig: :pig_nose: :pig_nose: :cow: :cow: :boar: :boar: :monkey_face: :monkey_face: :monkey: :monkey: :horse: :horse: :racehorse: :racehorse: :camel: :camel: :sheep: :sheep: :elephant: :elephant: :panda_face: :panda_face: :snake: :snake: :bird: :bird: :baby_chick: :baby_chick: :hatched_chick: :hatched_chick: :hatching_chick: :hatching_chick: :chicken: :chicken: :penguin: :penguin: :turtle: :turtle: :bug: :bug: :honeybee: :honeybee: :ant: :ant: :beetle: :beetle: :snail: :snail: :octopus: :octopus: :tropical_fish: :tropical_fish: :fish: :fish: :whale: :whale: :whale2: :whale2: :dolphin: :dolphin: :cow2: :cow2: :ram: :ram: :rat: :rat: :water_buffalo: :water_buffalo: :tiger2: :tiger2: :rabbit2: :rabbit2: :dragon: :dragon: :goat: :goat: :rooster: :rooster: :dog2: :dog2: :pig2: :pig2: :mouse2: :mouse2: :ox: :ox: :dragon_face: :dragon_face: :blowfish: :blowfish: :crocodile: :crocodile: :dromedary_camel: :dromedary_camel: :leopard: :leopard: :cat2: :cat2: :poodle: :poodle: :paw_prints: :paw_prints: :bouquet: :bouquet: :cherry_blossom: :cherry_blossom: :tulip: :tulip: :four_leaf_clover: :four_leaf_clover: :rose: :rose: :sunflower: :sunflower: :hibiscus: :hibiscus: :maple_leaf: :maple_leaf: :leaves: :leaves: :fallen_leaf: :fallen_leaf: :herb: :herb: :mushroom: :mushroom: :cactus: :cactus: :palm_tree: :palm_tree: :evergreen_tree: :evergreen_tree: :deciduous_tree: :deciduous_tree: :chestnut: :chestnut: :seedling: :seedling: :blossom: :blossom: :ear_of_rice: :ear_of_rice: :shell: :shell: :globe_with_meridians: :globe_with_meridians: :sun_with_face: :sun_with_face: :full_moon_with_face: :full_moon_with_face: :new_moon_with_face: :new_moon_with_face: :new_moon: :new_moon: :waxing_crescent_moon: :waxing_crescent_moon: :first_quarter_moon: :first_quarter_moon: :full_moon: :full_moon: :waning_gibbous_moon: :waning_gibbous_moon: :last_quarter_moon: :last_quarter_moon: :waning_crescent_moon: :waning_crescent_moon: :last_quarter_moon_with_face: :last_quarter_moon_with_face: :first_quarter_moon_with_face: :first_quarter_moon_with_face: :moon: :moon: :earth_africa: :earth_africa: :earth_americas: :earth_americas: :earth_asia: :earth_asia: :volcano: :volcano: :milky_way: :milky_way: :partly_sunny: :partly_sunny: :octocat: :octocat: :squirrel: :squirrel: :waxing_gibbous_moon: :waxing_gibbous_moon: 物体 syntax preview syntax preview syntax preview :bamboo: :bamboo: :gift_heart: :gift_heart: :dolls: :dolls: :school_satchel: :school_satchel: :mortar_board: :mortar_board: :flags: :flags: :fireworks: :fireworks: :sparkler: :sparkler: :wind_chime: :wind_chime: :rice_scene: :rice_scene: :jack_o_lantern: :jack_o_lantern: :ghost: :ghost: :santa: :santa: :christmas_tree: :christmas_tree: :gift: :gift: :bell: :bell: :no_bell: :no_bell: :tanabata_tree: :tanabata_tree: :tada: :tada: :confetti_ball: :confetti_ball: :balloon: :balloon: :crystal_ball: :crystal_ball: :cd: :cd: :dvd: :dvd: :floppy_disk: :floppy_disk: :camera: :camera: :video_camera: :video_camera: :movie_camera: :movie_camera: :computer: :computer: :tv: :tv: :iphone: :iphone: :phone: :phone: :telephone: :telephone: :telephone_receiver: :telephone_receiver: :pager: :pager: :fax: :fax: :minidisc: :minidisc: :vhs: :vhs: :sound: :sound: :speaker: :speaker: :mute: :mute: :loudspeaker: :loudspeaker: :mega: :mega: :hourglass: :hourglass: :hourglass_flowing_sand: :hourglass_flowing_sand: :alarm_clock: :alarm_clock: :watch: :watch: :radio: :radio: :satellite: :satellite: :loop: :loop: :mag: :mag: :mag_right: :mag_right: :unlock: :unlock: :lock: :lock: :lock_with_ink_pen: :lock_with_ink_pen: :closed_lock_with_key: :closed_lock_with_key: :key: :key: :bulb: :bulb: :flashlight: :flashlight: :high_brightness: :high_brightness: :low_brightness: :low_brightness: :electric_plug: :electric_plug: :battery: :battery: :calling: :calling: :email: :email: :mailbox: :mailbox: :postbox: :postbox: :bath: :bath: :bathtub: :bathtub: :shower: :shower: :toilet: :toilet: :wrench: :wrench: :nut_and_bolt: :nut_and_bolt: :hammer: :hammer: :seat: :seat: :moneybag: :moneybag: :yen: :yen: :dollar: :dollar: :pound: :pound: :euro: :euro: :credit_card: :credit_card: :money_with_wings: :money_with_wings: :e-mail: :e-mail: :inbox_tray: :inbox_tray: :outbox_tray: :outbox_tray: :envelope: :envelope: :incoming_envelope: :incoming_envelope: :postal_horn: :postal_horn: :mailbox_closed: :mailbox_closed: :mailbox_with_mail: :mailbox_with_mail: :mailbox_with_no_mail: :mailbox_with_no_mail: :door: :door: :smoking: :smoking: :bomb: :bomb: :gun: :gun: :hocho: :hocho: :pill: :pill: :syringe: :syringe: :page_facing_up: :page_facing_up: :page_with_curl: :page_with_curl: :bookmark_tabs: :bookmark_tabs: :bar_chart: :bar_chart: :chart_with_upwards_trend: :chart_with_upwards_trend: :chart_with_downwards_trend: :chart_with_downwards_trend: :scroll: :scroll: :clipboard: :clipboard: :calendar: :calendar: :date: :date: :card_index: :card_index: :file_folder: :file_folder: :open_file_folder: :open_file_folder: :scissors: :scissors: :pushpin: :pushpin: :paperclip: :paperclip: :black_nib: :black_nib: :pencil2: :pencil2: :straight_ruler: :straight_ruler: :triangular_ruler: :triangular_ruler: :closed_book: :closed_book: :green_book: :green_book: :blue_book: :blue_book: :orange_book: :orange_book: :notebook: :notebook: :notebook_with_decorative_cover: :notebook_with_decorative_cover: :ledger: :ledger: :books: :books: :bookmark: :bookmark: :microscope: :microscope: :telescope: :telescope: :name_badge: :name_badge: :newspaper: :newspaper: :football: :football: :basketball: :basketball: :soccer: :soccer: :baseball: :baseball: :tennis: :tennis: :8ball: :8ball: :rugby_football: :rugby_football: :bowling: :bowling: :golf: :golf: :mountain_bicyclist: :mountain_bicyclist: :bicyclist: :bicyclist: :horse_racing: :horse_racing: :snowboarder: :snowboarder: :swimmer: :swimmer: :surfer: :surfer: :ski: :ski: :spades: :spades: :hearts: :hearts: :clubs: :clubs: :diamonds: :diamonds: :gem: :gem: :ring: :ring: :trophy: :trophy: :musical_score: :musical_score: :musical_keyboard: :musical_keyboard: :violin: :violin: :space_invader: :space_invader: :video_game: :video_game: :black_joker: :black_joker: :flower_playing_cards: :flower_playing_cards: :game_die: :game_die: :dart: :dart: :mahjong: :mahjong: :clapper: :clapper: :memo: :memo: :pencil: :pencil: :book: :book: :art: :art: :microphone: :microphone: :headphones: :headphones: :trumpet: :trumpet: :saxophone: :saxophone: :guitar: :guitar: :shoe: :shoe: :sandal: :sandal: :high_heel: :high_heel: :lipstick: :lipstick: :boot: :boot: :shirt: :shirt: :tshirt: :tshirt: :necktie: :necktie: :womans_clothes: :womans_clothes: :dress: :dress: :running_shirt_with_sash: :running_shirt_with_sash: :jeans: :jeans: :kimono: :kimono: :bikini: :bikini: :ribbon: :ribbon: :tophat: :tophat: :crown: :crown: :womans_hat: :womans_hat: :mans_shoe: :mans_shoe: :closed_umbrella: :closed_umbrella: :briefcase: :briefcase: :handbag: :handbag: :pouch: :pouch: :purse: :purse: :eyeglasses: :eyeglasses: :fishing_pole_and_fish: :fishing_pole_and_fish: :coffee: :coffee: :tea: :tea: :sake: :sake: :baby_bottle: :baby_bottle: :beer: :beer: :beers: :beers: :cocktail: :cocktail: :tropical_drink: :tropical_drink: :wine_glass: :wine_glass: :fork_and_knife: :fork_and_knife: :pizza: :pizza: :hamburger: :hamburger: :fries: :fries: :poultry_leg: :poultry_leg: :meat_on_bone: :meat_on_bone: :spaghetti: :spaghetti: :curry: :curry: :fried_shrimp: :fried_shrimp: :bento: :bento: :sushi: :sushi: :fish_cake: :fish_cake: :rice_ball: :rice_ball: :rice_cracker: :rice_cracker: :rice: :rice: :ramen: :ramen: :stew: :stew: :oden: :oden: :dango: :dango: :egg: :egg: :bread: :bread: :doughnut: :doughnut: :custard: :custard: :icecream: :icecream: :ice_cream: :ice_cream: :shaved_ice: :shaved_ice: :birthday: :birthday: :cake: :cake: :cookie: :cookie: :chocolate_bar: :chocolate_bar: :candy: :candy: :lollipop: :lollipop: :honey_pot: :honey_pot: :apple: :apple: :green_apple: :green_apple: :tangerine: :tangerine: :lemon: :lemon: :cherries: :cherries: :grapes: :grapes: :watermelon: :watermelon: :strawberry: :strawberry: :peach: :peach: :melon: :melon: :banana: :banana: :pear: :pear: :pineapple: :pineapple: :sweet_potato: :sweet_potato: :eggplant: :eggplant: :tomato: :tomato: :corn: :corn: 地点 syntax preview syntax preview syntax preview :house: :house: :house_with_garden: :house_with_garden: :school: :school: :office: :office: :post_office: :post_office: :hospital: :hospital: :bank: :bank: :convenience_store: :convenience_store: :love_hotel: :love_hotel: :hotel: :hotel: :wedding: :wedding: :church: :church: :department_store: :department_store: :european_post_office: :european_post_office: :city_sunrise: :city_sunrise: :city_sunset: :city_sunset: :japanese_castle: :japanese_castle: :european_castle: :european_castle: :tent: :tent: :factory: :factory: :tokyo_tower: :tokyo_tower: :japan: :japan: :mount_fuji: :mount_fuji: :sunrise_over_mountains: :sunrise_over_mountains: :sunrise: :sunrise: :stars: :stars: :statue_of_liberty: :statue_of_liberty: :bridge_at_night: :bridge_at_night: :carousel_horse: :carousel_horse: :rainbow: :rainbow: :ferris_wheel: :ferris_wheel: :fountain: :fountain: :roller_coaster: :roller_coaster: :ship: :ship: :speedboat: :speedboat: :boat: :boat: :sailboat: :sailboat: :rowboat: :rowboat: :anchor: :anchor: :rocket: :rocket: :airplane: :airplane: :helicopter: :helicopter: :steam_locomotive: :steam_locomotive: :tram: :tram: :mountain_railway: :mountain_railway: :bike: :bike: :aerial_tramway: :aerial_tramway: :suspension_railway: :suspension_railway: :mountain_cableway: :mountain_cableway: :tractor: :tractor: :blue_car: :blue_car: :oncoming_automobile: :oncoming_automobile: :car: :car: :red_car: :red_car: :taxi: :taxi: :oncoming_taxi: :oncoming_taxi: :articulated_lorry: :articulated_lorry: :bus: :bus: :oncoming_bus: :oncoming_bus: :rotating_light: :rotating_light: :police_car: :police_car: :oncoming_police_car: :oncoming_police_car: :fire_engine: :fire_engine: :ambulance: :ambulance: :minibus: :minibus: :truck: :truck: :train: :train: :station: :station: :train2: :train2: :bullettrain_front: :bullettrain_front: :bullettrain_side: :bullettrain_side: :light_rail: :light_rail: :monorail: :monorail: :railway_car: :railway_car: :trolleybus: :trolleybus: :ticket: :ticket: :fuelpump: :fuelpump: :vertical_traffic_light: :vertical_traffic_light: :traffic_light: :traffic_light: :warning: :warning: :construction: :construction: :beginner: :beginner: :atm: :atm: :slot_machine: :slot_machine: :busstop: :busstop: :barber: :barber: :hotsprings: :hotsprings: :checkered_flag: :checkered_flag: :crossed_flags: :crossed_flags: :izakaya_lantern: :izakaya_lantern: :moyai: :moyai: :circus_tent: :circus_tent: :performing_arts: :performing_arts: :round_pushpin: :round_pushpin: :triangular_flag_on_post: :triangular_flag_on_post: :jp: :jp: :kr: :kr: :cn: :cn: :us: :us: :fr: :fr: :es: :es: :it: :it: :ru: :ru: :gb: :gb: :uk: :uk: :de: :de: 符号 syntax preview syntax preview syntax preview :one: :one: :two: :two: :three: :three: :four: :four: :five: :five: :six: :six: :seven: :seven: :eight: :eight: :nine: :nine: :keycap_ten: :keycap_ten: :1234: :1234: :zero: :zero: :hash: :hash: :symbols: :symbols: :arrow_backward: :arrow_backward: :arrow_down: :arrow_down: :arrow_forward: :arrow_forward: :arrow_left: :arrow_left: :capital_abcd: :capital_abcd: :abcd: :abcd: :abc: :abc: :arrow_lower_left: :arrow_lower_left: :arrow_lower_right: :arrow_lower_right: :arrow_right: :arrow_right: :arrow_up: :arrow_up: :arrow_upper_left: :arrow_upper_left: :arrow_upper_right: :arrow_upper_right: :arrow_double_down: :arrow_double_down: :arrow_double_up: :arrow_double_up: :arrow_down_small: :arrow_down_small: :arrow_heading_down: :arrow_heading_down: :arrow_heading_up: :arrow_heading_up: :leftwards_arrow_with_hook: :leftwards_arrow_with_hook: :arrow_right_hook: :arrow_right_hook: :left_right_arrow: :left_right_arrow: :arrow_up_down: :arrow_up_down: :arrow_up_small: :arrow_up_small: :arrows_clockwise: :arrows_clockwise: :arrows_counterclockwise: :arrows_counterclockwise: :rewind: :rewind: :fast_forward: :fast_forward: :information_source: :information_source: :ok: :ok: :twisted_rightwards_arrows: :twisted_rightwards_arrows: :repeat: :repeat: :repeat_one: :repeat_one: :new: :new: :top: :top: :up: :up: :cool: :cool: :free: :free: :ng: :ng: :cinema: :cinema: :koko: :koko: :signal_strength: :signal_strength: :u5272: :u5272: :u5408: :u5408: :u55b6: :u55b6: :u6307: :u6307: :u6708: :u6708: :u6709: :u6709: :u6e80: :u6e80: :u7121: :u7121: :u7533: :u7533: :u7a7a: :u7a7a: :u7981: :u7981: :sa: :sa: :restroom: :restroom: :mens: :mens: :womens: :womens: :baby_symbol: :baby_symbol: :no_smoking: :no_smoking: :parking: :parking: :wheelchair: :wheelchair: :metro: :metro: :baggage_claim: :baggage_claim: :accept: :accept: :wc: :wc: :potable_water: :potable_water: :put_litter_in_its_place: :put_litter_in_its_place: :secret: :secret: :congratulations: :congratulations: :m: :m: :passport_control: :passport_control: :left_luggage: :left_luggage: :customs: :customs: :ideograph_advantage: :ideograph_advantage: :cl: :cl: :sos: :sos: :id: :id: :no_entry_sign: :no_entry_sign: :underage: :underage: :no_mobile_phones: :no_mobile_phones: :do_not_litter: :do_not_litter: :non-potable_water: :non-potable_water: :no_bicycles: :no_bicycles: :no_pedestrians: :no_pedestrians: :children_crossing: :children_crossing: :no_entry: :no_entry: :eight_spoked_asterisk: :eight_spoked_asterisk: :eight_pointed_black_star: :eight_pointed_black_star: :heart_decoration: :heart_decoration: :vs: :vs: :vibration_mode: :vibration_mode: :mobile_phone_off: :mobile_phone_off: :chart: :chart: :currency_exchange: :currency_exchange: :aries: :aries: :taurus: :taurus: :gemini: :gemini: :cancer: :cancer: :leo: :leo: :virgo: :virgo: :libra: :libra: :scorpius: :scorpius: :sagittarius: :sagittarius: :capricorn: :capricorn: :aquarius: :aquarius: :pisces: :pisces: :ophiuchus: :ophiuchus: :six_pointed_star: :six_pointed_star: :negative_squared_cross_mark: :negative_squared_cross_mark: :a: :a: :b: :b: :ab: :ab: :o2: :o2: :diamond_shape_with_a_dot_inside: :diamond_shape_with_a_dot_inside: :recycle: :recycle: :end: :end: :on: :on: :soon: :soon: :clock1: :clock1: :clock130: :clock130: :clock10: :clock10: :clock1030: :clock1030: :clock11: :clock11: :clock1130: :clock1130: :clock12: :clock12: :clock1230: :clock1230: :clock2: :clock2: :clock230: :clock230: :clock3: :clock3: :clock330: :clock330: :clock4: :clock4: :clock430: :clock430: :clock5: :clock5: :clock530: :clock530: :clock6: :clock6: :clock630: :clock630: :clock7: :clock7: :clock730: :clock730: :clock8: :clock8: :clock830: :clock830: :clock9: :clock9: :clock930: :clock930: :heavy_dollar_sign: :heavy_dollar_sign: :copyright: :copyright: :registered: :registered: :tm: :tm: :x: :x: :heavy_exclamation_mark: :heavy_exclamation_mark: :bangbang: :bangbang: :interrobang: :interrobang: :o: :o: :heavy_multiplication_x: :heavy_multiplication_x: :heavy_plus_sign: :heavy_plus_sign: :heavy_minus_sign: :heavy_minus_sign: :heavy_division_sign: :heavy_division_sign: :white_flower: :white_flower: :100: :100: :heavy_check_mark: :heavy_check_mark: :ballot_box_with_check: :ballot_box_with_check: :radio_button: :radio_button: :link: :link: :curly_loop: :curly_loop: :wavy_dash: :wavy_dash: :part_alternation_mark: :part_alternation_mark: :trident: :trident: :black_large_square: :black_large_square: :white_large_square: :white_large_square: :white_check_mark: :white_check_mark: :white_square_button: :white_square_button: :black_square_button: :black_square_button: :black_circle: :black_circle: :white_circle: :white_circle: :red_circle: :red_circle: :large_blue_circle: :large_blue_circle: :large_blue_diamond: :large_blue_diamond: :large_orange_diamond: :large_orange_diamond: :small_blue_diamond: :small_blue_diamond: :small_orange_diamond: :small_orange_diamond: :small_red_triangle: :small_red_triangle: :small_red_triangle_down: :small_red_triangle_down: :shipit: :shipit: "},"other/简明-Vim-练级攻略.html":{"url":"other/简明-Vim-练级攻略.html","title":"简明-Vim-练级攻略","keywords":"","body":"简明-Vim-练级攻略.md 简明-Vim-练级攻略.md- [**第一级 – 存活**](#第一级--存活) - [**第二级 – 感觉良好**](#第二级--感觉良好) - [**第三级 – 更好，更强，更快**](#第三级--更好更强更快) - [**第四级 – Vim 超能力**](#第四级--Vim-超能力) - [**结束语**](#结束语) 第一级 – 存活 下面是一些命令，可以让你在 Normal 模式下幸存下来： i → Insert 模式，按 ESC 回到 Normal 模式. x → 删当前光标所在的一个字符。 :wq → 存盘 + 退出 (:w 存盘, :q 退出) （陈皓注：:w 后可以跟文件名） dd → 删除当前行，并把删除的行存到剪贴板里 p → 粘贴剪贴板 推荐: hjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。 :help → 显示相关命令的帮助。你也可以就输入 :help 而不跟命令。（陈皓注：退出帮助需要输入:q） 注意：在VIM的Normal模式下，所有的键就是功能键 你能在vim幸存下来只需要上述的那5个命令，你就可以编辑文本了，你一定要把这些命令练成一种下意识的状态。于是你就可以开始进阶到第二级了 第二级 – 感觉良好 1、各种插入模式 a → 在光标后插入 o → 在当前行后插入一个新行 O → 在当前行前插入一个新行 cw → 替换从光标所在位置后到一个单词结尾的字符 2、简单的移动光标 0 → 数字零，到行头 ^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等） $ → 到本行行尾 g_ → 到本行最后一个不是blank字符的位置。 /pattern → 搜索 pattern 的字符串（注：如果搜索出多个匹配，可按n键到下一个） 3、拷贝/粘贴 （皓注：p/P都可以，p是表示在当前位置之后，P表示在当前位置之前） P → 粘贴 yy → 拷贝当前行当行于 ddP 4、Undo/Redo u → undo → redo 5、打开/保存/退出/改变文件(Buffer) :e → 打开一个文件 :w → 存盘 :saveas → 另存为 :x， ZZ 或 :wq → 保存并退出 (:x 表示仅在需要时保存，ZZ不需要输入冒号并回车) :q! → 退出不保存 :qa! 强行退出所有的正在编辑的文件，就算别的文件有更改。 :bn 和 :bp → 你可以同时打开很多文件，使用这两个命令来切换下一个或上一个文件。（注：我喜欢使用:n到下一个文件） 花点时间熟悉一下上面的命令，一旦你掌握他们了，你就几乎可以干其它编辑器都能干的事了。但是到现在为止，你还是觉得使用vim还是有点笨拙，不过没关系，你可以进阶到第三级了。 第三级 – 更好，更强，更快 在第三级，我们只谈那些和vi可以兼容的命令。 更好 下面，让我们看一下vim是怎么重复自己的： . → (小数点) 可以重复上一次的命令 N → 重复某个命令N次 下面是一个示例，找开一个文件你可以试试下面的命令： 2dd → 删除2行 3p → 粘贴文本3次 100idesu [ESC] → 会写下 “desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu desu “ . → 重复上一个命令—— 100 “desu “. → 重复 3 次 “desu” (注意：不是 300，你看，VIM多聪明啊). 更强 你要让你的光标移动更有效率，你一定要了解下面的这些命令，千万别跳过。 NG → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行） gg → 到第一行。（陈皓注：相当于1G，或 :1） G → 到最后一行。 按单词移动： w → 到下一个单词的开头。 e → 到下一个单词的结尾。 如果你认为单词是由默认方式，那么就用小写的e和w。默认上来说，一个单词由字母，数字和下划线组成（注：程序变量） 如果你认为单词是由blank字符分隔符，那么你需要使用大写的E和W。（注：程序语句） 下面，让我们来说说最强的光标移动： % : 匹配括号移动，包括 (, {, [. （注：你需要把光标先移到括号上） 和 #: 匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个） 相信我，上面这三个命令对程序员来说是相当强大的 更快 你一定要记住光标的移动，因为很多命令都可以和这些移动光标的命令连动。很多命令都可以如下来干： 例如 0y$ 命令意味着： 0 → 先到行头 y → 从这里开始拷贝 $ → 拷贝到本行最后一个字符 你可可以输入 ye，从当前位置拷贝到本单词的最后一个字符。 你也可以输入 y2/foo 来拷贝2个 “foo” 之间的字符串。 还有很多时间并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝： d (删除 ) v (可视化的选择) gU (变大写) gu (变小写) 注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等 第四级 – Vim 超能力 你只需要掌握前面的命令，你就可以很舒服的使用VIM了。但是，现在，我们向你介绍的是VIM杀手级的功能。下面这些功能是我只用vim的原因。 在当前行上移动光标: 0 ^ $ f F t T , ; 0 → 到行头 ^ → 到本行的第一个非blank字符 $ → 到行尾 g_ → 到本行最后一个不是blank字符的位置。 fa → 到下一个为a的字符处，你也可以fs到下一个为s的字符。 t, → 到逗号前的第一个字符。逗号可以变成其它字符。 3fa → 在当前行查找第三个出现的a。 F 和 T → 和 f 和 t 一样，只不过是相反方向。 注：还有一个很有用的命令是 dt\" → 删除所有的内容，直到遇到双引号—— \"。 区域选择 a 或 i 在visual 模式下，这些命令很强大，其命令格式为: a 和 i action可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。 object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：\"、 '、 )、 }、 ]。 假设你有一个字符串 (map (+) (\"foo\")).而光标键在第一个 o 的位置。 vi\" → 会选择 foo. va\" → 会选择 \"foo\". vi) → 会选择 \"foo\". va) → 会选择(\"foo\"). v2i) → 会选择 map (+) (\"foo\") v2a) → 会选择 (map (+) (\"foo\")) 块操作: 块操作，典型的操作： 0 I-- [ESC] ^ → 到行头 → 开始块操作 → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的) I-- [ESC] → I是插入，插入“--”，按ESC键来为每一行生效 在Windows下的vim，你需要使用 而不是 ， 是拷贝剪贴板 自动提示： 和 在 Insert 模式下，你可以输入一个词的开头，然后按 或是，自动补齐功能就出现了…… 宏录制： qa 操作序列 q, @a, @@ qa 把你的操作记录在寄存器 a。 于是 @a 会replay被录制的宏。 @@ 是一个快捷键用来replay最新录制的宏。 在一个只有一行且这一行只有“1”的文本中，键入如下命令： qaYpq→ qa 开始录制 Yp 复制行. 增加1. q 停止录制. @a → 在1下面写下 2 @@ → 在2 正面写下3 现在做 100@@ 会创建新的100行，并把数据增加到 103. 可视化选择： v,V, 前面，我们看到了 的示例 （在Windows下应该是），我们可以使用 v 和 V。一但被选好了，你可以做下面的事： J → 把所有的行连接起来（变成一行） → 左右缩进 = → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了） 在所有被选择的行后加上点东西： 选中相关的行 (可使用 j 或 或是 /pattern 或是 % 等……) $ 到行最后 A, 输入字符串，按 ESC。 分屏: :split 和 vsplit. 下面是主要的命令，你可以使用VIM的帮助 :help split. :split → 创建分屏 (:vsplit创建垂直分屏) : dir就是方向，可以是 hjkl 或是 ←↓↑→ 中的一个，其用来切换分屏。 _ (或 |) : 最大化尺寸 (| 垂直分屏) + (或 -) : 增加尺寸 结束语 上面是最常用的90%的命令。 建议每天都学1到2个新的命令。 在两到三周后，你会感到vim的强大的。 有时候，学习VIM就像是在死背一些东西。 幸运的是，vim有很多很不错的工具和优秀的文档。 运行vimtutor直到你熟悉了那些基本命令。 其在线帮助文档中你应该要仔细阅读的是 :help usr_02.txt. 你会学习到诸如 !， 目录，寄存器，插件等很多其它的功能。 学习vim就像学弹钢琴一样，一旦学会，受益无穷 "}}